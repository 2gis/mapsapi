/*
 Maps api created at 2GIS. Build on Leaflet.
 (c) 2013-2015, 2GIS
*/

(function (window, document, undefined) {

var L = {
	version: '0.8-dev'
};

function expose() {
	var oldL = window.L;

	L.noConflict = function () {
		window.L = oldL;
		return this;
	};

	window.L = L;
}

// define Leaflet for Node module pattern loaders, including Browserify
if (typeof module === 'object' && typeof module.exports === 'object') {
	module.exports = L;

// define Leaflet as an AMD module
} else if (typeof define === 'function' && define.amd) {
	define(L);

// define Leaflet as a global L variable, saving the original L to restore later if needed
} else {
	expose();
}

/*
 * L.Util contains various utility functions used throughout Leaflet code.
 */

L.Util = {
	// extend an object with properties of one or more other objects
	extend: function (dest) {
		var sources = Array.prototype.slice.call(arguments, 1),
		    i, j, len, src;

		for (j = 0, len = sources.length; j < len; j++) {
			src = sources[j];
			for (i in src) {
				dest[i] = src[i];
			}
		}
		return dest;
	},

	// create an object from a given prototype
	create: Object.create || (function () {
		function F() {}
		return function (proto) {
			F.prototype = proto;
			return new F();
		};
	})(),

	// bind a function to be called with a given context
	bind: function (fn, obj) {
		var slice = Array.prototype.slice;

		if (fn.bind) {
			return fn.bind.apply(fn, slice.call(arguments, 1));
		}

		var args = slice.call(arguments, 2);

		return function () {
			return fn.apply(obj, args.length ? args.concat(slice.call(arguments)) : arguments);
		};
	},

	// return unique ID of an object
	stamp: function (obj) {
		// jshint camelcase: false
		obj._leaflet_id = obj._leaflet_id || ++L.Util.lastId;
		return obj._leaflet_id;
	},

	lastId: 0,

	// return a function that won't be called more often than the given interval
	throttle: function (fn, time, context) {
		var lock, args, wrapperFn, later;

		later = function () {
			// reset lock and call if queued
			lock = false;
			if (args) {
				wrapperFn.apply(context, args);
				args = false;
			}
		};

		wrapperFn = function () {
			if (lock) {
				// called too soon, queue to call later
				args = arguments;

			} else {
				// call and lock until later
				fn.apply(context, arguments);
				setTimeout(later, time);
				lock = true;
			}
		};

		return wrapperFn;
	},

	// wrap the given number to lie within a certain range (used for wrapping longitude)
	wrapNum: function (x, range, includeMax) {
		var max = range[1],
		    min = range[0],
		    d = max - min;
		return x === max && includeMax ? x : ((x - min) % d + d) % d + min;
	},

	// do nothing (used as a noop throughout the code)
	falseFn: function () { return false; },

	// round a given number to a given precision
	formatNum: function (num, digits) {
		var pow = Math.pow(10, digits || 5);
		return Math.round(num * pow) / pow;
	},

	// trim whitespace from both sides of a string
	trim: function (str) {
		return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
	},

	// split a string into words
	splitWords: function (str) {
		return L.Util.trim(str).split(/\s+/);
	},

	// set options to an object, inheriting parent's options as well
	setOptions: function (obj, options) {
		if (!obj.hasOwnProperty('options')) {
			obj.options = obj.options ? L.Util.create(obj.options) : {};
		}
		for (var i in options) {
			obj.options[i] = options[i];
		}
		return obj.options;
	},

	// make an URL with GET parameters out of a set of properties/values
	getParamString: function (obj, existingUrl, uppercase) {
		var params = [];
		for (var i in obj) {
			params.push(encodeURIComponent(uppercase ? i.toUpperCase() : i) + '=' + encodeURIComponent(obj[i]));
		}
		return ((!existingUrl || existingUrl.indexOf('?') === -1) ? '?' : '&') + params.join('&');
	},

	// super-simple templating facility, used for TileLayer URLs
	template: function (str, data) {
		return str.replace(L.Util.templateRe, function (str, key) {
			var value = data[key];

			if (value === undefined) {
				throw new Error('No value provided for variable ' + str);

			} else if (typeof value === 'function') {
				value = value(data);
			}
			return value;
		});
	},

	templateRe: /\{ *([\w_]+) *\}/g,

	isArray: Array.isArray || function (obj) {
		return (Object.prototype.toString.call(obj) === '[object Array]');
	},

	// minimal image URI, set to an image when disposing to flush memory
	emptyImageUrl: 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs='
};

(function () {
	// inspired by http://paulirish.com/2011/requestanimationframe-for-smart-animating/

	function getPrefixed(name) {
		return window['webkit' + name] || window['moz' + name] || window['ms' + name];
	}

	var lastTime = 0;

	// fallback for IE 7-8
	function timeoutDefer(fn) {
		var time = +new Date(),
		    timeToCall = Math.max(0, 16 - (time - lastTime));

		lastTime = time + timeToCall;
		return window.setTimeout(fn, timeToCall);
	}

	var requestFn = window.requestAnimationFrame || getPrefixed('RequestAnimationFrame') || timeoutDefer,
	    cancelFn = window.cancelAnimationFrame || getPrefixed('CancelAnimationFrame') ||
	               getPrefixed('CancelRequestAnimationFrame') || function (id) { window.clearTimeout(id); };


	L.Util.requestAnimFrame = function (fn, context, immediate, element) {
		if (immediate && requestFn === timeoutDefer) {
			fn.call(context);
		} else {
			return requestFn.call(window, L.bind(fn, context), element);
		}
	};

	L.Util.cancelAnimFrame = function (id) {
		if (id) {
			cancelFn.call(window, id);
		}
	};
})();

// shortcuts for most used utility functions
L.extend = L.Util.extend;
L.bind = L.Util.bind;
L.stamp = L.Util.stamp;
L.setOptions = L.Util.setOptions;

/*
 * L.Class powers the OOP facilities of the library.
 * Thanks to John Resig and Dean Edwards for inspiration!
 */

L.Class = function () {};

L.Class.extend = function (props) {

	// extended class with the new prototype
	var NewClass = function () {

		// call the constructor
		if (this.initialize) {
			this.initialize.apply(this, arguments);
		}

		// call all constructor hooks
		if (this._initHooks.length) {
			this.callInitHooks();
		}
	};

	// jshint camelcase: false
	var parentProto = NewClass.__super__ = this.prototype;

	var proto = L.Util.create(parentProto);
	proto.constructor = NewClass;

	NewClass.prototype = proto;

	//inherit parent's statics
	for (var i in this) {
		if (this.hasOwnProperty(i) && i !== 'prototype') {
			NewClass[i] = this[i];
		}
	}

	// mix static properties into the class
	if (props.statics) {
		L.extend(NewClass, props.statics);
		delete props.statics;
	}

	// mix includes into the prototype
	if (props.includes) {
		L.Util.extend.apply(null, [proto].concat(props.includes));
		delete props.includes;
	}

	// merge options
	if (proto.options) {
		props.options = L.Util.extend(L.Util.create(proto.options), props.options);
	}

	// mix given properties into the prototype
	L.extend(proto, props);

	proto._initHooks = [];

	// add method for calling all hooks
	proto.callInitHooks = function () {

		if (this._initHooksCalled) { return; }

		if (parentProto.callInitHooks) {
			parentProto.callInitHooks.call(this);
		}

		this._initHooksCalled = true;

		for (var i = 0, len = proto._initHooks.length; i < len; i++) {
			proto._initHooks[i].call(this);
		}
	};

	return NewClass;
};


// method for adding properties to prototype
L.Class.include = function (props) {
	L.extend(this.prototype, props);
};

// merge new default options to the Class
L.Class.mergeOptions = function (options) {
	L.extend(this.prototype.options, options);
};

// add a constructor hook
L.Class.addInitHook = function (fn) { // (Function) || (String, args...)
	var args = Array.prototype.slice.call(arguments, 1);

	var init = typeof fn === 'function' ? fn : function () {
		this[fn].apply(this, args);
	};

	this.prototype._initHooks = this.prototype._initHooks || [];
	this.prototype._initHooks.push(init);
};

/*
 * L.Evented is a base class that Leaflet classes inherit from to handle custom events.
 */

L.Evented = L.Class.extend({

	on: function (types, fn, context) {

		// types can be a map of types/handlers
		if (typeof types === 'object') {
			for (var type in types) {
				// we don't process space-separated events here for performance;
				// it's a hot path since Layer uses the on(obj) syntax
				this._on(type, types[type], fn);
			}

		} else {
			// types can be a string of space-separated words
			types = L.Util.splitWords(types);

			for (var i = 0, len = types.length; i < len; i++) {
				this._on(types[i], fn, context);
			}
		}

		return this;
	},

	off: function (types, fn, context) {

		if (!types) {
			// clear all listeners if called without arguments
			delete this._events;

		} else if (typeof types === 'object') {
			for (var type in types) {
				this._off(type, types[type], fn);
			}

		} else {
			types = L.Util.splitWords(types);

			for (var i = 0, len = types.length; i < len; i++) {
				this._off(types[i], fn, context);
			}
		}

		return this;
	},

	// attach listener (without syntactic sugar now)
	_on: function (type, fn, context) {

		var events = this._events = this._events || {},
		    contextId = context && context !== this && L.stamp(context);

		if (contextId) {
			// store listeners with custom context in a separate hash (if it has an id);
			// gives a major performance boost when firing and removing events (e.g. on map object)

			var indexKey = type + '_idx',
			    indexLenKey = type + '_len',
			    typeIndex = events[indexKey] = events[indexKey] || {},
			    id = L.stamp(fn) + '_' + contextId;

			if (!typeIndex[id]) {
				typeIndex[id] = {fn: fn, ctx: context};

				// keep track of the number of keys in the index to quickly check if it's empty
				events[indexLenKey] = (events[indexLenKey] || 0) + 1;
			}

		} else {
			// individual layers mostly use "this" for context and don't fire listeners too often
			// so simple array makes the memory footprint better while not degrading performance

			events[type] = events[type] || [];
			events[type].push({fn: fn});
		}
	},

	_off: function (type, fn, context) {
		var events = this._events,
		    indexKey = type + '_idx',
		    indexLenKey = type + '_len';

		if (!events) { return; }

		if (!fn) {
			// clear all listeners for a type if function isn't specified
			delete events[type];
			delete events[indexKey];
			delete events[indexLenKey];
			return;
		}

		var contextId = context && context !== this && L.stamp(context),
		    listeners, i, len, listener, id;

		if (contextId) {
			id = L.stamp(fn) + '_' + contextId;
			listeners = events[indexKey];

			if (listeners && listeners[id]) {
				listener = listeners[id];
				delete listeners[id];
				events[indexLenKey]--;
			}

		} else {
			listeners = events[type];

			if (listeners) {
				for (i = 0, len = listeners.length; i < len; i++) {
					if (listeners[i].fn === fn) {
						listener = listeners[i];
						listeners.splice(i, 1);
						break;
					}
				}
			}
		}

		// set the removed listener to noop so that's not called if remove happens in fire
		if (listener) {
			listener.fn = L.Util.falseFn;
		}
	},

	fire: function (type, data, propagate) {
		if (!this.listens(type, propagate)) { return this; }

		var event = L.Util.extend({}, data, {type: type, target: this}),
		    events = this._events;

		if (events) {
		    var typeIndex = events[type + '_idx'],
		        i, len, listeners, id;

			if (events[type]) {
				// make sure adding/removing listeners inside other listeners won't cause infinite loop
				listeners = events[type].slice();

				for (i = 0, len = listeners.length; i < len; i++) {
					listeners[i].fn.call(this, event);
				}
			}

			// fire event for the context-indexed listeners as well
			for (id in typeIndex) {
				typeIndex[id].fn.call(typeIndex[id].ctx, event);
			}
		}

		if (propagate) {
			// propagate the event to parents (set with addEventParent)
			this._propagateEvent(event);
		}

		return this;
	},

	listens: function (type, propagate) {
		var events = this._events;

		if (events && (events[type] || events[type + '_len'])) { return true; }

		if (propagate) {
			// also check parents for listeners if event propagates
			for (var id in this._eventParents) {
				if (this._eventParents[id].listens(type, propagate)) { return true; }
			}
		}
		return false;
	},

	once: function (types, fn, context) {

		if (typeof types === 'object') {
			for (var type in types) {
				this.once(type, types[type], fn);
			}
			return this;
		}

		var handler = L.bind(function () {
			this
			    .off(types, fn, context)
			    .off(types, handler, context);
		}, this);

		// add a listener that's executed once and removed after that
		return this
		    .on(types, fn, context)
		    .on(types, handler, context);
	},

	// adds a parent to propagate events to (when you fire with true as a 3rd argument)
	addEventParent: function (obj) {
		this._eventParents = this._eventParents || {};
		this._eventParents[L.stamp(obj)] = obj;
		return this;
	},

	removeEventParent: function (obj) {
		if (this._eventParents) {
			delete this._eventParents[L.stamp(obj)];
		}
		return this;
	},

	_propagateEvent: function (e) {
		for (var id in this._eventParents) {
			this._eventParents[id].fire(e.type, L.extend({layer: e.target}, e), true);
		}
	}
});

var proto = L.Evented.prototype;

// aliases; we should ditch those eventually
proto.addEventListener = proto.on;
proto.removeEventListener = proto.clearAllEventListeners = proto.off;
proto.addOneTimeEventListener = proto.once;
proto.fireEvent = proto.fire;
proto.hasEventListeners = proto.listens;

L.Mixin = {Events: proto};

/*
 * L.Browser handles different browser and feature detections for internal Leaflet use.
 */

(function () {

	var ua = navigator.userAgent.toLowerCase(),
	    doc = document.documentElement,

	    ie = 'ActiveXObject' in window,

	    webkit    = ua.indexOf('webkit') !== -1,
	    phantomjs = ua.indexOf('phantom') !== -1,
	    android23 = ua.search('android [23]') !== -1,
	    chrome    = ua.indexOf('chrome') !== -1,

	    mobile = typeof orientation !== 'undefined',
	    msPointer = navigator.msPointerEnabled && navigator.msMaxTouchPoints && !window.PointerEvent,
	    pointer = (window.PointerEvent && navigator.pointerEnabled && navigator.maxTouchPoints) || msPointer,

	    ie3d = ie && ('transition' in doc.style),
	    webkit3d = ('WebKitCSSMatrix' in window) && ('m11' in new window.WebKitCSSMatrix()) && !android23,
	    gecko3d = 'MozPerspective' in doc.style,
	    opera3d = 'OTransition' in doc.style;


	var retina = 'devicePixelRatio' in window && window.devicePixelRatio > 1;

	if (!retina && 'matchMedia' in window) {
		var matches = window.matchMedia('(min-resolution:144dpi)');
		retina = matches && matches.matches;
	}

	var touch = !window.L_NO_TOUCH && !phantomjs && (pointer || 'ontouchstart' in window ||
			(window.DocumentTouch && document instanceof window.DocumentTouch));

	L.Browser = {
		ie: ie,
		ielt9: ie && !document.addEventListener,
		webkit: webkit,
		gecko: (ua.indexOf('gecko') !== -1) && !webkit && !window.opera && !ie,
		android: ua.indexOf('android') !== -1,
		android23: android23,
		chrome: chrome,
		safari: !chrome && ua.indexOf('safari') !== -1,

		ie3d: ie3d,
		webkit3d: webkit3d,
		gecko3d: gecko3d,
		opera3d: opera3d,
		any3d: !window.L_DISABLE_3D && (ie3d || webkit3d || gecko3d || opera3d) && !phantomjs,

		mobile: mobile,
		mobileWebkit: mobile && webkit,
		mobileWebkit3d: mobile && webkit3d,
		mobileOpera: mobile && window.opera,

		touch: !!touch,
		msPointer: !!msPointer,
		pointer: !!pointer,

		retina: !!retina
	};

}());

/*
 * L.Point represents a point with x and y coordinates.
 */

L.Point = function (/*Number*/ x, /*Number*/ y, /*Boolean*/ round) {
	this.x = (round ? Math.round(x) : x);
	this.y = (round ? Math.round(y) : y);
};

L.Point.prototype = {

	clone: function () {
		return new L.Point(this.x, this.y);
	},

	// non-destructive, returns a new point
	add: function (point) {
		return this.clone()._add(L.point(point));
	},

	// destructive, used directly for performance in situations where it's safe to modify existing point
	_add: function (point) {
		this.x += point.x;
		this.y += point.y;
		return this;
	},

	subtract: function (point) {
		return this.clone()._subtract(L.point(point));
	},

	_subtract: function (point) {
		this.x -= point.x;
		this.y -= point.y;
		return this;
	},

	divideBy: function (num) {
		return this.clone()._divideBy(num);
	},

	_divideBy: function (num) {
		this.x /= num;
		this.y /= num;
		return this;
	},

	multiplyBy: function (num) {
		return this.clone()._multiplyBy(num);
	},

	_multiplyBy: function (num) {
		this.x *= num;
		this.y *= num;
		return this;
	},

	round: function () {
		return this.clone()._round();
	},

	_round: function () {
		this.x = Math.round(this.x);
		this.y = Math.round(this.y);
		return this;
	},

	floor: function () {
		return this.clone()._floor();
	},

	_floor: function () {
		this.x = Math.floor(this.x);
		this.y = Math.floor(this.y);
		return this;
	},

	ceil: function () {
		return this.clone()._ceil();
	},

	_ceil: function () {
		this.x = Math.ceil(this.x);
		this.y = Math.ceil(this.y);
		return this;
	},

	distanceTo: function (point) {
		point = L.point(point);

		var x = point.x - this.x,
		    y = point.y - this.y;

		return Math.sqrt(x * x + y * y);
	},

	equals: function (point) {
		point = L.point(point);

		return point.x === this.x &&
		       point.y === this.y;
	},

	contains: function (point) {
		point = L.point(point);

		return Math.abs(point.x) <= Math.abs(this.x) &&
		       Math.abs(point.y) <= Math.abs(this.y);
	},

	toString: function () {
		return 'Point(' +
		        L.Util.formatNum(this.x) + ', ' +
		        L.Util.formatNum(this.y) + ')';
	}
};

L.point = function (x, y, round) {
	if (x instanceof L.Point) {
		return x;
	}
	if (L.Util.isArray(x)) {
		return new L.Point(x[0], x[1]);
	}
	if (x === undefined || x === null) {
		return x;
	}
	return new L.Point(x, y, round);
};

/*
 * L.Bounds represents a rectangular area on the screen in pixel coordinates.
 */

L.Bounds = function (a, b) { //(Point, Point) or Point[]
	if (!a) { return; }

	var points = b ? [a, b] : a;

	for (var i = 0, len = points.length; i < len; i++) {
		this.extend(points[i]);
	}
};

L.Bounds.prototype = {
	// extend the bounds to contain the given point
	extend: function (point) { // (Point)
		point = L.point(point);

		if (!this.min && !this.max) {
			this.min = point.clone();
			this.max = point.clone();
		} else {
			this.min.x = Math.min(point.x, this.min.x);
			this.max.x = Math.max(point.x, this.max.x);
			this.min.y = Math.min(point.y, this.min.y);
			this.max.y = Math.max(point.y, this.max.y);
		}
		return this;
	},

	getCenter: function (round) { // (Boolean) -> Point
		return new L.Point(
		        (this.min.x + this.max.x) / 2,
		        (this.min.y + this.max.y) / 2, round);
	},

	getBottomLeft: function () { // -> Point
		return new L.Point(this.min.x, this.max.y);
	},

	getTopRight: function () { // -> Point
		return new L.Point(this.max.x, this.min.y);
	},

	getSize: function () {
		return this.max.subtract(this.min);
	},

	contains: function (obj) { // (Bounds) or (Point) -> Boolean
		var min, max;

		if (typeof obj[0] === 'number' || obj instanceof L.Point) {
			obj = L.point(obj);
		} else {
			obj = L.bounds(obj);
		}

		if (obj instanceof L.Bounds) {
			min = obj.min;
			max = obj.max;
		} else {
			min = max = obj;
		}

		return (min.x >= this.min.x) &&
		       (max.x <= this.max.x) &&
		       (min.y >= this.min.y) &&
		       (max.y <= this.max.y);
	},

	intersects: function (bounds) { // (Bounds) -> Boolean
		bounds = L.bounds(bounds);

		var min = this.min,
		    max = this.max,
		    min2 = bounds.min,
		    max2 = bounds.max,
		    xIntersects = (max2.x >= min.x) && (min2.x <= max.x),
		    yIntersects = (max2.y >= min.y) && (min2.y <= max.y);

		return xIntersects && yIntersects;
	},

	isValid: function () {
		return !!(this.min && this.max);
	}
};

L.bounds = function (a, b) { // (Bounds) or (Point, Point) or (Point[])
	if (!a || a instanceof L.Bounds) {
		return a;
	}
	return new L.Bounds(a, b);
};

/*
 * L.Transformation is an utility class to perform simple point transformations through a 2d-matrix.
 */

L.Transformation = function (a, b, c, d) {
	this._a = a;
	this._b = b;
	this._c = c;
	this._d = d;
};

L.Transformation.prototype = {
	transform: function (point, scale) { // (Point, Number) -> Point
		return this._transform(point.clone(), scale);
	},

	// destructive transform (faster)
	_transform: function (point, scale) {
		scale = scale || 1;
		point.x = scale * (this._a * point.x + this._b);
		point.y = scale * (this._c * point.y + this._d);
		return point;
	},

	untransform: function (point, scale) {
		scale = scale || 1;
		return new L.Point(
		        (point.x / scale - this._b) / this._a,
		        (point.y / scale - this._d) / this._c);
	}
};

/*
 * L.DomUtil contains various utility functions for working with DOM.
 */

L.DomUtil = {
	get: function (id) {
		return typeof id === 'string' ? document.getElementById(id) : id;
	},

	getStyle: function (el, style) {

		var value = el.style[style] || (el.currentStyle && el.currentStyle[style]);

		if ((!value || value === 'auto') && document.defaultView) {
			var css = document.defaultView.getComputedStyle(el, null);
			value = css ? css[style] : null;
		}

		return value === 'auto' ? null : value;
	},

	create: function (tagName, className, container) {

		var el = document.createElement(tagName);
		el.className = className;

		if (container) {
			container.appendChild(el);
		}

		return el;
	},

	remove: function (el) {
		var parent = el.parentNode;
		if (parent) {
			parent.removeChild(el);
		}
	},

	toFront: function (el) {
		el.parentNode.appendChild(el);
	},

	toBack: function (el) {
		var parent = el.parentNode;
		parent.insertBefore(el, parent.firstChild);
	},

	hasClass: function (el, name) {
		if (el.classList !== undefined) {
			return el.classList.contains(name);
		}
		var className = L.DomUtil.getClass(el);
		return className.length > 0 && new RegExp('(^|\\s)' + name + '(\\s|$)').test(className);
	},

	addClass: function (el, name) {
		if (el.classList !== undefined) {
			var classes = L.Util.splitWords(name);
			for (var i = 0, len = classes.length; i < len; i++) {
				el.classList.add(classes[i]);
			}
		} else if (!L.DomUtil.hasClass(el, name)) {
			var className = L.DomUtil.getClass(el);
			L.DomUtil.setClass(el, (className ? className + ' ' : '') + name);
		}
	},

	removeClass: function (el, name) {
		if (el.classList !== undefined) {
			el.classList.remove(name);
		} else {
			L.DomUtil.setClass(el, L.Util.trim((' ' + L.DomUtil.getClass(el) + ' ').replace(' ' + name + ' ', ' ')));
		}
	},

	setClass: function (el, name) {
		if (el.className.baseVal === undefined) {
			el.className = name;
		} else {
			// in case of SVG element
			el.className.baseVal = name;
		}
	},

	getClass: function (el) {
		return el.className.baseVal === undefined ? el.className : el.className.baseVal;
	},

	setOpacity: function (el, value) {

		if ('opacity' in el.style) {
			el.style.opacity = value;

		} else if ('filter' in el.style) {

			var filter = false,
			    filterName = 'DXImageTransform.Microsoft.Alpha';

			// filters collection throws an error if we try to retrieve a filter that doesn't exist
			try {
				filter = el.filters.item(filterName);
			} catch (e) {
				// don't set opacity to 1 if we haven't already set an opacity,
				// it isn't needed and breaks transparent pngs.
				if (value === 1) { return; }
			}

			value = Math.round(value * 100);

			if (filter) {
				filter.Enabled = (value !== 100);
				filter.Opacity = value;
			} else {
				el.style.filter += ' progid:' + filterName + '(opacity=' + value + ')';
			}
		}
	},

	testProp: function (props) {

		var style = document.documentElement.style;

		for (var i = 0; i < props.length; i++) {
			if (props[i] in style) {
				return props[i];
			}
		}
		return false;
	},

	setTransform: function (el, offset, scale) {
		var pos = offset || new L.Point(0, 0),
			is3d = L.Browser.webkit3d,
		    open = 'translate' + (is3d ? '3d' : '') + '(',
		    close = (is3d ? ',0' : '') + ')';

		el.style[L.DomUtil.TRANSFORM] =
			open + pos.x + 'px,' + pos.y + 'px' + close + (scale ? ' scale(' + scale + ')' : '');
	},

	setPosition: function (el, point, no3d) { // (HTMLElement, Point[, Boolean])

		// jshint camelcase: false
		el._leaflet_pos = point;

		if (L.Browser.any3d && !no3d) {
			L.DomUtil.setTransform(el, point);
		} else {
			el.style.left = point.x + 'px';
			el.style.top = point.y + 'px';
		}
	},

	getPosition: function (el) {
		// this method is only used for elements previously positioned using setPosition,
		// so it's safe to cache the position for performance

		// jshint camelcase: false
		return el._leaflet_pos;
	}
};


(function () {
	// prefix style property names

	L.DomUtil.TRANSFORM = L.DomUtil.testProp(
			['transform', 'WebkitTransform', 'OTransform', 'MozTransform', 'msTransform']);


	// webkitTransition comes first because some browser versions that drop vendor prefix don't do
	// the same for the transitionend event, in particular the Android 4.1 stock browser

	var transition = L.DomUtil.TRANSITION = L.DomUtil.testProp(
			['webkitTransition', 'transition', 'OTransition', 'MozTransition', 'msTransition']);

	L.DomUtil.TRANSITION_END =
			transition === 'webkitTransition' || transition === 'OTransition' ? transition + 'End' : 'transitionend';


	if ('onselectstart' in document) {
		L.DomUtil.disableTextSelection = function () {
			L.DomEvent.on(window, 'selectstart', L.DomEvent.preventDefault);
		};
		L.DomUtil.enableTextSelection = function () {
			L.DomEvent.off(window, 'selectstart', L.DomEvent.preventDefault);
		};

	} else {
		var userSelectProperty = L.DomUtil.testProp(
			['userSelect', 'WebkitUserSelect', 'OUserSelect', 'MozUserSelect', 'msUserSelect']);

		L.DomUtil.disableTextSelection = function () {
			if (userSelectProperty) {
				var style = document.documentElement.style;
				this._userSelect = style[userSelectProperty];
				style[userSelectProperty] = 'none';
			}
		};
		L.DomUtil.enableTextSelection = function () {
			if (userSelectProperty) {
				document.documentElement.style[userSelectProperty] = this._userSelect;
				delete this._userSelect;
			}
		};
	}

	L.DomUtil.disableImageDrag = function () {
		L.DomEvent.on(window, 'dragstart', L.DomEvent.preventDefault);
	};
	L.DomUtil.enableImageDrag = function () {
		L.DomEvent.off(window, 'dragstart', L.DomEvent.preventDefault);
	};
})();

/*
 * L.LatLng represents a geographical point with latitude and longitude coordinates.
 */

L.LatLng = function (lat, lng, alt) {
	if (isNaN(lat) || isNaN(lng)) {
		throw new Error('Invalid LatLng object: (' + lat + ', ' + lng + ')');
	}

	this.lat = +lat;
	this.lng = +lng;

	if (alt !== undefined) {
		this.alt = +alt;
	}
};

L.LatLng.prototype = {
	equals: function (obj, maxMargin) {
		if (!obj) { return false; }

		obj = L.latLng(obj);

		var margin = Math.max(
		        Math.abs(this.lat - obj.lat),
		        Math.abs(this.lng - obj.lng));

		return margin <= (maxMargin === undefined ? 1.0E-9 : maxMargin);
	},

	toString: function (precision) {
		return 'LatLng(' +
		        L.Util.formatNum(this.lat, precision) + ', ' +
		        L.Util.formatNum(this.lng, precision) + ')';
	},

	distanceTo: function (other) {
		return L.CRS.Earth.distance(this, L.latLng(other));
	},

	wrap: function () {
		return L.CRS.Earth.wrapLatLng(this);
	}
};


// constructs LatLng with different signatures
// (LatLng) or ([Number, Number]) or (Number, Number) or (Object)

L.latLng = function (a, b) {
	if (a instanceof L.LatLng) {
		return a;
	}
	if (L.Util.isArray(a) && typeof a[0] !== 'object') {
		if (a.length === 3) {
			return new L.LatLng(a[0], a[1], a[2]);
		}
		return new L.LatLng(a[0], a[1]);
	}
	if (a === undefined || a === null) {
		return a;
	}
	if (typeof a === 'object' && 'lat' in a) {
		return new L.LatLng(a.lat, 'lng' in a ? a.lng : a.lon);
	}
	if (b === undefined) {
		return null;
	}
	return new L.LatLng(a, b);
};


/*
 * L.LatLngBounds represents a rectangular area on the map in geographical coordinates.
 */

L.LatLngBounds = function (southWest, northEast) { // (LatLng, LatLng) or (LatLng[])
	if (!southWest) { return; }

	var latlngs = northEast ? [southWest, northEast] : southWest;

	for (var i = 0, len = latlngs.length; i < len; i++) {
		this.extend(latlngs[i]);
	}
};

L.LatLngBounds.prototype = {

	// extend the bounds to contain the given point or bounds
	extend: function (obj) { // (LatLng) or (LatLngBounds)
		var sw = this._southWest,
			ne = this._northEast,
			sw2, ne2;

		if (obj instanceof L.LatLng) {
			sw2 = obj;
			ne2 = obj;

		} else if (obj instanceof L.LatLngBounds) {
			sw2 = obj._southWest;
			ne2 = obj._northEast;

			if (!sw2 || !ne2) { return this; }

		} else {
			return obj ? this.extend(L.latLng(obj) || L.latLngBounds(obj)) : this;
		}

		if (!sw && !ne) {
			this._southWest = new L.LatLng(sw2.lat, sw2.lng);
			this._northEast = new L.LatLng(ne2.lat, ne2.lng);
		} else {
			sw.lat = Math.min(sw2.lat, sw.lat);
			sw.lng = Math.min(sw2.lng, sw.lng);
			ne.lat = Math.max(ne2.lat, ne.lat);
			ne.lng = Math.max(ne2.lng, ne.lng);
		}

		return this;
	},

	// extend the bounds by a percentage
	pad: function (bufferRatio) { // (Number) -> LatLngBounds
		var sw = this._southWest,
		    ne = this._northEast,
		    heightBuffer = Math.abs(sw.lat - ne.lat) * bufferRatio,
		    widthBuffer = Math.abs(sw.lng - ne.lng) * bufferRatio;

		return new L.LatLngBounds(
		        new L.LatLng(sw.lat - heightBuffer, sw.lng - widthBuffer),
		        new L.LatLng(ne.lat + heightBuffer, ne.lng + widthBuffer));
	},

	getCenter: function () { // -> LatLng
		return new L.LatLng(
		        (this._southWest.lat + this._northEast.lat) / 2,
		        (this._southWest.lng + this._northEast.lng) / 2);
	},

	getSouthWest: function () {
		return this._southWest;
	},

	getNorthEast: function () {
		return this._northEast;
	},

	getNorthWest: function () {
		return new L.LatLng(this.getNorth(), this.getWest());
	},

	getSouthEast: function () {
		return new L.LatLng(this.getSouth(), this.getEast());
	},

	getWest: function () {
		return this._southWest.lng;
	},

	getSouth: function () {
		return this._southWest.lat;
	},

	getEast: function () {
		return this._northEast.lng;
	},

	getNorth: function () {
		return this._northEast.lat;
	},

	contains: function (obj) { // (LatLngBounds) or (LatLng) -> Boolean
		if (typeof obj[0] === 'number' || obj instanceof L.LatLng) {
			obj = L.latLng(obj);
		} else {
			obj = L.latLngBounds(obj);
		}

		var sw = this._southWest,
		    ne = this._northEast,
		    sw2, ne2;

		if (obj instanceof L.LatLngBounds) {
			sw2 = obj.getSouthWest();
			ne2 = obj.getNorthEast();
		} else {
			sw2 = ne2 = obj;
		}

		return (sw2.lat >= sw.lat) && (ne2.lat <= ne.lat) &&
		       (sw2.lng >= sw.lng) && (ne2.lng <= ne.lng);
	},

	intersects: function (bounds) { // (LatLngBounds)
		bounds = L.latLngBounds(bounds);

		var sw = this._southWest,
		    ne = this._northEast,
		    sw2 = bounds.getSouthWest(),
		    ne2 = bounds.getNorthEast(),

		    latIntersects = (ne2.lat >= sw.lat) && (sw2.lat <= ne.lat),
		    lngIntersects = (ne2.lng >= sw.lng) && (sw2.lng <= ne.lng);

		return latIntersects && lngIntersects;
	},

	toBBoxString: function () {
		return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(',');
	},

	equals: function (bounds) { // (LatLngBounds)
		if (!bounds) { return false; }

		bounds = L.latLngBounds(bounds);

		return this._southWest.equals(bounds.getSouthWest()) &&
		       this._northEast.equals(bounds.getNorthEast());
	},

	isValid: function () {
		return !!(this._southWest && this._northEast);
	}
};

//TODO International date line?

L.latLngBounds = function (a, b) { // (LatLngBounds) or (LatLng, LatLng)
	if (!a || a instanceof L.LatLngBounds) {
		return a;
	}
	return new L.LatLngBounds(a, b);
};

/*
 * Simple equirectangular (Plate Carree) projection, used by CRS like EPSG:4326 and Simple.
 */

L.Projection = {};

L.Projection.LonLat = {
	project: function (latlng) {
		return new L.Point(latlng.lng, latlng.lat);
	},

	unproject: function (point) {
		return new L.LatLng(point.y, point.x);
	},

	bounds: L.bounds([-180, -90], [180, 90])
};

/*
 * Spherical Mercator is the most popular map projection, used by EPSG:3857 CRS used by default.
 */

L.Projection.SphericalMercator = {

	R: 6378137,

	project: function (latlng) {
		var d = Math.PI / 180,
		    max = 1 - 1E-15,
		    sin = Math.max(Math.min(Math.sin(latlng.lat * d), max), -max);

		return new L.Point(
				this.R * latlng.lng * d,
				this.R * Math.log((1 + sin) / (1 - sin)) / 2);
	},

	unproject: function (point) {
		var d = 180 / Math.PI;

		return new L.LatLng(
			(2 * Math.atan(Math.exp(point.y / this.R)) - (Math.PI / 2)) * d,
			point.x * d / this.R);
	},

	bounds: (function () {
		var d = 6378137 * Math.PI;
		return L.bounds([-d, -d], [d, d]);
	})()
};

/*
 * L.CRS is the base object for all defined CRS (Coordinate Reference Systems) in Leaflet.
 */

L.CRS = {
	// converts geo coords to pixel ones
	latLngToPoint: function (latlng, zoom) {
		var projectedPoint = this.projection.project(latlng),
		    scale = this.scale(zoom);

		return this.transformation._transform(projectedPoint, scale);
	},

	// converts pixel coords to geo coords
	pointToLatLng: function (point, zoom) {
		var scale = this.scale(zoom),
		    untransformedPoint = this.transformation.untransform(point, scale);

		return this.projection.unproject(untransformedPoint);
	},

	// converts geo coords to projection-specific coords (e.g. in meters)
	project: function (latlng) {
		return this.projection.project(latlng);
	},

	// converts projected coords to geo coords
	unproject: function (point) {
		return this.projection.unproject(point);
	},

	// defines how the world scales with zoom
	scale: function (zoom) {
		return 256 * Math.pow(2, zoom);
	},

	// returns the bounds of the world in projected coords if applicable
	getProjectedBounds: function (zoom) {
		if (this.infinite) { return null; }

		var b = this.projection.bounds,
		    s = this.scale(zoom),
		    min = this.transformation.transform(b.min, s),
		    max = this.transformation.transform(b.max, s);

		return L.bounds(min, max);
	},

	// whether a coordinate axis wraps in a given range (e.g. longitude from -180 to 180); depends on CRS
	// wrapLng: [min, max],
	// wrapLat: [min, max],

	// if true, the coordinate space will be unbounded (infinite in all directions)
	// infinite: false,

	// wraps geo coords in certain ranges if applicable
	wrapLatLng: function (latlng) {
		var lng = this.wrapLng ? L.Util.wrapNum(latlng.lng, this.wrapLng, true) : latlng.lng,
		    lat = this.wrapLat ? L.Util.wrapNum(latlng.lat, this.wrapLat, true) : latlng.lat;

		return L.latLng(lat, lng);
	}
};

/*
 * A simple CRS that can be used for flat non-Earth maps like panoramas or game maps.
 */

L.CRS.Simple = L.extend({}, L.CRS, {
	projection: L.Projection.LonLat,
	transformation: new L.Transformation(1, 0, -1, 0),

	scale: function (zoom) {
		return Math.pow(2, zoom);
	},

	distance: function (latlng1, latlng2) {
		var dx = latlng2.lng - latlng1.lng,
		    dy = latlng2.lat - latlng1.lat;

		return Math.sqrt(dx * dx + dy * dy);
	},

	infinite: true
});

/*
 * L.CRS.Earth is the base class for all CRS representing Earth.
 */

L.CRS.Earth = L.extend({}, L.CRS, {
	wrapLng: [-180, 180],

	R: 6378137,

	// distane between two geographical points using spherical law of cosines approximation
	distance: function (latlng1, latlng2) {
		var rad = Math.PI / 180,
		    lat1 = latlng1.lat * rad,
		    lat2 = latlng2.lat * rad;

		return this.R * Math.acos(Math.sin(lat1) * Math.sin(lat2) +
				Math.cos(lat1) * Math.cos(lat2) * Math.cos((latlng2.lng - latlng1.lng) * rad));
	}
});

/*
 * L.CRS.EPSG3857 (Spherical Mercator) is the most common CRS for web mapping and is used by Leaflet by default.
 */

L.CRS.EPSG3857 = L.extend({}, L.CRS.Earth, {
	code: 'EPSG:3857',
	projection: L.Projection.SphericalMercator,

	transformation: (function () {
		var scale = 0.5 / (Math.PI * L.Projection.SphericalMercator.R);
		return new L.Transformation(scale, 0.5, -scale, 0.5);
	}())
});

L.CRS.EPSG900913 = L.extend({}, L.CRS.EPSG3857, {
	code: 'EPSG:900913'
});

/*
 * L.CRS.EPSG4326 is a CRS popular among advanced GIS specialists.
 */

L.CRS.EPSG4326 = L.extend({}, L.CRS.Earth, {
	code: 'EPSG:4326',
	projection: L.Projection.LonLat,
	transformation: new L.Transformation(1 / 180, 1, -1 / 180, 0.5)
});

/*
 * L.Map is the central class of the API - it is used to create a map.
 */

L.Map = L.Evented.extend({

	options: {
		crs: L.CRS.EPSG3857,

		/*
		center: LatLng,
		zoom: Number,
		layers: Array,
		*/

		fadeAnimation: true,
		trackResize: true,
		markerZoomAnimation: true
	},

	initialize: function (id, options) { // (HTMLElement or String, Object)
		options = L.setOptions(this, options);

		this._initContainer(id);
		this._initLayout();

		// hack for https://github.com/Leaflet/Leaflet/issues/1980
		this._onResize = L.bind(this._onResize, this);

		this._initEvents();

		if (options.maxBounds) {
			this.setMaxBounds(options.maxBounds);
		}

		if (options.center && options.zoom !== undefined) {
			this.setView(L.latLng(options.center), options.zoom, {reset: true});
		}

		this._handlers = [];
		this._layers = {};
		this._zoomBoundLayers = {};

		this.callInitHooks();

		this._addLayers(this.options.layers);
	},


	// public methods that modify map state

	// replaced by animation-powered implementation in Map.PanAnimation.js
	setView: function (center, zoom) {
		zoom = zoom === undefined ? this.getZoom() : zoom;
		this._resetView(L.latLng(center), this._limitZoom(zoom));
		return this;
	},

	setZoom: function (zoom, options) {
		if (!this._loaded) {
			this._zoom = this._limitZoom(zoom);
			return this;
		}
		return this.setView(this.getCenter(), zoom, {zoom: options});
	},

	zoomIn: function (delta, options) {
		return this.setZoom(this._zoom + (delta || 1), options);
	},

	zoomOut: function (delta, options) {
		return this.setZoom(this._zoom - (delta || 1), options);
	},

	setZoomAround: function (latlng, zoom, options) {
		var scale = this.getZoomScale(zoom),
		    viewHalf = this.getSize().divideBy(2),
		    containerPoint = latlng instanceof L.Point ? latlng : this.latLngToContainerPoint(latlng),

		    centerOffset = containerPoint.subtract(viewHalf).multiplyBy(1 - 1 / scale),
		    newCenter = this.containerPointToLatLng(viewHalf.add(centerOffset));

		return this.setView(newCenter, zoom, {zoom: options});
	},

	fitBounds: function (bounds, options) {

		options = options || {};
		bounds = bounds.getBounds ? bounds.getBounds() : L.latLngBounds(bounds);

		var paddingTL = L.point(options.paddingTopLeft || options.padding || [0, 0]),
		    paddingBR = L.point(options.paddingBottomRight || options.padding || [0, 0]),

		    zoom = this.getBoundsZoom(bounds, false, paddingTL.add(paddingBR));

		zoom = options.maxZoom ? Math.min(options.maxZoom, zoom) : zoom;

		var paddingOffset = paddingBR.subtract(paddingTL).divideBy(2),

		    swPoint = this.project(bounds.getSouthWest(), zoom),
		    nePoint = this.project(bounds.getNorthEast(), zoom),
		    center = this.unproject(swPoint.add(nePoint).divideBy(2).add(paddingOffset), zoom);

		return this.setView(center, zoom, options);
	},

	fitWorld: function (options) {
		return this.fitBounds([[-90, -180], [90, 180]], options);
	},

	panTo: function (center, options) { // (LatLng)
		return this.setView(center, this._zoom, {pan: options});
	},

	panBy: function (offset) { // (Point)
		// replaced with animated panBy in Map.PanAnimation.js
		this.fire('movestart');

		this._rawPanBy(L.point(offset));

		this.fire('move');
		return this.fire('moveend');
	},

	setMaxBounds: function (bounds) {
		bounds = L.latLngBounds(bounds);

		this.options.maxBounds = bounds;

		if (!bounds) {
			return this.off('moveend', this._panInsideMaxBounds);
		}

		if (this._loaded) {
			this._panInsideMaxBounds();
		}

		return this.on('moveend', this._panInsideMaxBounds);
	},

	panInsideBounds: function (bounds, options) {
		var center = this.getCenter(),
			newCenter = this._limitCenter(center, this._zoom, bounds);

		if (center.equals(newCenter)) { return this; }

		return this.panTo(newCenter, options);
	},

	invalidateSize: function (options) {
		if (!this._loaded) { return this; }

		options = L.extend({
			animate: false,
			pan: true
		}, options === true ? {animate: true} : options);

		var oldSize = this.getSize();
		this._sizeChanged = true;
		this._initialCenter = null;

		var newSize = this.getSize(),
		    oldCenter = oldSize.divideBy(2).round(),
		    newCenter = newSize.divideBy(2).round(),
		    offset = oldCenter.subtract(newCenter);

		if (!offset.x && !offset.y) { return this; }

		if (options.animate && options.pan) {
			this.panBy(offset);

		} else {
			if (options.pan) {
				this._rawPanBy(offset);
			}

			this.fire('move');

			if (options.debounceMoveend) {
				clearTimeout(this._sizeTimer);
				this._sizeTimer = setTimeout(L.bind(this.fire, this, 'moveend'), 200);
			} else {
				this.fire('moveend');
			}
		}

		return this.fire('resize', {
			oldSize: oldSize,
			newSize: newSize
		});
	},

	// TODO handler.addTo
	addHandler: function (name, HandlerClass) {
		if (!HandlerClass) { return this; }

		var handler = this[name] = new HandlerClass(this);

		this._handlers.push(handler);

		if (this.options[name]) {
			handler.enable();
		}

		return this;
	},

	remove: function () {

		this._initEvents('off');

		try {
			// throws error in IE6-8
			delete this._container._leaflet;
		} catch (e) {
			this._container._leaflet = undefined;
		}

		L.DomUtil.remove(this._mapPane);

		if (this._clearControlPos) {
			this._clearControlPos();
		}

		this._clearHandlers();

		if (this._loaded) {
			this.fire('unload');
		}

		return this;
	},

	createPane: function (name, container) {
		var className = 'leaflet-pane' + (name ? ' leaflet-' + name.replace('Pane', '') + '-pane' : ''),
		    pane = L.DomUtil.create('div', className, container || this._mapPane);

		if (name) {
			this._panes[name] = pane;
		}
		return pane;
	},


	// public methods for getting map state

	getCenter: function () { // (Boolean) -> LatLng
		this._checkIfLoaded();

		if (this._initialCenter && !this._moved()) {
			return this._initialCenter;
		}
		return this.layerPointToLatLng(this._getCenterLayerPoint());
	},

	getZoom: function () {
		return this._zoom;
	},

	getBounds: function () {
		var bounds = this.getPixelBounds(),
		    sw = this.unproject(bounds.getBottomLeft()),
		    ne = this.unproject(bounds.getTopRight());

		return new L.LatLngBounds(sw, ne);
	},

	getMinZoom: function () {
		return this.options.minZoom === undefined ? this._layersMinZoom || 0 : this.options.minZoom;
	},

	getMaxZoom: function () {
		return this.options.maxZoom === undefined ?
			(this._layersMaxZoom === undefined ? Infinity : this._layersMaxZoom) :
			this.options.maxZoom;
	},

	getBoundsZoom: function (bounds, inside, padding) { // (LatLngBounds[, Boolean, Point]) -> Number
		bounds = L.latLngBounds(bounds);

		var zoom = this.getMinZoom() - (inside ? 1 : 0),
		    maxZoom = this.getMaxZoom(),
		    size = this.getSize(),

		    nw = bounds.getNorthWest(),
		    se = bounds.getSouthEast(),

		    zoomNotFound = true,
		    boundsSize;

		padding = L.point(padding || [0, 0]);

		do {
			zoom++;
			boundsSize = this.project(se, zoom).subtract(this.project(nw, zoom)).add(padding);
			zoomNotFound = !inside ? size.contains(boundsSize) : boundsSize.x < size.x || boundsSize.y < size.y;

		} while (zoomNotFound && zoom <= maxZoom);

		if (zoomNotFound && inside) {
			return null;
		}

		return inside ? zoom : zoom - 1;
	},

	getSize: function () {
		if (!this._size || this._sizeChanged) {
			this._size = new L.Point(
				this._container.clientWidth,
				this._container.clientHeight);

			this._sizeChanged = false;
		}
		return this._size.clone();
	},

	getPixelBounds: function () {
		var topLeftPoint = this._getTopLeftPoint();
		return new L.Bounds(topLeftPoint, topLeftPoint.add(this.getSize()));
	},

	getPixelOrigin: function () {
		this._checkIfLoaded();
		return this._initialTopLeftPoint;
	},

	getPixelWorldBounds: function () {
		return this.options.crs.getProjectedBounds(this.getZoom());
	},

	getPane: function (pane) {
		return typeof pane === 'string' ? this._panes[pane] : pane;
	},

	getPanes: function () {
		return this._panes;
	},

	getContainer: function () {
		return this._container;
	},


	// TODO replace with universal implementation after refactoring projections

	getZoomScale: function (toZoom) {
		var crs = this.options.crs;
		return crs.scale(toZoom) / crs.scale(this._zoom);
	},

	getScaleZoom: function (scale) {
		return this._zoom + (Math.log(scale) / Math.LN2);
	},


	// conversion methods

	project: function (latlng, zoom) { // (LatLng[, Number]) -> Point
		zoom = zoom === undefined ? this._zoom : zoom;
		return this.options.crs.latLngToPoint(L.latLng(latlng), zoom);
	},

	unproject: function (point, zoom) { // (Point[, Number]) -> LatLng
		zoom = zoom === undefined ? this._zoom : zoom;
		return this.options.crs.pointToLatLng(L.point(point), zoom);
	},

	layerPointToLatLng: function (point) { // (Point)
		var projectedPoint = L.point(point).add(this.getPixelOrigin());
		return this.unproject(projectedPoint);
	},

	latLngToLayerPoint: function (latlng) { // (LatLng)
		var projectedPoint = this.project(L.latLng(latlng))._round();
		return projectedPoint._subtract(this.getPixelOrigin());
	},

	wrapLatLng: function (latlng) {
		return this.options.crs.wrapLatLng(L.latLng(latlng));
	},

	distance: function (latlng1, latlng2) {
		return this.options.crs.distance(L.latLng(latlng1), L.latLng(latlng2));
	},

	containerPointToLayerPoint: function (point) { // (Point)
		return L.point(point).subtract(this._getMapPanePos());
	},

	layerPointToContainerPoint: function (point) { // (Point)
		return L.point(point).add(this._getMapPanePos());
	},

	containerPointToLatLng: function (point) {
		var layerPoint = this.containerPointToLayerPoint(L.point(point));
		return this.layerPointToLatLng(layerPoint);
	},

	latLngToContainerPoint: function (latlng) {
		return this.layerPointToContainerPoint(this.latLngToLayerPoint(L.latLng(latlng)));
	},

	mouseEventToContainerPoint: function (e) { // (MouseEvent)
		return L.DomEvent.getMousePosition(e, this._container);
	},

	mouseEventToLayerPoint: function (e) { // (MouseEvent)
		return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(e));
	},

	mouseEventToLatLng: function (e) { // (MouseEvent)
		return this.layerPointToLatLng(this.mouseEventToLayerPoint(e));
	},


	// map initialization methods

	_initContainer: function (id) {
		var container = this._container = L.DomUtil.get(id);

		if (!container) {
			throw new Error('Map container not found.');
		} else if (container._leaflet) {
			throw new Error('Map container is already initialized.');
		}

		container._leaflet = true;
	},

	_initLayout: function () {
		var container = this._container;

		this._fadeAnimated = this.options.fadeAnimation && L.Browser.any3d;

		L.DomUtil.addClass(container, 'leaflet-container' +
			(L.Browser.touch ? ' leaflet-touch' : '') +
			(L.Browser.retina ? ' leaflet-retina' : '') +
			(L.Browser.ielt9 ? ' leaflet-oldie' : '') +
			(L.Browser.safari ? ' leaflet-safari' : '') +
			(this._fadeAnimated ? ' leaflet-fade-anim' : ''));

		var position = L.DomUtil.getStyle(container, 'position');

		if (position !== 'absolute' && position !== 'relative' && position !== 'fixed') {
			container.style.position = 'relative';
		}

		this._initPanes();

		if (this._initControlPos) {
			this._initControlPos();
		}
	},

	_initPanes: function () {
		var panes = this._panes = {};

		this._mapPane = this.createPane('mapPane', this._container);

		this.createPane('tilePane');
		this.createPane('shadowPane');
		this.createPane('overlayPane');
		this.createPane('markerPane');
		this.createPane('popupPane');

		if (!this.options.markerZoomAnimation) {
			L.DomUtil.addClass(panes.markerPane, 'leaflet-zoom-hide');
			L.DomUtil.addClass(panes.shadowPane, 'leaflet-zoom-hide');
		}
	},


	// private methods that modify map state

	_resetView: function (center, zoom, preserveMapOffset, afterZoomAnim) {

		var zoomChanged = (this._zoom !== zoom);

		if (!afterZoomAnim) {
			this.fire('movestart');

			if (zoomChanged) {
				this.fire('zoomstart');
			}
		}

		this._zoom = zoom;
		this._initialCenter = center;

		this._initialTopLeftPoint = this._getNewTopLeftPoint(center);

		if (!preserveMapOffset) {
			L.DomUtil.setPosition(this._mapPane, new L.Point(0, 0));
		} else {
			this._initialTopLeftPoint._add(this._getMapPanePos());
		}

		var loading = !this._loaded;
		this._loaded = true;

		this.fire('viewreset', {hard: !preserveMapOffset});

		if (loading) {
			this.fire('load');
		}

		this.fire('move');

		if (zoomChanged || afterZoomAnim) {
			this.fire('zoomend');
		}

		this.fire('moveend', {hard: !preserveMapOffset});
	},

	_rawPanBy: function (offset) {
		L.DomUtil.setPosition(this._mapPane, this._getMapPanePos().subtract(offset));
	},

	_getZoomSpan: function () {
		return this.getMaxZoom() - this.getMinZoom();
	},

	_panInsideMaxBounds: function () {
		this.panInsideBounds(this.options.maxBounds);
	},

	_checkIfLoaded: function () {
		if (!this._loaded) {
			throw new Error('Set map center and zoom first.');
		}
	},

	// map events

	_initEvents: function (onOff) {
		if (!L.DomEvent) { return; }

		onOff = onOff || 'on';

		L.DomEvent[onOff](this._container,
			'click dblclick mousedown mouseup mouseenter mouseleave mousemove contextmenu',
			this._handleMouseEvent, this);

		if (this.options.trackResize) {
			L.DomEvent[onOff](window, 'resize', this._onResize, this);
		}
	},

	_onResize: function () {
		L.Util.cancelAnimFrame(this._resizeRequest);
		this._resizeRequest = L.Util.requestAnimFrame(
		        function () { this.invalidateSize({debounceMoveend: true}); }, this, false, this._container);
	},

	_handleMouseEvent: function (e) {
		if (!this._loaded) { return; }

		this._fireMouseEvent(this, e,
				e.type === 'mouseenter' ? 'mouseover' :
				e.type === 'mouseleave' ? 'mouseout' : e.type);
	},

	_fireMouseEvent: function (obj, e, type, propagate, latlng) {
		type = type || e.type;

		if (L.DomEvent._skipped(e)) { return; }

		if (type === 'click') {
			if (!e._simulated && ((this.dragging && this.dragging.moved()) ||
			                      (this.boxZoom && this.boxZoom.moved()))) { return; }
			obj.fire('preclick');
		}

		if (!obj.listens(type, propagate)) { return; }

		if (type === 'contextmenu') {
			L.DomEvent.preventDefault(e);
		}
		if (type === 'click' || type === 'dblclick' || type === 'contextmenu') {
			L.DomEvent.stopPropagation(e);
		}

		var data = {
			originalEvent: e,
			containerPoint: this.mouseEventToContainerPoint(e)
		};

		data.layerPoint = this.containerPointToLayerPoint(data.containerPoint);
		data.latlng = latlng || this.layerPointToLatLng(data.layerPoint);

		obj.fire(type, data, propagate);
	},

	_clearHandlers: function () {
		for (var i = 0, len = this._handlers.length; i < len; i++) {
			this._handlers[i].disable();
		}
	},

	whenReady: function (callback, context) {
		if (this._loaded) {
			callback.call(context || this, {target: this});
		} else {
			this.on('load', callback, context);
		}
		return this;
	},


	// private methods for getting map state

	_getMapPanePos: function () {
		return L.DomUtil.getPosition(this._mapPane);
	},

	_moved: function () {
		var pos = this._getMapPanePos();
		return pos && !pos.equals([0, 0]);
	},

	_getTopLeftPoint: function () {
		return this.getPixelOrigin().subtract(this._getMapPanePos());
	},

	_getNewTopLeftPoint: function (center, zoom) {
		var viewHalf = this.getSize()._divideBy(2);
		// TODO round on display, not calculation to increase precision?
		return this.project(center, zoom)._subtract(viewHalf)._round();
	},

	_latLngToNewLayerPoint: function (latlng, newZoom, newCenter) {
		var topLeft = this._getNewTopLeftPoint(newCenter, newZoom).add(this._getMapPanePos());
		return this.project(latlng, newZoom)._subtract(topLeft);
	},

	// layer point of the current center
	_getCenterLayerPoint: function () {
		return this.containerPointToLayerPoint(this.getSize()._divideBy(2));
	},

	// offset of the specified place to the current center in pixels
	_getCenterOffset: function (latlng) {
		return this.latLngToLayerPoint(latlng).subtract(this._getCenterLayerPoint());
	},

	// adjust center for view to get inside bounds
	_limitCenter: function (center, zoom, bounds) {

		if (!bounds) { return center; }

		var centerPoint = this.project(center, zoom),
		    viewHalf = this.getSize().divideBy(2),
		    viewBounds = new L.Bounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)),
		    offset = this._getBoundsOffset(viewBounds, bounds, zoom);

		return this.unproject(centerPoint.add(offset), zoom);
	},

	// adjust offset for view to get inside bounds
	_limitOffset: function (offset, bounds) {
		if (!bounds) { return offset; }

		var viewBounds = this.getPixelBounds(),
		    newBounds = new L.Bounds(viewBounds.min.add(offset), viewBounds.max.add(offset));

		return offset.add(this._getBoundsOffset(newBounds, bounds));
	},

	// returns offset needed for pxBounds to get inside maxBounds at a specified zoom
	_getBoundsOffset: function (pxBounds, maxBounds, zoom) {
		var nwOffset = this.project(maxBounds.getNorthWest(), zoom).subtract(pxBounds.min),
		    seOffset = this.project(maxBounds.getSouthEast(), zoom).subtract(pxBounds.max),

		    dx = this._rebound(nwOffset.x, -seOffset.x),
		    dy = this._rebound(nwOffset.y, -seOffset.y);

		return new L.Point(dx, dy);
	},

	_rebound: function (left, right) {
		return left + right > 0 ?
			Math.round(left - right) / 2 :
			Math.max(0, Math.ceil(left)) - Math.max(0, Math.floor(right));
	},

	_limitZoom: function (zoom) {
		var min = this.getMinZoom(),
		    max = this.getMaxZoom();

		return Math.max(min, Math.min(max, zoom));
	}
});

L.map = function (id, options) {
	return new L.Map(id, options);
};


L.Layer = L.Evented.extend({

	options: {
		pane: 'overlayPane'
	},

	addTo: function (map) {
		map.addLayer(this);
		return this;
	},

	remove: function () {
		return this.removeFrom(this._map || this._mapToAdd);
	},

	removeFrom: function (obj) {
		if (obj) {
			obj.removeLayer(this);
		}
		return this;
	},

	getPane: function (name) {
		return this._map.getPane(name ? (this.options[name] || name) : this.options.pane);
	},

	_layerAdd: function (e) {
		var map = e.target;

		// check in case layer gets added and then removed before the map is ready
		if (!map.hasLayer(this)) { return; }

		this._map = map;
		this._zoomAnimated = map._zoomAnimated;

		this.onAdd(map);

		if (this.getAttribution && this._map.attributionControl) {
			this._map.attributionControl.addAttribution(this.getAttribution());
		}

		if (this.getEvents) {
			map.on(this.getEvents(), this);
		}

		this.fire('add');
		map.fire('layeradd', {layer: this});
	}
});


L.Map.include({
	addLayer: function (layer) {
		var id = L.stamp(layer);
		if (this._layers[id]) { return layer; }
		this._layers[id] = layer;

		layer._mapToAdd = this;

		if (layer.beforeAdd) {
			layer.beforeAdd(this);
		}

		this.whenReady(layer._layerAdd, layer);

		return this;
	},

	removeLayer: function (layer) {
		var id = L.stamp(layer);

		if (!this._layers[id]) { return this; }

		if (this._loaded) {
			layer.onRemove(this);
		}

		if (layer.getAttribution && this.attributionControl) {
			this.attributionControl.removeAttribution(layer.getAttribution());
		}

		if (layer.getEvents) {
			this.off(layer.getEvents(), layer);
		}

		delete this._layers[id];

		if (this._loaded) {
			this.fire('layerremove', {layer: layer});
			layer.fire('remove');
		}

		layer._map = layer._mapToAdd = null;

		return this;
	},

	hasLayer: function (layer) {
		return !!layer && (L.stamp(layer) in this._layers);
	},

	eachLayer: function (method, context) {
		for (var i in this._layers) {
			method.call(context, this._layers[i]);
		}
		return this;
	},

	_addLayers: function (layers) {
		layers = layers ? (L.Util.isArray(layers) ? layers : [layers]) : [];

		for (var i = 0, len = layers.length; i < len; i++) {
			this.addLayer(layers[i]);
		}
	},

	_addZoomLimit: function (layer) {
		if (isNaN(layer.options.maxZoom) || !isNaN(layer.options.minZoom)) {
			this._zoomBoundLayers[L.stamp(layer)] = layer;
			this._updateZoomLevels();
		}
	},

	_removeZoomLimit: function (layer) {
		var id = L.stamp(layer);

		if (this._zoomBoundLayers[id]) {
			delete this._zoomBoundLayers[id];
			this._updateZoomLevels();
		}
	},

	_updateZoomLevels: function () {
		var minZoom = Infinity,
			maxZoom = -Infinity,
			oldZoomSpan = this._getZoomSpan();

		for (var i in this._zoomBoundLayers) {
			var options = this._zoomBoundLayers[i].options;

			minZoom = options.minZoom === undefined ? minZoom : Math.min(minZoom, options.minZoom);
			maxZoom = options.maxZoom === undefined ? maxZoom : Math.max(maxZoom, options.maxZoom);
		}

		this._layersMaxZoom = maxZoom === -Infinity ? undefined : maxZoom;
		this._layersMinZoom = minZoom === Infinity ? undefined : minZoom;

		if (oldZoomSpan !== this._getZoomSpan()) {
			this.fire('zoomlevelschange');
		}
	}
});

/*
 * Mercator projection that takes into account that the Earth is not a perfect sphere.
 * Less popular than spherical mercator; used by projections like EPSG:3395.
 */

L.Projection.Mercator = {
	R: 6378137,
	R_MINOR: 6356752.314245179,

	bounds: L.bounds([-20037508.34279, -15496570.73972], [20037508.34279, 18764656.23138]),

	project: function (latlng) {
		var d = Math.PI / 180,
		    r = this.R,
		    y = latlng.lat * d,
		    tmp = this.R_MINOR / r,
		    e = Math.sqrt(1 - tmp * tmp),
		    con = e * Math.sin(y);

		var ts = Math.tan(Math.PI / 4 - y / 2) / Math.pow((1 - con) / (1 + con), e / 2);
		y = -r * Math.log(Math.max(ts, 1E-10));

		return new L.Point(latlng.lng * d * r, y);
	},

	unproject: function (point) {
		var d = 180 / Math.PI,
		    r = this.R,
		    tmp = this.R_MINOR / r,
		    e = Math.sqrt(1 - tmp * tmp),
		    ts = Math.exp(-point.y / r),
		    phi = Math.PI / 2 - 2 * Math.atan(ts);

		for (var i = 0, dphi = 0.1, con; i < 15 && Math.abs(dphi) > 1e-7; i++) {
			con = e * Math.sin(phi);
			con = Math.pow((1 - con) / (1 + con), e / 2);
			dphi = Math.PI / 2 - 2 * Math.atan(ts * con) - phi;
			phi += dphi;
		}

		return new L.LatLng(phi * d, point.x * d / r);
	}
};

/*
 * L.CRS.EPSG3857 (World Mercator) CRS implementation.
 */

L.CRS.EPSG3395 = L.extend({}, L.CRS.Earth, {
	code: 'EPSG:3395',
	projection: L.Projection.Mercator,

	transformation: (function () {
		var scale = 0.5 / (Math.PI * L.Projection.Mercator.R);
		return new L.Transformation(scale, 0.5, -scale, 0.5);
	}())
});

/*
 * L.GridLayer is used as base class for grid-like layers like TileLayer.
 */

L.GridLayer = L.Layer.extend({

	options: {
		pane: 'tilePane',

		tileSize: 256,
		opacity: 1,

		unloadInvisibleTiles: L.Browser.mobile,
		updateWhenIdle: L.Browser.mobile,
		updateInterval: 150

		/*
		minZoom: <Number>,
		maxZoom: <Number>,
		attribution: <String>,
		zIndex: <Number>,
		bounds: <LatLngBounds>
		*/
	},

	initialize: function (options) {
		options = L.setOptions(this, options);
	},

	onAdd: function () {
		this._initContainer();

		if (!this.options.updateWhenIdle) {
			// update tiles on move, but not more often than once per given interval
			this._update = L.Util.throttle(this._update, this.options.updateInterval, this);
		}

		this._reset();
		this._update();
	},

	beforeAdd: function (map) {
		map._addZoomLimit(this);
	},

	onRemove: function (map) {
		this._clearBgBuffer();
		L.DomUtil.remove(this._container);

		map._removeZoomLimit(this);

		this._container = null;
	},

	bringToFront: function () {
		if (this._map) {
			L.DomUtil.toFront(this._container);
			this._setAutoZIndex(Math.max);
		}
		return this;
	},

	bringToBack: function () {
		if (this._map) {
			L.DomUtil.toBack(this._container);
			this._setAutoZIndex(Math.min);
		}
		return this;
	},

	getAttribution: function () {
		return this.options.attribution;
	},

	getContainer: function () {
		return this._container;
	},

	setOpacity: function (opacity) {
		this.options.opacity = opacity;

		if (this._map) {
			this._updateOpacity();
		}
		return this;
	},

	setZIndex: function (zIndex) {
		this.options.zIndex = zIndex;
		this._updateZIndex();

		return this;
	},

	redraw: function () {
		if (this._map) {
			this._reset({hard: true});
			this._update();
		}
		return this;
	},

	getEvents: function () {
		var events = {
			viewreset: this._reset,
			moveend: this._update
		};

		if (!this.options.updateWhenIdle) {
			events.move = this._update;
		}

		if (this._zoomAnimated) {
			events.zoomstart = this._startZoomAnim;
			events.zoomanim = this._animateZoom;
			events.zoomend = this._endZoomAnim;
		}

		return events;
	},

	_updateZIndex: function () {
		if (this._container && this.options.zIndex !== undefined) {
			this._container.style.zIndex = this.options.zIndex;
		}
	},

	_setAutoZIndex: function (compare) {
		// go through all other layers of the same pane, set zIndex to max + 1 (front) or min - 1 (back)

		var layers = this.getPane().children,
		    edgeZIndex = -compare(-Infinity, Infinity); // -Infinity for max, Infinity for min

		for (var i = 0, len = layers.length, zIndex; i < len; i++) {

			zIndex = layers[i].style.zIndex;

			if (layers[i] !== this._container && zIndex) {
				edgeZIndex = compare(edgeZIndex, +zIndex);
			}
		}

		if (isFinite(edgeZIndex)) {
			this.options.zIndex = edgeZIndex + compare(-1, 1);
			this._updateZIndex();
		}
	},

	_updateOpacity: function () {
		var opacity = this.options.opacity;

		if (L.Browser.ielt9) {
			// IE doesn't inherit filter opacity properly, so we're forced to set it on tiles
			for (var i in this._tiles) {
				L.DomUtil.setOpacity(this._tiles[i], opacity);
			}
		} else {
			L.DomUtil.setOpacity(this._container, opacity);
		}
	},

	_initContainer: function () {
		if (this._container) { return; }

		this._container = L.DomUtil.create('div', 'leaflet-layer');
		this._updateZIndex();

		if (this._zoomAnimated) {
			var className = 'leaflet-tile-container leaflet-zoom-animated';

			this._bgBuffer = L.DomUtil.create('div', className, this._container);
			this._tileContainer = L.DomUtil.create('div', className, this._container);

			L.DomUtil.setTransform(this._tileContainer);

		} else {
			this._tileContainer = this._container;
		}

		if (this.options.opacity < 1) {
			this._updateOpacity();
		}

		this.getPane().appendChild(this._container);
	},

	_reset: function (e) {
		for (var key in this._tiles) {
			this.fire('tileunload', {
				tile: this._tiles[key]
			});
		}

		this._tiles = {};
		this._tilesToLoad = 0;
		this._tilesTotal = 0;

		this._tileContainer.innerHTML = '';

		if (this._zoomAnimated && e && e.hard) {
			this._clearBgBuffer();
		}

		this._tileNumBounds = this._getTileNumBounds();
		this._resetWrap();
	},

	_resetWrap: function () {
		var map = this._map,
		    crs = map.options.crs;

		if (crs.infinite) { return; }

		var tileSize = this._getTileSize();

		if (crs.wrapLng) {
			this._wrapLng = [
				Math.floor(map.project([0, crs.wrapLng[0]]).x / tileSize),
				Math.ceil(map.project([0, crs.wrapLng[1]]).x / tileSize)
			];
		}

		if (crs.wrapLat) {
			this._wrapLat = [
				Math.floor(map.project([crs.wrapLat[0], 0]).y / tileSize),
				Math.ceil(map.project([crs.wrapLat[1], 0]).y / tileSize)
			];
		}
	},

	_getTileSize: function () {
		return this.options.tileSize;
	},

	_update: function () {

		if (!this._map) { return; }

		var bounds = this._map.getPixelBounds(),
		    zoom = this._map.getZoom(),
		    tileSize = this._getTileSize();

		if (zoom > this.options.maxZoom ||
		    zoom < this.options.minZoom) { return; }

		// tile coordinates range for the current view
		var tileBounds = L.bounds(
			bounds.min.divideBy(tileSize).floor(),
			bounds.max.divideBy(tileSize).floor());

		this._addTiles(tileBounds);

		if (this.options.unloadInvisibleTiles) {
			this._removeOtherTiles(tileBounds);
		}
	},

	_addTiles: function (bounds) {
		var queue = [],
		    center = bounds.getCenter(),
		    zoom = this._map.getZoom();

		var j, i, coords;

		// create a queue of coordinates to load tiles from
		for (j = bounds.min.y; j <= bounds.max.y; j++) {
			for (i = bounds.min.x; i <= bounds.max.x; i++) {

				coords = new L.Point(i, j);
				coords.z = zoom;

				// add tile to queue if it's not in cache or out of bounds
				if (!(this._tileCoordsToKey(coords) in this._tiles) && this._isValidTile(coords)) {
					queue.push(coords);
				}
			}
		}

		var tilesToLoad = queue.length;

		if (tilesToLoad === 0) { return; }

		// if its the first batch of tiles to load
		if (!this._tilesToLoad) {
			this.fire('loading');
		}

		this._tilesToLoad += tilesToLoad;
		this._tilesTotal += tilesToLoad;

		// sort tile queue to load tiles in order of their distance to center
		queue.sort(function (a, b) {
			return a.distanceTo(center) - b.distanceTo(center);
		});

		// create DOM fragment to append tiles in one batch
		var fragment = document.createDocumentFragment();

		for (i = 0; i < tilesToLoad; i++) {
			this._addTile(queue[i], fragment);
		}

		this._tileContainer.appendChild(fragment);
	},

	_isValidTile: function (coords) {
		var crs = this._map.options.crs;

		if (!crs.infinite) {
			// don't load tile if it's out of bounds and not wrapped
			var bounds = this._tileNumBounds;
			if ((!crs.wrapLng && (coords.x < bounds.min.x || coords.x > bounds.max.x)) ||
			    (!crs.wrapLat && (coords.y < bounds.min.y || coords.y > bounds.max.y))) { return false; }
		}

		if (!this.options.bounds) { return true; }

		// don't load tile if it doesn't intersect the bounds in options
		var tileBounds = this._tileCoordsToBounds(coords);
		return L.latLngBounds(this.options.bounds).intersects(tileBounds);
	},

	// converts tile coordinates to its geographical bounds
	_tileCoordsToBounds: function (coords) {

		var map = this._map,
		    tileSize = this.options.tileSize,

		    nwPoint = coords.multiplyBy(tileSize),
		    sePoint = nwPoint.add([tileSize, tileSize]),

		    nw = map.wrapLatLng(map.unproject(nwPoint, coords.z)),
		    se = map.wrapLatLng(map.unproject(sePoint, coords.z));

		return new L.LatLngBounds(nw, se);
	},

	// converts tile coordinates to key for the tile cache
	_tileCoordsToKey: function (coords) {
		return coords.x + ':' + coords.y;
	},

	// converts tile cache key to coordiantes
	_keyToTileCoords: function (key) {
		var kArr = key.split(':'),
		    x = parseInt(kArr[0], 10),
		    y = parseInt(kArr[1], 10);

		return new L.Point(x, y);
	},

	// remove any present tiles that are off the specified bounds
	_removeOtherTiles: function (bounds) {
		for (var key in this._tiles) {
			if (!bounds.contains(this._keyToTileCoords(key))) {
				this._removeTile(key);
			}
		}
	},

	_removeTile: function (key) {
		var tile = this._tiles[key];

		L.DomUtil.remove(tile);

		delete this._tiles[key];

		this.fire('tileunload', {tile: tile});
	},

	_initTile: function (tile) {
		var size = this._getTileSize();

		L.DomUtil.addClass(tile, 'leaflet-tile');

		tile.style.width = size + 'px';
		tile.style.height = size + 'px';

		tile.onselectstart = L.Util.falseFn;
		tile.onmousemove = L.Util.falseFn;

		// update opacity on tiles in IE7-8 because of filter inheritance problems
		if (L.Browser.ielt9 && this.options.opacity < 1) {
			L.DomUtil.setOpacity(tile, this.options.opacity);
		}

		// without this hack, tiles disappear after zoom on Chrome for Android
		// https://github.com/Leaflet/Leaflet/issues/2078
		if (L.Browser.android && !L.Browser.android23) {
			tile.style.WebkitBackfaceVisibility = 'hidden';
		}
	},

	_addTile: function (coords, container) {
		var tilePos = this._getTilePos(coords);

		// wrap tile coords if necessary (depending on CRS)
		this._wrapCoords(coords);

		var tile = this.createTile(coords, L.bind(this._tileReady, this));

		this._initTile(tile);

		// if createTile is defined with a second argument ("done" callback),
		// we know that tile is async and will be ready later; otherwise
		if (this.createTile.length < 2) {
			// mark tile as ready, but delay one frame for opacity animation to happen
			setTimeout(L.bind(this._tileReady, this, null, tile), 0);
		}

		// we prefer top/left over translate3d so that we don't create a HW-accelerated layer from each tile
		// which is slow, and it also fixes gaps between tiles in Safari
		L.DomUtil.setPosition(tile, tilePos, true);

		// save tile in cache
		this._tiles[this._tileCoordsToKey(coords)] = tile;

		container.appendChild(tile);
		this.fire('tileloadstart', {tile: tile});
	},

	_tileReady: function (err, tile) {
		if (err) {
			this.fire('tileerror', {
				error: err,
				tile: tile
			});
		}

		L.DomUtil.addClass(tile, 'leaflet-tile-loaded');

		this.fire('tileload', {tile: tile});

		this._tilesToLoad--;

		if (this._tilesToLoad === 0) {
			this._visibleTilesReady();
		}
	},

	_visibleTilesReady: function () {
		this.fire('load');

		if (this._zoomAnimated) {
			// clear scaled tiles after all new tiles are loaded (for performance)
			clearTimeout(this._clearBgBufferTimer);
			this._clearBgBufferTimer = setTimeout(L.bind(this._clearBgBuffer, this), 300);
		}
	},

	_getTilePos: function (coords) {
		return coords
				.multiplyBy(this._getTileSize())
				.subtract(this._map.getPixelOrigin());
	},

	_wrapCoords: function (coords) {
		coords.x = this._wrapLng ? L.Util.wrapNum(coords.x, this._wrapLng) : coords.x;
		coords.y = this._wrapLat ? L.Util.wrapNum(coords.y, this._wrapLat) : coords.y;
	},

	// get the global tile coordinates range for the current zoom
	_getTileNumBounds: function () {
		var bounds = this._map.getPixelWorldBounds(),
			size = this._getTileSize();

		return bounds ? L.bounds(
				bounds.min.divideBy(size).floor(),
				bounds.max.divideBy(size).ceil().subtract([1, 1])) : null;
	},

	_startZoomAnim: function () {
		this._prepareBgBuffer();
		this._prevTranslate = this._translate || new L.Point(0, 0);
		this._prevScale = this._scale;
	},

	_animateZoom: function (e) {
		// avoid stacking transforms by calculating cumulating translate/scale sequence
		this._translate = this._prevTranslate.multiplyBy(e.scale).add(e.origin.multiplyBy(1 - e.scale));
		this._scale = this._prevScale * e.scale;

		L.DomUtil.setTransform(this._bgBuffer, this._translate, this._scale);
	},

	_endZoomAnim: function () {
		var front = this._tileContainer;
		front.style.visibility = '';
		L.DomUtil.toFront(front); // bring to front
	},

	_clearBgBuffer: function () {
		var map = this._map,
			bg = this._bgBuffer;

		if (map && !map._animatingZoom && !map.touchZoom._zooming && bg) {
			bg.innerHTML = '';
			L.DomUtil.setTransform(bg);
		}
	},

	_prepareBgBuffer: function () {

		var front = this._tileContainer,
		    bg = this._bgBuffer;

		if (this._abortLoading) {
			this._abortLoading();
		}

		if (this._tilesToLoad / this._tilesTotal > 0.5) {
			// if foreground layer doesn't have many tiles loaded,
			// keep the existing bg layer and just zoom it some more
			front.style.visibility = 'hidden';
			return;
		}

		// prepare the buffer to become the front tile pane
		bg.style.visibility = 'hidden';
		L.DomUtil.setTransform(bg);

		// switch out the current layer to be the new bg layer (and vice-versa)
		this._tileContainer = bg;
		this._bgBuffer = front;

		// reset bg layer transform info
		this._translate = new L.Point(0, 0);
		this._scale = 1;

		// prevent bg buffer from clearing right after zoom
		clearTimeout(this._clearBgBufferTimer);
	}
});

L.gridLayer = function (options) {
	return new L.GridLayer(options);
};

/*
 * L.TileLayer is used for standard xyz-numbered tile layers.
 */

L.TileLayer = L.GridLayer.extend({

	options: {
		minZoom: 0,
		maxZoom: 18,

		subdomains: 'abc',
		// errorTileUrl: '',
		zoomOffset: 0

		/*
		maxNativeZoom: <Number>,
		tms: <Boolean>,
		zoomReverse: <Number>,
		detectRetina: <Number>,
		*/
	},

	initialize: function (url, options) {

		this._url = url;

		options = L.setOptions(this, options);

		// detecting retina displays, adjusting tileSize and zoom levels
		if (options.detectRetina && L.Browser.retina && options.maxZoom > 0) {

			options.tileSize = Math.floor(options.tileSize / 2);
			options.zoomOffset++;

			options.minZoom = Math.max(0, options.minZoom);
			options.maxZoom--;
		}

		if (typeof options.subdomains === 'string') {
			options.subdomains = options.subdomains.split('');
		}
	},

	setUrl: function (url, noRedraw) {
		this._url = url;

		if (!noRedraw) {
			this.redraw();
		}
		return this;
	},

	createTile: function (coords, done) {
		var tile = document.createElement('img');

		tile.onload = L.bind(this._tileOnLoad, this, done, tile);
		tile.onerror = L.bind(this._tileOnError, this, done, tile);

		/*
		 Alt tag is set to empty string to keep screen readers from reading URL and for compliance reasons
		 http://www.w3.org/TR/WCAG20-TECHS/H67
		*/
		tile.alt = '';

		tile.src = this.getTileUrl(coords);

		return tile;
	},

	getTileUrl: function (coords) {
		return L.Util.template(this._url, L.extend({
			r: this.options.detectRetina && L.Browser.retina && this.options.maxZoom > 0 ? '@2x' : '',
			s: this._getSubdomain(coords),
			x: coords.x,
			y: this.options.tms ? this._tileNumBounds.max.y - coords.y : coords.y,
			z: this._getZoomForUrl()
		}, this.options));
	},

	_tileOnLoad: function (done, tile) {
		done(null, tile);
	},

	_tileOnError: function (done, tile, e) {
		var errorUrl = this.options.errorTileUrl;
		if (errorUrl) {
			tile.src = errorUrl;
		}
		done(e, tile);
	},

	_getTileSize: function () {
		var map = this._map,
		    options = this.options,
		    zoom = map.getZoom() + options.zoomOffset,
		    zoomN = options.maxNativeZoom;

		// increase tile size when overscaling
		return zoomN && zoom > zoomN ?
				Math.round(map.getZoomScale(zoom) / map.getZoomScale(zoomN) * options.tileSize) :
				options.tileSize;
	},

	_removeTile: function (key) {
		var tile = this._tiles[key];

		L.GridLayer.prototype._removeTile.call(this, key);

		// for https://github.com/Leaflet/Leaflet/issues/137
		if (!L.Browser.android) {
			tile.onload = null;
			tile.src = L.Util.emptyImageUrl;
		}
	},

	_getZoomForUrl: function () {

		var options = this.options,
		    zoom = this._map.getZoom();

		if (options.zoomReverse) {
			zoom = options.maxZoom - zoom;
		}

		zoom += options.zoomOffset;

		return options.maxNativeZoom ? Math.min(zoom, options.maxNativeZoom) : zoom;
	},

	_getSubdomain: function (tilePoint) {
		var index = Math.abs(tilePoint.x + tilePoint.y) % this.options.subdomains.length;
		return this.options.subdomains[index];
	},

	// stops loading all tiles in the background layer
	_abortLoading: function () {
		var i, tile;
		for (i in this._tiles) {
			tile = this._tiles[i];

			if (!tile.complete) {
				tile.onload = L.Util.falseFn;
				tile.onerror = L.Util.falseFn;
				tile.src = L.Util.emptyImageUrl;

				L.DomUtil.remove(tile);
			}
		}
	}
});

L.tileLayer = function (url, options) {
	return new L.TileLayer(url, options);
};

/*
 * L.TileLayer.WMS is used for WMS tile layers.
 */

L.TileLayer.WMS = L.TileLayer.extend({

	defaultWmsParams: {
		service: 'WMS',
		request: 'GetMap',
		version: '1.1.1',
		layers: '',
		styles: '',
		format: 'image/jpeg',
		transparent: false
	},

	initialize: function (url, options) {

		this._url = url;

		var wmsParams = L.extend({}, this.defaultWmsParams);

		// all keys that are not TileLayer options go to WMS params
		for (var i in options) {
			if (!this.options.hasOwnProperty(i) && i !== 'crs') {
				wmsParams[i] = options[i];
			}
		}

		options = L.setOptions(this, options);

		wmsParams.width = wmsParams.height =
				options.tileSize * (options.detectRetina && L.Browser.retina ? 2 : 1);

		this.wmsParams = wmsParams;
	},

	onAdd: function (map) {

		this._crs = this.options.crs || map.options.crs;

		this._wmsVersion = parseFloat(this.wmsParams.version);

		var projectionKey = this._wmsVersion >= 1.3 ? 'crs' : 'srs';
		this.wmsParams[projectionKey] = this._crs.code;

		L.TileLayer.prototype.onAdd.call(this, map);
	},

	getTileUrl: function (coords) {

		var tileBounds = this._tileCoordsToBounds(coords),
		    nw = this._crs.project(tileBounds.getNorthWest()),
		    se = this._crs.project(tileBounds.getSouthEast()),

		    bbox = (this._wmsVersion >= 1.3 && this._crs === L.CRS.EPSG4326 ?
			    [se.y, nw.x, nw.y, se.x] :
			    [nw.x, se.y, se.x, nw.y]).join(','),

		    url = L.Util.template(this._url, {s: this._getSubdomain(coords)});

		return url + L.Util.getParamString(this.wmsParams, url, true) + '&BBOX=' + bbox;
	},

	setParams: function (params, noRedraw) {

		L.extend(this.wmsParams, params);

		if (!noRedraw) {
			this.redraw();
		}

		return this;
	}
});

L.tileLayer.wms = function (url, options) {
	return new L.TileLayer.WMS(url, options);
};

/*
 * L.ImageOverlay is used to overlay images over the map (to specific geographical bounds).
 */

L.ImageOverlay = L.Layer.extend({

	options: {
		opacity: 1
	},

	initialize: function (url, bounds, options) { // (String, LatLngBounds, Object)
		this._url = url;
		this._bounds = L.latLngBounds(bounds);

		L.setOptions(this, options);
	},

	onAdd: function () {
		if (!this._image) {
			this._initImage();

			if (this.options.opacity < 1) {
				this._updateOpacity();
			}
		}

		this.getPane().appendChild(this._image);

		this._reset();
	},

	onRemove: function () {
		L.DomUtil.remove(this._image);
	},

	setOpacity: function (opacity) {
		this.options.opacity = opacity;

		if (this._image) {
			this._updateOpacity();
		}
		return this;
	},

	bringToFront: function () {
		if (this._map) {
			L.DomUtil.toFront(this._image);
		}
		return this;
	},

	bringToBack: function () {
		if (this._map) {
			L.DomUtil.toBack(this._image);
		}
		return this;
	},

	setUrl: function (url) {
		this._url = url;

		if (this._image) {
			this._image.src = url;
		}
		return this;
	},

	getAttribution: function () {
		return this.options.attribution;
	},

	getEvents: function () {
		var events = {
			viewreset: this._reset
		};

		if (this._zoomAnimated) {
			events.zoomanim = this._animateZoom;
		}

		return events;
	},

	_initImage: function () {
		var img = this._image = L.DomUtil.create('img',
				'leaflet-image-layer ' + (this._zoomAnimated ? 'leaflet-zoom-animated' : ''));

		img.onselectstart = L.Util.falseFn;
		img.onmousemove = L.Util.falseFn;

		img.onload = L.bind(this.fire, this, 'load');
		img.src = this._url;
	},

	_animateZoom: function (e) {
		var topLeft = this._map._latLngToNewLayerPoint(this._bounds.getNorthWest(), e.zoom, e.center),
		    size = this._map._latLngToNewLayerPoint(this._bounds.getSouthEast(), e.zoom, e.center).subtract(topLeft),
		    offset = topLeft.add(size._multiplyBy((1 - 1 / e.scale) / 2));

		L.DomUtil.setTransform(this._image, offset, e.scale);
	},

	_reset: function () {
		var image = this._image,
		    bounds = new L.Bounds(
		        this._map.latLngToLayerPoint(this._bounds.getNorthWest()),
		        this._map.latLngToLayerPoint(this._bounds.getSouthEast())),
		    size = bounds.getSize();

		L.DomUtil.setPosition(image, bounds.min);

		image.style.width  = size.x + 'px';
		image.style.height = size.y + 'px';
	},

	_updateOpacity: function () {
		L.DomUtil.setOpacity(this._image, this.options.opacity);
	}
});

L.imageOverlay = function (url, bounds, options) {
	return new L.ImageOverlay(url, bounds, options);
};

/*
 * L.Icon is an image-based icon class that you can use with L.Marker for custom markers.
 */

L.Icon = L.Class.extend({
	/*
	options: {
		iconUrl: (String) (required)
		iconRetinaUrl: (String) (optional, used for retina devices if detected)
		iconSize: (Point) (can be set through CSS)
		iconAnchor: (Point) (centered by default, can be set in CSS with negative margins)
		popupAnchor: (Point) (if not specified, popup opens in the anchor point)
		shadowUrl: (String) (no shadow by default)
		shadowRetinaUrl: (String) (optional, used for retina devices if detected)
		shadowSize: (Point)
		shadowAnchor: (Point)
		className: (String)
	},
	*/

	initialize: function (options) {
		L.setOptions(this, options);
	},

	createIcon: function (oldIcon) {
		return this._createIcon('icon', oldIcon);
	},

	createShadow: function (oldIcon) {
		return this._createIcon('shadow', oldIcon);
	},

	_createIcon: function (name, oldIcon) {
		var src = this._getIconUrl(name);

		if (!src) {
			if (name === 'icon') {
				throw new Error('iconUrl not set in Icon options (see the docs).');
			}
			return null;
		}

		var img = this._createImg(src, oldIcon && oldIcon.tagName === 'IMG' ? oldIcon : null);
		this._setIconStyles(img, name);

		return img;
	},

	_setIconStyles: function (img, name) {
		var options = this.options,
		    size = L.point(options[name + 'Size']),
		    anchor = L.point(name === 'shadow' && options.shadowAnchor || options.iconAnchor ||
		            size && size.divideBy(2, true));

		img.className = 'leaflet-marker-' + name + ' ' + (options.className || '');

		if (anchor) {
			img.style.marginLeft = (-anchor.x) + 'px';
			img.style.marginTop  = (-anchor.y) + 'px';
		}

		if (size) {
			img.style.width  = size.x + 'px';
			img.style.height = size.y + 'px';
		}
	},

	_createImg: function (src, el) {
		el = el || document.createElement('img');
		el.src = src;
		return el;
	},

	_getIconUrl: function (name) {
		return L.Browser.retina && this.options[name + 'RetinaUrl'] || this.options[name + 'Url'];
	}
});

L.icon = function (options) {
	return new L.Icon(options);
};

/*
 * L.Icon.Default is the blue marker icon used by default in Leaflet.
 */

L.Icon.Default = L.Icon.extend({

	options: {
		iconSize:    [25, 41],
		iconAnchor:  [12, 41],
		popupAnchor: [1, -34],
		shadowSize:  [41, 41]
	},

	_getIconUrl: function (name) {
		var key = name + 'Url';

		if (this.options[key]) {
			return this.options[key];
		}

		var path = L.Icon.Default.imagePath;

		if (!path) {
			throw new Error('Couldn\'t autodetect L.Icon.Default.imagePath, set it manually.');
		}

		return path + '/marker-' + name + (L.Browser.retina && name === 'icon' ? '-2x' : '') + '.png';
	}
});

L.Icon.Default.imagePath = (function () {
	var scripts = document.getElementsByTagName('script'),
	    leafletRe = /[\/^]leaflet[\-\._]?([\w\-\._]*)\.js\??/;

	var i, len, src, path;

	for (i = 0, len = scripts.length; i < len; i++) {
		src = scripts[i].src;

		if (src.match(leafletRe)) {
			path = src.split(leafletRe)[0];
			return (path ? path + '/' : '') + 'images';
		}
	}
}());

/*
 * L.Marker is used to display clickable/draggable icons on the map.
 */

L.Marker = L.Layer.extend({

	options: {
		pane: 'markerPane',

		icon: new L.Icon.Default(),
		// title: '',
		// alt: '',
		clickable: true,
		// draggable: false,
		keyboard: true,
		zIndexOffset: 0,
		opacity: 1,
		// riseOnHover: false,
		riseOffset: 250
	},

	initialize: function (latlng, options) {
		L.setOptions(this, options);
		this._latlng = L.latLng(latlng);
	},

	onAdd: function (map) {
		this._zoomAnimated = this._zoomAnimated && map.options.markerZoomAnimation;

		this._initIcon();
		this.update();
	},

	onRemove: function () {
		if (this.dragging) {
			this.dragging.disable();
		}

		this._removeIcon();
		this._removeShadow();
	},

	getEvents: function () {
		var events = {viewreset: this.update};

		if (this._zoomAnimated) {
			events.zoomanim = this._animateZoom;
		}

		return events;
	},

	getLatLng: function () {
		return this._latlng;
	},

	setLatLng: function (latlng) {
		var oldLatLng = this._latlng;
		this._latlng = L.latLng(latlng);
		this.update();
		return this.fire('move', { oldLatLng: oldLatLng, latlng: this._latlng });
	},

	setZIndexOffset: function (offset) {
		this.options.zIndexOffset = offset;
		return this.update();
	},

	setIcon: function (icon) {

		this.options.icon = icon;

		if (this._map) {
			this._initIcon();
			this.update();
		}

		if (this._popup) {
			this.bindPopup(this._popup);
		}

		return this;
	},

	update: function () {

		if (this._icon) {
			var pos = this._map.latLngToLayerPoint(this._latlng).round();
			this._setPos(pos);
		}

		return this;
	},

	_initIcon: function () {
		var options = this.options,
		    classToAdd = 'leaflet-zoom-' + (this._zoomAnimated ? 'animated' : 'hide');

		var icon = options.icon.createIcon(this._icon),
			addIcon = false;

		// if we're not reusing the icon, remove the old one and init new one
		if (icon !== this._icon) {
			if (this._icon) {
				this._removeIcon();
			}
			addIcon = true;

			if (options.title) {
				icon.title = options.title;
			}
			if (options.alt) {
				icon.alt = options.alt;
			}
		}

		L.DomUtil.addClass(icon, classToAdd);

		if (options.keyboard) {
			icon.tabIndex = '0';
		}

		this._icon = icon;
		this._initInteraction();

		if (options.riseOnHover) {
			L.DomEvent.on(icon, {
				mouseover: this._bringToFront,
				mouseout: this._resetZIndex
			}, this);
		}

		var newShadow = options.icon.createShadow(this._shadow),
			addShadow = false;

		if (newShadow !== this._shadow) {
			this._removeShadow();
			addShadow = true;
		}

		if (newShadow) {
			L.DomUtil.addClass(newShadow, classToAdd);
		}
		this._shadow = newShadow;


		if (options.opacity < 1) {
			this._updateOpacity();
		}


		if (addIcon) {
			this.getPane().appendChild(this._icon);
		}
		if (newShadow && addShadow) {
			this.getPane('shadowPane').appendChild(this._shadow);
		}
	},

	_removeIcon: function () {
		if (this.options.riseOnHover) {
			L.DomEvent.off(this._icon, {
				mouseover: this._bringToFront,
			    mouseout: this._resetZIndex
			}, this);
		}

		L.DomUtil.remove(this._icon);

		this._icon = null;
	},

	_removeShadow: function () {
		if (this._shadow) {
			L.DomUtil.remove(this._shadow);
		}
		this._shadow = null;
	},

	_setPos: function (pos) {
		L.DomUtil.setPosition(this._icon, pos);

		if (this._shadow) {
			L.DomUtil.setPosition(this._shadow, pos);
		}

		this._zIndex = pos.y + this.options.zIndexOffset;

		this._resetZIndex();
	},

	_updateZIndex: function (offset) {
		this._icon.style.zIndex = this._zIndex + offset;
	},

	_animateZoom: function (opt) {
		var pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center).round();

		this._setPos(pos);
	},

	_initInteraction: function () {

		if (!this.options.clickable) { return; }

		L.DomUtil.addClass(this._icon, 'leaflet-clickable');

		L.DomEvent.on(this._icon, 'click dblclick mousedown mouseup mouseover mouseout contextmenu keypress',
				this._fireMouseEvent, this);

		if (L.Handler.MarkerDrag) {
			this.dragging = new L.Handler.MarkerDrag(this);

			if (this.options.draggable) {
				this.dragging.enable();
			}
		}
	},

	_fireMouseEvent: function (e, type) {
		// to prevent outline when clicking on keyboard-focusable marker
		if (e.type === 'mousedown') {
			L.DomEvent.preventDefault(e);
		}

		if (e.type === 'click' && this.dragging && this.dragging.moved()) {
			L.DomEvent.stopPropagation(e);
			return;
		}

		if (e.type === 'keypress' && e.keyCode === 13) {
			type = 'click';
		}

		if (this._map) {
			this._map._fireMouseEvent(this, e, type, true, this._latlng);
		}
	},

	setOpacity: function (opacity) {
		this.options.opacity = opacity;
		if (this._map) {
			this._updateOpacity();
		}

		return this;
	},

	_updateOpacity: function () {
		var opacity = this.options.opacity;

		L.DomUtil.setOpacity(this._icon, opacity);

		if (this._shadow) {
			L.DomUtil.setOpacity(this._shadow, opacity);
		}
	},

	_bringToFront: function () {
		this._updateZIndex(this.options.riseOffset);
	},

	_resetZIndex: function () {
		this._updateZIndex(0);
	}
});

L.marker = function (latlng, options) {
	return new L.Marker(latlng, options);
};

/*
 * L.DivIcon is a lightweight HTML-based icon class (as opposed to the image-based L.Icon)
 * to use with L.Marker.
 */

L.DivIcon = L.Icon.extend({
	options: {
		iconSize: [12, 12], // also can be set through CSS
		/*
		iconAnchor: (Point)
		popupAnchor: (Point)
		html: (String)
		bgPos: (Point)
		*/
		className: 'leaflet-div-icon',
		html: false
	},

	createIcon: function (oldIcon) {
		var div = (oldIcon && oldIcon.tagName === 'DIV') ? oldIcon : document.createElement('div'),
		    options = this.options;

		div.innerHTML = options.html !== false ? options.html : '';

		if (options.bgPos) {
			div.style.backgroundPosition = (-options.bgPos.x) + 'px ' + (-options.bgPos.y) + 'px';
		}
		this._setIconStyles(div, 'icon');

		return div;
	},

	createShadow: function () {
		return null;
	}
});

L.divIcon = function (options) {
	return new L.DivIcon(options);
};

/*
 * L.Popup is used for displaying popups on the map.
 */

L.Map.mergeOptions({
	closePopupOnClick: true
});

L.Popup = L.Layer.extend({

	options: {
		pane: 'popupPane',

		minWidth: 50,
		maxWidth: 300,
		// maxHeight: <Number>,
		offset: [0, 7],

		autoPan: true,
		autoPanPadding: [5, 5],
		// autoPanPaddingTopLeft: <Point>,
		// autoPanPaddingBottomRight: <Point>,

		closeButton: true,
		// keepInView: false,
		// className: '',
		zoomAnimation: true
	},

	initialize: function (options, source) {
		L.setOptions(this, options);

		this._source = source;
	},

	onAdd: function (map) {
		this._zoomAnimated = this._zoomAnimated && this.options.zoomAnimation;

		if (!this._container) {
			this._initLayout();
		}

		if (map._fadeAnimated) {
			L.DomUtil.setOpacity(this._container, 0);
		}

		clearTimeout(this._removeTimeout);
		this.getPane().appendChild(this._container);
		this.update();

		if (map._fadeAnimated) {
			L.DomUtil.setOpacity(this._container, 1);
		}

		map.fire('popupopen', {popup: this});

		if (this._source) {
			this._source.fire('popupopen', {popup: this}, true);
		}
	},

	openOn: function (map) {
		map.openPopup(this);
		return this;
	},

	onRemove: function (map) {
		if (map._fadeAnimated) {
			L.DomUtil.setOpacity(this._container, 0);
			this._removeTimeout = setTimeout(L.bind(L.DomUtil.remove, L.DomUtil, this._container), 200);
		} else {
			L.DomUtil.remove(this._container);
		}

		map.fire('popupclose', {popup: this});

		if (this._source) {
			this._source.fire('popupclose', {popup: this}, true);
		}
	},

	getLatLng: function () {
		return this._latlng;
	},

	setLatLng: function (latlng) {
		this._latlng = L.latLng(latlng);
		if (this._map) {
			this._updatePosition();
			this._adjustPan();
		}
		return this;
	},

	getContent: function () {
		return this._content;
	},

	setContent: function (content) {
		this._content = content;
		this.update();
		return this;
	},

	update: function () {
		if (!this._map) { return; }

		this._container.style.visibility = 'hidden';

		this._updateContent();
		this._updateLayout();
		this._updatePosition();

		this._container.style.visibility = '';

		this._adjustPan();
	},

	getEvents: function () {
		var events = {viewreset: this._updatePosition},
		    options = this.options;

		if (this._zoomAnimated) {
			events.zoomanim = this._animateZoom;
		}
		if ('closeOnClick' in options ? options.closeOnClick : this._map.options.closePopupOnClick) {
			events.preclick = this._close;
		}
		if (options.keepInView) {
			events.moveend = this._adjustPan;
		}
		return events;
	},
	
	isOpen: function () {
		return !!this._map && this._map.hasLayer(this);
	},

	_close: function () {
		if (this._map) {
			this._map.closePopup(this);
		}
	},

	_initLayout: function () {
		var prefix = 'leaflet-popup',
		    container = this._container = L.DomUtil.create('div',
			prefix + ' ' + (this.options.className || '') +
			' leaflet-zoom-' + (this._zoomAnimated ? 'animated' : 'hide'));

		if (this.options.closeButton) {
			var closeButton = this._closeButton = L.DomUtil.create('a', prefix + '-close-button', container);
			closeButton.href = '#close';
			closeButton.innerHTML = '&#215;';

			L.DomEvent.on(closeButton, 'click', this._onCloseButtonClick, this);
		}

		var wrapper = this._wrapper = L.DomUtil.create('div', prefix + '-content-wrapper', container);
		this._contentNode = L.DomUtil.create('div', prefix + '-content', wrapper);

		L.DomEvent
			.disableClickPropagation(wrapper)
			.disableScrollPropagation(this._contentNode)
			.on(wrapper, 'contextmenu', L.DomEvent.stopPropagation);

		this._tipContainer = L.DomUtil.create('div', prefix + '-tip-container', container);
		this._tip = L.DomUtil.create('div', prefix + '-tip', this._tipContainer);
	},

	_updateContent: function () {
		if (!this._content) { return; }

		var node = this._contentNode;

		if (typeof this._content === 'string') {
			node.innerHTML = this._content;
		} else {
			while (node.hasChildNodes()) {
				node.removeChild(node.firstChild);
			}
			node.appendChild(this._content);
		}
		this.fire('contentupdate');
	},

	_updateLayout: function () {
		var container = this._contentNode,
		    style = container.style;

		style.width = '';
		style.whiteSpace = 'nowrap';

		var width = container.offsetWidth;
		width = Math.min(width, this.options.maxWidth);
		width = Math.max(width, this.options.minWidth);

		style.width = (width + 1) + 'px';
		style.whiteSpace = '';

		style.height = '';

		var height = container.offsetHeight,
		    maxHeight = this.options.maxHeight,
		    scrolledClass = 'leaflet-popup-scrolled';

		if (maxHeight && height > maxHeight) {
			style.height = maxHeight + 'px';
			L.DomUtil.addClass(container, scrolledClass);
		} else {
			L.DomUtil.removeClass(container, scrolledClass);
		}

		this._containerWidth = this._container.offsetWidth;
	},

	_updatePosition: function () {
		if (!this._map) { return; }

		var pos = this._map.latLngToLayerPoint(this._latlng),
		    offset = L.point(this.options.offset);

		if (this._zoomAnimated) {
			L.DomUtil.setPosition(this._container, pos);
		} else {
			offset = offset.add(pos);
		}

		var bottom = this._containerBottom = -offset.y,
		    left = this._containerLeft = -Math.round(this._containerWidth / 2) + offset.x;

		// bottom position the popup in case the height of the popup changes (images loading etc)
		this._container.style.bottom = bottom + 'px';
		this._container.style.left = left + 'px';
	},

	_animateZoom: function (e) {
		var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center);
		L.DomUtil.setPosition(this._container, pos);
	},

	_adjustPan: function () {
		if (!this.options.autoPan) { return; }

		var map = this._map,
		    containerHeight = this._container.offsetHeight,
		    containerWidth = this._containerWidth,
		    layerPos = new L.Point(this._containerLeft, -containerHeight - this._containerBottom);

		if (this._zoomAnimated) {
			layerPos._add(L.DomUtil.getPosition(this._container));
		}

		var containerPos = map.layerPointToContainerPoint(layerPos),
		    padding = L.point(this.options.autoPanPadding),
		    paddingTL = L.point(this.options.autoPanPaddingTopLeft || padding),
		    paddingBR = L.point(this.options.autoPanPaddingBottomRight || padding),
		    size = map.getSize(),
		    dx = 0,
		    dy = 0;

		if (containerPos.x + containerWidth + paddingBR.x > size.x) { // right
			dx = containerPos.x + containerWidth - size.x + paddingBR.x;
		}
		if (containerPos.x - dx - paddingTL.x < 0) { // left
			dx = containerPos.x - paddingTL.x;
		}
		if (containerPos.y + containerHeight + paddingBR.y > size.y) { // bottom
			dy = containerPos.y + containerHeight - size.y + paddingBR.y;
		}
		if (containerPos.y - dy - paddingTL.y < 0) { // top
			dy = containerPos.y - paddingTL.y;
		}

		if (dx || dy) {
			map
			    .fire('autopanstart')
			    .panBy([dx, dy]);
		}
	},

	_onCloseButtonClick: function (e) {
		this._close();
		L.DomEvent.stop(e);
	}
});

L.popup = function (options, source) {
	return new L.Popup(options, source);
};


L.Map.include({
	openPopup: function (popup, latlng, options) { // (Popup) or (String || HTMLElement, LatLng[, Object])
		if (!(popup instanceof L.Popup)) {
			var content = popup;

			popup = new L.Popup(options).setContent(content);
		}

		if (latlng) {
			popup.setLatLng(latlng);
		}

		if (this.hasLayer(popup)) {
			return this;
		}

		this.closePopup();
		this._popup = popup;
		return this.addLayer(popup);
	},

	closePopup: function (popup) {
		if (!popup || popup === this._popup) {
			popup = this._popup;
			this._popup = null;
		}
		if (popup) {
			this.removeLayer(popup);
		}
		return this;
	}
});

/*
 * Adds popup-related methods to all layers.
 */

L.Layer.include({

	bindPopup: function (content, options) {

		if (content instanceof L.Popup) {
			this._popup = content;
			content._source = this;
		} else {
			if (!this._popup || options) {
				this._popup = new L.Popup(options, this);
			}
			this._popup.setContent(content);
		}

		if (!this._popupHandlersAdded) {
			this.on({
				click: this._openPopup,
				remove: this.closePopup,
				move: this._movePopup
			});
			this._popupHandlersAdded = true;
		}

		return this;
	},

	unbindPopup: function () {
		if (this._popup) {
			this.on({
			    click: this._openPopup,
			    remove: this.closePopup,
			    move: this._movePopup
			});
			this._popupHandlersAdded = false;
			this._popup = null;
		}
		return this;
	},

	openPopup: function (latlng) {
		if (this._popup && this._map) {
			this._map.openPopup(this._popup, latlng || this._latlng || this.getCenter());
		}
		return this;
	},

	closePopup: function () {
		if (this._popup) {
			this._popup._close();
		}
		return this;
	},

	togglePopup: function () {
		if (this._popup) {
			if (this._popup._map) {
				this.closePopup();
			} else {
				this.openPopup();
			}
		}
		return this;
	},

	setPopupContent: function (content) {
		if (this._popup) {
			this._popup.setContent(content);
		}
		return this;
	},

	getPopup: function () {
		return this._popup;
	},

	_openPopup: function (e) {
		this._map.openPopup(this._popup, e.latlng);
	},

	_movePopup: function (e) {
		this._popup.setLatLng(e.latlng);
	}
});

/*
 * Popup extension to L.Marker, adding popup-related methods.
 */

L.Marker.include({
	bindPopup: function (content, options) {
		var anchor = L.point(this.options.icon.options.popupAnchor || [0, 0])
			.add(L.Popup.prototype.options.offset);

		options = L.extend({offset: anchor}, options);

		return L.Layer.prototype.bindPopup.call(this, content, options);
	},

	_openPopup: L.Layer.prototype.togglePopup
});

/*
 * L.LayerGroup is a class to combine several layers into one so that
 * you can manipulate the group (e.g. add/remove it) as one layer.
 */

L.LayerGroup = L.Layer.extend({

	initialize: function (layers) {
		this._layers = {};

		var i, len;

		if (layers) {
			for (i = 0, len = layers.length; i < len; i++) {
				this.addLayer(layers[i]);
			}
		}
	},

	addLayer: function (layer) {
		var id = this.getLayerId(layer);

		this._layers[id] = layer;

		if (this._map) {
			this._map.addLayer(layer);
		}

		return this;
	},

	removeLayer: function (layer) {
		var id = layer in this._layers ? layer : this.getLayerId(layer);

		if (this._map && this._layers[id]) {
			this._map.removeLayer(this._layers[id]);
		}

		delete this._layers[id];

		return this;
	},

	hasLayer: function (layer) {
		return !!layer && (layer in this._layers || this.getLayerId(layer) in this._layers);
	},

	clearLayers: function () {
		for (var i in this._layers) {
			this.removeLayer(this._layers[i]);
		}
		return this;
	},

	invoke: function (methodName) {
		var args = Array.prototype.slice.call(arguments, 1),
		    i, layer;

		for (i in this._layers) {
			layer = this._layers[i];

			if (layer[methodName]) {
				layer[methodName].apply(layer, args);
			}
		}

		return this;
	},

	onAdd: function (map) {
		for (var i in this._layers) {
			map.addLayer(this._layers[i]);
		}
	},

	onRemove: function (map) {
		for (var i in this._layers) {
			map.removeLayer(this._layers[i]);
		}
	},

	eachLayer: function (method, context) {
		for (var i in this._layers) {
			method.call(context, this._layers[i]);
		}
		return this;
	},

	getLayer: function (id) {
		return this._layers[id];
	},

	getLayers: function () {
		var layers = [];

		for (var i in this._layers) {
			layers.push(this._layers[i]);
		}
		return layers;
	},

	setZIndex: function (zIndex) {
		return this.invoke('setZIndex', zIndex);
	},

	getLayerId: function (layer) {
		return L.stamp(layer);
	}
});

L.layerGroup = function (layers) {
	return new L.LayerGroup(layers);
};

/*
 * L.FeatureGroup extends L.LayerGroup by introducing mouse events and additional methods
 * shared between a group of interactive layers (like vectors or markers).
 */

L.FeatureGroup = L.LayerGroup.extend({

	addLayer: function (layer) {
		if (this.hasLayer(layer)) {
			return this;
		}

		layer.addEventParent(this);

		L.LayerGroup.prototype.addLayer.call(this, layer);

		if (this._popupContent && layer.bindPopup) {
			layer.bindPopup(this._popupContent, this._popupOptions);
		}

		return this.fire('layeradd', {layer: layer});
	},

	removeLayer: function (layer) {
		if (!this.hasLayer(layer)) {
			return this;
		}
		if (layer in this._layers) {
			layer = this._layers[layer];
		}

		layer.removeEventParent(this);

		L.LayerGroup.prototype.removeLayer.call(this, layer);

		if (this._popupContent) {
			this.invoke('unbindPopup');
		}

		return this.fire('layerremove', {layer: layer});
	},

	bindPopup: function (content, options) {
		this._popupContent = content;
		this._popupOptions = options;
		return this.invoke('bindPopup', content, options);
	},

	openPopup: function (latlng) {
		// open popup on the first layer
		for (var id in this._layers) {
			this._layers[id].openPopup(latlng);
			break;
		}
		return this;
	},

	setStyle: function (style) {
		return this.invoke('setStyle', style);
	},

	bringToFront: function () {
		return this.invoke('bringToFront');
	},

	bringToBack: function () {
		return this.invoke('bringToBack');
	},

	getBounds: function () {
		var bounds = new L.LatLngBounds();

		this.eachLayer(function (layer) {
			bounds.extend(layer.getBounds ? layer.getBounds() : layer.getLatLng());
		});

		return bounds;
	}
});

L.featureGroup = function (layers) {
	return new L.FeatureGroup(layers);
};

/*
 * L.Renderer is a base class for renderer implementations (SVG, Canvas);
 * handles renderer container, bounds and zoom animation.
 */

L.Renderer = L.Layer.extend({

	options: {
		// how much to extend the clip area around the map view (relative to its size)
		// e.g. 0.1 would be 10% of map view in each direction; defaults to clip with the map view
		padding: 0
	},

	initialize: function (options) {
		L.setOptions(this, options);
		L.stamp(this);
	},

	onAdd: function () {
		if (!this._container) {
			this._initContainer(); // defined by renderer implementations

			if (this._zoomAnimated) {
				L.DomUtil.addClass(this._container, 'leaflet-zoom-animated');
			}
		}

		this.getPane().appendChild(this._container);
		this._update();
	},

	onRemove: function () {
		L.DomUtil.remove(this._container);
	},

	getEvents: function () {
		var events = {
			moveend: this._update
		};
		if (this._zoomAnimated) {
			events.zoomanim = this._animateZoom;
		}
		return events;
	},

	_animateZoom: function (e) {
		var origin = e.origin.subtract(this._map._getCenterLayerPoint()),
		    offset = this._bounds.min.add(origin.multiplyBy(1 - e.scale));

		L.DomUtil.setTransform(this._container, offset, e.scale);
	},

	_update: function () {
		// update pixel bounds of renderer container (for positioning/sizing/clipping later)
		var p = this.options.padding,
		    size = this._map.getSize(),
		    min = this._map.containerPointToLayerPoint(size.multiplyBy(-p)).round();

		this._bounds = new L.Bounds(min, min.add(size.multiplyBy(1 + p * 2)).round());
	}
});


L.Map.include({
	// used by each vector layer to decide which renderer to use
	getRenderer: function (layer) {
		var renderer = layer.options.renderer || this.options.renderer || this._renderer;

		if (!renderer) {
			renderer = this._renderer = (L.SVG && L.svg()) || (L.Canvas && L.canvas());
		}

		if (!this.hasLayer(renderer)) {
			this.addLayer(renderer);
		}
		return renderer;
	}
});

/*
 * L.Path is the base class for all Leaflet vector layers like polygons and circles.
 */

L.Path = L.Layer.extend({

	options: {
		stroke: true,
		color: '#3388ff',
		weight: 3,
		opacity: 1,
		lineCap: 'round',
		lineJoin: 'round',
		// dashArray: null
		// dashOffset: null

		// fill: false
		// fillColor: same as color by default
		fillOpacity: 0.2,

		// className: ''
		clickable: true
	},

	onAdd: function () {
		this._renderer = this._map.getRenderer(this);
		this._renderer._initPath(this);

		// defined in children classes
		this._project();
		this._update();

		this._renderer._addPath(this);
	},

	onRemove: function () {
		this._renderer._removePath(this);
	},

	getEvents: function () {
		return {
			viewreset: this._project,
			moveend: this._update
		};
	},

	redraw: function () {
		if (this._map) {
			this._renderer._updatePath(this);
		}
		return this;
	},

	setStyle: function (style) {
		L.setOptions(this, style);
		if (this._renderer) {
			this._renderer._updateStyle(this);
		}
		return this;
	},

	bringToFront: function () {
		this._renderer._bringToFront(this);
		return this;
	},

	bringToBack: function () {
		this._renderer._bringToBack(this);
		return this;
	},

	_fireMouseEvent: function (e, type) {
		this._map._fireMouseEvent(this, e, type, true);
	},

	_clickTolerance: function () {
		// used when doing hit detection for Canvas layers
		return (this.options.stroke ? this.options.weight / 2 : 0) + (L.Browser.touch ? 10 : 0);
	}
});

/*
 * L.LineUtil contains different utility functions for line segments
 * and polylines (clipping, simplification, distances, etc.)
 */

/*jshint bitwise:false */ // allow bitwise operations for this file

L.LineUtil = {

	// Simplify polyline with vertex reduction and Douglas-Peucker simplification.
	// Improves rendering performance dramatically by lessening the number of points to draw.

	simplify: function (/*Point[]*/ points, /*Number*/ tolerance) {
		if (!tolerance || !points.length) {
			return points.slice();
		}

		var sqTolerance = tolerance * tolerance;

		// stage 1: vertex reduction
		points = this._reducePoints(points, sqTolerance);

		// stage 2: Douglas-Peucker simplification
		points = this._simplifyDP(points, sqTolerance);

		return points;
	},

	// distance from a point to a segment between two points
	pointToSegmentDistance:  function (/*Point*/ p, /*Point*/ p1, /*Point*/ p2) {
		return Math.sqrt(this._sqClosestPointOnSegment(p, p1, p2, true));
	},

	closestPointOnSegment: function (/*Point*/ p, /*Point*/ p1, /*Point*/ p2) {
		return this._sqClosestPointOnSegment(p, p1, p2);
	},

	// Douglas-Peucker simplification, see http://en.wikipedia.org/wiki/Douglas-Peucker_algorithm
	_simplifyDP: function (points, sqTolerance) {

		var len = points.length,
		    ArrayConstructor = typeof Uint8Array !== undefined + '' ? Uint8Array : Array,
		    markers = new ArrayConstructor(len);

		markers[0] = markers[len - 1] = 1;

		this._simplifyDPStep(points, markers, sqTolerance, 0, len - 1);

		var i,
		    newPoints = [];

		for (i = 0; i < len; i++) {
			if (markers[i]) {
				newPoints.push(points[i]);
			}
		}

		return newPoints;
	},

	_simplifyDPStep: function (points, markers, sqTolerance, first, last) {

		var maxSqDist = 0,
		    index, i, sqDist;

		for (i = first + 1; i <= last - 1; i++) {
			sqDist = this._sqClosestPointOnSegment(points[i], points[first], points[last], true);

			if (sqDist > maxSqDist) {
				index = i;
				maxSqDist = sqDist;
			}
		}

		if (maxSqDist > sqTolerance) {
			markers[index] = 1;

			this._simplifyDPStep(points, markers, sqTolerance, first, index);
			this._simplifyDPStep(points, markers, sqTolerance, index, last);
		}
	},

	// reduce points that are too close to each other to a single point
	_reducePoints: function (points, sqTolerance) {
		var reducedPoints = [points[0]];

		for (var i = 1, prev = 0, len = points.length; i < len; i++) {
			if (this._sqDist(points[i], points[prev]) > sqTolerance) {
				reducedPoints.push(points[i]);
				prev = i;
			}
		}
		if (prev < len - 1) {
			reducedPoints.push(points[len - 1]);
		}
		return reducedPoints;
	},

	// Cohen-Sutherland line clipping algorithm.
	// Used to avoid rendering parts of a polyline that are not currently visible.

	clipSegment: function (a, b, bounds, useLastCode) {
		var codeA = useLastCode ? this._lastCode : this._getBitCode(a, bounds),
		    codeB = this._getBitCode(b, bounds),

		    codeOut, p, newCode;

		// save 2nd code to avoid calculating it on the next segment
		this._lastCode = codeB;

		while (true) {
			// if a,b is inside the clip window (trivial accept)
			if (!(codeA | codeB)) {
				return [a, b];
			// if a,b is outside the clip window (trivial reject)
			} else if (codeA & codeB) {
				return false;
			// other cases
			} else {
				codeOut = codeA || codeB;
				p = this._getEdgeIntersection(a, b, codeOut, bounds);
				newCode = this._getBitCode(p, bounds);

				if (codeOut === codeA) {
					a = p;
					codeA = newCode;
				} else {
					b = p;
					codeB = newCode;
				}
			}
		}
	},

	_getEdgeIntersection: function (a, b, code, bounds) {
		var dx = b.x - a.x,
		    dy = b.y - a.y,
		    min = bounds.min,
		    max = bounds.max,
		    x, y;

		if (code & 8) { // top
			x = a.x + dx * (max.y - a.y) / dy;
			y = max.y;

		} else if (code & 4) { // bottom
			x = a.x + dx * (min.y - a.y) / dy;
			y = min.y;

		} else if (code & 2) { // right
			x = max.x;
			y = a.y + dy * (max.x - a.x) / dx;

		} else if (code & 1) { // left
			x = min.x;
			y = a.y + dy * (min.x - a.x) / dx;
		}

		return new L.Point(x, y, true);
	},

	_getBitCode: function (/*Point*/ p, bounds) {
		var code = 0;

		if (p.x < bounds.min.x) { // left
			code |= 1;
		} else if (p.x > bounds.max.x) { // right
			code |= 2;
		}

		if (p.y < bounds.min.y) { // bottom
			code |= 4;
		} else if (p.y > bounds.max.y) { // top
			code |= 8;
		}

		return code;
	},

	// square distance (to avoid unnecessary Math.sqrt calls)
	_sqDist: function (p1, p2) {
		var dx = p2.x - p1.x,
		    dy = p2.y - p1.y;
		return dx * dx + dy * dy;
	},

	// return closest point on segment or distance to that point
	_sqClosestPointOnSegment: function (p, p1, p2, sqDist) {
		var x = p1.x,
		    y = p1.y,
		    dx = p2.x - x,
		    dy = p2.y - y,
		    dot = dx * dx + dy * dy,
		    t;

		if (dot > 0) {
			t = ((p.x - x) * dx + (p.y - y) * dy) / dot;

			if (t > 1) {
				x = p2.x;
				y = p2.y;
			} else if (t > 0) {
				x += dx * t;
				y += dy * t;
			}
		}

		dx = p.x - x;
		dy = p.y - y;

		return sqDist ? dx * dx + dy * dy : new L.Point(x, y);
	}
};

/*
 * L.Polyline implements polyline vector layer (a set of points connected with lines)
 */

L.Polyline = L.Path.extend({

	options: {
		// how much to simplify the polyline on each zoom level
		// more = better performance and smoother look, less = more accurate
		smoothFactor: 1.0
		// noClip: false
	},

	initialize: function (latlngs, options) {
		L.setOptions(this, options);
		this._setLatLngs(latlngs);
	},

	getLatLngs: function () {
		// TODO rings
		return this._latlngs;
	},

	setLatLngs: function (latlngs) {
		this._setLatLngs(latlngs);
		return this.redraw();
	},

	addLatLng: function (latlng) {
		// TODO rings
		latlng = L.latLng(latlng);
		this._latlngs.push(latlng);
		this._bounds.extend(latlng);
		return this.redraw();
	},

	spliceLatLngs: function () {
		// TODO rings
		var removed = [].splice.apply(this._latlngs, arguments);
		this._setLatLngs(this._latlngs);
		this.redraw();
		return removed;
	},

	closestLayerPoint: function (p) {
		var minDistance = Infinity,
		    minPoint = null,
		    closest = L.LineUtil._sqClosestPointOnSegment,
		    p1, p2;

		for (var j = 0, jLen = this._parts.length; j < jLen; j++) {
			var points = this._parts[j];

			for (var i = 1, len = points.length; i < len; i++) {
				p1 = points[i - 1];
				p2 = points[i];

				var sqDist = closest(p, p1, p2, true);

				if (sqDist < minDistance) {
					minDistance = sqDist;
					minPoint = closest(p, p1, p2);
				}
			}
		}
		if (minPoint) {
			minPoint.distance = Math.sqrt(minDistance);
		}
		return minPoint;
	},

	getCenter: function () {
		var i, halfDist, segDist, dist, p1, p2, ratio,
		    points = this._rings[0],
		    len = points.length;

		// polyline centroid algorithm; only uses the first ring if there are multiple

		for (i = 0, halfDist = 0; i < len - 1; i++) {
			halfDist += points[i].distanceTo(points[i + 1]) / 2;
		}

		for (i = 0, dist = 0; i < len - 1; i++) {
			p1 = points[i];
			p2 = points[i + 1];
			segDist = p1.distanceTo(p2);
			dist += segDist;

			if (dist > halfDist) {
				ratio = (dist - halfDist) / segDist;
				return this._map.layerPointToLatLng([
					p2.x - ratio * (p2.x - p1.x),
					p2.y - ratio * (p2.y - p1.y)
				]);
			}
		}
	},

	getBounds: function () {
		return this._bounds;
	},

	_setLatLngs: function (latlngs) {
		this._bounds = new L.LatLngBounds();
		this._latlngs = this._convertLatLngs(latlngs);
	},

	// recursively convert latlngs input into actual LatLng instances; calculate bounds along the way
	_convertLatLngs: function (latlngs) {
		var result = [],
		    flat = this._flat(latlngs);

		for (var i = 0, len = latlngs.length; i < len; i++) {
			if (flat) {
				result[i] = L.latLng(latlngs[i]);
				this._bounds.extend(result[i]);
			} else {
				result[i] = this._convertLatLngs(latlngs[i]);
			}
		}

		return result;
	},

	_flat: function (latlngs) {
		// true if it's a flat array of latlngs; false if nested
		return !L.Util.isArray(latlngs[0]) || typeof latlngs[0][0] !== 'object';
	},

	_project: function () {
		this._rings = [];
		this._projectLatlngs(this._latlngs, this._rings);

		// project bounds as well to use later for Canvas hit detection/etc.
		var w = this._clickTolerance(),
			p = new L.Point(w, -w);

		if (this._latlngs.length) {
			this._pxBounds = new L.Bounds(
				this._map.latLngToLayerPoint(this._bounds.getSouthWest())._subtract(p),
				this._map.latLngToLayerPoint(this._bounds.getNorthEast())._add(p));
		}
	},

	// recursively turns latlngs into a set of rings with projected coordinates
	_projectLatlngs: function (latlngs, result) {

		var flat = latlngs[0] instanceof L.LatLng,
		    len = latlngs.length,
		    i, ring;

		if (flat) {
			ring = [];
			for (i = 0; i < len; i++) {
				ring[i] = this._map.latLngToLayerPoint(latlngs[i]);
			}
			result.push(ring);
		} else {
			for (i = 0; i < len; i++) {
				this._projectLatlngs(latlngs[i], result);
			}
		}
	},

	// clip polyline by renderer bounds so that we have less to render for performance
	_clipPoints: function () {
		if (this.options.noClip) {
			this._parts = this._rings;
			return;
		}

		this._parts = [];

		var parts = this._parts,
		    bounds = this._renderer._bounds,
		    i, j, k, len, len2, segment, points;

		for (i = 0, k = 0, len = this._rings.length; i < len; i++) {
			points = this._rings[i];

			for (j = 0, len2 = points.length; j < len2 - 1; j++) {
				segment = L.LineUtil.clipSegment(points[j], points[j + 1], bounds, j);

				if (!segment) { continue; }

				parts[k] = parts[k] || [];
				parts[k].push(segment[0]);

				// if segment goes out of screen, or it's the last one, it's the end of the line part
				if ((segment[1] !== points[j + 1]) || (j === len2 - 2)) {
					parts[k].push(segment[1]);
					k++;
				}
			}
		}
	},

	// simplify each clipped part of the polyline for performance
	_simplifyPoints: function () {
		var parts = this._parts,
			tolerance = this.options.smoothFactor;

		for (var i = 0, len = parts.length; i < len; i++) {
			parts[i] = L.LineUtil.simplify(parts[i], tolerance);
		}
	},

	_update: function () {
		if (!this._map) { return; }

		this._clipPoints();
		this._simplifyPoints();
		this._updatePath();
	},

	_updatePath: function () {
		this._renderer._updatePoly(this);
	}
});

L.polyline = function (latlngs, options) {
	return new L.Polyline(latlngs, options);
};

/*
 * L.PolyUtil contains utility functions for polygons (clipping, etc.).
 */

/*jshint bitwise:false */ // allow bitwise operations here

L.PolyUtil = {};

/*
 * Sutherland-Hodgeman polygon clipping algorithm.
 * Used to avoid rendering parts of a polygon that are not currently visible.
 */
L.PolyUtil.clipPolygon = function (points, bounds) {
	var clippedPoints,
	    edges = [1, 4, 2, 8],
	    i, j, k,
	    a, b,
	    len, edge, p,
	    lu = L.LineUtil;

	for (i = 0, len = points.length; i < len; i++) {
		points[i]._code = lu._getBitCode(points[i], bounds);
	}

	// for each edge (left, bottom, right, top)
	for (k = 0; k < 4; k++) {
		edge = edges[k];
		clippedPoints = [];

		for (i = 0, len = points.length, j = len - 1; i < len; j = i++) {
			a = points[i];
			b = points[j];

			// if a is inside the clip window
			if (!(a._code & edge)) {
				// if b is outside the clip window (a->b goes out of screen)
				if (b._code & edge) {
					p = lu._getEdgeIntersection(b, a, edge, bounds);
					p._code = lu._getBitCode(p, bounds);
					clippedPoints.push(p);
				}
				clippedPoints.push(a);

			// else if b is inside the clip window (a->b enters the screen)
			} else if (!(b._code & edge)) {
				p = lu._getEdgeIntersection(b, a, edge, bounds);
				p._code = lu._getBitCode(p, bounds);
				clippedPoints.push(p);
			}
		}
		points = clippedPoints;
	}

	return points;
};

/*
 * L.Polygon implements polygon vector layer (closed polyline with a fill inside).
 */

L.Polygon = L.Polyline.extend({

	options: {
		fill: true
	},

	getCenter: function () {
		var i, j, len, p1, p2, f, area, x, y,
		    points = this._rings[0];

		// polygon centroid algorithm; only uses the first ring if there are multiple

		area = x = y = 0;

		for (i = 0, len = points.length, j = len - 1; i < len; j = i++) {
			p1 = points[i];
			p2 = points[j];

			f = p1.y * p2.x - p2.y * p1.x;
			x += (p1.x + p2.x) * f;
			y += (p1.y + p2.y) * f;
			area += f * 3;
		}

		return this._map.layerPointToLatLng([x / area, y / area]);
	},

	_convertLatLngs: function (latlngs) {
		var result = L.Polyline.prototype._convertLatLngs.call(this, latlngs),
		    len = result.length;

		// remove last point if it equals first one
		if (len >= 2 && result[0] instanceof L.LatLng && result[0].equals(result[len - 1])) {
			result.pop();
		}
		return result;
	},

	_clipPoints: function () {
		if (this.options.noClip) {
			this._parts = this._rings;
			return;
		}

		// polygons need a different clipping algorithm so we redefine that

		var bounds = this._renderer._bounds,
		    w = this.options.weight,
		    p = new L.Point(w, w);

		// increase clip padding by stroke width to avoid stroke on clip edges
		bounds = new L.Bounds(bounds.min.subtract(p), bounds.max.add(p));

		this._parts = [];

		for (var i = 0, len = this._rings.length, clipped; i < len; i++) {
			clipped = L.PolyUtil.clipPolygon(this._rings[i], bounds);
			if (clipped.length) {
				this._parts.push(clipped);
			}
		}
	},

	_updatePath: function () {
		this._renderer._updatePoly(this, true);
	}
});

L.polygon = function (latlngs, options) {
	return new L.Polygon(latlngs, options);
};

/*
 * L.Rectangle extends Polygon and creates a rectangle when passed a LatLngBounds object.
 */

L.Rectangle = L.Polygon.extend({
	initialize: function (latLngBounds, options) {
		L.Polygon.prototype.initialize.call(this, this._boundsToLatLngs(latLngBounds), options);
	},

	setBounds: function (latLngBounds) {
		this.setLatLngs(this._boundsToLatLngs(latLngBounds));
	},

	_boundsToLatLngs: function (latLngBounds) {
		latLngBounds = L.latLngBounds(latLngBounds);
		return [
			latLngBounds.getSouthWest(),
			latLngBounds.getNorthWest(),
			latLngBounds.getNorthEast(),
			latLngBounds.getSouthEast()
		];
	}
});

L.rectangle = function (latLngBounds, options) {
	return new L.Rectangle(latLngBounds, options);
};

/*
 * L.CircleMarker is a circle overlay with a permanent pixel radius.
 */

L.CircleMarker = L.Path.extend({

	options: {
		fill: true,
		radius: 10
	},

	initialize: function (latlng, options) {
		L.setOptions(this, options);
		this._latlng = L.latLng(latlng);
		this._radius = this.options.radius;
	},

	setLatLng: function (latlng) {
		this._latlng = L.latLng(latlng);
		this.redraw();
		return this.fire('move', {latlng: this._latlng});
	},

	getLatLng: function () {
		return this._latlng;
	},

	setRadius: function (radius) {
		this.options.radius = this._radius = radius;
		return this.redraw();
	},

	getRadius: function () {
		return this._radius;
	},

	setStyle : function (options) {
		var radius = options && options.radius || this._radius;
		L.Path.prototype.setStyle.call(this, options);
		this.setRadius(radius);
		return this;
	},

	_project: function () {
		this._point = this._map.latLngToLayerPoint(this._latlng);
		this._updateBounds();
	},

	_updateBounds: function () {
		var r = this._radius,
		    r2 = this._radiusY || r,
		    w = this._clickTolerance(),
		    p = [r + w, r2 + w];
		this._pxBounds = new L.Bounds(this._point.subtract(p), this._point.add(p));
	},

	_update: function () {
		if (this._map) {
			this._updatePath();
		}
	},

	_updatePath: function () {
		this._renderer._updateCircle(this);
	},

	_empty: function () {
		return this._radius && !this._renderer._bounds.intersects(this._pxBounds);
	}
});

L.circleMarker = function (latlng, options) {
	return new L.CircleMarker(latlng, options);
};

/*
 * L.Circle is a circle overlay (with a certain radius in meters).
 * It's an approximation and starts to diverge from a real circle closer to poles (due to projection distortion)
 */

L.Circle = L.CircleMarker.extend({

	initialize: function (latlng, radius, options) {
		L.setOptions(this, options);
		this._latlng = L.latLng(latlng);
		this._mRadius = radius;
	},

	setRadius: function (radius) {
		this._mRadius = radius;
		return this.redraw();
	},

	getRadius: function () {
		return this._mRadius;
	},

	getBounds: function () {
		var half = [this._radius, this._radiusY];

		return new L.LatLngBounds(
			this._map.layerPointToLatLng(this._point.subtract(half)),
			this._map.layerPointToLatLng(this._point.add(half)));
	},

	setStyle: L.Path.prototype.setStyle,

	_project: function () {

		var lng = this._latlng.lng,
		    lat = this._latlng.lat,
		    map = this._map,
		    crs = map.options.crs;

		if (crs.distance === L.CRS.Earth.distance) {
			var d = Math.PI / 180,
			    latR = (this._mRadius / L.CRS.Earth.R) / d,
			    top = map.project([lat + latR, lng]),
			    bottom = map.project([lat - latR, lng]),
			    p = top.add(bottom).divideBy(2),
			    lat2 = map.unproject(p).lat,
			    lngR = Math.acos((Math.cos(latR * d) - Math.sin(lat * d) * Math.sin(lat2 * d)) /
			            (Math.cos(lat * d) * Math.cos(lat2 * d))) / d;

			this._point = p.subtract(map.getPixelOrigin());
			this._radius = isNaN(lngR) ? 0 : Math.max(Math.round(p.x - map.project([lat2, lng - lngR]).x), 1);
			this._radiusY = Math.max(Math.round(p.y - top.y), 1);

		} else {
			var latlng2 = crs.unproject(crs.project(this._latlng).subtract([this._mRadius, 0]));

			this._point = map.latLngToLayerPoint(this._latlng);
			this._radius = this._point.x - map.latLngToLayerPoint(latlng2).x;
		}

		this._updateBounds();
	}
});

L.circle = function (latlng, radius, options) {
	return new L.Circle(latlng, radius, options);
};

/*
 * L.SVG renders vector layers with SVG. All SVG-specific code goes here.
 */

L.SVG = L.Renderer.extend({

	_initContainer: function () {
		this._container = L.SVG.create('svg');

		this._paths = {};
		this._initEvents();

		// makes it possible to click through svg root; we'll reset it back in individual paths
		this._container.setAttribute('pointer-events', 'none');
	},

	_update: function () {
		if (this._map._animatingZoom && this._bounds) { return; }

		L.Renderer.prototype._update.call(this);

		var b = this._bounds,
		    size = b.getSize(),
		    container = this._container,
		    pane = this.getPane();

		// hack to make flicker on drag end on mobile webkit less irritating
		if (L.Browser.mobileWebkit) {
			pane.removeChild(container);
		}

		L.DomUtil.setPosition(container, b.min);

		// update container viewBox so that we don't have to change coordinates of individual layers
		container.setAttribute('width', size.x);
		container.setAttribute('height', size.y);
		container.setAttribute('viewBox', [b.min.x, b.min.y, size.x, size.y].join(' '));

		if (L.Browser.mobileWebkit) {
			pane.appendChild(container);
		}
	},

	// methods below are called by vector layers implementations

	_initPath: function (layer) {
		var path = layer._path = L.SVG.create('path');

		if (layer.options.className) {
			L.DomUtil.addClass(path, layer.options.className);
		}

		if (layer.options.clickable) {
			L.DomUtil.addClass(path, 'leaflet-clickable');
		}

		this._updateStyle(layer);
	},

	_addPath: function (layer) {
		var path = layer._path;
		this._container.appendChild(path);
		this._paths[L.stamp(path)] = layer;
	},

	_removePath: function (layer) {
		var path = layer._path;
		L.DomUtil.remove(path);
		delete this._paths[L.stamp(path)];
	},

	_updatePath: function (layer) {
		layer._project();
		layer._update();
	},

	_updateStyle: function (layer) {
		var path = layer._path,
			options = layer.options;

		if (!path) { return; }

		if (options.stroke) {
			path.setAttribute('stroke', options.color);
			path.setAttribute('stroke-opacity', options.opacity);
			path.setAttribute('stroke-width', options.weight);
			path.setAttribute('stroke-linecap', options.lineCap);
			path.setAttribute('stroke-linejoin', options.lineJoin);

			if (options.dashArray) {
				path.setAttribute('stroke-dasharray', options.dashArray);
			} else {
				path.removeAttribute('stroke-dasharray');
			}

			if (options.dashOffset) {
				path.setAttribute('stroke-dashoffset', options.dashOffset);
			} else {
				path.removeAttribute('stroke-dashoffset');
			}
		} else {
			path.setAttribute('stroke', 'none');
		}

		if (options.fill) {
			path.setAttribute('fill', options.fillColor || options.color);
			path.setAttribute('fill-opacity', options.fillOpacity);
			path.setAttribute('fill-rule', 'evenodd');
		} else {
			path.setAttribute('fill', 'none');
		}

		path.setAttribute('pointer-events', options.pointerEvents || (options.clickable ? 'visiblePainted' : 'none'));
	},

	_updatePoly: function (layer, closed) {
		this._setPath(layer, L.SVG.pointsToPath(layer._parts, closed));
	},

	_updateCircle: function (layer) {
		var p = layer._point,
		    r = layer._radius,
		    r2 = layer._radiusY || r,
		    arc = 'a' + r + ',' + r2 + ' 0 1,0 ';

		// drawing a circle with two half-arcs
		var d = layer._empty() ? 'M0 0' :
				'M' + (p.x - r) + ',' + p.y +
				arc +  (r * 2) + ',0 ' +
				arc + (-r * 2) + ',0 ';

		this._setPath(layer, d);
	},

	_setPath: function (layer, path) {
		layer._path.setAttribute('d', path);
	},

	// SVG does not have the concept of zIndex so we resort to changing the DOM order of elements
	_bringToFront: function (layer) {
		L.DomUtil.toFront(layer._path);
	},

	_bringToBack: function (layer) {
		L.DomUtil.toBack(layer._path);
	},

	// TODO remove duplication with L.Map
	_initEvents: function () {
		L.DomEvent.on(this._container, 'click dblclick mousedown mouseup mouseover mouseout mousemove contextmenu',
				this._fireMouseEvent, this);
	},

	_fireMouseEvent: function (e) {
		this._paths[L.stamp(e.target || e.srcElement)] && this._paths[L.stamp(e.target || e.srcElement)]._fireMouseEvent(e);
	}
});


L.extend(L.SVG, {
	create: function (name) {
		return document.createElementNS('http://www.w3.org/2000/svg', name);
	},

	// generates SVG path string for multiple rings, with each ring turning into "M..L..L.." instructions
	pointsToPath: function (rings, closed) {
		var str = '',
			i, j, len, len2, points, p;

		for (i = 0, len = rings.length; i < len; i++) {
			points = rings[i];

			for (j = 0, len2 = points.length; j < len2; j++) {
				p = points[j];
				str += (j ? 'L' : 'M') + p.x + ' ' + p.y;
			}

			// closes the ring for polygons; "x" is VML syntax
			str += closed ? (L.Browser.svg ? 'z' : 'x') : '';
		}

		// SVG complains about empty path strings
		return str || 'M0 0';
	}
});

L.Browser.svg = !!(document.createElementNS && L.SVG.create('svg').createSVGRect);

L.svg = function (options) {
	return L.Browser.svg || L.Browser.vml ? new L.SVG(options) : null;
};

/*
 * Vector rendering for IE7-8 through VML.
 * Thanks to Dmitry Baranovsky and his Raphael library for inspiration!
 */

L.Browser.vml = !L.Browser.svg && (function () {
	try {
		var div = document.createElement('div');
		div.innerHTML = '<v:shape adj="1"/>';

		var shape = div.firstChild;
		shape.style.behavior = 'url(#default#VML)';

		return shape && (typeof shape.adj === 'object');

	} catch (e) {
		return false;
	}
}());

// redefine some SVG methods to handle VML syntax which is similar but with some differences
L.SVG.include(!L.Browser.vml ? {} : {

	_initContainer: function () {
		this._container = L.DomUtil.create('div', 'leaflet-vml-container');

		this._paths = {};
		this._initEvents();
	},

	_update: function () {
		if (this._map._animatingZoom) { return; }
		L.Renderer.prototype._update.call(this);
	},

	_initPath: function (layer) {
		var container = layer._container = L.SVG.create('shape');

		L.DomUtil.addClass(container, 'leaflet-vml-shape ' + (this.options.className || ''));

		container.coordsize = '1 1';

		layer._path = L.SVG.create('path');
		container.appendChild(layer._path);

		this._updateStyle(layer);
	},

	_addPath: function (layer) {
		var container = layer._container;
		this._container.appendChild(container);
		this._paths[L.stamp(container)] = layer;
	},

	_removePath: function (layer) {
		var container = layer._container;
		L.DomUtil.remove(container);
		delete this._paths[L.stamp(container)];
	},

	_updateStyle: function (layer) {
		var stroke = layer._stroke,
		    fill = layer._fill,
		    options = layer.options,
		    container = layer._container;

		container.stroked = !!options.stroke;
		container.filled = !!options.fill;

		if (options.stroke) {
			if (!stroke) {
				stroke = layer._stroke = L.SVG.create('stroke');
				container.appendChild(stroke);
			}
			stroke.weight = options.weight + 'px';
			stroke.color = options.color;
			stroke.opacity = options.opacity;

			if (options.dashArray) {
				stroke.dashStyle = L.Util.isArray(options.dashArray) ?
				    options.dashArray.join(' ') :
				    options.dashArray.replace(/( *, *)/g, ' ');
			} else {
				stroke.dashStyle = '';
			}
			stroke.endcap = options.lineCap.replace('butt', 'flat');
			stroke.joinstyle = options.lineJoin;

		} else if (stroke) {
			container.removeChild(stroke);
			layer._stroke = null;
		}

		if (options.fill) {
			if (!fill) {
				fill = layer._fill = L.SVG.create('fill');
				container.appendChild(fill);
			}
			fill.color = options.fillColor || options.color;
			fill.opacity = options.fillOpacity;

		} else if (fill) {
			container.removeChild(fill);
			layer._fill = null;
		}
	},

	_updateCircle: function (layer) {
		var p = layer._point,
		    r = Math.round(layer._radius),
		    r2 = Math.round(layer._radiusY || r);

		this._setPath(layer, layer._empty() ? 'M0 0' :
				'AL ' + p.x + ',' + p.y + ' ' + r + ',' + r2 + ' 0,' + (65535 * 360));
	},

	_setPath: function (layer, path) {
		layer._path.v = path;
	},

	_bringToFront: function (layer) {
		L.DomUtil.toFront(layer._path.parentNode);
	},

	_bringToBack: function (layer) {
		L.DomUtil.toBack(layer._path.parentNode);
	}
});

if (L.Browser.vml) {
	L.SVG.create = (function () {
		try {
			document.namespaces.add('lvml', 'urn:schemas-microsoft-com:vml');
			return function (name) {
				return document.createElement('<lvml:' + name + ' class="lvml">');
			};
		} catch (e) {
			return function (name) {
				return document.createElement('<' + name + ' xmlns="urn:schemas-microsoft.com:vml" class="lvml">');
			};
		}
	})();
}

/*
 * L.Canvas handles Canvas vector layers rendering and mouse events handling. All Canvas-specific code goes here.
 */

L.Canvas = L.Renderer.extend({

	onAdd: function () {
		L.Renderer.prototype.onAdd.call(this);

		this._layers = this._layers || {};

		// redraw vectors since canvas is cleared upon removal
		this._draw();
	},

	_initContainer: function () {
		var container = this._container = document.createElement('canvas');

		L.DomEvent
			.on(container, 'mousemove', this._onMouseMove, this)
			.on(container, 'click dblclick mousedown mouseup contextmenu', this._onClick, this);

		this._ctx = container.getContext('2d');
	},

	_update: function () {
		if (this._map._animatingZoom && this._bounds) { return; }

		L.Renderer.prototype._update.call(this);

		var b = this._bounds,
		    container = this._container,
		    size = b.getSize(),
		    m = L.Browser.retina ? 2 : 1;

		L.DomUtil.setPosition(container, b.min);

		// set canvas size (also clearing it); use double size on retina
		container.width = m * size.x;
		container.height = m * size.y;
		container.style.width = size.x + 'px';
		container.style.height = size.y + 'px';

		if (L.Browser.retina) {
			this._ctx.scale(2, 2);
		}

		// translate so we use the same path coordinates after canvas element moves
		this._ctx.translate(-b.min.x, -b.min.y);
	},

	_initPath: function (layer) {
		this._layers[L.stamp(layer)] = layer;
	},

	_addPath: L.Util.falseFn,

	_removePath: function (layer) {
		layer._removed = true;
		this._requestRedraw(layer);
	},

	_updatePath: function (layer) {
		this._redrawBounds = layer._pxBounds;
		this._draw(true);
		layer._project();
		layer._update();
		this._draw();
		this._redrawBounds = null;
	},

	_updateStyle: function (layer) {
		this._requestRedraw(layer);
	},

	_requestRedraw: function (layer) {
		if (!this._map) { return; }

		this._redrawBounds = this._redrawBounds || new L.Bounds();
		this._redrawBounds.extend(layer._pxBounds.min).extend(layer._pxBounds.max);

		this._redrawRequest = this._redrawRequest || L.Util.requestAnimFrame(this._redraw, this);
	},

	_redraw: function () {
		this._redrawRequest = null;

		this._draw(true); // clear layers in redraw bounds
		this._draw(); // draw layers

		this._redrawBounds = null;
	},

	_draw: function (clear) {
		this._clear = clear;
		var layer;

		for (var id in this._layers) {
			layer = this._layers[id];
			if (!this._redrawBounds || layer._pxBounds.intersects(this._redrawBounds)) {
				layer._updatePath();
			}
			if (clear && layer._removed) {
				delete layer._removed;
				delete this._layers[id];
			}
		}
	},

	_updatePoly: function (layer, closed) {

		var i, j, len2, p,
		    parts = layer._parts,
		    len = parts.length,
		    ctx = this._ctx;

	    if (!len) { return; }

		ctx.beginPath();

		for (i = 0; i < len; i++) {
			for (j = 0, len2 = parts[i].length; j < len2; j++) {
				p = parts[i][j];
				ctx[j ? 'lineTo' : 'moveTo'](p.x, p.y);
			}
			if (closed) {
				ctx.closePath();
			}
		}

		this._fillStroke(ctx, layer);

		// TODO optimization: 1 fill/stroke for all features with equal style instead of 1 for each feature
	},

	_updateCircle: function (layer) {

		if (layer._empty()) { return; }

		var p = layer._point,
		    ctx = this._ctx,
		    r = layer._radius,
		    s = (layer._radiusY || r) / r;

		if (s !== 1) {
			ctx.save();
			ctx.scale(1, s);
		}

		ctx.beginPath();
		ctx.arc(p.x, p.y / s, r, 0, Math.PI * 2, false);

		if (s !== 1) {
			ctx.restore();
		}

		this._fillStroke(ctx, layer);
	},

	_fillStroke: function (ctx, layer) {
		var clear = this._clear,
		    options = layer.options;

		ctx.globalCompositeOperation = clear ? 'destination-out' : 'source-over';

		if (options.fill) {
			ctx.globalAlpha = clear ? 1 : options.fillOpacity;
			ctx.fillStyle = options.fillColor || options.color;
			ctx.fill('evenodd');
		}

		if (options.stroke) {
			ctx.globalAlpha = clear ? 1 : options.opacity;

			// if clearing shape, do it with the previously drawn line width
			layer._prevWeight = ctx.lineWidth = clear ? layer._prevWeight + 1 : options.weight;

			ctx.strokeStyle = options.color;
			ctx.lineCap = options.lineCap;
			ctx.lineJoin = options.lineJoin;
			ctx.stroke();
		}
	},

	// Canvas obviously doesn't have mouse events for individual drawn objects,
	// so we emulate that by calculating what's under the mouse on mousemove/click manually

	_onClick: function (e) {
		var point = this._map.mouseEventToLayerPoint(e);

		for (var id in this._layers) {
			if (this._layers[id]._containsPoint(point)) {
				this._layers[id]._fireMouseEvent(e);
			}
		}
	},

	_onMouseMove: function (e) {
		if (!this._map || this._map._animatingZoom) { return; }

		var point = this._map.mouseEventToLayerPoint(e);

		// TODO don't do on each move event, throttle since it's expensive
		for (var id in this._layers) {
			this._handleHover(this._layers[id], e, point);
		}
	},

	_handleHover: function (layer, e, point) {
		if (!layer.options.clickable) { return; }

		if (layer._containsPoint(point)) {
			// if we just got inside the layer, fire mouseover
			if (!layer._mouseInside) {
				L.DomUtil.addClass(this._container, 'leaflet-clickable'); // change cursor
				layer._fireMouseEvent(e, 'mouseover');
				layer._mouseInside = true;
			}
			// fire mousemove
			layer._fireMouseEvent(e);

		} else if (layer._mouseInside) {
			// if we're leaving the layer, fire mouseout
			L.DomUtil.removeClass(this._container, 'leaflet-clickable');
			layer._fireMouseEvent(e, 'mouseout');
			layer._mouseInside = false;
		}
	},

	// TODO _bringToFront & _bringToBack, pretty tricky

	_bringToFront: L.Util.falseFn,
	_bringToBack: L.Util.falseFn
});

L.Browser.canvas = (function () {
	return !!document.createElement('canvas').getContext;
}());

L.canvas = function (options) {
	return L.Browser.canvas ? new L.Canvas(options) : null;
};

L.Polyline.prototype._containsPoint = function (p, closed) {
	var i, j, k, len, len2, part,
	    w = this._clickTolerance();

	if (!this._pxBounds.contains(p)) { return false; }

	// hit detection for polylines
	for (i = 0, len = this._parts.length; i < len; i++) {
		part = this._parts[i];

		for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
			if (!closed && (j === 0)) { continue; }

			if (L.LineUtil.pointToSegmentDistance(p, part[k], part[j]) <= w) {
				return true;
			}
		}
	}
	return false;
};

L.Polygon.prototype._containsPoint = function (p) {
	var inside = false,
	    part, p1, p2, i, j, k, len, len2;

	if (!this._pxBounds.contains(p)) { return false; }

	// ray casting algorithm for detecting if point is in polygon
	for (i = 0, len = this._parts.length; i < len; i++) {
		part = this._parts[i];

		for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
			p1 = part[j];
			p2 = part[k];

			if (((p1.y > p.y) !== (p2.y > p.y)) && (p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x)) {
				inside = !inside;
			}
		}
	}

	// also check if it's on polygon stroke
	return inside || L.Polyline.prototype._containsPoint.call(this, p, true);
};

L.CircleMarker.prototype._containsPoint = function (p) {
	return p.distanceTo(this._point) <= this._radius + this._clickTolerance();
};

/*
 * L.GeoJSON turns any GeoJSON data into a Leaflet layer.
 */

L.GeoJSON = L.FeatureGroup.extend({

	initialize: function (geojson, options) {
		L.setOptions(this, options);

		this._layers = {};

		if (geojson) {
			this.addData(geojson);
		}
	},

	addData: function (geojson) {
		var features = L.Util.isArray(geojson) ? geojson : geojson.features,
		    i, len, feature;

		if (features) {
			for (i = 0, len = features.length; i < len; i++) {
				// Only add this if geometry or geometries are set and not null
				feature = features[i];
				if (feature.geometries || feature.geometry || feature.features || feature.coordinates) {
					this.addData(feature);
				}
			}
			return this;
		}

		var options = this.options;

		if (options.filter && !options.filter(geojson)) { return; }

		var layer = L.GeoJSON.geometryToLayer(geojson, options);
		layer.feature = L.GeoJSON.asFeature(geojson);

		layer.defaultOptions = layer.options;
		this.resetStyle(layer);

		if (options.onEachFeature) {
			options.onEachFeature(geojson, layer);
		}

		return this.addLayer(layer);
	},

	resetStyle: function (layer) {
		// reset any custom styles
		layer.options = layer.defaultOptions;
		this._setLayerStyle(layer, this.options.style);
	},

	setStyle: function (style) {
		this.eachLayer(function (layer) {
			this._setLayerStyle(layer, style);
		}, this);
	},

	_setLayerStyle: function (layer, style) {
		if (typeof style === 'function') {
			style = style(layer.feature);
		}
		if (layer.setStyle) {
			layer.setStyle(style);
		}
	}
});

L.extend(L.GeoJSON, {
	geometryToLayer: function (geojson, options) {

		var geometry = geojson.type === 'Feature' ? geojson.geometry : geojson,
		    coords = geometry.coordinates,
		    layers = [],
		    pointToLayer = options && options.pointToLayer,
		    coordsToLatLng = options && options.coordsToLatLng || this.coordsToLatLng,
		    latlng, latlngs, i, len;

		switch (geometry.type) {
		case 'Point':
			latlng = coordsToLatLng(coords);
			return pointToLayer ? pointToLayer(geojson, latlng) : new L.Marker(latlng);

		case 'MultiPoint':
			for (i = 0, len = coords.length; i < len; i++) {
				latlng = coordsToLatLng(coords[i]);
				layers.push(pointToLayer ? pointToLayer(geojson, latlng) : new L.Marker(latlng));
			}
			return new L.FeatureGroup(layers);

		case 'LineString':
		case 'MultiLineString':
			latlngs = this.coordsToLatLngs(coords, geometry.type === 'LineString' ? 0 : 1, coordsToLatLng);
			return new L.Polyline(latlngs, options);

		case 'Polygon':
		case 'MultiPolygon':
			latlngs = this.coordsToLatLngs(coords, geometry.type === 'Polygon' ? 1 : 2, coordsToLatLng);
			return new L.Polygon(latlngs, options);

		case 'GeometryCollection':
			for (i = 0, len = geometry.geometries.length; i < len; i++) {

				layers.push(this.geometryToLayer({
					geometry: geometry.geometries[i],
					type: 'Feature',
					properties: geojson.properties
				}, options));
			}
			return new L.FeatureGroup(layers);

		default:
			throw new Error('Invalid GeoJSON object.');
		}
	},

	coordsToLatLng: function (coords) {
		return new L.LatLng(coords[1], coords[0], coords[2]);
	},

	coordsToLatLngs: function (coords, levelsDeep, coordsToLatLng) {
		var latlngs = [];

		for (var i = 0, len = coords.length, latlng; i < len; i++) {
			latlng = levelsDeep ?
			        this.coordsToLatLngs(coords[i], levelsDeep - 1, coordsToLatLng) :
			        (coordsToLatLng || this.coordsToLatLng)(coords[i]);

			latlngs.push(latlng);
		}

		return latlngs;
	},

	latLngToCoords: function (latlng) {
		return latlng.alt !== undefined ?
				[latlng.lng, latlng.lat, latlng.alt] :
				[latlng.lng, latlng.lat];
	},

	latLngsToCoords: function (latlngs, levelsDeep, closed) {
		var coords = [];

		for (var i = 0, len = latlngs.length; i < len; i++) {
			coords.push(levelsDeep ?
				L.GeoJSON.latLngsToCoords(latlngs[i], levelsDeep - 1, closed):
				L.GeoJSON.latLngToCoords(latlngs[i]));
		}

		if (!levelsDeep && closed) {
			coords.push(coords[0]);
		}

		return coords;
	},

	getFeature: function (layer, newGeometry) {
		return layer.feature ?
				L.extend({}, layer.feature, {geometry: newGeometry}) :
				L.GeoJSON.asFeature(newGeometry);
	},

	asFeature: function (geoJSON) {
		if (geoJSON.type === 'Feature') {
			return geoJSON;
		}

		return {
			type: 'Feature',
			properties: {},
			geometry: geoJSON
		};
	}
});

var PointToGeoJSON = {
	toGeoJSON: function () {
		return L.GeoJSON.getFeature(this, {
			type: 'Point',
			coordinates: L.GeoJSON.latLngToCoords(this.getLatLng())
		});
	}
};

L.Marker.include(PointToGeoJSON);
L.Circle.include(PointToGeoJSON);
L.CircleMarker.include(PointToGeoJSON);

L.Polyline.prototype.toGeoJSON = function () {
	var multi = !this._flat(this._latlngs);

	var coords = L.GeoJSON.latLngsToCoords(this._latlngs, multi ? 1 : 0);

	return L.GeoJSON.getFeature(this, {
		type: (multi ? 'Multi' : '') + 'LineString',
		coordinates: coords
	});
};

L.Polygon.prototype.toGeoJSON = function () {
	var holes = !this._flat(this._latlngs),
	    multi = holes && !this._flat(this._latlngs[0]);

	var coords = L.GeoJSON.latLngsToCoords(this._latlngs, multi ? 2 : holes ? 1 : 0, true);

	if (holes && this._latlngs.length === 1) {
		multi = true;
		coords = [coords];
	}
	if (!holes) {
		coords = [coords];
	}

	return L.GeoJSON.getFeature(this, {
		type: (multi ? 'Multi' : '') + 'Polygon',
		coordinates: coords
	});
};


L.LayerGroup.include({
	toMultiPoint: function () {
		var coords = [];

		this.eachLayer(function (layer) {
			coords.push(layer.toGeoJSON().geometry.coordinates);
		});

		return L.GeoJSON.getFeature(this, {
			type: 'MultiPoint',
			coordinates: coords
		});
	},

	toGeoJSON: function () {

		var type = this.feature && this.feature.geometry && this.feature.geometry.type;

		if (type === 'MultiPoint') {
			return this.toMultiPoint();
		}

		var isGeometryCollection = type === 'GeometryCollection',
			jsons = [];

		this.eachLayer(function (layer) {
			if (layer.toGeoJSON) {
				var json = layer.toGeoJSON();
				jsons.push(isGeometryCollection ? json.geometry : L.GeoJSON.asFeature(json));
			}
		});

		if (isGeometryCollection) {
			return L.GeoJSON.getFeature(this, {
				geometries: jsons,
				type: 'GeometryCollection'
			});
		}

		return {
			type: 'FeatureCollection',
			features: jsons
		};
	}
});

L.geoJson = function (geojson, options) {
	return new L.GeoJSON(geojson, options);
};

/*
 * L.DomEvent contains functions for working with DOM events.
 * Inspired by John Resig, Dean Edwards and YUI addEvent implementations.
 */

var eventsKey = '_leaflet_events';

L.DomEvent = {

	on: function (obj, types, fn, context) {

		if (typeof types === 'object') {
			for (var type in types) {
				this._on(obj, type, types[type], fn);
			}
		} else {
			types = L.Util.splitWords(types);

			for (var i = 0, len = types.length; i < len; i++) {
				this._on(obj, types[i], fn, context);
			}
		}

		return this;
	},

	off: function (obj, types, fn, context) {

		if (typeof types === 'object') {
			for (var type in types) {
				this._off(obj, type, types[type], fn);
			}
		} else {
			types = L.Util.splitWords(types);

			for (var i = 0, len = types.length; i < len; i++) {
				this._off(obj, types[i], fn, context);
			}
		}

		return this;
	},

	_on: function (obj, type, fn, context) {
		var id = type + L.stamp(fn) + (context ? '_' + L.stamp(context) : '');

		if (obj[eventsKey] && obj[eventsKey][id]) { return this; }

		var handler = function (e) {
			return fn.call(context || obj, e || window.event);
		};

		var originalHandler = handler;

		if (L.Browser.pointer && type.indexOf('touch') === 0) {
			return this.addPointerListener(obj, type, handler, id);
		}
		if (L.Browser.touch && (type === 'dblclick') && this.addDoubleTapListener) {
			this.addDoubleTapListener(obj, handler, id);
		}

		if ('addEventListener' in obj) {

			if (type === 'mousewheel') {
				obj.addEventListener('DOMMouseScroll', handler, false);
				obj.addEventListener(type, handler, false);

			} else if ((type === 'mouseenter') || (type === 'mouseleave')) {
				handler = function (e) {
					e = e || window.event;
					if (!L.DomEvent._checkMouse(obj, e)) { return; }
					return originalHandler(e);
				};
				obj.addEventListener(type === 'mouseenter' ? 'mouseover' : 'mouseout', handler, false);

			} else {
				if (type === 'click' && L.Browser.android) {
					handler = function (e) {
						return L.DomEvent._filterClick(e, originalHandler);
					};
				}
				obj.addEventListener(type, handler, false);
			}

		} else if ('attachEvent' in obj) {
			obj.attachEvent('on' + type, handler);
		}

		obj[eventsKey] = obj[eventsKey] || {};
		obj[eventsKey][id] = handler;

		return this;
	},

	_off: function (obj, type, fn, context) {

		var id = type + L.stamp(fn) + (context ? '_' + L.stamp(context) : ''),
		    handler = obj[eventsKey] && obj[eventsKey][id];

		if (!handler) { return this; }

		if (L.Browser.pointer && type.indexOf('touch') === 0) {
			this.removePointerListener(obj, type, id);

		} else if (L.Browser.touch && (type === 'dblclick') && this.removeDoubleTapListener) {
			this.removeDoubleTapListener(obj, id);

		} else if ('removeEventListener' in obj) {

			if (type === 'mousewheel') {
				obj.removeEventListener('DOMMouseScroll', handler, false);
				obj.removeEventListener(type, handler, false);

			} else {
				obj.removeEventListener(
					type === 'mouseenter' ? 'mouseover' :
					type === 'mouseleave' ? 'mouseout' : type, handler, false);
			}

		} else if ('detachEvent' in obj) {
			obj.detachEvent('on' + type, handler);
		}

		obj[eventsKey][id] = null;

		return this;
	},

	stopPropagation: function (e) {

		if (e.stopPropagation) {
			e.stopPropagation();
		} else {
			e.cancelBubble = true;
		}
		L.DomEvent._skipped(e);

		return this;
	},

	disableScrollPropagation: function (el) {
		return L.DomEvent.on(el, 'mousewheel MozMousePixelScroll', L.DomEvent.stopPropagation);
	},

	disableClickPropagation: function (el) {
		var stop = L.DomEvent.stopPropagation;

		L.DomEvent.on(el, L.Draggable.START.join(' '), stop);

		return L.DomEvent.on(el, {
			click: L.DomEvent._fakeStop,
			dblclick: stop
		});
	},

	preventDefault: function (e) {

		if (e.preventDefault) {
			e.preventDefault();
		} else {
			e.returnValue = false;
		}
		return this;
	},

	stop: function (e) {
		return L.DomEvent
			.preventDefault(e)
			.stopPropagation(e);
	},

	getMousePosition: function (e, container) {
		if (!container) {
			return new L.Point(e.clientX, e.clientY);
		}

		var rect = container.getBoundingClientRect();

		return new L.Point(
			e.clientX - rect.left - container.clientLeft,
			e.clientY - rect.top - container.clientTop);
	},

	getWheelDelta: function (e) {

		var delta = 0;

		if (e.wheelDelta) {
			delta = e.wheelDelta / 120;
		}
		if (e.detail) {
			delta = -e.detail / 3;
		}
		return delta;
	},

	_skipEvents: {},

	_fakeStop: function (e) {
		// fakes stopPropagation by setting a special event flag, checked/reset with L.DomEvent._skipped(e)
		L.DomEvent._skipEvents[e.type] = true;
	},

	_skipped: function (e) {
		var skipped = this._skipEvents[e.type];
		// reset when checking, as it's only used in map container and propagates outside of the map
		this._skipEvents[e.type] = false;
		return skipped;
	},

	// check if element really left/entered the event target (for mouseenter/mouseleave)
	_checkMouse: function (el, e) {

		var related = e.relatedTarget;

		if (!related) { return true; }

		try {
			while (related && (related !== el)) {
				related = related.parentNode;
			}
		} catch (err) {
			return false;
		}
		return (related !== el);
	},

	// this is a horrible workaround for a bug in Android where a single touch triggers two click events
	_filterClick: function (e, handler) {
		var timeStamp = (e.timeStamp || e.originalEvent.timeStamp),
			elapsed = L.DomEvent._lastClick && (timeStamp - L.DomEvent._lastClick);

		// are they closer together than 500ms yet more than 100ms?
		// Android typically triggers them ~300ms apart while multiple listeners
		// on the same event should be triggered far faster;
		// or check if click is simulated on the element, and if it is, reject any non-simulated events

		if ((elapsed && elapsed > 100 && elapsed < 500) || (e.target._simulatedClick && !e._simulated)) {
			L.DomEvent.stop(e);
			return;
		}
		L.DomEvent._lastClick = timeStamp;

		return handler(e);
	}
};

L.DomEvent.addListener = L.DomEvent.on;
L.DomEvent.removeListener = L.DomEvent.off;

/*
 * L.Draggable allows you to add dragging capabilities to any element. Supports mobile devices too.
 */

L.Draggable = L.Evented.extend({

	statics: {
		START: L.Browser.touch ? ['touchstart', 'mousedown'] : ['mousedown'],
		END: {
			mousedown: 'mouseup',
			touchstart: 'touchend',
			pointerdown: 'touchend',
			MSPointerDown: 'touchend'
		},
		MOVE: {
			mousedown: 'mousemove',
			touchstart: 'touchmove',
			pointerdown: 'touchmove',
			MSPointerDown: 'touchmove'
		}
	},

	initialize: function (element, dragStartTarget) {
		this._element = element;
		this._dragStartTarget = dragStartTarget || element;
	},

	enable: function () {
		if (this._enabled) { return; }

		L.DomEvent.on(this._dragStartTarget, L.Draggable.START.join(' '), this._onDown, this);

		this._enabled = true;
	},

	disable: function () {
		if (!this._enabled) { return; }

		L.DomEvent.off(this._dragStartTarget, L.Draggable.START.join(' '), this._onDown, this);

		this._enabled = false;
		this._moved = false;
	},

	_onDown: function (e) {
		this._moved = false;

		if (e.shiftKey || ((e.which !== 1) && (e.button !== 1) && !e.touches)) { return; }

		L.DomEvent.stopPropagation(e);

		if (L.Draggable._disabled) { return; }

		L.DomUtil.disableImageDrag();
		L.DomUtil.disableTextSelection();

		if (this._moving) { return; }

		this.fire('down');

		var first = e.touches ? e.touches[0] : e;

		this._startPoint = new L.Point(first.clientX, first.clientY);
		this._startPos = this._newPos = L.DomUtil.getPosition(this._element);

		L.DomEvent
		    .on(document, L.Draggable.MOVE[e.type], this._onMove, this)
		    .on(document, L.Draggable.END[e.type], this._onUp, this);
	},

	_onMove: function (e) {
		if (e.touches && e.touches.length > 1) {
			this._moved = true;
			return;
		}

		var first = (e.touches && e.touches.length === 1 ? e.touches[0] : e),
		    newPoint = new L.Point(first.clientX, first.clientY),
		    offset = newPoint.subtract(this._startPoint);

		if (!offset.x && !offset.y) { return; }
		if (L.Browser.touch && Math.abs(offset.x) + Math.abs(offset.y) < 3) { return; }

		L.DomEvent.preventDefault(e);

		if (!this._moved) {
			this.fire('dragstart');

			this._moved = true;
			this._startPos = L.DomUtil.getPosition(this._element).subtract(offset);

			L.DomUtil.addClass(document.body, 'leaflet-dragging');
			L.DomUtil.addClass(e.target || e.srcElement, 'leaflet-drag-target');
		}

		this._newPos = this._startPos.add(offset);
		this._moving = true;

		L.Util.cancelAnimFrame(this._animRequest);
		this._animRequest = L.Util.requestAnimFrame(this._updatePosition, this, true, this._dragStartTarget);
	},

	_updatePosition: function () {
		this.fire('predrag');
		L.DomUtil.setPosition(this._element, this._newPos);
		this.fire('drag');
	},

	_onUp: function (e) {
		L.DomUtil.removeClass(document.body, 'leaflet-dragging');
		L.DomUtil.removeClass(e.target || e.srcElement, 'leaflet-drag-target');

		for (var i in L.Draggable.MOVE) {
			L.DomEvent
			    .off(document, L.Draggable.MOVE[i], this._onMove, this)
			    .off(document, L.Draggable.END[i], this._onUp, this);
		}

		L.DomUtil.enableImageDrag();
		L.DomUtil.enableTextSelection();

		if (this._moved && this._moving) {
			// ensure drag is not fired after dragend
			L.Util.cancelAnimFrame(this._animRequest);

			this.fire('dragend', {
				distance: this._newPos.distanceTo(this._startPos)
			});
		}

		this._moving = false;
	}
});

/*
	L.Handler is a base class for handler classes that are used internally to inject
	interaction features like dragging to classes like Map and Marker.
*/

L.Handler = L.Class.extend({
	initialize: function (map) {
		this._map = map;
	},

	enable: function () {
		if (this._enabled) { return; }

		this._enabled = true;
		this.addHooks();
	},

	disable: function () {
		if (!this._enabled) { return; }

		this._enabled = false;
		this.removeHooks();
	},

	enabled: function () {
		return !!this._enabled;
	}
});

/*
 * L.Handler.MapDrag is used to make the map draggable (with panning inertia), enabled by default.
 */

L.Map.mergeOptions({
	dragging: true,

	inertia: !L.Browser.android23,
	inertiaDeceleration: 3400, // px/s^2
	inertiaMaxSpeed: Infinity, // px/s
	inertiaThreshold: L.Browser.touch ? 32 : 18, // ms
	easeLinearity: 0.25,

	// TODO refactor, move to CRS
	worldCopyJump: false
});

L.Map.Drag = L.Handler.extend({
	addHooks: function () {
		if (!this._draggable) {
			var map = this._map;

			this._draggable = new L.Draggable(map._mapPane, map._container);

			this._draggable.on({
				down: this._onDown,
				dragstart: this._onDragStart,
				drag: this._onDrag,
				dragend: this._onDragEnd
			}, this);

			if (map.options.worldCopyJump) {
				this._draggable.on('predrag', this._onPreDrag, this);
				map.on('viewreset', this._onViewReset, this);

				map.whenReady(this._onViewReset, this);
			}
		}
		this._draggable.enable();
	},

	removeHooks: function () {
		this._draggable.disable();
	},

	moved: function () {
		return this._draggable && this._draggable._moved;
	},

	_onDown: function () {
		if (this._map._panAnim) {
			this._map._panAnim.stop();
		}
	},

	_onDragStart: function () {
		var map = this._map;

		map
		    .fire('movestart')
		    .fire('dragstart');

		if (map.options.inertia) {
			this._positions = [];
			this._times = [];
		}
	},

	_onDrag: function () {
		if (this._map.options.inertia) {
			var time = this._lastTime = +new Date(),
			    pos = this._lastPos = this._draggable._newPos;

			this._positions.push(pos);
			this._times.push(time);

			if (time - this._times[0] > 200) {
				this._positions.shift();
				this._times.shift();
			}
		}

		this._map
		    .fire('move')
		    .fire('drag');
	},

	_onViewReset: function () {
		var pxCenter = this._map.getSize().divideBy(2),
		    pxWorldCenter = this._map.latLngToLayerPoint([0, 0]);

		this._initialWorldOffset = pxWorldCenter.subtract(pxCenter).x;
		this._worldWidth = this._map.getPixelWorldBounds().getSize().x;
	},

	_onPreDrag: function () {
		// TODO refactor to be able to adjust map pane position after zoom
		var worldWidth = this._worldWidth,
		    halfWidth = Math.round(worldWidth / 2),
		    dx = this._initialWorldOffset,
		    x = this._draggable._newPos.x,
		    newX1 = (x - halfWidth + dx) % worldWidth + halfWidth - dx,
		    newX2 = (x + halfWidth + dx) % worldWidth - halfWidth - dx,
		    newX = Math.abs(newX1 + dx) < Math.abs(newX2 + dx) ? newX1 : newX2;

		this._draggable._newPos.x = newX;
	},

	_onDragEnd: function (e) {
		var map = this._map,
		    options = map.options,
		    delay = +new Date() - this._lastTime,

		    noInertia = !options.inertia || delay > options.inertiaThreshold || !this._positions[0];

		map.fire('dragend', e);

		if (noInertia) {
			map.fire('moveend');

		} else {

			var direction = this._lastPos.subtract(this._positions[0]),
			    duration = (this._lastTime + delay - this._times[0]) / 1000,
			    ease = options.easeLinearity,

			    speedVector = direction.multiplyBy(ease / duration),
			    speed = speedVector.distanceTo([0, 0]),

			    limitedSpeed = Math.min(options.inertiaMaxSpeed, speed),
			    limitedSpeedVector = speedVector.multiplyBy(limitedSpeed / speed),

			    decelerationDuration = limitedSpeed / (options.inertiaDeceleration * ease),
			    offset = limitedSpeedVector.multiplyBy(-decelerationDuration / 2).round();

			if (!offset.x || !offset.y) {
				map.fire('moveend');

			} else {
				offset = map._limitOffset(offset, map.options.maxBounds);

				L.Util.requestAnimFrame(function () {
					map.panBy(offset, {
						duration: decelerationDuration,
						easeLinearity: ease,
						noMoveStart: true
					});
				});
			}
		}
	}
});

L.Map.addInitHook('addHandler', 'dragging', L.Map.Drag);

/*
 * L.Handler.DoubleClickZoom is used to handle double-click zoom on the map, enabled by default.
 */

L.Map.mergeOptions({
	doubleClickZoom: true
});

L.Map.DoubleClickZoom = L.Handler.extend({
	addHooks: function () {
		this._map.on('dblclick', this._onDoubleClick, this);
	},

	removeHooks: function () {
		this._map.off('dblclick', this._onDoubleClick, this);
	},

	_onDoubleClick: function (e) {
		var map = this._map,
		    zoom = map.getZoom() + (e.originalEvent.shiftKey ? -1 : 1);

		if (map.options.doubleClickZoom === 'center') {
			map.setZoom(zoom);
		} else {
			map.setZoomAround(e.containerPoint, zoom);
		}
	}
});

L.Map.addInitHook('addHandler', 'doubleClickZoom', L.Map.DoubleClickZoom);

/*
 * L.Handler.ScrollWheelZoom is used by L.Map to enable mouse scroll wheel zoom on the map.
 */

L.Map.mergeOptions({
	scrollWheelZoom: true
});

L.Map.ScrollWheelZoom = L.Handler.extend({
	addHooks: function () {
		L.DomEvent.on(this._map._container, {
			mousewheel: this._onWheelScroll,
			MozMousePixelScroll: L.DomEvent.preventDefault
		}, this);

		this._delta = 0;
	},

	removeHooks: function () {
		L.DomEvent.off(this._map._container, {
			mousewheel: this._onWheelScroll,
			MozMousePixelScroll: L.DomEvent.preventDefault
		}, this);
	},

	_onWheelScroll: function (e) {
		var delta = L.DomEvent.getWheelDelta(e);

		this._delta += delta;
		this._lastMousePos = this._map.mouseEventToContainerPoint(e);

		if (!this._startTime) {
			this._startTime = +new Date();
		}

		var left = Math.max(40 - (+new Date() - this._startTime), 0);

		clearTimeout(this._timer);
		this._timer = setTimeout(L.bind(this._performZoom, this), left);

		L.DomEvent.stop(e);
	},

	_performZoom: function () {
		var map = this._map,
		    delta = this._delta,
		    zoom = map.getZoom();

		delta = delta > 0 ? Math.ceil(delta) : Math.floor(delta);
		delta = Math.max(Math.min(delta, 4), -4);
		delta = map._limitZoom(zoom + delta) - zoom;

		this._delta = 0;
		this._startTime = null;

		if (!delta) { return; }

		if (map.options.scrollWheelZoom === 'center') {
			map.setZoom(zoom + delta);
		} else {
			map.setZoomAround(this._lastMousePos, zoom + delta);
		}
	}
});

L.Map.addInitHook('addHandler', 'scrollWheelZoom', L.Map.ScrollWheelZoom);

/*
 * L.PosAnimation is used by Leaflet internally for pan animations.
 */

L.PosAnimation = L.Evented.extend({

	run: function (el, newPos, duration, easeLinearity) { // (HTMLElement, Point[, Number, Number])
		this.stop();

		this._el = el;
		this._inProgress = true;
		this._newPos = newPos;

		this.fire('start');

		el.style[L.DomUtil.TRANSITION] = 'all ' + (duration || 0.25) +
		        's cubic-bezier(0,0,' + (easeLinearity || 0.5) + ',1)';

		L.DomEvent.on(el, L.DomUtil.TRANSITION_END, this._onTransitionEnd, this);
		L.DomUtil.setPosition(el, newPos);

		// toggle reflow, Chrome flickers for some reason if you don't do this
		L.Util.falseFn(el.offsetWidth);

		// there's no native way to track value updates of transitioned properties, so we imitate this
		this._stepTimer = setInterval(L.bind(this._onStep, this), 50);
	},

	stop: function () {
		if (!this._inProgress) { return; }

		// if we just removed the transition property, the element would jump to its final position,
		// so we need to make it stay at the current position

		this._newPos = this._getPos();
		L.DomUtil.setPosition(this._el, this._newPos);

		this._onTransitionEnd();
		L.Util.falseFn(this._el.offsetWidth); // force reflow in case we are about to start a new animation
	},

	_onStep: function () {
		var stepPos = this._getPos();
		if (!stepPos) {
			this._onTransitionEnd();
			return;
		}
		// jshint camelcase: false
		// make L.DomUtil.getPosition return intermediate position value during animation
		this._el._leaflet_pos = stepPos;

		this.fire('step');
	},

	// you can't easily get intermediate values of properties animated with CSS3 Transitions,
	// we need to parse computed style (in case of transform it returns matrix string)

	_transformRe: /([-+]?(?:\d*\.)?\d+)\D*, ([-+]?(?:\d*\.)?\d+)\D*\)/,

	_getPos: function () {
		var left, top, matches,
		    el = this._el,
		    style = window.getComputedStyle(el);

		if (L.Browser.any3d) {
			matches = style[L.DomUtil.TRANSFORM].match(this._transformRe);
			if (!matches) { return; }
			left = parseFloat(matches[1]);
			top  = parseFloat(matches[2]);
		} else {
			left = parseFloat(style.left);
			top  = parseFloat(style.top);
		}

		return new L.Point(left, top, true);
	},

	_onTransitionEnd: function () {
		L.DomEvent.off(this._el, L.DomUtil.TRANSITION_END, this._onTransitionEnd, this);

		if (!this._inProgress) { return; }
		this._inProgress = false;

		this._el.style[L.DomUtil.TRANSITION] = '';

		// jshint camelcase: false
		// make sure L.DomUtil.getPosition returns the final position value after animation
		this._el._leaflet_pos = this._newPos;

		clearInterval(this._stepTimer);

		this.fire('step').fire('end');
	}

});

/*
 * Extends L.Map to handle panning animations.
 */

L.Map.include({

	setView: function (center, zoom, options) {

		zoom = zoom === undefined ? this._zoom : this._limitZoom(zoom);
		center = this._limitCenter(L.latLng(center), zoom, this.options.maxBounds);
		options = options || {};

		if (this._panAnim) {
			this._panAnim.stop();
		}

		if (this._loaded && !options.reset && options !== true) {

			if (options.animate !== undefined) {
				options.zoom = L.extend({animate: options.animate}, options.zoom);
				options.pan = L.extend({animate: options.animate}, options.pan);
			}

			// try animating pan or zoom
			var animated = (this._zoom !== zoom) ?
				this._tryAnimatedZoom && this._tryAnimatedZoom(center, zoom, options.zoom) :
				this._tryAnimatedPan(center, options.pan);

			if (animated) {
				// prevent resize handler call, the view will refresh after animation anyway
				clearTimeout(this._sizeTimer);
				return this;
			}
		}

		// animation didn't start, just reset the map view
		this._resetView(center, zoom);

		return this;
	},

	panBy: function (offset, options) {
		offset = L.point(offset).round();
		options = options || {};

		if (!offset.x && !offset.y) {
			return this;
		}

		if (!this._panAnim) {
			this._panAnim = new L.PosAnimation();

			this._panAnim.on({
				'step': this._onPanTransitionStep,
				'end': this._onPanTransitionEnd
			}, this);
		}

		// don't fire movestart if animating inertia
		if (!options.noMoveStart) {
			this.fire('movestart');
		}

		// animate pan unless animate: false specified
		if (options.animate !== false) {
			L.DomUtil.addClass(this._mapPane, 'leaflet-pan-anim');

			var newPos = this._getMapPanePos().subtract(offset);
			this._panAnim.run(this._mapPane, newPos, options.duration || 0.25, options.easeLinearity);
		} else {
			this._rawPanBy(offset);
			this.fire('move').fire('moveend');
		}

		return this;
	},

	_onPanTransitionStep: function () {
		this.fire('move');
	},

	_onPanTransitionEnd: function () {
		L.DomUtil.removeClass(this._mapPane, 'leaflet-pan-anim');
		this.fire('moveend');
	},

	_tryAnimatedPan: function (center, options) {
		// difference between the new and current centers in pixels
		var offset = this._getCenterOffset(center)._floor();

		// don't animate too far unless animate: true specified in options
		if ((options && options.animate) !== true && !this.getSize().contains(offset)) { return false; }

		this.panBy(offset, options);

		return true;
	}
});

/*
 * Extends L.Map to handle zoom animations.
 */

L.Map.mergeOptions({
	zoomAnimation: true,
	zoomAnimationThreshold: 4
});

var zoomAnimated = L.DomUtil.TRANSITION && L.Browser.any3d && !L.Browser.mobileOpera;

if (zoomAnimated) {

	L.Map.addInitHook(function () {
		// don't animate on browsers without hardware-accelerated transitions or old Android/Opera
		this._zoomAnimated = this.options.zoomAnimation;

		// zoom transitions run with the same duration for all layers, so if one of transitionend events
		// happens after starting zoom animation (propagating to the map pane), we know that it ended globally
		if (this._zoomAnimated) {
			L.DomEvent.on(this._mapPane, L.DomUtil.TRANSITION_END, this._catchTransitionEnd, this);
		}
	});
}

L.Map.include(!zoomAnimated ? {} : {

	_catchTransitionEnd: function (e) {
		if (this._animatingZoom && e.propertyName.indexOf('transform') >= 0) {
			this._onZoomTransitionEnd();
		}
	},

	_nothingToAnimate: function () {
		return !this._container.getElementsByClassName('leaflet-zoom-animated').length;
	},

	_tryAnimatedZoom: function (center, zoom, options) {

		if (this._animatingZoom) { return true; }

		options = options || {};

		// don't animate if disabled, not supported or zoom difference is too large
		if (!this._zoomAnimated || options.animate === false || this._nothingToAnimate() ||
		        Math.abs(zoom - this._zoom) > this.options.zoomAnimationThreshold) { return false; }

		// offset is the pixel coords of the zoom origin relative to the current center
		var scale = this.getZoomScale(zoom),
		    offset = this._getCenterOffset(center)._divideBy(1 - 1 / scale);

		// don't animate if the zoom origin isn't within one screen from the current center, unless forced
		if (options.animate !== true && !this.getSize().contains(offset)) { return false; }

		L.Util.requestAnimFrame(function () {
			this
			    .fire('movestart')
			    .fire('zoomstart')
			    ._animateZoom(center, zoom, true);
		}, this);

		return true;
	},

	_animateZoom: function (center, zoom, startAnim) {
		if (startAnim) {
			this._animatingZoom = true;

			// remember what center/zoom to set after animation
			this._animateToCenter = center;
			this._animateToZoom = zoom;

			// disable any dragging during animation
			if (L.Draggable) {
				L.Draggable._disabled = true;
			}

			L.DomUtil.addClass(this._mapPane, 'leaflet-zoom-anim');
		}

		var scale = this.getZoomScale(zoom),
			origin = this._getCenterLayerPoint().add(this._getCenterOffset(center)._divideBy(1 - 1 / scale));

		this.fire('zoomanim', {
			center: center,
			zoom: zoom,
			origin: origin,
			scale: scale
		});
	},

	_onZoomTransitionEnd: function () {

		this._animatingZoom = false;

		L.DomUtil.removeClass(this._mapPane, 'leaflet-zoom-anim');

		this._resetView(this._animateToCenter, this._animateToZoom, true, true);

		if (L.Draggable) {
			L.Draggable._disabled = false;
		}
	}
});

/*
 * Extends the event handling code with double tap support for mobile browsers.
 */

L.extend(L.DomEvent, {

	_touchstart: L.Browser.msPointer ? 'MSPointerDown' : L.Browser.pointer ? 'pointerdown' : 'touchstart',
	_touchend: L.Browser.msPointer ? 'MSPointerUp' : L.Browser.pointer ? 'pointerup' : 'touchend',

	// inspired by Zepto touch code by Thomas Fuchs
	addDoubleTapListener: function (obj, handler, id) {
		var last, touch,
		    doubleTap = false,
		    delay = 250,
		    trackedTouches = [];

		function onTouchStart(e) {
			var count;

			if (L.Browser.pointer) {
				trackedTouches.push(e.pointerId);
				count = trackedTouches.length;
			} else {
				count = e.touches.length;
			}

			if (count > 1) { return; }

			var now = Date.now(),
			    delta = now - (last || now);

			touch = e.touches ? e.touches[0] : e;
			doubleTap = (delta > 0 && delta <= delay);
			last = now;
		}

		function onTouchEnd(e) {
			if (L.Browser.pointer) {
				var idx = trackedTouches.indexOf(e.pointerId);
				if (idx === -1) { return; }
				trackedTouches.splice(idx, 1);
			}

			if (doubleTap) {
				if (L.Browser.pointer) {
					// work around .type being readonly with MSPointer* events
					var newTouch = {},
						prop, i;

					for (i in touch) {
						prop = touch[i];
						newTouch[i] = prop && prop.bind ? prop.bind(touch) : prop;
					}
					touch = newTouch;
				}
				touch.type = 'dblclick';
				handler(touch);
				last = null;
			}
		}

		var pre = '_leaflet_',
		    touchstart = this._touchstart,
		    touchend = this._touchend;

		obj[pre + touchstart + id] = onTouchStart;
		obj[pre + touchend + id] = onTouchEnd;

		// on pointer we need to listen on the document, otherwise a drag starting on the map and moving off screen
		// will not come through to us, so we will lose track of how many touches are ongoing
		var endElement = L.Browser.pointer ? document.documentElement : obj;

		obj.addEventListener(touchstart, onTouchStart, false);

		endElement.addEventListener(touchend, onTouchEnd, false);
		if (L.Browser.pointer) {
			endElement.addEventListener(L.DomEvent.POINTER_CANCEL, onTouchEnd, false);
		}

		return this;
	},

	removeDoubleTapListener: function (obj, id) {
		var pre = '_leaflet_',
		    endElement = L.Browser.pointer ? document.documentElement : obj,
		    touchend = obj[pre + this._touchend + id];

		obj.removeEventListener(this._touchstart, obj[pre + this._touchstart + id], false);

		endElement.removeEventListener(this._touchend, touchend, false);
		if (L.Browser.pointer) {
			endElement.removeEventListener(L.DomEvent.POINTER_CANCEL, touchend, false);
		}

		return this;
	}
});

/*
 * Extends L.DomEvent to provide touch support for Internet Explorer and Windows-based devices.
 */

L.extend(L.DomEvent, {

	POINTER_DOWN:   L.Browser.msPointer ? 'MSPointerDown'   : 'pointerdown',
	POINTER_MOVE:   L.Browser.msPointer ? 'MSPointerMove'   : 'pointermove',
	POINTER_UP:     L.Browser.msPointer ? 'MSPointerUp'     : 'pointerup',
	POINTER_CANCEL: L.Browser.msPointer ? 'MSPointerCancel' : 'pointercancel',

	_pointers: {},

	// Provides a touch events wrapper for (ms)pointer events.
	// ref http://www.w3.org/TR/pointerevents/ https://www.w3.org/Bugs/Public/show_bug.cgi?id=22890

	addPointerListener: function (obj, type, handler, id) {

		if (type === 'touchstart') {
			this._addPointerStart(obj, handler, id);

		} else if (type === 'touchmove') {
			this._addPointerMove(obj, handler, id);

		} else if (type === 'touchend') {
			this._addPointerEnd(obj, handler, id);
		}

		return this;
	},

	removePointerListener: function (obj, type, id) {
		var handler = obj['_leaflet_' + type + id];

		if (type === 'touchstart') {
			obj.removeEventListener(this.POINTER_DOWN, handler, false);

		} else if (type === 'touchmove') {
			obj.removeEventListener(this.POINTER_MOVE, handler, false);

		} else if (type === 'touchend') {
			obj.removeEventListener(this.POINTER_UP, handler, false);
			obj.removeEventListener(this.POINTER_CANCEL, handler, false);
		}

		return this;
	},

	_addPointerStart: function (obj, handler, id) {
		var onDown = L.bind(function (e) {
			L.DomEvent.preventDefault(e);

			this._pointers[e.pointerId] = e;
			this._handlePointer(e, handler);
		}, this);

		obj['_leaflet_touchstart' + id] = onDown;
		obj.addEventListener(this.POINTER_DOWN, onDown, false);

		// need to also listen for end events to keep the _pointers object accurate
		if (!this._pointerDocListener) {
			var removePointer = L.bind(function (e) {
				delete this._pointers[e.pointerId];
			}, this);

			// we listen documentElement as any drags that end by moving the touch off the screen get fired there
			document.documentElement.addEventListener(this.POINTER_UP, removePointer, false);
			document.documentElement.addEventListener(this.POINTER_CANCEL, removePointer, false);

			this._pointerDocListener = true;
		}
	},

	_handlePointer: function (e, handler) {
		e.touches = [];
		for (var i in this._pointers) {
			e.touches.push(this._pointers[i]);
		}
		e.changedTouches = [e];

		handler(e);
	},

	_addPointerMove: function (obj, handler, id) {
		var onMove = L.bind(function (e) {
			// don't fire touch moves when mouse isn't down
			if ((e.pointerType === e.MSPOINTER_TYPE_MOUSE || e.pointerType === 'mouse') && e.buttons === 0) { return; }

			this._pointers[e.pointerId] = e;
			this._handlePointer(e, handler);
		}, this);

		obj['_leaflet_touchmove' + id] = onMove;
		obj.addEventListener(this.POINTER_MOVE, onMove, false);
	},

	_addPointerEnd: function (obj, handler, id) {
		var onUp = L.bind(function (e) {
			delete this._pointers[e.pointerId];
			this._handlePointer(e, handler);
		}, this);

		obj['_leaflet_touchend' + id] = onUp;
		obj.addEventListener(this.POINTER_UP, onUp, false);
		obj.addEventListener(this.POINTER_CANCEL, onUp, false);
	}
});

/*
 * L.Handler.TouchZoom is used by L.Map to add pinch zoom on supported mobile browsers.
 */

L.Map.mergeOptions({
	touchZoom: L.Browser.touch && !L.Browser.android23,
	bounceAtZoomLimits: true
});

L.Map.TouchZoom = L.Handler.extend({
	addHooks: function () {
		L.DomEvent.on(this._map._container, 'touchstart', this._onTouchStart, this);
	},

	removeHooks: function () {
		L.DomEvent.off(this._map._container, 'touchstart', this._onTouchStart, this);
	},

	_onTouchStart: function (e) {
		var map = this._map;

		if (!e.touches || e.touches.length !== 2 || map._animatingZoom || this._zooming) { return; }

		var p1 = map.mouseEventToLayerPoint(e.touches[0]),
		    p2 = map.mouseEventToLayerPoint(e.touches[1]),
		    viewCenter = map._getCenterLayerPoint();

		this._startCenter = p1.add(p2)._divideBy(2);
		this._startDist = p1.distanceTo(p2);

		this._moved = false;
		this._zooming = true;

		this._centerOffset = viewCenter.subtract(this._startCenter);

		if (map._panAnim) {
			map._panAnim.stop();
		}

		L.DomEvent
		    .on(document, 'touchmove', this._onTouchMove, this)
		    .on(document, 'touchend', this._onTouchEnd, this);

		L.DomEvent.preventDefault(e);
	},

	_onTouchMove: function (e) {
		if (!e.touches || e.touches.length !== 2 || !this._zooming) { return; }

		var map = this._map,
		    p1 = map.mouseEventToLayerPoint(e.touches[0]),
		    p2 = map.mouseEventToLayerPoint(e.touches[1]);

		this._scale = p1.distanceTo(p2) / this._startDist;
		this._delta = p1._add(p2)._divideBy(2)._subtract(this._startCenter);

		if (!map.options.bounceAtZoomLimits &&
		    ((map.getZoom() === map.getMinZoom() && this._scale < 1) ||
		     (map.getZoom() === map.getMaxZoom() && this._scale > 1))) { return; }

		if (!this._moved) {
			map
			    .fire('movestart')
			    .fire('zoomstart');

			this._moved = true;
		}

		L.Util.cancelAnimFrame(this._animRequest);
		this._animRequest = L.Util.requestAnimFrame(this._updateOnMove, this, true, this._map._container);

		L.DomEvent.preventDefault(e);
	},

	_updateOnMove: function () {
		var map = this._map;

		if (map.options.touchZoom === 'center') {
			this._center = map.getCenter();
		} else {
			this._center = map.layerPointToLatLng(this._getTargetCenter());
		}
		this._zoom = map.getScaleZoom(this._scale);

		map._animateZoom(this._center, this._zoom);
	},

	_onTouchEnd: function () {
		if (!this._moved || !this._zooming) {
			this._zooming = false;
			return;
		}

		this._zooming = false;
		L.Util.cancelAnimFrame(this._animRequest);

		L.DomEvent
		    .off(document, 'touchmove', this._onTouchMove)
		    .off(document, 'touchend', this._onTouchEnd);

		var map = this._map,
		    oldZoom = map.getZoom(),
		    zoomDelta = this._zoom - oldZoom,
		    finalZoom = map._limitZoom(oldZoom + (zoomDelta > 0 ? Math.ceil(zoomDelta) : Math.floor(zoomDelta)));

		map._animateZoom(this._center, finalZoom, true);
	},

	_getTargetCenter: function () {
		var centerOffset = this._centerOffset.subtract(this._delta).divideBy(this._scale);
		return this._startCenter.add(centerOffset);
	}
});

L.Map.addInitHook('addHandler', 'touchZoom', L.Map.TouchZoom);

/*
 * L.Map.Tap is used to enable mobile hacks like quick taps and long hold.
 */

L.Map.mergeOptions({
	tap: true,
	tapTolerance: 15
});

L.Map.Tap = L.Handler.extend({
	addHooks: function () {
		L.DomEvent.on(this._map._container, 'touchstart', this._onDown, this);
	},

	removeHooks: function () {
		L.DomEvent.off(this._map._container, 'touchstart', this._onDown, this);
	},

	_onDown: function (e) {
		if (!e.touches) { return; }

		L.DomEvent.preventDefault(e);

		this._fireClick = true;

		// don't simulate click or track longpress if more than 1 touch
		if (e.touches.length > 1) {
			this._fireClick = false;
			clearTimeout(this._holdTimeout);
			return;
		}

		var first = e.touches[0],
		    el = first.target;

		this._startPos = this._newPos = new L.Point(first.clientX, first.clientY);

		// if touching a link, highlight it
		if (el.tagName && el.tagName.toLowerCase() === 'a') {
			L.DomUtil.addClass(el, 'leaflet-active');
		}

		// simulate long hold but setting a timeout
		this._holdTimeout = setTimeout(L.bind(function () {
			if (this._isTapValid()) {
				this._fireClick = false;
				this._onUp();
				this._simulateEvent('contextmenu', first);
			}
		}, this), 1000);
		
		this._simulateEvent('mousedown', first);

		L.DomEvent.on(document, {
			touchmove: this._onMove,
			touchend: this._onUp
		}, this);
	},

	_onUp: function (e) {
		clearTimeout(this._holdTimeout);

		L.DomEvent.off(document, {
			touchmove: this._onMove,
			touchend: this._onUp
		}, this);

		if (this._fireClick && e && e.changedTouches) {

			var first = e.changedTouches[0],
			    el = first.target;

			if (el && el.tagName && el.tagName.toLowerCase() === 'a') {
				L.DomUtil.removeClass(el, 'leaflet-active');
			}
			
			this._simulateEvent('mouseup', first);

			// simulate click if the touch didn't move too much
			if (this._isTapValid()) {
				this._simulateEvent('click', first);
			}
		}
	},

	_isTapValid: function () {
		return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;
	},

	_onMove: function (e) {
		var first = e.touches[0];
		this._newPos = new L.Point(first.clientX, first.clientY);
	},

	_simulateEvent: function (type, e) {
		var simulatedEvent = document.createEvent('MouseEvents');

		simulatedEvent._simulated = true;
		e.target._simulatedClick = true;

		simulatedEvent.initMouseEvent(
		        type, true, true, window, 1,
		        e.screenX, e.screenY,
		        e.clientX, e.clientY,
		        false, false, false, false, 0, null);

		e.target.dispatchEvent(simulatedEvent);
	}
});

if (L.Browser.touch && !L.Browser.pointer) {
	L.Map.addInitHook('addHandler', 'tap', L.Map.Tap);
}

/*
 * L.Handler.ShiftDragZoom is used to add shift-drag zoom interaction to the map
  * (zoom to a selected bounding box), enabled by default.
 */

L.Map.mergeOptions({
	boxZoom: true
});

L.Map.BoxZoom = L.Handler.extend({
	initialize: function (map) {
		this._map = map;
		this._container = map._container;
		this._pane = map._panes.overlayPane;
	},

	addHooks: function () {
		L.DomEvent.on(this._container, 'mousedown', this._onMouseDown, this);
	},

	removeHooks: function () {
		L.DomEvent.off(this._container, 'mousedown', this._onMouseDown, this);
	},

	moved: function () {
		return this._moved;
	},

	_onMouseDown: function (e) {
		this._moved = false;

		if (!e.shiftKey || ((e.which !== 1) && (e.button !== 1))) { return false; }

		L.DomUtil.disableTextSelection();
		L.DomUtil.disableImageDrag();

		this._startPoint = this._map.mouseEventToContainerPoint(e);

		L.DomEvent.on(document, {
			mousemove: this._onMouseMove,
		    mouseup: this._onMouseUp,
		    keydown: this._onKeyDown
		}, this);
	},

	_onMouseMove: function (e) {
		if (!this._moved) {
			this._moved = true;

			this._box = L.DomUtil.create('div', 'leaflet-zoom-box', this._container);
			L.DomUtil.addClass(this._container, 'leaflet-crosshair');

			this._map.fire('boxzoomstart');
		}

		this._point = this._map.mouseEventToContainerPoint(e);

		var bounds = new L.Bounds(this._point, this._startPoint),
		    size = bounds.getSize();

		L.DomUtil.setPosition(this._box, bounds.min);

		this._box.style.width  = size.x + 'px';
		this._box.style.height = size.y + 'px';
	},

	_finish: function () {
		if (this._moved) {
			L.DomUtil.remove(this._box);
			L.DomUtil.removeClass(this._container, 'leaflet-crosshair');
		}

		L.DomUtil.enableTextSelection();
		L.DomUtil.enableImageDrag();

		L.DomEvent.off(document, {
			mousemove: this._onMouseMove,
		    mouseup: this._onMouseUp,
		    keydown: this._onKeyDown
		}, this);
	},

	_onMouseUp: function () {

		this._finish();

		if (!this._moved) { return; }

		var bounds = new L.LatLngBounds(
		        this._map.containerPointToLatLng(this._startPoint),
		        this._map.containerPointToLatLng(this._point));

		this._map
			.fitBounds(bounds)
			.fire('boxzoomend', {boxZoomBounds: bounds});
	},

	_onKeyDown: function (e) {
		if (e.keyCode === 27) {
			this._finish();
		}
	}
});

L.Map.addInitHook('addHandler', 'boxZoom', L.Map.BoxZoom);

/*
 * L.Map.Keyboard is handling keyboard interaction with the map, enabled by default.
 */

L.Map.mergeOptions({
	keyboard: true,
	keyboardPanOffset: 80,
	keyboardZoomOffset: 1
});

L.Map.Keyboard = L.Handler.extend({

	keyCodes: {
		left:    [37],
		right:   [39],
		down:    [40],
		up:      [38],
		zoomIn:  [187, 107, 61, 171],
		zoomOut: [189, 109, 173]
	},

	initialize: function (map) {
		this._map = map;

		this._setPanOffset(map.options.keyboardPanOffset);
		this._setZoomOffset(map.options.keyboardZoomOffset);
	},

	addHooks: function () {
		var container = this._map._container;

		// make the container focusable by tabbing
		if (container.tabIndex === -1) {
			container.tabIndex = '0';
		}

		L.DomEvent.on(container, {
		    focus: this._onFocus,
		    blur: this._onBlur,
		    mousedown: this._onMouseDown
		}, this);

		this._map.on({
			focus: this._addHooks,
		    blur: this._removeHooks
		}, this);
	},

	removeHooks: function () {
		this._removeHooks();

		L.DomEvent.off(this._map._container, {
		    focus: this._onFocus,
		    blur: this._onBlur,
		    mousedown: this._onMouseDown
		}, this);

		this._map.off({
			focus: this._addHooks,
		    blur: this._removeHooks
		}, this);
	},

	_onMouseDown: function () {
		if (this._focused) { return; }

		var body = document.body,
		    docEl = document.documentElement,
		    top = body.scrollTop || docEl.scrollTop,
		    left = body.scrollLeft || docEl.scrollLeft;

		this._map._container.focus();

		window.scrollTo(left, top);
	},

	_onFocus: function () {
		this._focused = true;
		this._map.fire('focus');
	},

	_onBlur: function () {
		this._focused = false;
		this._map.fire('blur');
	},

	_setPanOffset: function (pan) {
		var keys = this._panKeys = {},
		    codes = this.keyCodes,
		    i, len;

		for (i = 0, len = codes.left.length; i < len; i++) {
			keys[codes.left[i]] = [-1 * pan, 0];
		}
		for (i = 0, len = codes.right.length; i < len; i++) {
			keys[codes.right[i]] = [pan, 0];
		}
		for (i = 0, len = codes.down.length; i < len; i++) {
			keys[codes.down[i]] = [0, pan];
		}
		for (i = 0, len = codes.up.length; i < len; i++) {
			keys[codes.up[i]] = [0, -1 * pan];
		}
	},

	_setZoomOffset: function (zoom) {
		var keys = this._zoomKeys = {},
		    codes = this.keyCodes,
		    i, len;

		for (i = 0, len = codes.zoomIn.length; i < len; i++) {
			keys[codes.zoomIn[i]] = zoom;
		}
		for (i = 0, len = codes.zoomOut.length; i < len; i++) {
			keys[codes.zoomOut[i]] = -zoom;
		}
	},

	_addHooks: function () {
		L.DomEvent.on(document, 'keydown', this._onKeyDown, this);
	},

	_removeHooks: function () {
		L.DomEvent.off(document, 'keydown', this._onKeyDown, this);
	},

	_onKeyDown: function (e) {
		if (e.altKey || e.ctrlKey || e.metaKey) { return; }

		var key = e.keyCode,
		    map = this._map;

		if (key in this._panKeys) {

			if (map._panAnim && map._panAnim._inProgress) { return; }

			map.panBy(this._panKeys[key]);

			if (map.options.maxBounds) {
				map.panInsideBounds(map.options.maxBounds);
			}

		} else if (key in this._zoomKeys) {
			map.setZoom(map.getZoom() + this._zoomKeys[key]);

		} else {
			return;
		}

		L.DomEvent.stop(e);
	}
});

L.Map.addInitHook('addHandler', 'keyboard', L.Map.Keyboard);

/*
 * L.Handler.MarkerDrag is used internally by L.Marker to make the markers draggable.
 */

L.Handler.MarkerDrag = L.Handler.extend({
	initialize: function (marker) {
		this._marker = marker;
	},

	addHooks: function () {
		var icon = this._marker._icon;

		if (!this._draggable) {
			this._draggable = new L.Draggable(icon, icon);
		}

		this._draggable.on({
			dragstart: this._onDragStart,
			drag: this._onDrag,
			dragend: this._onDragEnd
		}, this).enable();

		L.DomUtil.addClass(icon, 'leaflet-marker-draggable');
	},

	removeHooks: function () {
		this._draggable.off({
			dragstart: this._onDragStart,
			drag: this._onDrag,
			dragend: this._onDragEnd
		}, this).disable();

		L.DomUtil.removeClass(this._marker._icon, 'leaflet-marker-draggable');
	},

	moved: function () {
		return this._draggable && this._draggable._moved;
	},

	_onDragStart: function () {
		this._marker
		    .closePopup()
		    .fire('movestart')
		    .fire('dragstart');
	},

	_onDrag: function () {
		var marker = this._marker,
		    shadow = marker._shadow,
		    iconPos = L.DomUtil.getPosition(marker._icon),
		    latlng = marker._map.layerPointToLatLng(iconPos);

		// update shadow position
		if (shadow) {
			L.DomUtil.setPosition(shadow, iconPos);
		}

		marker._latlng = latlng;

		marker
		    .fire('move', {latlng: latlng})
		    .fire('drag');
	},

	_onDragEnd: function (e) {
		this._marker
		    .fire('moveend')
		    .fire('dragend', e);
	}
});

/*
 * L.Control is a base class for implementing map controls. Handles positioning.
 * All other controls extend from this class.
 */

L.Control = L.Class.extend({
	options: {
		position: 'topright'
	},

	initialize: function (options) {
		L.setOptions(this, options);
	},

	getPosition: function () {
		return this.options.position;
	},

	setPosition: function (position) {
		var map = this._map;

		if (map) {
			map.removeControl(this);
		}

		this.options.position = position;

		if (map) {
			map.addControl(this);
		}

		return this;
	},

	getContainer: function () {
		return this._container;
	},

	addTo: function (map) {
		this._map = map;

		var container = this._container = this.onAdd(map),
		    pos = this.getPosition(),
		    corner = map._controlCorners[pos];

		L.DomUtil.addClass(container, 'leaflet-control');

		if (pos.indexOf('bottom') !== -1) {
			corner.insertBefore(container, corner.firstChild);
		} else {
			corner.appendChild(container);
		}

		return this;
	},

	remove: function () {
		L.DomUtil.remove(this._container);

		if (this.onRemove) {
			this.onRemove(this._map);
		}

		this._map = null;

		return this;
	},

	_refocusOnMap: function () {
		if (this._map) {
			this._map.getContainer().focus();
		}
	}
});

L.control = function (options) {
	return new L.Control(options);
};


// adds control-related methods to L.Map

L.Map.include({
	addControl: function (control) {
		control.addTo(this);
		return this;
	},

	removeControl: function (control) {
		control.remove();
		return this;
	},

	_initControlPos: function () {
		var corners = this._controlCorners = {},
		    l = 'leaflet-',
		    container = this._controlContainer =
		            L.DomUtil.create('div', l + 'control-container', this._container);

		function createCorner(vSide, hSide) {
			var className = l + vSide + ' ' + l + hSide;

			corners[vSide + hSide] = L.DomUtil.create('div', className, container);
		}

		createCorner('top', 'left');
		createCorner('top', 'right');
		createCorner('bottom', 'left');
		createCorner('bottom', 'right');
	},

	_clearControlPos: function () {
		L.DomUtil.remove(this._controlContainer);
	}
});

/*
 * L.Control.Attribution is used for displaying attribution on the map (added by default).
 */

L.Control.Attribution = L.Control.extend({
	options: {
		position: 'bottomright',
		prefix: '<a href="http://leafletjs.com" title="A JS library for interactive maps">Leaflet</a>'
	},

	initialize: function (options) {
		L.setOptions(this, options);

		this._attributions = {};
	},

	onAdd: function (map) {
		this._container = L.DomUtil.create('div', 'leaflet-control-attribution');
		L.DomEvent.disableClickPropagation(this._container);

		// TODO ugly, refactor
		for (var i in map._layers) {
			if (map._layers[i].getAttribution) {
				this.addAttribution(map._layers[i].getAttribution());
			}
		}

		this._update();

		return this._container;
	},

	setPrefix: function (prefix) {
		this.options.prefix = prefix;
		this._update();
		return this;
	},

	addAttribution: function (text) {
		if (!text) { return; }

		if (!this._attributions[text]) {
			this._attributions[text] = 0;
		}
		this._attributions[text]++;

		this._update();

		return this;
	},

	removeAttribution: function (text) {
		if (!text) { return; }

		if (this._attributions[text]) {
			this._attributions[text]--;
			this._update();
		}

		return this;
	},

	_update: function () {
		if (!this._map) { return; }

		var attribs = [];

		for (var i in this._attributions) {
			if (this._attributions[i]) {
				attribs.push(i);
			}
		}

		var prefixAndAttribs = [];

		if (this.options.prefix) {
			prefixAndAttribs.push(this.options.prefix);
		}
		if (attribs.length) {
			prefixAndAttribs.push(attribs.join(', '));
		}

		this._container.innerHTML = prefixAndAttribs.join(' | ');
	}
});

L.Map.mergeOptions({
	attributionControl: true
});

L.Map.addInitHook(function () {
	if (this.options.attributionControl) {
		this.attributionControl = (new L.Control.Attribution()).addTo(this);
	}
});

L.control.attribution = function (options) {
	return new L.Control.Attribution(options);
};

/*
 * L.Control.Zoom is used for the default zoom buttons on the map.
 */

L.Control.Zoom = L.Control.extend({
    options: {
        position: 'topleft',
        zoomInText: '+',
        zoomInTitle: 'Zoom in',
        zoomOutText: '-',
        zoomOutTitle: 'Zoom out'
    },

    onAdd: function (map) {
        var zoomName = 'leaflet-control-zoom',
            container = L.DomUtil.create('div', zoomName + ' leaflet-bar'),
            options = this.options;

        this._zoomInButton  = this._createButton(options.zoomInText, options.zoomInTitle,
                zoomName + '-in',  container, this._zoomIn);
        this._zoomOutButton = this._createButton(options.zoomOutText, options.zoomOutTitle,
                zoomName + '-out', container, this._zoomOut);

        this._updateDisabled();
        map.on('zoomend zoomlevelschange', this._updateDisabled, this);

        return container;
    },

    onRemove: function (map) {
        map.off('zoomend zoomlevelschange', this._updateDisabled, this);
    },

    _zoomIn: function (e) {
        this._map.zoomIn(e.shiftKey ? 3 : 1);
    },

    _zoomOut: function (e) {
        this._map.zoomOut(e.shiftKey ? 3 : 1);
    },

    _createButton: function (html, title, className, container, fn) {
        var link = L.DomUtil.create('a', className, container);
        link.innerHTML = html;
        link.href = '#';
        link.title = title;

        L.DomEvent
            .on(link, 'mousedown dblclick', L.DomEvent.stopPropagation)
            .on(link, 'click', L.DomEvent.stop)
            .on(link, 'click', fn, this)
            .on(link, 'click', this._refocusOnMap, this);

        return link;
    },

    _updateDisabled: function () {
        var map = this._map,
            className = 'leaflet-disabled';

        L.DomUtil.removeClass(this._zoomInButton, className);
        L.DomUtil.removeClass(this._zoomOutButton, className);

        if (map._zoom === map.getMinZoom()) {
            L.DomUtil.addClass(this._zoomOutButton, className);
        }
        if (map._zoom === map.getMaxZoom()) {
            L.DomUtil.addClass(this._zoomInButton, className);
        }
    }
});

L.Map.mergeOptions({
    zoomControl: true
});

L.Map.addInitHook(function () {
    if (this.options.zoomControl) {
        this.zoomControl = new L.Control.Zoom();
        this.addControl(this.zoomControl);
    }
});

L.control.zoom = function (options) {
    return new L.Control.Zoom(options);
};


/*
 * L.Control.Scale is used for displaying metric/imperial scale on the map.
 */

L.Control.Scale = L.Control.extend({
	options: {
		position: 'bottomleft',
		maxWidth: 100,
		metric: true,
		imperial: true
		// updateWhenIdle: false
	},

	onAdd: function (map) {
		var className = 'leaflet-control-scale',
		    container = L.DomUtil.create('div', className),
		    options = this.options;

		this._addScales(options, className + '-line', container);

		map.on(options.updateWhenIdle ? 'moveend' : 'move', this._update, this);
		map.whenReady(this._update, this);

		return container;
	},

	onRemove: function (map) {
		map.off(this.options.updateWhenIdle ? 'moveend' : 'move', this._update, this);
	},

	_addScales: function (options, className, container) {
		if (options.metric) {
			this._mScale = L.DomUtil.create('div', className, container);
		}
		if (options.imperial) {
			this._iScale = L.DomUtil.create('div', className, container);
		}
	},

	_update: function () {
		var map = this._map,
		    y = map.getSize().y / 2;

		var maxMeters = L.CRS.Earth.distance(
				map.containerPointToLatLng([0, y]),
				map.containerPointToLatLng([this.options.maxWidth, y]));

		this._updateScales(maxMeters);
	},

	_updateScales: function (maxMeters) {
		if (this.options.metric && maxMeters) {
			this._updateMetric(maxMeters);
		}
		if (this.options.imperial && maxMeters) {
			this._updateImperial(maxMeters);
		}
	},

	_updateMetric: function (maxMeters) {
		var meters = this._getRoundNum(maxMeters),
		    label = meters < 1000 ? meters + ' m' : (meters / 1000) + ' km';

		this._updateScale(this._mScale, label, meters / maxMeters);
	},

	_updateImperial: function (maxMeters) {
		var maxFeet = maxMeters * 3.2808399,
		    maxMiles, miles, feet;

		if (maxFeet > 5280) {
			maxMiles = maxFeet / 5280;
			miles = this._getRoundNum(maxMiles);
			this._updateScale(this._iScale, miles + ' mi', miles / maxMiles);

		} else {
			feet = this._getRoundNum(maxFeet);
			this._updateScale(this._iScale, feet + ' ft', feet / maxFeet);
		}
	},

	_updateScale: function (scale, text, ratio) {
		scale.style.width = (Math.round(this.options.maxWidth * ratio) - 10) + 'px';
		scale.innerHTML = text;
	},

	_getRoundNum: function (num) {
		var pow10 = Math.pow(10, (Math.floor(num) + '').length - 1),
		    d = num / pow10;

		d = d >= 10 ? 10 :
		    d >= 5 ? 5 :
		    d >= 3 ? 3 :
		    d >= 2 ? 2 : 1;

		return pow10 * d;
	}
});

L.control.scale = function (options) {
	return new L.Control.Scale(options);
};

/*
 * L.Control.Layers is a control to allow users to switch between different layers on the map.
 */

L.Control.Layers = L.Control.extend({
	options: {
		collapsed: true,
		position: 'topright',
		autoZIndex: true
	},

	initialize: function (baseLayers, overlays, options) {
		L.setOptions(this, options);

		this._layers = {};
		this._lastZIndex = 0;
		this._handlingClick = false;

		for (var i in baseLayers) {
			this._addLayer(baseLayers[i], i);
		}

		for (i in overlays) {
			this._addLayer(overlays[i], i, true);
		}
	},

	onAdd: function () {
		this._initLayout();
		this._update();

		return this._container;
	},

	addBaseLayer: function (layer, name) {
		this._addLayer(layer, name);
		return this._update();
	},

	addOverlay: function (layer, name) {
		this._addLayer(layer, name, true);
		return this._update();
	},

	removeLayer: function (layer) {
		layer.off('add remove', this._onLayerChange, this);

		delete this._layers[L.stamp(layer)];
		return this._update();
	},

	_initLayout: function () {
		var className = 'leaflet-control-layers',
		    container = this._container = L.DomUtil.create('div', className);

		// makes this work on IE touch devices by stopping it from firing a mouseout event when the touch is released
		container.setAttribute('aria-haspopup', true);

		if (!L.Browser.touch) {
			L.DomEvent
				.disableClickPropagation(container)
				.disableScrollPropagation(container);
		} else {
			L.DomEvent.on(container, 'click', L.DomEvent.stopPropagation);
		}

		var form = this._form = L.DomUtil.create('form', className + '-list');

		if (this.options.collapsed) {
			if (!L.Browser.android) {
				L.DomEvent.on(container, {
					mouseenter: this._expand,
					mouseleave: this._collapse
				}, this);
			}

			var link = this._layersLink = L.DomUtil.create('a', className + '-toggle', container);
			link.href = '#';
			link.title = 'Layers';

			if (L.Browser.touch) {
				L.DomEvent
				    .on(link, 'click', L.DomEvent.stop)
				    .on(link, 'click', this._expand, this);
			} else {
				L.DomEvent.on(link, 'focus', this._expand, this);
			}

			// work around for Firefox Android issue https://github.com/Leaflet/Leaflet/issues/2033
			L.DomEvent.on(form, 'click', function () {
				setTimeout(L.bind(this._onInputClick, this), 0);
			}, this);

			this._map.on('click', this._collapse, this);
			// TODO keyboard accessibility
		} else {
			this._expand();
		}

		this._baseLayersList = L.DomUtil.create('div', className + '-base', form);
		this._separator = L.DomUtil.create('div', className + '-separator', form);
		this._overlaysList = L.DomUtil.create('div', className + '-overlays', form);

		container.appendChild(form);
	},

	_addLayer: function (layer, name, overlay) {
		layer.on('add remove', this._onLayerChange, this);

		var id = L.stamp(layer);

		this._layers[id] = {
			layer: layer,
			name: name,
			overlay: overlay
		};

		if (this.options.autoZIndex && layer.setZIndex) {
			this._lastZIndex++;
			layer.setZIndex(this._lastZIndex);
		}
	},

	_update: function () {
		if (!this._container) { return; }

		this._baseLayersList.innerHTML = '';
		this._overlaysList.innerHTML = '';

		var baseLayersPresent, overlaysPresent, i, obj;

		for (i in this._layers) {
			obj = this._layers[i];
			this._addItem(obj);
			overlaysPresent = overlaysPresent || obj.overlay;
			baseLayersPresent = baseLayersPresent || !obj.overlay;
		}

		this._separator.style.display = overlaysPresent && baseLayersPresent ? '' : 'none';

		return this;
	},

	_onLayerChange: function (e) {
		if (!this._handlingClick) {
			this._update();
		}

		var overlay = this._layers[L.stamp(e.target)].overlay;

		var type = overlay ?
			(e.type === 'add' ? 'overlayadd' : 'overlayremove') :
			(e.type === 'add' ? 'baselayerchange' : null);

		if (type) {
			this._map.fire(type, e.target);
		}
	},

	// IE7 bugs out if you create a radio dynamically, so you have to do it this hacky way (see http://bit.ly/PqYLBe)
	_createRadioElement: function (name, checked) {

		var radioHtml = '<input type="radio" class="leaflet-control-layers-selector" name="' +
				name + '"' + (checked ? ' checked="checked"' : '') + '/>';

		var radioFragment = document.createElement('div');
		radioFragment.innerHTML = radioHtml;

		return radioFragment.firstChild;
	},

	_addItem: function (obj) {
		var label = document.createElement('label'),
		    checked = this._map.hasLayer(obj.layer),
		    input;

		if (obj.overlay) {
			input = document.createElement('input');
			input.type = 'checkbox';
			input.className = 'leaflet-control-layers-selector';
			input.defaultChecked = checked;
		} else {
			input = this._createRadioElement('leaflet-base-layers', checked);
		}

		input.layerId = L.stamp(obj.layer);

		L.DomEvent.on(input, 'click', this._onInputClick, this);

		var name = document.createElement('span');
		name.innerHTML = ' ' + obj.name;

		label.appendChild(input);
		label.appendChild(name);

		var container = obj.overlay ? this._overlaysList : this._baseLayersList;
		container.appendChild(label);

		return label;
	},

	_onInputClick: function () {
		var inputs = this._form.getElementsByTagName('input'),
		    input, layer, hasLayer;

		this._handlingClick = true;

		for (var i = 0, len = inputs.length; i < len; i++) {
			input = inputs[i];
			layer = this._layers[input.layerId].layer;
			hasLayer = this._map.hasLayer(layer);

			if (input.checked && !hasLayer) {
				this._map.addLayer(layer);

			} else if (!input.checked && hasLayer) {
				this._map.removeLayer(layer);
			}
		}

		this._handlingClick = false;

		this._refocusOnMap();
	},

	_expand: function () {
		L.DomUtil.addClass(this._container, 'leaflet-control-layers-expanded');
	},

	_collapse: function () {
		L.DomUtil.removeClass(this._container, 'leaflet-control-layers-expanded');
	}
});

L.control.layers = function (baseLayers, overlays, options) {
	return new L.Control.Layers(baseLayers, overlays, options);
};

/*
 * L.PosAnimation fallback implementation that powers Leaflet pan animations
 * in browsers that don't support CSS3 Transitions.
 */

L.PosAnimation = L.DomUtil.TRANSITION ? L.PosAnimation : L.PosAnimation.extend({

	run: function (el, newPos, duration, easeLinearity) { // (HTMLElement, Point[, Number, Number])
		this.stop();

		this._el = el;
		this._inProgress = true;
		this._duration = duration || 0.25;
		this._easeOutPower = 1 / Math.max(easeLinearity || 0.5, 0.2);

		this._startPos = L.DomUtil.getPosition(el);
		this._offset = newPos.subtract(this._startPos);
		this._startTime = +new Date();

		this.fire('start');

		this._animate();
	},

	stop: function () {
		if (!this._inProgress) { return; }

		this._step();
		this._complete();
	},

	_animate: function () {
		// animation loop
		this._animId = L.Util.requestAnimFrame(this._animate, this);
		this._step();
	},

	_step: function () {
		var elapsed = (+new Date()) - this._startTime,
		    duration = this._duration * 1000;

		if (elapsed < duration) {
			this._runFrame(this._easeOut(elapsed / duration));
		} else {
			this._runFrame(1);
			this._complete();
		}
	},

	_runFrame: function (progress) {
		var pos = this._startPos.add(this._offset.multiplyBy(progress));
		L.DomUtil.setPosition(this._el, pos);

		this.fire('step');
	},

	_complete: function () {
		L.Util.cancelAnimFrame(this._animId);

		this._inProgress = false;
		this.fire('end');
	},

	_easeOut: function (t) {
		return 1 - Math.pow(1 - t, this._easeOutPower);
	}
});

/*
 * Provides L.Map with convenient shortcuts for using browser geolocation features.
 */

L.Map.include({
	_defaultLocateOptions: {
		timeout: 10000,
		watch: false
		// setView: false
		// maxZoom: <Number>
		// maximumAge: 0
		// enableHighAccuracy: false
	},

	locate: function (/*Object*/ options) {

		options = this._locateOptions = L.extend(this._defaultLocateOptions, options);

		if (!navigator.geolocation) {
			this._handleGeolocationError({
				code: 0,
				message: 'Geolocation not supported.'
			});
			return this;
		}

		var onResponse = L.bind(this._handleGeolocationResponse, this),
			onError = L.bind(this._handleGeolocationError, this);

		if (options.watch) {
			this._locationWatchId =
			        navigator.geolocation.watchPosition(onResponse, onError, options);
		} else {
			navigator.geolocation.getCurrentPosition(onResponse, onError, options);
		}
		return this;
	},

	stopLocate: function () {
		if (navigator.geolocation) {
			navigator.geolocation.clearWatch(this._locationWatchId);
		}
		if (this._locateOptions) {
			this._locateOptions.setView = false;
		}
		return this;
	},

	_handleGeolocationError: function (error) {
		var c = error.code,
		    message = error.message ||
		            (c === 1 ? 'permission denied' :
		            (c === 2 ? 'position unavailable' : 'timeout'));

		if (this._locateOptions.setView && !this._loaded) {
			this.fitWorld();
		}

		this.fire('locationerror', {
			code: c,
			message: 'Geolocation error: ' + message + '.'
		});
	},

	_handleGeolocationResponse: function (pos) {
		var lat = pos.coords.latitude,
		    lng = pos.coords.longitude,
		    latlng = new L.LatLng(lat, lng),

		    latAccuracy = 180 * pos.coords.accuracy / 40075017,
		    lngAccuracy = latAccuracy / Math.cos((Math.PI / 180) * lat),

		    bounds = L.latLngBounds(
		            [lat - latAccuracy, lng - lngAccuracy],
		            [lat + latAccuracy, lng + lngAccuracy]),

		    options = this._locateOptions;

		if (options.setView) {
			var zoom = this.getBoundsZoom(bounds);
			this.setView(latlng, options.maxZoom ? Math.min(zoom, options.maxZoom) : zoom);
		}

		var data = {
			latlng: latlng,
			bounds: bounds,
			timestamp: pos.timestamp
		};

		for (var i in pos.coords) {
			if (typeof pos.coords[i] === 'number') {
				data[i] = pos.coords[i];
			}
		}

		this.fire('locationfound', data);
	}
});

/**
* @preserve HTML5 Shiv 3.7.2 | @afarkas @jdalton @jon_neal @rem | MIT/GPL2 Licensed
*/
;(function(window, document) {
/*jshint evil:true */
  /** version */
  var version = '3.7.2';

  /** Preset options */
  var options = window.html5 || {};

  /** Used to skip problem elements */
  var reSkip = /^<|^(?:button|map|select|textarea|object|iframe|option|optgroup)$/i;

  /** Not all elements can be cloned in IE **/
  var saveClones = /^(?:a|b|code|div|fieldset|h1|h2|h3|h4|h5|h6|i|label|li|ol|p|q|span|strong|style|table|tbody|td|th|tr|ul)$/i;

  /** Detect whether the browser supports default html5 styles */
  var supportsHtml5Styles;

  /** Name of the expando, to work with multiple documents or to re-shiv one document */
  var expando = '_html5shiv';

  /** The id for the the documents expando */
  var expanID = 0;

  /** Cached data for each document */
  var expandoData = {};

  /** Detect whether the browser supports unknown elements */
  var supportsUnknownElements;

  (function() {
    try {
        var a = document.createElement('a');
        a.innerHTML = '<xyz></xyz>';
        //if the hidden property is implemented we can assume, that the browser supports basic HTML5 Styles
        supportsHtml5Styles = ('hidden' in a);

        supportsUnknownElements = a.childNodes.length == 1 || (function() {
          // assign a false positive if unable to shiv
          (document.createElement)('a');
          var frag = document.createDocumentFragment();
          return (
            typeof frag.cloneNode == 'undefined' ||
            typeof frag.createDocumentFragment == 'undefined' ||
            typeof frag.createElement == 'undefined'
          );
        }());
    } catch(e) {
      // assign a false positive if detection fails => unable to shiv
      supportsHtml5Styles = true;
      supportsUnknownElements = true;
    }

  }());

  /*--------------------------------------------------------------------------*/

  /**
   * Creates a style sheet with the given CSS text and adds it to the document.
   * @private
   * @param {Document} ownerDocument The document.
   * @param {String} cssText The CSS text.
   * @returns {StyleSheet} The style element.
   */
  function addStyleSheet(ownerDocument, cssText) {
    var p = ownerDocument.createElement('p'),
        parent = ownerDocument.getElementsByTagName('head')[0] || ownerDocument.documentElement;

    p.innerHTML = 'x<style>' + cssText + '</style>';
    return parent.insertBefore(p.lastChild, parent.firstChild);
  }

  /**
   * Returns the value of `html5.elements` as an array.
   * @private
   * @returns {Array} An array of shived element node names.
   */
  function getElements() {
    var elements = html5.elements;
    return typeof elements == 'string' ? elements.split(' ') : elements;
  }

  /**
   * Extends the built-in list of html5 elements
   * @memberOf html5
   * @param {String|Array} newElements whitespace separated list or array of new element names to shiv
   * @param {Document} ownerDocument The context document.
   */
  function addElements(newElements, ownerDocument) {
    var elements = html5.elements;
    if(typeof elements != 'string'){
      elements = elements.join(' ');
    }
    if(typeof newElements != 'string'){
      newElements = newElements.join(' ');
    }
    html5.elements = elements +' '+ newElements;
    shivDocument(ownerDocument);
  }

   /**
   * Returns the data associated to the given document
   * @private
   * @param {Document} ownerDocument The document.
   * @returns {Object} An object of data.
   */
  function getExpandoData(ownerDocument) {
    var data = expandoData[ownerDocument[expando]];
    if (!data) {
        data = {};
        expanID++;
        ownerDocument[expando] = expanID;
        expandoData[expanID] = data;
    }
    return data;
  }

  /**
   * returns a shived element for the given nodeName and document
   * @memberOf html5
   * @param {String} nodeName name of the element
   * @param {Document} ownerDocument The context document.
   * @returns {Object} The shived element.
   */
  function createElement(nodeName, ownerDocument, data){
    if (!ownerDocument) {
        ownerDocument = document;
    }
    if(supportsUnknownElements){
        return ownerDocument.createElement(nodeName);
    }
    if (!data) {
        data = getExpandoData(ownerDocument);
    }
    var node;

    if (data.cache[nodeName]) {
        node = data.cache[nodeName].cloneNode();
    } else if (saveClones.test(nodeName)) {
        node = (data.cache[nodeName] = data.createElem(nodeName)).cloneNode();
    } else {
        node = data.createElem(nodeName);
    }

    // Avoid adding some elements to fragments in IE < 9 because
    // * Attributes like `name` or `type` cannot be set/changed once an element
    //   is inserted into a document/fragment
    // * Link elements with `src` attributes that are inaccessible, as with
    //   a 403 response, will cause the tab/window to crash
    // * Script elements appended to fragments will execute when their `src`
    //   or `text` property is set
    return node.canHaveChildren && !reSkip.test(nodeName) && !node.tagUrn ? data.frag.appendChild(node) : node;
  }

  /**
   * returns a shived DocumentFragment for the given document
   * @memberOf html5
   * @param {Document} ownerDocument The context document.
   * @returns {Object} The shived DocumentFragment.
   */
  function createDocumentFragment(ownerDocument, data){
    if (!ownerDocument) {
        ownerDocument = document;
    }
    if(supportsUnknownElements){
        return ownerDocument.createDocumentFragment();
    }
    data = data || getExpandoData(ownerDocument);
    var clone = data.frag.cloneNode(),
        i = 0,
        elems = getElements(),
        l = elems.length;
    for(;i<l;i++){
        clone.createElement(elems[i]);
    }
    return clone;
  }

  /**
   * Shivs the `createElement` and `createDocumentFragment` methods of the document.
   * @private
   * @param {Document|DocumentFragment} ownerDocument The document.
   * @param {Object} data of the document.
   */
  function shivMethods(ownerDocument, data) {
    if (!data.cache) {
        data.cache = {};
        data.createElem = ownerDocument.createElement;
        data.createFrag = ownerDocument.createDocumentFragment;
        data.frag = data.createFrag();
    }


    ownerDocument.createElement = function(nodeName) {
      //abort shiv
      if (!html5.shivMethods) {
          return data.createElem(nodeName);
      }
      return createElement(nodeName, ownerDocument, data);
    };

    ownerDocument.createDocumentFragment = Function('h,f', 'return function(){' +
      'var n=f.cloneNode(),c=n.createElement;' +
      'h.shivMethods&&(' +
        // unroll the `createElement` calls
        getElements().join().replace(/[\w\-:]+/g, function(nodeName) {
          data.createElem(nodeName);
          data.frag.createElement(nodeName);
          return 'c("' + nodeName + '")';
        }) +
      ');return n}'
    )(html5, data.frag);
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Shivs the given document.
   * @memberOf html5
   * @param {Document} ownerDocument The document to shiv.
   * @returns {Document} The shived document.
   */
  function shivDocument(ownerDocument) {
    if (!ownerDocument) {
        ownerDocument = document;
    }
    var data = getExpandoData(ownerDocument);

    if (html5.shivCSS && !supportsHtml5Styles && !data.hasCSS) {
      data.hasCSS = !!addStyleSheet(ownerDocument,
        // corrects block display not defined in IE6/7/8/9
        'article,aside,dialog,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}' +
        // adds styling not present in IE6/7/8/9
        'mark{background:#FF0;color:#000}' +
        // hides non-rendered elements
        'template{display:none}'
      );
    }
    if (!supportsUnknownElements) {
      shivMethods(ownerDocument, data);
    }
    return ownerDocument;
  }

  /*--------------------------------------------------------------------------*/

  /**
   * The `html5` object is exposed so that more elements can be shived and
   * existing shiving can be detected on iframes.
   * @type Object
   * @example
   *
   * // options can be changed before the script is included
   * html5 = { 'elements': 'mark section', 'shivCSS': false, 'shivMethods': false };
   */
  var html5 = {

    /**
     * An array or space separated string of node names of the elements to shiv.
     * @memberOf html5
     * @type Array|String
     */
    'elements': options.elements || 'abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output picture progress section summary template time video',

    /**
     * current version of html5shiv
     */
    'version': version,

    /**
     * A flag to indicate that the HTML5 style sheet should be inserted.
     * @memberOf html5
     * @type Boolean
     */
    'shivCSS': (options.shivCSS !== false),

    /**
     * Is equal to true if a browser supports creating unknown/HTML5 elements
     * @memberOf html5
     * @type boolean
     */
    'supportsUnknownElements': supportsUnknownElements,

    /**
     * A flag to indicate that the document's `createElement` and `createDocumentFragment`
     * methods should be overwritten.
     * @memberOf html5
     * @type Boolean
     */
    'shivMethods': (options.shivMethods !== false),

    /**
     * A string to describe the type of `html5` object ("default" or "default print").
     * @memberOf html5
     * @type String
     */
    'type': 'default',

    // shivs the document according to the specified `html5` object options
    'shivDocument': shivDocument,

    //creates a shived element
    createElement: createElement,

    //creates a shived documentFragment
    createDocumentFragment: createDocumentFragment,

    //extends list of elements
    addElements: addElements
  };

  /*--------------------------------------------------------------------------*/

  // expose html5
  window.html5 = html5;

  // shiv the document
  shivDocument(document);

}(this, document));

if (!Array.prototype.map)
{
  Array.prototype.map = function(fun /*, thisArg */)
  {
    "use strict";

    if (this === void 0 || this === null)
      throw new TypeError();

    var t = Object(this);
    var len = t.length >>> 0;
    if (typeof fun !== "function")
      throw new TypeError();

    var res = new Array(len);
    var thisArg = arguments.length >= 2 ? arguments[1] : void 0;
    for (var i = 0; i < len; i++)
    {
      // NOTE: Absolute correctness would demand Object.defineProperty
      //       be used.  But this method is fairly new, and failure is
      //       possible only if Object.prototype or Array.prototype
      //       has a property |i| (very unlikely), so use a less-correct
      //       but more portable alternative.
      if (i in t)
        res[i] = fun.call(thisArg, t[i], i, t);
    }

    return res;
  };
}

/* reduce implemintation by Mozila https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FArray%2FReduce*/
if ('function' !== typeof Array.prototype.reduce) {
  Array.prototype.reduce = function(callback, opt_initialValue){
    'use strict';
    if (null === this || 'undefined' === typeof this) {
      // At the moment all modern browsers, that support strict mode, have
      // native implementation of Array.prototype.reduce. For instance, IE8
      // does not support strict mode, so this check is actually useless.
      throw new TypeError(
          'Array.prototype.reduce called on null or undefined');
    }
    if ('function' !== typeof callback) {
      throw new TypeError(callback + ' is not a function');
    }
    var index, value,
        length = this.length >>> 0,
        isValueSet = false;
    if (1 < arguments.length) {
      value = opt_initialValue;
      isValueSet = true;
    }
    for (index = 0; length > index; ++index) {
      if (this.hasOwnProperty(index)) {
        if (isValueSet) {
          value = callback(value, this[index], index, this);
        }
        else {
          value = this[index];
          isValueSet = true;
        }
      }
    }
    if (!isValueSet) {
      throw new TypeError('Reduce of empty array with no initial value');
    }
    return value;
  };
}

// From https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach
// Production steps of ECMA-262, Edition 5, 15.4.4.18
// Reference: http://es5.github.com/#x15.4.4.18
if (!Array.prototype.forEach) {

  Array.prototype.forEach = function forEach(callback, thisArg) {
    'use strict';
    var T, k;

    if (this == null) {
      throw new TypeError("this is null or not defined");
    }

    var kValue,
        // 1. Let O be the result of calling ToObject passing the |this| value as the argument.
        O = Object(this),

        // 2. Let lenValue be the result of calling the Get internal method of O with the argument "length".
        // 3. Let len be ToUint32(lenValue).
        len = O.length >>> 0; // Hack to convert O.length to a UInt32

    // 4. If IsCallable(callback) is false, throw a TypeError exception.
    // See: http://es5.github.com/#x9.11
    if ({}.toString.call(callback) !== "[object Function]") {
      throw new TypeError(callback + " is not a function");
    }

    // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.
    if (arguments.length >= 2) {
      T = thisArg;
    }

    // 6. Let k be 0
    k = 0;

    // 7. Repeat, while k < len
    while (k < len) {

      // a. Let Pk be ToString(k).
      //   This is implicit for LHS operands of the in operator
      // b. Let kPresent be the result of calling the HasProperty internal method of O with argument Pk.
      //   This step can be combined with c
      // c. If kPresent is true, then
      if (k in O) {

        // i. Let kValue be the result of calling the Get internal method of O with argument Pk.
        kValue = O[k];

        // ii. Call the Call internal method of callback with T as the this value and
        // argument list containing kValue, k, and O.
        callback.call(T, kValue, k, O);
      }
      // d. Increase k by 1.
      k++;
    }
    // 8. return undefined
  };
}

// From https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys
if (!Object.keys) {
  Object.keys = (function () {
    'use strict';
    var hasOwnProperty = Object.prototype.hasOwnProperty,
        hasDontEnumBug = !({toString: null}).propertyIsEnumerable('toString'),
        dontEnums = [
          'toString',
          'toLocaleString',
          'valueOf',
          'hasOwnProperty',
          'isPrototypeOf',
          'propertyIsEnumerable',
          'constructor'
        ],
        dontEnumsLength = dontEnums.length;

    return function (obj) {
      if (typeof obj !== 'object' && (typeof obj !== 'function' || obj === null)) {
        throw new TypeError('Object.keys called on non-object');
      }

      var result = [], prop, i;

      for (prop in obj) {
        if (hasOwnProperty.call(obj, prop)) {
          result.push(prop);
        }
      }

      if (hasDontEnumBug) {
        for (i = 0; i < dontEnumsLength; i++) {
          if (hasOwnProperty.call(obj, dontEnums[i])) {
            result.push(dontEnums[i]);
          }
        }
      }
      return result;
    };
  }());
}

// From https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some
if (!Array.prototype.some)
{
  Array.prototype.some = function(fun /*, thisArg */)
  {
    'use strict';

    if (this === void 0 || this === null)
      throw new TypeError();

    var t = Object(this);
    var len = t.length >>> 0;
    if (typeof fun !== 'function')
      throw new TypeError();

    var thisArg = arguments.length >= 2 ? arguments[1] : void 0;
    for (var i = 0; i < len; i++)
    {
      if (i in t && fun.call(thisArg, t[i], i, t))
        return true;
    }

    return false;
  };
}

// From https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map
if (!Array.prototype.map)
{
  Array.prototype.map = function(fun /*, thisArg */)
  {
    "use strict";

    if (this === void 0 || this === null)
      throw new TypeError();

    var t = Object(this);
    var len = t.length >>> 0;
    if (typeof fun !== "function")
      throw new TypeError();

    var res = new Array(len);
    var thisArg = arguments.length >= 2 ? arguments[1] : void 0;
    for (var i = 0; i < len; i++)
    {
      // NOTE: Absolute correctness would demand Object.defineProperty
      //       be used.  But this method is fairly new, and failure is
      //       possible only if Object.prototype or Array.prototype
      //       has a property |i| (very unlikely), so use a less-correct
      //       but more portable alternative.
      if (i in t)
        res[i] = fun.call(thisArg, t[i], i, t);
    }

    return res;
  };
}

//From https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter
if (!Array.prototype.filter)
{
  Array.prototype.filter = function(fun /*, thisArg */)
  {
    "use strict";

    if (this === void 0 || this === null)
      throw new TypeError();

    var t = Object(this);
    var len = t.length >>> 0;
    if (typeof fun != "function")
      throw new TypeError();

    var res = [];
    var thisArg = arguments.length >= 2 ? arguments[1] : void 0;
    for (var i = 0; i < len; i++)
    {
      if (i in t)
      {
        var val = t[i];

        // NOTE: Technically this should Object.defineProperty at
        //       the next index, as push can be affected by
        //       properties on Object.prototype and Array.prototype.
        //       But that method's new, and collisions should be
        //       rare, so use the more-compatible alternative.
        if (fun.call(thisArg, val, i, t))
          res.push(val);
      }
    }

    return res;
  };
}

//From https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind
if (!Function.prototype.bind) {
  Function.prototype.bind = function (oThis) {
    if (typeof this !== "function") {
      // closest thing possible to the ECMAScript 5 internal IsCallable function
      throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable");
    }

    var aArgs = Array.prototype.slice.call(arguments, 1),
        fToBind = this,
        fNOP = function () {},
        fBound = function () {
          return fToBind.apply(this instanceof fNOP && oThis
                                 ? this
                                 : oThis,
                               aArgs.concat(Array.prototype.slice.call(arguments)));
        };

    fNOP.prototype = this.prototype;
    fBound.prototype = new fNOP();

    return fBound;
  };
}

//From https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FArray%2FindexOf
if (!Array.prototype.indexOf) {
  Array.prototype.indexOf = function (searchElement, fromIndex) {
    if ( this === undefined || this === null ) {
      throw new TypeError( '"this" is null or not defined' );
    }

    var length = this.length >>> 0; // Hack to convert object.length to a UInt32

    fromIndex = +fromIndex || 0;

    if (Math.abs(fromIndex) === Infinity) {
      fromIndex = 0;
    }

    if (fromIndex < 0) {
      fromIndex += length;
      if (fromIndex < 0) {
        fromIndex = 0;
      }
    }

    for (;fromIndex < length; fromIndex++) {
      if (this[fromIndex] === searchElement) {
        return fromIndex;
      }
    }

    return -1;
  };
}

if (typeof Promise !== 'function') {
  (function() {
  var define, requireModule, require, requirejs;

  (function() {
    var registry = {}, seen = {};

    define = function(name, deps, callback) {
      registry[name] = { deps: deps, callback: callback };
    };

    requirejs = require = requireModule = function(name) {
    requirejs._eak_seen = registry;

      if (seen[name]) { return seen[name]; }
      seen[name] = {};

      if (!registry[name]) {
        throw new Error("Could not find module " + name);
      }

      var mod = registry[name],
          deps = mod.deps,
          callback = mod.callback,
          reified = [],
          exports;

      for (var i=0, l=deps.length; i<l; i++) {
        if (deps[i] === 'exports') {
          reified.push(exports = {});
        } else {
          reified.push(requireModule(resolve(deps[i])));
        }
      }

      var value = callback.apply(this, reified);
      return seen[name] = exports || value;

      function resolve(child) {
        if (child.charAt(0) !== '.') { return child; }
        var parts = child.split("/");
        var parentBase = name.split("/").slice(0, -1);

        for (var i=0, l=parts.length; i<l; i++) {
          var part = parts[i];

          if (part === '..') { parentBase.pop(); }
          else if (part === '.') { continue; }
          else { parentBase.push(part); }
        }

        return parentBase.join("/");
      }
    };
  })();

  define("promise/all",
    ["./utils","exports"],
    function(__dependency1__, __exports__) {
      "use strict";
      /* global toString */

      var isArray = __dependency1__.isArray;
      var isFunction = __dependency1__.isFunction;

      /**
        Returns a promise that is fulfilled when all the given promises have been
        fulfilled, or rejected if any of them become rejected. The return promise
        is fulfilled with an array that gives all the values in the order they were
        passed in the `promises` array argument.

        Example:

        ```javascript
        var promise1 = RSVP.resolve(1);
        var promise2 = RSVP.resolve(2);
        var promise3 = RSVP.resolve(3);
        var promises = [ promise1, promise2, promise3 ];

        RSVP.all(promises).then(function(array){
          // The array here would be [ 1, 2, 3 ];
        });
        ```

        If any of the `promises` given to `RSVP.all` are rejected, the first promise
        that is rejected will be given as an argument to the returned promises's
        rejection handler. For example:

        Example:

        ```javascript
        var promise1 = RSVP.resolve(1);
        var promise2 = RSVP.reject(new Error("2"));
        var promise3 = RSVP.reject(new Error("3"));
        var promises = [ promise1, promise2, promise3 ];

        RSVP.all(promises).then(function(array){
          // Code here never runs because there are rejected promises!
        }, function(error) {
          // error.message === "2"
        });
        ```

        @method all
        @for RSVP
        @param {Array} promises
        @param {String} label
        @return {Promise} promise that is fulfilled when all `promises` have been
        fulfilled, or rejected if any of them become rejected.
      */
      function all(promises) {
        /*jshint validthis:true */
        var Promise = this;

        if (!isArray(promises)) {
          throw new TypeError('You must pass an array to all.');
        }

        return new Promise(function(resolve, reject) {
          var results = [], remaining = promises.length,
          promise;

          if (remaining === 0) {
            resolve([]);
          }

          function resolver(index) {
            return function(value) {
              resolveAll(index, value);
            };
          }

          function resolveAll(index, value) {
            results[index] = value;
            if (--remaining === 0) {
              resolve(results);
            }
          }

          for (var i = 0; i < promises.length; i++) {
            promise = promises[i];

            if (promise && isFunction(promise.then)) {
              promise.then(resolver(i), reject);
            } else {
              resolveAll(i, promise);
            }
          }
        });
      }

      __exports__.all = all;
    });
  define("promise/asap",
    ["exports"],
    function(__exports__) {
      "use strict";
      var browserGlobal = (typeof window !== 'undefined') ? window : {};
      var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
      var local = (typeof global !== 'undefined') ? global : (this === undefined? window:this);

      // node
      function useNextTick() {
        return function() {
          process.nextTick(flush);
        };
      }

      function useMutationObserver() {
        var iterations = 0;
        var observer = new BrowserMutationObserver(flush);
        var node = document.createTextNode('');
        observer.observe(node, { characterData: true });

        return function() {
          node.data = (iterations = ++iterations % 2);
        };
      }

      function useSetTimeout() {
        return function() {
          local.setTimeout(flush, 1);
        };
      }

      var queue = [];
      function flush() {
        for (var i = 0; i < queue.length; i++) {
          var tuple = queue[i];
          var callback = tuple[0], arg = tuple[1];
          callback(arg);
        }
        queue = [];
      }

      var scheduleFlush;

      // Decide what async method to use to triggering processing of queued callbacks:
      if (typeof process !== 'undefined' && {}.toString.call(process) === '[object process]') {
        scheduleFlush = useNextTick();
      } else if (BrowserMutationObserver) {
        scheduleFlush = useMutationObserver();
      } else {
        scheduleFlush = useSetTimeout();
      }

      function asap(callback, arg) {
        var length = queue.push([callback, arg]);
        if (length === 1) {
          // If length is 1, that means that we need to schedule an async flush.
          // If additional callbacks are queued before the queue is flushed, they
          // will be processed by this flush that we are scheduling.
          scheduleFlush();
        }
      }

      __exports__.asap = asap;
    });
  define("promise/config",
    ["exports"],
    function(__exports__) {
      "use strict";
      var config = {
        instrument: false
      };

      function configure(name, value) {
        if (arguments.length === 2) {
          config[name] = value;
        } else {
          return config[name];
        }
      }

      __exports__.config = config;
      __exports__.configure = configure;
    });
  define("promise/polyfill",
    ["./promise","./utils","exports"],
    function(__dependency1__, __dependency2__, __exports__) {
      "use strict";
      /*global self*/
      var RSVPPromise = __dependency1__.Promise;
      var isFunction = __dependency2__.isFunction;

      function polyfill() {
        var local;

        if (typeof global !== 'undefined') {
          local = global;
        } else if (typeof window !== 'undefined' && window.document) {
          local = window;
        } else {
          local = self;
        }

        var es6PromiseSupport =
          "Promise" in local &&
          // Some of these methods are missing from
          // Firefox/Chrome experimental implementations
          "resolve" in local.Promise &&
          "reject" in local.Promise &&
          "all" in local.Promise &&
          "race" in local.Promise &&
          // Older version of the spec had a resolver object
          // as the arg rather than a function
          (function() {
            var resolve;
            new local.Promise(function(r) { resolve = r; });
            return isFunction(resolve);
          }());

        if (!es6PromiseSupport) {
          local.Promise = RSVPPromise;
        }
      }

      __exports__.polyfill = polyfill;
    });
  define("promise/promise",
    ["./config","./utils","./all","./race","./resolve","./reject","./asap","exports"],
    function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __dependency5__, __dependency6__, __dependency7__, __exports__) {
      "use strict";
      var config = __dependency1__.config;
      var configure = __dependency1__.configure;
      var objectOrFunction = __dependency2__.objectOrFunction;
      var isFunction = __dependency2__.isFunction;
      var now = __dependency2__.now;
      var all = __dependency3__.all;
      var race = __dependency4__.race;
      var staticResolve = __dependency5__.resolve;
      var staticReject = __dependency6__.reject;
      var asap = __dependency7__.asap;

      var counter = 0;

      config.async = asap; // default async is asap;

      function Promise(resolver) {
        if (!isFunction(resolver)) {
          throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
        }

        if (!(this instanceof Promise)) {
          throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
        }

        this._subscribers = [];

        invokeResolver(resolver, this);
      }

      function invokeResolver(resolver, promise) {
        function resolvePromise(value) {
          resolve(promise, value);
        }

        function rejectPromise(reason) {
          reject(promise, reason);
        }

        try {
          resolver(resolvePromise, rejectPromise);
        } catch(e) {
          rejectPromise(e);
        }
      }

      function invokeCallback(settled, promise, callback, detail) {
        var hasCallback = isFunction(callback),
            value, error, succeeded, failed;

        if (hasCallback) {
          try {
            value = callback(detail);
            succeeded = true;
          } catch(e) {
            failed = true;
            error = e;
          }
        } else {
          value = detail;
          succeeded = true;
        }

        if (handleThenable(promise, value)) {
          return;
        } else if (hasCallback && succeeded) {
          resolve(promise, value);
        } else if (failed) {
          reject(promise, error);
        } else if (settled === FULFILLED) {
          resolve(promise, value);
        } else if (settled === REJECTED) {
          reject(promise, value);
        }
      }

      var PENDING   = void 0;
      var SEALED    = 0;
      var FULFILLED = 1;
      var REJECTED  = 2;

      function subscribe(parent, child, onFulfillment, onRejection) {
        var subscribers = parent._subscribers;
        var length = subscribers.length;

        subscribers[length] = child;
        subscribers[length + FULFILLED] = onFulfillment;
        subscribers[length + REJECTED]  = onRejection;
      }

      function publish(promise, settled) {
        var child, callback, subscribers = promise._subscribers, detail = promise._detail;

        for (var i = 0; i < subscribers.length; i += 3) {
          child = subscribers[i];
          callback = subscribers[i + settled];

          invokeCallback(settled, child, callback, detail);
        }

        promise._subscribers = null;
      }

      Promise.prototype = {
        constructor: Promise,

        _state: undefined,
        _detail: undefined,
        _subscribers: undefined,

        then: function(onFulfillment, onRejection) {
          var promise = this;

          var thenPromise = new this.constructor(function() {});

          if (this._state) {
            var callbacks = arguments;
            config.async(function invokePromiseCallback() {
              invokeCallback(promise._state, thenPromise, callbacks[promise._state - 1], promise._detail);
            });
          } else {
            subscribe(this, thenPromise, onFulfillment, onRejection);
          }

          return thenPromise;
        },

        'catch': function(onRejection) {
          return this.then(null, onRejection);
        }
      };

      Promise.all = all;
      Promise.race = race;
      Promise.resolve = staticResolve;
      Promise.reject = staticReject;

      function handleThenable(promise, value) {
        var then = null,
        resolved;

        try {
          if (promise === value) {
            throw new TypeError("A promises callback cannot return that same promise.");
          }

          if (objectOrFunction(value)) {
            then = value.then;

            if (isFunction(then)) {
              then.call(value, function(val) {
                if (resolved) { return true; }
                resolved = true;

                if (value !== val) {
                  resolve(promise, val);
                } else {
                  fulfill(promise, val);
                }
              }, function(val) {
                if (resolved) { return true; }
                resolved = true;

                reject(promise, val);
              });

              return true;
            }
          }
        } catch (error) {
          if (resolved) { return true; }
          reject(promise, error);
          return true;
        }

        return false;
      }

      function resolve(promise, value) {
        if (promise === value) {
          fulfill(promise, value);
        } else if (!handleThenable(promise, value)) {
          fulfill(promise, value);
        }
      }

      function fulfill(promise, value) {
        if (promise._state !== PENDING) { return; }
        promise._state = SEALED;
        promise._detail = value;

        config.async(publishFulfillment, promise);
      }

      function reject(promise, reason) {
        if (promise._state !== PENDING) { return; }
        promise._state = SEALED;
        promise._detail = reason;

        config.async(publishRejection, promise);
      }

      function publishFulfillment(promise) {
        publish(promise, promise._state = FULFILLED);
      }

      function publishRejection(promise) {
        publish(promise, promise._state = REJECTED);
      }

      __exports__.Promise = Promise;
    });
  define("promise/race",
    ["./utils","exports"],
    function(__dependency1__, __exports__) {
      "use strict";
      /* global toString */
      var isArray = __dependency1__.isArray;

      /**
        `RSVP.race` allows you to watch a series of promises and act as soon as the
        first promise given to the `promises` argument fulfills or rejects.

        Example:

        ```javascript
        var promise1 = new RSVP.Promise(function(resolve, reject){
          setTimeout(function(){
            resolve("promise 1");
          }, 200);
        });

        var promise2 = new RSVP.Promise(function(resolve, reject){
          setTimeout(function(){
            resolve("promise 2");
          }, 100);
        });

        RSVP.race([promise1, promise2]).then(function(result){
          // result === "promise 2" because it was resolved before promise1
          // was resolved.
        });
        ```

        `RSVP.race` is deterministic in that only the state of the first completed
        promise matters. For example, even if other promises given to the `promises`
        array argument are resolved, but the first completed promise has become
        rejected before the other promises became fulfilled, the returned promise
        will become rejected:

        ```javascript
        var promise1 = new RSVP.Promise(function(resolve, reject){
          setTimeout(function(){
            resolve("promise 1");
          }, 200);
        });

        var promise2 = new RSVP.Promise(function(resolve, reject){
          setTimeout(function(){
            reject(new Error("promise 2"));
          }, 100);
        });

        RSVP.race([promise1, promise2]).then(function(result){
          // Code here never runs because there are rejected promises!
        }, function(reason){
          // reason.message === "promise2" because promise 2 became rejected before
          // promise 1 became fulfilled
        });
        ```

        @method race
        @for RSVP
        @param {Array} promises array of promises to observe
        @param {String} label optional string for describing the promise returned.
        Useful for tooling.
        @return {Promise} a promise that becomes fulfilled with the value the first
        completed promises is resolved with if the first completed promise was
        fulfilled, or rejected with the reason that the first completed promise
        was rejected with.
      */
      function race(promises) {
        /*jshint validthis:true */
        var Promise = this;

        if (!isArray(promises)) {
          throw new TypeError('You must pass an array to race.');
        }
        return new Promise(function(resolve, reject) {
          var results = [], promise;

          for (var i = 0; i < promises.length; i++) {
            promise = promises[i];

            if (promise && typeof promise.then === 'function') {
              promise.then(resolve, reject);
            } else {
              resolve(promise);
            }
          }
        });
      }

      __exports__.race = race;
    });
  define("promise/reject",
    ["exports"],
    function(__exports__) {
      "use strict";
      /**
        `RSVP.reject` returns a promise that will become rejected with the passed
        `reason`. `RSVP.reject` is essentially shorthand for the following:

        ```javascript
        var promise = new RSVP.Promise(function(resolve, reject){
          reject(new Error('WHOOPS'));
        });

        promise.then(function(value){
          // Code here doesn't run because the promise is rejected!
        }, function(reason){
          // reason.message === 'WHOOPS'
        });
        ```

        Instead of writing the above, your code now simply becomes the following:

        ```javascript
        var promise = RSVP.reject(new Error('WHOOPS'));

        promise.then(function(value){
          // Code here doesn't run because the promise is rejected!
        }, function(reason){
          // reason.message === 'WHOOPS'
        });
        ```

        @method reject
        @for RSVP
        @param {Any} reason value that the returned promise will be rejected with.
        @param {String} label optional string for identifying the returned promise.
        Useful for tooling.
        @return {Promise} a promise that will become rejected with the given
        `reason`.
      */
      function reject(reason) {
        /*jshint validthis:true */
        var Promise = this;

        return new Promise(function (resolve, reject) {
          reject(reason);
        });
      }

      __exports__.reject = reject;
    });
  define("promise/resolve",
    ["exports"],
    function(__exports__) {
      "use strict";
      function resolve(value) {
        /*jshint validthis:true */
        if (value && typeof value === 'object' && value.constructor === this) {
          return value;
        }

        var Promise = this;

        return new Promise(function(resolve) {
          resolve(value);
        });
      }

      __exports__.resolve = resolve;
    });
  define("promise/utils",
    ["exports"],
    function(__exports__) {
      "use strict";
      function objectOrFunction(x) {
        return isFunction(x) || (typeof x === "object" && x !== null);
      }

      function isFunction(x) {
        return typeof x === "function";
      }

      function isArray(x) {
        return Object.prototype.toString.call(x) === "[object Array]";
      }

      // Date.now is not available in browsers < IE9
      // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/now#Compatibility
      var now = Date.now || function() { return new Date().getTime(); };


      __exports__.objectOrFunction = objectOrFunction;
      __exports__.isFunction = isFunction;
      __exports__.isArray = isArray;
      __exports__.now = now;
    });
  requireModule('promise/polyfill').polyfill();
  }());
}

//DG inheritance
var oldDG = window.DG;
DG = new (
    (function () {
        var DgApi = function () {},
            DgApiCore = function () {};

        DgApiCore.prototype = L;
        DgApi.prototype = new DgApiCore();

        return DgApi;
    })()
)();

for (var prop in oldDG) {
    if (oldDG.hasOwnProperty(prop) && typeof DG[prop] === 'undefined') {
        DG[prop] = oldDG[prop];
    }
}

window.__dgApi__ = window.__dgApi__ || {};
DG.version = window.__dgApi__.version;
DG.debug = window.__dgApi__.debug;
DG.Icon.Default.imagePath  = '../img/vendors/leaflet';

/* eslint-disable */
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','http://www.google-analytics.com/analytics.js','ga');
/* eslint-enable */

/*global ga:false*/
ga('create', 'UA-38243181-2', 'none');
ga('send', 'pageview');

//track statistics
var newImg = new Image();
newImg.src = 'http://maps.api.2gis.ru/analytics/track-user.png?' +
            'sr=' + window.screen.width + 'x' + window.screen.height + '&' +
            'v=' + DG.version;

// Improve IHandler
DG.Map.include({
    addHandler: function (name, HandlerClass) {
        if (!HandlerClass) { return this; }

        var options = this.options[name],
            param = (options === Object(options)) ? options : null,
            handler = this[name] = new HandlerClass(this, param);

        this._handlers.push(handler);

        if (options) {
            handler.enable();
        }

        return this;
    }
});

// Apply class to map container for detect when we dont need hover effects
DG.Map.addInitHook(function () {
    if (!DG.Browser.touch) {
        DG.DomUtil.addClass(this._container, 'no-touch');
    }
});

var handlers = window.__dgApi__.callbacks || [],
    chain = Promise.resolve();

// dont pollute global space!
try {
    delete window.__dgApi__;
} catch(e) {
    window.__dgApi__ = undefined; // ie8 cant delete from window object
}

handlers.forEach(function (handlers) {
    chain = chain.then(handlers[0], handlers[1]);
});

DG.then = function (resolve, reject) {
    return chain.then(resolve, reject);
};

// IE8 throw error if `chain.catch`
/* eslint-disable dot-notation, no-console */
chain['catch'](function(err) {
    console.error(err);
});
/* eslint-enable dot-notation, no-console */

DG.plugin = function (plugins) {
    var count,
        jsReg = new RegExp(/.js$/i),
        cssReg = new RegExp(/.css$/i),

    promise = new Promise(function (resolve) {
        function checkLoading() {
            count--;

            if (count === 0) {
                resolve();
            }
        }

        function appendJS(link) {
            var js = document.createElement('script');
            js.setAttribute('type', 'text/javascript');
            js.setAttribute('src', link);
            js.onload = function () {
                checkLoading();
            };
            js.onerror = function () {
                checkLoading();
            };
            // load/error for IE
            js.onreadystatechange = function () {
                if (js.readyState === 'complete' || js.readyState === 'loaded') {
                    checkLoading();
                }
            };

            document.getElementsByTagName('head')[0].appendChild(js);
        }

        function appendCSS(link) {
            var css = document.createElement('link');
            css.setAttribute('rel', 'stylesheet');
            css.setAttribute('type', 'text/css');
            css.setAttribute('href', link);
            document.getElementsByTagName('head')[0].appendChild(css);

            checkLoading();
        }

        function isJs(url) {
            return jsReg.test(url);
        }

        function isCss(url) {
            return cssReg.test(url);
        }

        function appendAsset(asset) {
            if (isJs(asset)) {
                appendJS(asset);
            } else if (isCss(asset)) {
                appendCSS(asset);
            } else {
                count--;
            }
        }

        if (DG.Util.isArray(plugins)) {
            count = plugins.length;
            plugins.forEach(function (plugin) {
                appendAsset(plugin);
            });
        }

        if (typeof plugins === 'string') {
            count = 1;
            appendAsset(plugins);
        }
    });

    return promise;
};

DG.ajax = (function () {

    var win = window,
        doc = document,

        rurl = /^([\w.+-]+:)?(?:\/\/([^\/?#:]*)(?::(\d+)|)|)/,
        twoHundo = /^20\d$/,

        // Document location
        ajaxLocParts,
        ajaxLocation,

        byTag = 'getElementsByTagName',
        readyState = 'readyState',
        contentType = 'Content-Type',
        requestedWith = 'X-Requested-With',
        head = doc[byTag]('head')[0],
        uniqid = 0,
        callbackPrefix = 'l_dg_ajax_callback_' + (+new Date()),
        lastValue, // data stored by the most recent JSONP callback
        xmlHttpRequest = 'XMLHttpRequest',
        xDomainRequest = 'XDomainRequest',
        noop = function () {},
        defaultHeaders = {
            contentType: 'application/x-www-form-urlencoded',
            requestedWith: xmlHttpRequest,
            accept: {
                '*':  'text/javascript, text/html, application/xml, text/xml, */*',
                xml:  'application/xml, text/xml',
                html: 'text/html',
                text: 'text/plain',
                json: 'application/json, text/javascript',
                js:   'application/javascript, text/javascript'
            }
        },
        /*global XDomainRequest:false, ActiveXObject:false */
        xhr = function (o) {
            // is it x-domain
            if (o.crossDomain === true) {
                var xhr = win[xmlHttpRequest] ? new XMLHttpRequest() : null;
                if (xhr && 'withCredentials' in xhr) {
                    return xhr;
                } else if (win[xDomainRequest]) {
                    return new XDomainRequest();
                } else {
                    throw new Error('Browser does not support cross-origin requests');
                }
            } else if (win[xmlHttpRequest]) {
                return new XMLHttpRequest();
            } else {
                return new ActiveXObject('Microsoft.XMLHTTP');
            }
        },

        globalSetupOptions = {
            dataFilter: function (data) {
                return data;
            }
        };

    // IE may throw an exception when accessing
    // a field from window.location if document.domain has been set
    try {
        ajaxLocation = location.href;
    } catch (e) {
        // Use the href attribute of an A element
        // since IE will modify it given document.location
        ajaxLocation = document.createElement('a');
        ajaxLocation.href = '';
        ajaxLocation = ajaxLocation.href;
    }

    // Segment location into parts
    ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || [];

    function handleReadyState(r, success, error) {
        return function () {
            // use _aborted to mitigate against IE err c00c023f
            // (can't read props on aborted request objects)
            if (r._aborted) {
                return error(r.request);
            }
            if (r.request && r.request[readyState] === 4) {
                r.request.onreadystatechange = noop;
                if (twoHundo.test(r.request.status)) {
                    success(r.request);
                } else {
                    error(r.request);
                }
            }
        };
    }

    function setHeaders(http, o) {
        var headers = o.headers || {},
            h;

        headers.Accept = headers.Accept || defaultHeaders.accept[o.dataType] || defaultHeaders.accept['*'];

        // breaks cross-origin requests with legacy browsers
        if (!o.crossDomain && !headers[requestedWith]) {
            headers[requestedWith] = defaultHeaders.requestedWith;
        }
        if (!headers[contentType]) {
            headers[contentType] = o.contentType || defaultHeaders.contentType;
        }
        for (h in headers) {
            if (headers.hasOwnProperty(h) && 'setRequestHeader' in http) {
                http.setRequestHeader(h, headers[h]);
            }
        }
    }

    function setCredentials(http, o) {
        if (typeof o.withCredentials !== 'undefined' && typeof http.withCredentials !== 'undefined') {
            http.withCredentials = !!o.withCredentials;
        }
    }

    function generalCallback(data) {
        lastValue = data;
    }

    function urlappend(url, s) {
        return url + (/\?/.test(url) ? '&' : '?') + s;
    }

    function handleJsonp(o, fn, err, url) {
        var reqId = uniqid++,
            cbkey = o.jsonpCallback || 'callback', // the 'callback' key
            cbval = o.jsonpCallbackName || callbackPrefix,
            cbreg = new RegExp('((^|\\?|&)' + cbkey + ')=([^&]+)'),
            match = url.match(cbreg),
            script = doc.createElement('script'),
            loaded = 0,
            isIE10 = navigator.userAgent.indexOf('MSIE 10.0') !== -1;

        if (match) {
            if (match[3] === '?') {
                url = url.replace(cbreg, '$1=' + cbval); // wildcard callback func name
            } else {
                cbval = match[3]; // provided callback func name
            }
        } else {
            url = urlappend(url, cbkey + '=' + cbval); // no callback details, add 'em
        }

        win[cbval] = generalCallback;

        script.type = 'text/javascript';
        script.src = url;
        script.async = true;
        if (typeof script.onreadystatechange !== 'undefined' && !isIE10) {
            // need this for IE due to out-of-order onreadystatechange(), binding script
            // execution to an event listener gives us control over when the script
            // is executed. See http://jaubourg.net/2010/07/loading-script-as-onclick-handler-of.html
            //
            // if this hack is used in IE10 jsonp callback are never called
            script.event = 'onclick';
            script.htmlFor = script.id = '_request_' + reqId;
        }

        script.onerror = function () {
            script.onerror = script.onload = script.onreadystatechange = null;
            err({}, 'Request unknown error', {});
            lastValue = undefined;
            head.removeChild(script);
            loaded = 1;
        };
        script.onload = script.onreadystatechange = function () {
            if ((script[readyState] && script[readyState] !== 'complete' && script[readyState] !== 'loaded') || loaded) {
                return false;
            }
            script.onerror = script.onload = script.onreadystatechange = null;
            if (script.onclick) {
                script.onclick();
            }
            // Call the user callback with the last value stored and clean up values and scripts.
            fn(lastValue);
            lastValue = undefined;
            head.removeChild(script);
            loaded = 1;
        };

        // Add the script to the DOM head
        head.appendChild(script);

        // Enable JSONP timeout
        return {
            abort: function () {
                script.onerror = script.onload = script.onreadystatechange = null;
                err({}, 'Request is aborted: timeout', {});
                lastValue = undefined;
                head.removeChild(script);
                loaded = 1;
            }
        };
    }

    function getRequest(fn, err) {
        var o = this.options,
            method = (o.type || 'GET').toUpperCase(),
            url = typeof o === 'string' ? o : o.url,
            // convert non-string objects to query-string form unless o.processData is false
            data = (o.processData !== false && o.data && typeof o.data !== 'string') ? Ajax.toQueryString(o.data) : (o.data || null),
            http,
            sendWait = false;

        // if we're working on a GET request and we have data then we should append
        // query string to end of URL and not post data
        if ((o.type === 'jsonp' || method === 'GET') && data) {
            url = urlappend(url, data);
            data = null;
        }

        if (o.type === 'jsonp') {
            return handleJsonp(o, fn, err, url);
        }

        http = xhr(o);
        http.open(method, url, o.async === false ? false : true);

        setHeaders(http, o);
        setCredentials(http, o);

        if (win[xDomainRequest] && http instanceof win[xDomainRequest]) {
            http.onload = fn;
            http.onerror = err;
            sendWait = true;
        } else {
            http.onreadystatechange = handleReadyState(this, fn, err);
        }
        if (sendWait) {
            setTimeout(function () {
                http.send(data);
            }, 200);
        } else {
            http.send(data);
        }
        return http;
    }

    function buildParams(prefix, obj, traditional, add) {
        var name, i, v,
            rbracket = /\[\]$/;

        if (DG.Util.isArray(obj)) {
        // Serialize array item.
            for (i = 0; obj && i < obj.length; i++) {
                v = obj[i];
                if (traditional || rbracket.test(prefix)) {
                    // Treat each array item as a scalar.
                    add(prefix, v);
                } else {
                    buildParams(prefix + '[' + (typeof v === 'object' ? i : '') + ']', v, traditional, add);
                }
            }
        } else if (obj && obj.toString() === '[object Object]') {
            // Serialize object item.
            for (name in obj) {
                if (obj.hasOwnProperty(name)) {
                    buildParams(prefix + '[' + name + ']', obj[name], traditional, add);
                }
            }
        } else {
            // Serialize scalar item.
            add(prefix, obj);
        }
    }

    function setType(url) {
        var m = url.match(/\.(json|jsonp|html|xml)(\?|$)/);
        return m ? m[1] : 'js';
    }

    function isCrossDomain(url) {
        var parts = rurl.exec(url.toLowerCase());
        return !!(parts &&
                (parts[1] !== ajaxLocParts[1] || parts[2] !== ajaxLocParts[2] ||
                    (parts[3] || (parts[1] === 'http:' ? '80' : '443')) !==
                        (ajaxLocParts[3] || (ajaxLocParts[1] === 'http:' ? '80' : '443')))
            );
    }

    function doRequest(o) {

        if (!('crossDomain' in o)) {
            o.crossDomain = isCrossDomain(o.url);
        }

        var self = {};
        self.promise = new Promise(function (resolve, reject) {
            self.abort = function () {
                self._aborted = true;
                reject('aborted');
            };

            self.url = o.url;
            self.timeout = null;
            self.options = o;

            self._aborted = false;
            self._erred = false;
            self._responseArgs = {};

            var type = o.type === 'jsonp' ? o.type : (o.dataType || setType(self.url));

            if (o.timeout) {
                self.timeout = setTimeout(function () {
                    self.abort();
                }, o.timeout);
            }

            function complete(resp) {
                if (o.timeout) {
                    clearTimeout(self.timeout);
                }
                self.timeout = null;
                if (self._erred) {
                    reject(resp);
                } else {
                    resolve(resp);
                }
            }

            function success(resp) {
                resp = (type !== 'jsonp') ? self.request : resp;
                // use global data filter on response text
                var filteredResponse = globalSetupOptions.dataFilter(resp.responseText, type),
                    r = filteredResponse;

                try {
                    resp.responseText = r;
                } catch (e) {
                    // can't assign this in IE<=8, just ignore
                }
                /* eslint-disable no-eval */
                if (r) {
                    switch (type) {
                    case 'json':
                        try {
                            resp = win.JSON ? win.JSON.parse(r) : eval('(' + r + ')');
                        } catch (err) {
                            return error(resp, 'Could not parse JSON in response', err);
                        }
                        break;
                    case 'js':
                        resp = eval('(' + r + ')');
                        break;
                    case 'html':
                        resp = r;
                        break;
                    case 'xml':
                        resp = resp.responseXML && resp.responseXML.parseError && resp.responseXML.parseError.errorCode && resp.responseXML.parseError.reason ? null : resp.responseXML;
                        break;
                    }
                }
                /* eslint-enable no-eval */
                self._responseArgs.resp = resp;
                complete(resp);
            }

            function error(resp, msg, t) {
                resp = self.request;
                self._responseArgs.resp = resp;
                self._responseArgs.msg = msg;
                self._responseArgs.t = t;
                self._erred = true;
                complete(resp);
            }

            self.request = getRequest.call(self, success, error);
        });

        return self;
    }

    function Ajax(url, options) {

        if (Object.prototype.toString.call(url) === '[object Object]') {
            options = url;
            url = undefined;
        }
        options = options || {};
        options.url = url || options.url;

        var requestPromise = doRequest(options),
            resultPromise = requestPromise.promise;

        if (options.success || options.error || options.complete) {
            resultPromise.then(options.success, options.error);
        }

        resultPromise.abort = requestPromise.abort;

        return resultPromise;
    }

    Ajax.setup = function (options) {
        options = options || {};
        for (var k in options) {
            if (options.hasOwnProperty(k)) {
                globalSetupOptions[k] = options[k];
            }
        }
    };

    Ajax.toQueryString = function (o, trad) {
        var prefix, i,
            traditional = trad || false,
            s = [],
            enc = encodeURIComponent,
            add = function (key, value) {
                // If value is a function, invoke it and return its value
                if (typeof value == 'function') {
                    value = value();
                } else {
                    value = value || '';
                }

                s[s.length] = enc(key) + '=' + enc(value);
            };

        // If an array was passed in, assume that it is an array of form elements.
        if (DG.Util.isArray(o)) {
            for (i = 0; o && i < o.length; i++) {
                add(o[i].name, o[i].value);
            }
        } else {
            // If traditional, encode the "old" way (the way 1.3.2 or older
            // did it), otherwise encode params recursively.
            for (prefix in o) {
                if (o.hasOwnProperty(prefix)) {
                    buildParams(prefix, o[prefix], traditional, add);
                }
            }
        }

        // spaces should be + according to spec
        return s.join('&').replace(/%20/g, '+');
    };

    var testxhr = win[xmlHttpRequest] ? new XMLHttpRequest() : null;

    Ajax.corsSupport = !(!(testxhr && 'withCredentials' in testxhr) && !win[xDomainRequest]) &&
        // cors not available in IE and with cyrillic domain
        !(DG.Browser.ie && document.location.host.toLowerCase().search(/[-]/) != -1);

    return Ajax;
})();

DG.Label = DG.Layer.extend({

    options: {
        offset: new DG.Point(12, 15),
        className: 'dg-label',
        zIndexOffset: 0
    },

    _typeOfString : Object.prototype.toString.call('s'),
    _defaultZIndex: 100,

    initialize: function (content, options) {
        DG.Util.setOptions(this, options);

        this._animated = DG.Browser.any3d;
        this._content = content;
    },

    onAdd: function (map) {
        this._map = map;

        if (!this._el) {
            this._initDOM();
        }

        this._visible = true;

        this
            .setContent(this._content)
            ._onViewReset();

        map
            .on('viewreset', this._onViewReset, this)
            .on('zoomanim', this._onZoomAnimation, this);
    },

    onRemove: function (map) {
        map
            .off('viewreset', this._onViewReset, this)
            .off('zoomanim', this._onZoomAnimation, this);

        this._visible = false;

        this._el.removeChild(this._container);
        DG.Util.falseFn(this._container.offsetWidth); // we need reflow here
        this._container = null;

        map.getPanes().markerPane.removeChild(this._el);
        this._el = null;
    },

    _initDOM: function () {
        this._el = DG.DomUtil.create(
                        'div',
                        this.options.className + ' leaflet-zoom-' + (this._animated ? 'animated' : 'hide'),
                        this._map.getPanes().markerPane);
        this._el.style.zIndex = this._defaultZIndex + this.options.zIndexOffset;

        this._container = DG.DomUtil.create('div', this.options.className + '__content', this._el);
        DG.DomUtil.disableTextSelection(this._container);
        DG.DomEvent
            .disableClickPropagation(this._el)
            .on(this._container, 'mousewheel', DG.DomEvent.stopPropagation)
            .on(this._container, 'contextmenu', DG.DomEvent.stopPropagation);
    },

    _onViewReset: function () {
        if (this._visible && this._latlng) {
            DG.DomUtil.setPosition(this._el, this._map.latLngToLayerPoint(this._latlng).add(this.options.offset), DG.Browser.ie);
        }
    },

    _onZoomAnimation: function (opt) {
        if (this._latlng) {
            DG.DomUtil.setPosition(this._el, this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center).add(this.options.offset));
        }
    },

    setOffset: function (point) {
        if (point instanceof DG.Point) {
            this.options.offset = point;
            this._onViewReset();
        }
        return this;
    },

    setZIndexOffset: function (zIndex) {
        if (!isNaN(+zIndex)) {
            this.options.zIndexOffset = +zIndex;
            if (this._visible) {
                this._el.style.zIndex = this._defaultZIndex + this.options.zIndexOffset;
            }
        }
        return this;
    },

    setContent: function (content) {
        if (Object.prototype.toString.call(content) !== this._typeOfString) {
            return this;
        }
        this._content = content;
        if (this._visible) {
            this._container.innerHTML = content;
        }
        return this;
    },

    setPosition: function (latlng) {
        if (!(latlng instanceof DG.LatLng)) {
            return this;
        }

        this._latlng = latlng;
        this._onViewReset();
        return this;
    }
});

DG.label = function (content, options) {
    return new DG.Label(content, options);
};

DG.Marker.include({

    bindLabel: function (content, options) {
        if (this._label) {
            this._label.setContent(content);
            if (options) {
                if (this.options.offset !== options.offset) {
                    this._label.setOffset(this.options.offset = options.offset);
                }
                if (this.options.static !== options.static) {
                    this.unbindLabel().bindLabel(content, options);
                }
            }
        } else {
            options = DG.extend({
                offset: new DG.Point(5, 5)
            }, options);

            this._label = DG.label(content, options);

            this.once('remove', this.unbindLabel);

            if (options.static) {
                this.showLabel();
            } else {
                this
                    .on('mouseover', this._mouseOverLabel)
                    .on('mouseout', this._mouseOutLabel)
                    .on('dragstart', this._dragStartLabel)
                    .on('dragend', this._dragEndLabel);
            }

            if (typeof this._map !== 'undefined') {
                this._updateLabelZIndex();
            } else {
                this.once('add', this._updateLabelZIndex);
            }
        }
        return this;
    },

    unbindLabel: function () {
        if (this._label) {
            this
                .hideLabel()
                .off('remove', this.unbindLabel)
                .off('mouseover', this._mouseOverLabel)
                .off('mouseout', this._mouseOutLabel)
                .off('dragstart', this._dragStartLabel)
                .off('dragend', this._dragEndLabel)
                .off('move', this._updatePosition)
                .off('add', this._updateLabelZIndex);

            this._label = null;
        }
        return this;
    },

    getLabel: function () {
        return this._label ? this._label : null;
    },

    _originalUpdateZIndex: DG.Marker.prototype._updateZIndex,
    _updateZIndex: function (offset) {
        this._originalUpdateZIndex(offset);
        this._updateLabelZIndex();
        return this;
    },

    _updateLabelZIndex: function () {
        if (this._label && this._icon) {
            this._label.setZIndexOffset(this._icon.style.zIndex);
        }
        return this;
    },

    showLabel : function () {
        if (this._label) {
            this
                .on('move', this._updatePosition)
                ._map.addLayer(this._label.setPosition(this.getLatLng()));
        }

        return this;
    },

    hideLabel : function () {
        if (this._label) {
            this
                .off('move', this._updatePosition)
                ._map.removeLayer(this._label);
        }
        return this;
    },

    _updatePosition : function () {
        this._label.setPosition(this.getLatLng());
    },

    _dragStartLabel: function () {
        this._label.isMarkerDragging = true;

        this.hideLabel();
    },

    _dragEndLabel: function () {
        this._label.isMarkerDragging = false;

        if (this._label.isMouseOverMarker) {
            this.showLabel();
        }
    },

    _mouseOverLabel: function () {
        this._label.isMouseOverMarker = true;

        if (!this._label.isMarkerDragging) {
            this.showLabel();
        }
    },

    _mouseOutLabel: function () {
        this._label.isMouseOverMarker = false;

        this.hideLabel();
    }
});

DG.Marker.addInitHook(function () {
    if (typeof this.options.label !== 'undefined') {
        this.bindLabel(this.options.label);
    }
});

DG.Path.include({
    bindLabel: function (content, options) {

        if (!this._label) {
            this._label = DG.label(content, options);
            this.on(this._labelEvents, this);
        } else {
            this._label.setContent(content);

            if (this._label.options.offset !== options.offset) {
                this._label.setOffset(options.offset);
            }
        }
        return this;
    },

    unbindLabel: function () {
        if (this._label) {
            this.off(this._labelEvents, this);
            this._map.removeLayer(this._label);
            this._label = null;
        }
        return this;
    },

    getLabel: function () {
        return this._label ? this._label : null;
    },

    _labelEvents : {
        'mouseover': function (event) {
            this._map.addLayer(this._label.setPosition(event.latlng));
        },
        'mousemove': function (event) {
            this._label.setPosition(event.latlng);
        },
        'mouseout': function () {
            this._map.removeLayer(this._label);
        },
        'remove': function () {
            this._map.removeLayer(this._label);
        }
    }
});

DG.Path.addInitHook(function () {
    if (typeof this.options.label !== 'undefined') {
        this.bindLabel(this.options.label);
    }
});

DG.Wkt = {};

DG.Wkt.toGeoJSON = function (_) {
    if (DG.Util.isArray(_)) {
        _ = _[0];
    }
    var parts = _.split(';');
    _ = parts.pop();

    var i = 0,
        srid = (parts.shift() || '').split('=').pop();

    function $(re) {
        var match = _.substring(i).match(re);
        if (!match) {
            return null;
        }
        else {
            i += match[0].length;
            return match[0];
        }
    }

    function crs(obj) {
        if (obj && srid.match(/\d+/)) {
            obj.crs = {
                type: 'name',
                'properties': {
                    name: 'urn:ogc:def:crs:EPSG::' + srid
                }
            };
        }

        return obj;
    }

    function white() { $(/^\s*/); }

    function multicoords() {
        white();
        var depth = 0, rings = [], stack = [rings],
            pointer = rings, elem;
        while (elem =
            $(/^(\()/) ||
            $(/^(\))/) ||
            $(/^(\,)/) ||
            $(/^[-+]?([0-9]*\.[0-9]+|[0-9]+)/)) {
            if (elem === '(') {
                stack.push(pointer);
                pointer = [];
                stack[stack.length - 1].push(pointer);
                depth++;
            } else if (elem === ')') {
                pointer = stack.pop();
                depth--;
                if (depth === 0) {
                    break;
                }
            } else if (elem === ',') {
                pointer = [];
                stack[stack.length - 1].push(pointer);
            } else {
                pointer.push(parseFloat(elem));
            }
            white();
        }
        stack.length = 0;
        if (depth !== 0) {
            return null;
        }
        return rings;
    }

    function coords() {
        var list = [], item, pt;
        while (pt =
            $(/^[-+]?([0-9]*\.[0-9]+|[0-9]+)/) ||
            $(/^(\,)/)) {
            if (pt === ',') {
                list.push(item);
                item = [];
            } else {
                if (!item) {
                    item = [];
                }
                item.push(parseFloat(pt));
            }
            white();
        }
        if (item) {
            list.push(item);
        }
        return list.length ? list : null;
    }

    function point() {
        if (!$(/^(point)/i)) { return null; }
        white();
        if (!$(/^(\()/)) { return null; }
        var c = coords();
        white();
        if (!$(/^(\))/)) { return null; }
        return {
            type: 'Point',
            coordinates: c[0]
        };
    }

    function multipoint() {
        if (!$(/^(multipoint)/i)) { return null; }
        white();
        var c = multicoords();
        white();
        return {
            type: 'MultiPoint',
            coordinates: c
        };
    }

    function multilinestring() {
        if (!$(/^(multilinestring)/i)) { return null; }
        white();
        var c = multicoords();
        white();
        return {
            type: 'MultiLineString',
            coordinates: c
        };
    }

    function linestring() {
        if (!$(/^(linestring)/i)) { return null; }
        white();
        if (!$(/^(\()/)) { return null; }
        var c = coords();
        if (!$(/^(\))/)) { return null; }
        return {
            type: 'LineString',
            coordinates: c
        };
    }

    function polygon() {
        if (!$(/^(polygon)/i)) { return null; }
        white();
        return {
            type: 'Polygon',
            coordinates: multicoords()
        };
    }

    function multipolygon() {
        if (!$(/^(multipolygon)/i)) { return null; }
        white();
        return {
            type: 'MultiPolygon',
            coordinates: multicoords()
        };
    }

    function geometrycollection() {
        var geometries = [], geometry;

        if (!$(/^(geometrycollection)/i)) { return null; }
        white();

        if (!$(/^(\()/)) { return null; }
        while (geometry = root()) {
            geometries.push(geometry);
            white();
            $(/^(\,)/);
            white();
        }
        if (!$(/^(\))/)) { return null; }

        return {
            type: 'GeometryCollection',
            geometries: geometries
        };
    }

    function root() {
        return point() ||
            linestring() ||
            polygon() ||
            multipoint() ||
            multilinestring() ||
            multipolygon() ||
            geometrycollection();
    }

    return crs(root());
};

DG.Wkt.geoJsonLayer = function (data, opts) {
    return DG.geoJson(DG.Wkt.toGeoJSON(data), opts);
};

DG.Wkt.toLatLngs = function (data) {
    var coords = DG.Wkt.toGeoJSON(data).coordinates;
    return DG.Util.isArray(coords) ?
        coords
            .map(function (coord) {
                return DG.Util.isArray(coord[0]) ? DG.GeoJSON.coordsToLatLngs(coord) : [DG.GeoJSON.coordsToLatLng(coord)];
            })
            .reduce(function (arr, coord) {
                return arr.concat(coord);
            }) :
        DG.GeoJSON.coordsToLatLngs(coords);
};

DG.Wkt.toPoints = function (data) {
    return DG.Wkt.toGeoJSON(data).coordinates;
};

DG.Wkt.pointsToLatLngOnMap = function (wkt, map) {
    return (function parsePoints(points) {
        return (Array.isArray(points) && Array.isArray(points[0])) ?
            points.map(parsePoints) :
            map.containerPointToLatLng(points);
    })(DG.Wkt.toPoints(wkt));
};

DG.configTheme = DG.configTheme || {};

DG.configTheme.balloonOptions = {
    offset: {
        x: 1,
        y: -43
    }
};

(function(window, undefined) {
    'use strict';

    if (!window) return; // Server side

var
    _baron = window.baron, // Stored baron value for noConflict usage
    $ = window.jQuery, // Trying to use jQuery
    origin = {
        v: { // Vertical
            x: 'Y', pos: 'top', crossPos: 'left', size: 'height', crossSize: 'width',
            client: 'clientHeight', crossClient: 'clientWidth', offset: 'offsetHeight', crossOffset: 'offsetWidth', offsetPos: 'offsetTop',
            scroll: 'scrollTop', scrollSize: 'scrollHeight'
        },
        h: { // Horizontal
            x: 'X', pos: 'left', crossPos: 'top', size: 'width', crossSize: 'height',
            client: 'clientWidth', crossClient: 'clientHeight', offset: 'offsetWidth', crossOffset: 'offsetHeight', offsetPos: 'offsetLeft',
            scroll: 'scrollLeft', scrollSize: 'scrollWidth'
        }
    },

    each = function(obj, iterator) {
        var i = 0;

        if (obj.length === undefined || obj === window) obj = [obj];

        while (obj[i]) {
            iterator.call(this, obj[i], i);
            i++;
        }
    },

    baron = function(params) { // this - window or jQuery instance
        var jQueryMode = false,//(this && this[0] && this[0].nodeType),
            roots,
            $;

        params = params || {};
        $ = params.$ || window.jQuery;

        if (jQueryMode) {
            params.root = roots = this;
        } else {
            roots = $(params.root || params.scroller);
        }

        return new baron.fn.constructor(roots, params, $);
    };

    baron.fn = {
        constructor: function(roots, input, $) {
            var params = validate(input);

            params.$ = $;
            each.call(this, roots, function(root, i) {
                var localParams = clone(params);

                if (params.root && params.scroller) {
                    localParams.scroller = params.$(params.scroller, root);
                    if (!localParams.scroller.length) {
                        localParams.scroller = root;
                    }
                } else {
                    localParams.scroller = root;
                }

                localParams.root = root;
                this[i] = init(localParams);
                this.length = i + 1;
            });

            this.params = params;
        },

        dispose: function() {
            var params = this.params;

            each(this, function(item) {
                item.dispose(params);
            });
            this.params = null;
        },

        update: function() {
            var i = 0;

            while (this[i]) {
                this[i].update.apply(this[i], arguments);
                i++;
            }
        },

        baron: function(params) {
            params.root = [];
            params.scroller = this.params.scroller;

            each.call(this, this, function(elem) {
                params.root.push(elem.root);
            });
            params.direction = (this.params.direction == 'v') ? 'h' : 'v';
            params._chain = true;

            return baron(params);
        }
    };

    function manageEvents(item, eventManager, mode) {
        item._eventHandlers = item._eventHandlers || [ // Creating new functions for one baron item only one time
            {
                // onScroll:
                element: item.scroller,

                handler: function(e) {
                    item.scroll(e);
                },

                type: 'scroll'
            }, {
                // onMouseDown:
                element: item.bar,

                handler: function(e) {
                    e.preventDefault ? e.preventDefault() : e.returnValue = false; // Text selection disabling in Opera... and all other browsers?
                    item.selection(); // Disable text selection in ie8
                    item.drag.now = 1; // Save private byte
                },

                type: 'touchstart mousedown'
            }, {
                // onMouseUp:
                element: document,

                handler: function() {
                    item.selection(1); // Enable text selection
                    item.drag.now = 0;
                },

                type: 'mouseup blur touchend'
            }, {
                // onCoordinateReset:
                element: item.bar,

                handler: function(e) {
                    if (e.button != 2) { // Not RM
                        item._pos0(e);
                    }
                },

                type: 'touchstart mousedown'
            }, {
                // onMouseMove:
                element: document,

                handler: function(e) {
                    if (item.drag.now) {
                        item.drag(e);
                    }
                },

                type: 'mousemove touchmove'
            }, {
                // onResize:
                element: window,

                handler: function() {
                    item.update();
                },

                type: 'resize'
            }, {
                // sizeChange:
                element: item.root,

                handler: function() {
                    item.update();
                },

                type: 'sizeChange'
            }
        ];

        each(item._eventHandlers, function(event) {
            if (event.element) {
                eventManager(event.element, event.type, event.handler, mode);
            }
        });

        // if (item.scroller) {
        //     event(item.scroller, 'scroll', item._eventHandlers.onScroll, mode);
        // }
        // if (item.bar) {
        //     event(item.bar, 'touchstart mousedown', item._eventHandlers.onMouseDown, mode);
        // }
        // event(document, 'mouseup blur touchend', item._eventHandlers.onMouseUp, mode);
        // event(document, 'touchstart mousedown', item._eventHandlers.onCoordinateReset, mode);
        // event(document, 'mousemove touchmove', item._eventHandlers.onMouseMove, mode);
        // event(window, 'resize', item._eventHandlers.onResize, mode);
        // if (item.root) {
        //     event(item.root, 'sizeChange', item._eventHandlers.onResize, mode); // Custon event for alternate baron update mechanism
        // }
    }

    function manageAttr(node, direction, mode) {
        var attrName = 'data-baron-' + direction;

        if (mode == 'on') {
            node.setAttribute(attrName, 'inited');
        } else if (mode == 'off') {
            node.removeAttribute(attrName);
        } else {
            return node.getAttribute(attrName);
        }
    }

    function init(params) {
        if (manageAttr(params.root, params.direction)) return;

        var out = new item.prototype.constructor(params); // __proto__ of returning object is baron.prototype

        manageEvents(out, params.event, 'on');

        manageAttr(out.root, params.direction, 'on');

        out.update();

        return out;
    }

    function clone(input) {
        var output = {};

        input = input || {};

        for (var key in input) {
            if (input.hasOwnProperty(key)) {
                output[key] = input[key];
            }
        }

        return output;
    }

    function validate(input) {
        var output = clone(input);

        output.direction = output.direction || 'v';

        var event = input.event || function(elem, event, func, mode) {
            output.$(elem)[mode || 'on'](event, func);
        };

        output.event = function(elems, e, func, mode) {
            each(elems, function(elem) {
                event(elem, e, func, mode);
            });
        };

        return output;
    }

    function fire(eventName) {
        /* jshint validthis:true */
        if (this.events && this.events[eventName]) {
            for (var i = 0 ; i < this.events[eventName].length ; i++) {
                var args = Array.prototype.slice.call( arguments, 1 );

                this.events[eventName][i].apply(this, args);
            }
        }
    }

    var item = {};

    item.prototype = {
        constructor: function(params) {
            var $,
                barPos,
                scrollerPos0,
                track,
                resizePauseTimer,
                scrollPauseTimer,
                pause,
                scrollLastFire,
                resizeLastFire;

            resizeLastFire = scrollLastFire = new Date().getTime();

            $ = this.$ = params.$;
            this.event = params.event;
            this.events = {};

            function getNode(sel, context) {
                return $(sel, context)[0]; // Can be undefined
            }

            // DOM elements
            this.root = params.root; // Always html node, not just selector
            this.scroller = getNode(params.scroller); // (params.scroller) ? getNode(params.scroller, this.root) : this.root;
            this.bar = getNode(params.bar, this.root);
            track = this.track = getNode(params.track, this.root);
            if (!this.track && this.bar) {
                track = this.bar.parentNode;
            }
            this.clipper = this.scroller.parentNode;

            // Parameters
            this.direction = params.direction;
            this.origin = origin[this.direction];
            this.barOnCls = params.barOnCls;
            this.barTopLimit = 0;
            pause = params.pause * 1000 || 0;

            // Updating height or width of bar
            function setBarSize(size) {
                /* jshint validthis:true */
                var barMinSize = this.barMinSize || 20;

                if (size > 0 && size < barMinSize) {
                    size = barMinSize;
                }

                if (this.bar) {
                    $(this.bar).css(this.origin.size, parseInt(size, 10) + 'px');
                }
            }

            // Updating top or left bar position
            function posBar(pos) {
                /* jshint validthis:true */
                if (this.bar) {
                    $(this.bar).css(this.origin.pos, +pos + 'px');
                }
            }

            // Free path for bar
            function k() {
                /* jshint validthis:true */
                return track[this.origin.client] - this.barTopLimit - this.bar[this.origin.offset];
            }

            // Relative content top position to bar top position
            function relToPos(r) {
                /* jshint validthis:true */
                return r * k.call(this) + this.barTopLimit;
            }

            // Bar position to relative content position
            function posToRel(t) {
                /* jshint validthis:true */
                return (t - this.barTopLimit) / k.call(this);
            }

            // Cursor position in main direction in px // Now with iOs support
            this.cursor = function(e) {
                return e['client' + this.origin.x] || (((e.originalEvent || e).touches || {})[0] || {})['page' + this.origin.x];
            };

            // Text selection pos preventing
            function dontPosSelect() {
                return false;
            }

            this.pos = function(x) { // Absolute scroller position in px
                var ie = 'page' + this.origin.x + 'Offset',
                    key = (this.scroller[ie]) ? ie : this.origin.scroll;

                if (x !== undefined) this.scroller[key] = x;

                return this.scroller[key];
            };

            this.rpos = function(r) { // Relative scroller position (0..1)
                var free = this.scroller[this.origin.scrollSize] - this.scroller[this.origin.client],
                    x;

                if (r) x = this.pos(r * free);
                else x = this.pos();

                return x / (free || 1);
            };

            // Switch on the bar by adding user-defined CSS classname to scroller
            this.barOn = function(dispose) {
                if (this.barOnCls) {
                    if (dispose || this.scroller[this.origin.client] >= this.scroller[this.origin.scrollSize]) {
                        $(this.root).removeClass(this.barOnCls);
                    } else {
                        $(this.root).addClass(this.barOnCls);
                    }
                }
            };

            this._pos0 = function(e) {
                scrollerPos0 = this.cursor(e) - barPos;
            };

            this.drag = function(e) {
                this.scroller[this.origin.scroll] = posToRel.call(this, this.cursor(e) - scrollerPos0) * (this.scroller[this.origin.scrollSize] - this.scroller[this.origin.client]);
            };

            // Text selection preventing on drag
            this.selection = function(enable) {
                this.event(document, 'selectpos selectstart', dontPosSelect, enable ? 'off' : 'on');
            };

            // onResize & DOM modified handler
            this.resize = function() {
                var self = this,
                    delay = 0;

                if (new Date().getTime() - resizeLastFire < pause) {
                    clearTimeout(resizePauseTimer);
                    delay = pause;
                }

                function upd() {
                    var delta = self.scroller[self.origin.crossOffset] - self.scroller[self.origin.crossClient];

                    if (params.freeze && !self.clipper.style[self.origin.crossSize]) { // Sould fire only once
                        $(self.clipper).css(self.origin.crossSize, self.clipper[self.origin.crossClient] - delta + 'px');
                    }
                    $(self.scroller).css(self.origin.crossSize, self.clipper[self.origin.crossClient] + delta + 'px');

                    Array.prototype.unshift.call(arguments, 'resize');
                    fire.apply(self, arguments);

                    resizeLastFire = new Date().getTime();
                }

                if (delay) {
                    resizePauseTimer = setTimeout(upd, delay);
                } else {
                    upd();
                }
            };

            // onScroll handler
            this.scroll = function() {
                var oldBarSize, newBarSize,
                    delay = 0,
                    self = this;

                if (new Date().getTime() - scrollLastFire < pause) {
                    clearTimeout(scrollPauseTimer);
                    delay = pause;
                }

                function upd() {
                    if (self.bar) {
                        newBarSize = (track[self.origin.client] - self.barTopLimit) * self.scroller[self.origin.client] / self.scroller[self.origin.scrollSize];

                        // Positioning bar
                        if (oldBarSize != newBarSize) {
                            setBarSize.call(self, newBarSize);
                            oldBarSize = newBarSize;
                        }

                        barPos = relToPos.call(self, self.rpos());

                        posBar.call(self, barPos);
                    }

                    Array.prototype.unshift.call( arguments, 'scroll' );
                    fire.apply(self, arguments);

                    scrollLastFire = new Date().getTime();
                }

                if (delay) {
                    scrollPauseTimer = setTimeout(upd, delay);
                } else {
                    upd();
                }

            };

            return this;
        },

        update: function(params) {
            fire.call(this, 'upd', params); //    

            this.resize(1);
            this.barOn();
            this.scroll();

            return this;
        },

        dispose: function(params) {
            manageEvents(this, this.event, 'off');
            manageAttr(this.root, params.direction, 'off');
            $(this.scroller).css(this.origin.crossSize, '');
            this.barOn(true);
            fire.call(this, 'dispose');
        },

        on: function(eventName, func, arg) {
            var names = eventName.split(' ');

            for (var i = 0 ; i < names.length ; i++) {
                if (names[i] == 'init') {
                    func.call(this, arg);
                } else {
                    this.events[names[i]] = this.events[names[i]] || [];

                    this.events[names[i]].push(function(userArg) {
                        func.call(this, userArg || arg);
                    });
                }
            }
        }
    };

    baron.fn.constructor.prototype = baron.fn;
    item.prototype.constructor.prototype = item.prototype;

    // Use when you need "baron" global var for another purposes
    baron.noConflict = function() {
        window.baron = _baron; // Restoring original value of "baron" global var

        return baron;
    };

    baron.version = '0.6.6';

    if ($ && $.fn) { // Adding baron to jQuery as plugin
        $.fn.baron = baron;
    }
    window.baron = baron; // Use noConflict method if you need window.baron var for another purposes
    if (window['module'] && module.exports) {
        module.exports = baron.noConflict();
    }
})(window);
/* Fixable elements plugin for baron 0.6+ */
(function(window, undefined) {
    var fix = function(userParams) {
        var elements, viewPortSize,
            params = { // Default params
                outside: '',
                before: '',
                after: '',
                past: '',
                future: '',
                radius: 0,
                minView: 0
            },
            topFixHeights = [], // inline style for element
            topRealHeights = [], // real offset position when not fixed
            headerTops = [],
            scroller = this.scroller,
            eventManager = this.event,
            $ = this.$,
            self = this;

        function fixElement(i, pos) {
            if (viewPortSize < (params.minView || 0)) { // No headers fixing when no enought space for viewport
                pos = undefined;
            }

            if (pos !== undefined) {
                pos += 'px';
                this.$(elements[i]).css(this.origin.pos, pos).addClass(params.outside);
            } else {
                this.$(elements[i]).css(this.origin.pos, '').removeClass(params.outside);
            }
        }

        function bubbleWheel(e) {
            try {
                i = document.createEvent('WheelEvent'); // i - for extra byte
                // evt.initWebKitWheelEvent(deltaX, deltaY, window, screenX, screenY, clientX, clientY, ctrlKey, altKey, shiftKey, metaKey);
                i.initWebKitWheelEvent(e.originalEvent.wheelDeltaX, e.originalEvent.wheelDeltaY);
                scroller.dispatchEvent(i);
                e.preventDefault();
            } catch (e) {}
        }

        function init(_params) {
            var pos;

            for (var key in _params) {
                params[key] = _params[key];
            }

            elements = this.$(params.elements, this.scroller);

            if (elements) {
                viewPortSize = this.scroller[this.origin.client];
                for (var i = 0 ; i < elements.length ; i++) {
                    // Variable header heights
                    pos = {};
                    pos[this.origin.size] = elements[i][this.origin.offset];
                    if (elements[i].parentNode !== this.scroller) {
                        this.$(elements[i].parentNode).css(pos);
                    }
                    pos = {};
                    pos[this.origin.crossSize] = elements[i].parentNode[this.origin.crossClient];
                    this.$(elements[i]).css(pos);

                    // Between fixed headers
                    viewPortSize -= elements[i][this.origin.offset];

                    headerTops[i] = elements[i].parentNode[this.origin.offsetPos]; // No paddings for parentNode

                    // Summary elements height above current
                    topFixHeights[i] = (topFixHeights[i - 1] || 0); // Not zero because of negative margins
                    topRealHeights[i] = (topRealHeights[i - 1] || Math.min(headerTops[i], 0));

                    if (elements[i - 1]) {
                        topFixHeights[i] += elements[i - 1][this.origin.offset];
                        topRealHeights[i] += elements[i - 1][this.origin.offset];
                    }

                    if ( !(i == 0 && headerTops[i] == 0)/* && force */) {
                        this.event(elements[i], 'mousewheel', bubbleWheel, 'off');
                        this.event(elements[i], 'mousewheel', bubbleWheel);
                    }
                }

                if (params.limiter && elements[0]) { // Bottom edge of first header as top limit for track
                    if (this.track && this.track != this.scroller) {
                        pos = {};
                        pos[this.origin.pos] = elements[0].parentNode[this.origin.offset];
                        this.$(this.track).css(pos);
                    } else {
                        this.barTopLimit = elements[0].parentNode[this.origin.offset];
                    }
                    // this.barTopLimit = elements[0].parentNode[this.origin.offset];
                    this.scroll();
                }

                if (params.limiter === false) { // undefined (in second fix instance) should have no influence on bar limit
                    this.barTopLimit = 0;
                }
            }

            var event = {
                element: elements,

                handler: function() {
                    var parent = $(this)[0].parentNode,
                        top = parent.offsetTop,
                        num;

                    // finding num -> elements[num] === this
                    for (var i = 0 ; i < elements.length ; i++ ) {
                        if (elements[i] === this) num = i;
                    }

                    var pos = top - topFixHeights[num];

                    if (params.scroll) { // User defined callback
                        params.scroll({
                            x1: self.scroller.scrollTop,
                            x2: pos
                        });
                    } else {
                        self.scroller.scrollTop = pos;
                    }
                },

                type: 'click'
            };

            if (params.clickable) {
                this._eventHandlers.push(event); // For auto-dispose
                eventManager(event.element, event.type, event.handler, 'off');
                eventManager(event.element, event.type, event.handler, 'on');
            }
        }

        this.on('init', init, userParams);

        this.on('init scroll', function() {
            var fixState, hTop,
                fixFlag = []; // 1 - past, 2 - future, 3 - current (not fixed)

            if (elements) {
                var change;

                // fixFlag update
                for (var i = 0 ; i < elements.length ; i++) {
                    fixState = 0;
                    if (headerTops[i] - this.pos() < topRealHeights[i] + params.radius) {
                        // Header trying to go up
                        fixState = 1;
                        hTop = topFixHeights[i];
                    } else if (headerTops[i] - this.pos() > topRealHeights[i] + viewPortSize - params.radius) {
                        // Header trying to go down
                        fixState = 2;
                        hTop = topFixHeights[i] + viewPortSize;
                    } else {
                        // Header in viewport
                        fixState = 3;
                        hTop = undefined;
                    }
                    if (fixState != fixFlag[i]) {
                        fixElement.call(this, i, hTop);
                        fixFlag[i] = fixState;
                        change = true;
                    }
                }

                // Adding positioning classes (on last top and first bottom header)
                if (change) { // At leats one change in elements flag structure occured
                    for (i = 0 ; i < elements.length ; i++) {
                        if (fixFlag[i] == 1 && params.past) {
                            this.$(elements[i]).addClass(params.past).removeClass(params.future);
                        }

                        if (fixFlag[i] == 2 && params.future) {
                            this.$(elements[i]).addClass(params.future).removeClass(params.past);
                        }

                        if (fixFlag[i] == 3 && (params.future || params.past)) {
                            this.$(elements[i]).removeClass(params.past).removeClass(params.future);
                        }

                        if (fixFlag[i] != fixFlag[i + 1] && fixFlag[i] == 1 && params.before) {
                            this.$(elements[i]).addClass(params.before).removeClass(params.after); // Last top fixed header
                        } else if (fixFlag[i] != fixFlag[i - 1] && fixFlag[i] == 2 && params.after) {
                            this.$(elements[i]).addClass(params.after).removeClass(params.before); // First bottom fixed header
                        } else {
                            this.$(elements[i]).removeClass(params.before).removeClass(params.after);
                        }
                    }
                }
            }
        });

        this.on('resize upd', function(updParams) {
            init.call(this, updParams && updParams.fix);
        });
    };

    baron.fn.fix = function(params) {
        var i = 0;

        while (this[i]) {
            fix.call(this[i], params);
            i++;
        }

        return this;
    };
})(window);
/* Controls plugin for baron 0.6+ */
(function(window, undefined) {
    var controls = function(params) {
        var forward, backward, track, screen,
            self = this; // AAAAAA!!!!!11

        screen = params.screen || 0.9;

        if (params.forward) {
            forward = this.$(params.forward, this.clipper);

            this.event(forward, 'click', function() {
                var y = self.pos() - params.delta || 30;

                self.pos(y);
            });
        }

        if (params.backward) {
            backward = this.$(params.backward, this.clipper);

            this.event(backward, 'click', function() {
                var y = self.pos() + params.delta || 30;

                self.pos(y);
            });
        }

        if (params.track) {
            if (params.track === true) {
                track = this.track;
            } else {
                track = this.$(params.track, this.clipper)[0];
            }

            if (track) {
                this.event(track, 'mousedown', function(e) {
                    var x = e['offset' + self.origin.x],
                        xBar = self.bar[self.origin.offsetPos],
                        sign = 0;

                    if (x < xBar) {
                        sign = -1;
                    } else if (x > xBar + self.bar[self.origin.offset]) {
                        sign = 1;
                    }

                    var y = self.pos() + sign * screen * self.scroller[self.origin.client];
                    self.pos(y);
                });
            }
        }

    };

    baron.fn.controls = function(params) {
        var i = 0;

        while (this[i]) {
            controls.call(this[i], params);
            i++;
        }

        return this;
    };
})(window);
/* Pull to load plugin for baron 0.6+ */
(function(window, undefined) {
    var pull = function(params) {
        var block = this.$(params.block),
            size = params.size || this.origin.size,
            limit = params.limit || 80,
            onExpand = params.onExpand,
            elements = params.elements || [],
            inProgress = params.inProgress || '',
            self = this,
            _insistence = 0,
            _zeroXCount = 0,
            _interval,
            _timer,
            _x = 0,
            _onExpandCalled,
            _waiting = params.waiting || 500,
            _on;

        function getSize() {
            return self.scroller[self.origin.scroll] + self.scroller[self.origin.offset];
        }

        // Scroller content height
        function getContentSize() {
            return self.scroller[self.origin.scrollSize];
        }

        // Scroller height
        function getScrollerSize() {
            return self.scroller[self.origin.client];
        }

        function step(x, force) {
            var k = x * 0.0005;

            return Math.floor(force - k * (x + 550));
        }

        function toggle(on) {
            _on = on;

            if (on) {
                update(); // First time with no delay
                _interval = setInterval(update, 200);
            } else {
                clearInterval(_interval);
            }
        }

        function update() {
            var pos = {},
                height = getSize(),
                scrollHeight = getContentSize(),
                dx,
                op4,
                scrollInProgress = _insistence == 1;

            op4 = 0; //  
            if (_insistence > 0) {
                op4 = 40;
            }
            //if (_insistence > -1) {
                dx = step(_x, op4);
                if (height >= scrollHeight - _x && _insistence > -1) {
                    if (scrollInProgress) {
                        _x += dx;
                    }
                } else {
                    _x = 0;
                }

                if (_x < 0) _x = 0;

                pos[size] = _x + 'px';
                if (getScrollerSize() <= getContentSize()) {
                    self.$(block).css(pos);
                    for (var i = 0 ; i < elements.length ; i++) {
                        self.$(elements[i].self).css(elements[i].property, Math.min(_x / limit * 100, 100) + '%');
                    }
                }

                if (inProgress && _x) {
                    self.$(self.root).addClass(inProgress);
                }

                if (_x == 0) {
                    if (params.onCollapse) {
                        params.onCollapse();
                    }
                }

                _insistence = 0;
                _timer = setTimeout(function() {
                    _insistence = -1;
                }, _waiting);
            //}

            if (onExpand && _x > limit && !_onExpandCalled) {
                onExpand();
                _onExpandCalled = true;
            }

            if (_x == 0) {
                _zeroXCount++;
            } else {
                _zeroXCount = 0;

            }
            if (_zeroXCount > 1) {
                toggle(false);
                _onExpandCalled = false;
                if (inProgress) {
                    self.$(self.root).removeClass(inProgress);
                }
            }
        }

        this.on('init', function() {
            toggle(true);
        });

        this.on('dispose', function() {
            toggle(false);
        });

        this.event(this.scroller, 'mousewheel DOMMouseScroll', function(e) {
            var down = e.wheelDelta < 0 || (e.originalEvent && e.originalEvent.wheelDelta < 0) || e.detail > 0;

            if (down) {
                _insistence = 1;
                clearTimeout(_timer);
                if (!_on && getSize() >= getContentSize()) {
                    toggle(true);
                }
            }
            //  else {
            //     toggle(false);
            // }
        });
    };

    baron.fn.pull = function(params) {
        var i = 0;

        while (this[i]) {
            pull.call(this[i], params);
            i++;
        }

        return this;
    };
})(window);

// 2GIS-related popup content wrapper and offset
(function () {
    var offsetX = DG.configTheme.balloonOptions.offset.x,
        offsetY = DG.configTheme.balloonOptions.offset.y,
        originalInitialize = DG.Popup.prototype.initialize,
        originalInitLayout = DG.Popup.prototype._initLayout,
        originalOnAdd = DG.Popup.prototype.onAdd,
        originalAdjustPan = DG.Popup.prototype._adjustPan,
        graf = baron.noConflict();

    var BaronDomHelper = function (element) {
        this[0] = element;
        this.length = 1;
    };
    BaronDomHelper.prototype = {
        setAttribute: function (name, value) {
            this[0].setAttribute(name, value);
            return this;
        },
        getAttribute: function (name) {
            return this[0].getAttribute(name);
        },
        removeAttribute: function (name) {
            this[0].removeAttribute(name);
            return this;
        },
        css: function (style, value) {
            if (value) {
                this[0].style[style] = value;
                return this;
            } else {
                return DG.DomUtil.getStyle(this[0], style);
            }
        }
    };

    DG.Popup.prototype.options.offset = DG.point(offsetX, offsetY);

    DG.Popup.mergeOptions({
        border: 16,
        mapControlsWidth: 60
    });

    DG.Popup.include({
        _headerContent: null,
        _footerContent: null,

        //baron elements references
        _scroller: null,
        _scrollerBar: null,
        _barWrapper: null,
        _baron: null,
        _isBaronExist: false,

        _popupShowClass: 'leaflet-popup_show_true',
        _popupHideClass: 'leaflet-popup_show_false',

        _popupTipClass: 'leaflet-popup-tip-container',
        _tipSVGPath: 'M0 0c12.643 0 28 7.115 28 44h2c0-36.885 15.358-44 28-44h-58z',

        _isAutoPanPaddingUserDefined: false,

        initialize: function (options, source) { // (Object, Object)
            this._popupStructure = {};
            this._isAutoPanPaddingUserDefined = options && options.hasOwnProperty('autoPanPadding');
            originalInitialize.call(this, options, source);
        },

        onAdd: function (map) { // (Map)
            map.on('entranceshow', this._closePopup, this);
            originalOnAdd.call(this, map);
            this._animateOpening();
        },

        onRemove: function (map) { // (Map)
            this._animateClosing();
            map.off('entranceshow', this._closePopup, this);

            if (DG.DomUtil.TRANSITION) {
                this._removeTimeout = setTimeout(L.bind(L.DomUtil.remove, L.DomUtil, this._container), 200);
            } else {
                L.DomUtil.remove(this._container);
            }

            map.fire('popupclose', {popup: this});

            if (this._source) {
                this._source.fire('popupclose', {popup: this}, true);
            }
        },

        setContent: function (content) { // (DOMElement | Object | HTML) -> Popup
            if (!this._isNode(content) && typeof content === 'object') {
                Object.keys(content).forEach(function (item) {
                    this['_' + item + 'Content'] = content[item];
                }, this);
            } else {
                this._bodyContent = content;
            }

            this.update();

            return this;
        },

        setHeaderContent: function (content) { // (HTML) -> Popup
            this._headerContent = content;
            this.update();

            return this;
        },

        setFooterContent: function (content) { // (HTML) -> Popup
            this._footerContent = content;
            this.update();

            return this;
        },

        getContent: function() { // () -> HTML
            return this._bodyContent;
        },

        getHeaderContent: function() { // () -> HTML
            return this._headerContent;
        },

        getFooterContent: function() { // () -> HTML
            return this._footerContent;
        },

        clear: function () { // () -> Popup
            Object.keys(this._popupStructure).forEach(this._clearElement, this);

            // think about move this set to another public method
            this._isBaronExist = false;
            return this;
        },

        clearHeader: function () { // () -> Popup
            return this._clearElement('header');
        },

        clearFooter: function () { // () -> Popup
            return this._clearElement('footer');
        },

        findElement: function (element) { // (String) -> DOMElement
            return this._contentNode.querySelector(element);
        },

        _animateOpening: function () {
            DG.DomUtil.addClass(this._innerContainer, this._popupShowClass);
            DG.DomUtil.removeClass(this._innerContainer, this._popupHideClass);
        },

        _animateClosing: function () {
            DG.DomUtil.addClass(this._innerContainer, this._popupHideClass);
            DG.DomUtil.removeClass(this._innerContainer, this._popupShowClass);
        },

        _closePopup: function () {
            this._map.closePopup(this);
        },

        _isNode: function (o) { // (Object) -> Boolean
            return (o.nodeName ? true : false);
        },

        _initLayout: function () {
            originalInitLayout.call(this);
            this._innerContainer = DG.DomUtil.create('div', 'leaflet-popup-inner ' + this._popupHideClass, this._container);

            // Prevents mouse events from leaking through close button
            // See https://github.com/2gis/mapsapi/pull/153/
            DG.DomEvent.disableClickPropagation(this._innerContainer);

            if (this.options.closeButton) {
                this._innerContainer.appendChild(this._detachEl(this._closeButton));
            }

            this._innerContainer.appendChild(this._detachEl(this._wrapper));

            var tip = this._detachEl(this._tipContainer);

            if (DG.Browser.svg) {
                var path = DG.SVG.create('path');
                var svgClass = this._popupTipClass + ' ' + this._popupTipClass + '_svg';

                path.setAttribute('d', this._tipSVGPath);

                tip = DG.SVG.create('svg');
                tip.setAttribute('class', svgClass);

                tip.appendChild(path);
                DG.DomEvent.disableClickPropagation(path);
            } else {
                DG.DomUtil.addClass(tip, this._popupTipClass + '_image');
                DG.DomEvent.disableClickPropagation(tip);
            }

            this._innerContainer.appendChild(tip);
        },

        _clearElement: function (elem) { // (DOMElement) -> Popup
            this['_' + elem + 'Content'] = null;
            this._detachEl(this._popupStructure[elem]);
            delete this._popupStructure[elem];
            return this;
        },

        _updateScrollPosition: function () {
            if (this._baron) {
                this._baron.update();
            }
        },

        resize: function () {
            var scrolled = this._updateLayout();
            this._updatePosition();

            if (!scrolled) {
                if (this._isBaronExist) {
                    this._scrollerWrapper.style.height = '';
                    DG.DomUtil.removeClass(this._scroller, 'dg-scroller');

                    DG.DomUtil.addClass(this._scroller, 'dg-scroller_hidden_true');
                    DG.DomUtil.removeClass(this._scroller, 'dg-scroller');
                    DG.DomEvent.off(this._scroller, 'scroll', this._onScroll);
                }
            } else if (this._isBaronExist) {
                DG.DomUtil.removeClass(this._scroller, 'dg-scroller_hidden_true');
                DG.DomUtil.addClass(this._scroller, 'dg-scroller');

                var scrollTop = this._isBaronExist ? this._scroller.scrollTop : false;

                if (scrollTop) {
                    this._scroller.scrollTop = scrollTop;
                }

                var innerHeight = this.options.maxHeight - this.options.border * 2 - this._getDelta();
                this._scrollerWrapper.style.height = innerHeight + 'px';

                this._updateScrollPosition();
            } else {
                this._initBaronScroller();
                this._initBaron();
            }

            this._adjustPan();
            this._bindAdjustPanOnTransitionEnd();
        },

        _adjustPan: function (e) {
            if (!this._map) { return; }

            if (e) {
                if (e.propertyName === 'max-height') {
                    setTimeout(originalAdjustPan.bind(this), 1); //JSAPI-3409 fix safari glich
                    DG.DomEvent.off(this._wrapper, DG.DomUtil.TRANSITION_END, this._adjustPan);
                }

                return;
            }

            var options = this.options;

            if (!options.autoPan) { return; }

            var map = this._map,
                containerHeight = this._container.offsetHeight,
                containerWidth = this._containerWidth,
                layerPos = new L.Point(this._containerLeft, -containerHeight - this._containerBottom);

            if (this._zoomAnimated) {
                layerPos._add(L.DomUtil.getPosition(this._container));
            }

            var autoPanPadding = [options.autoPanPadding[0], options.autoPanPadding[1]];

            // if width of map is more then width of popup and controls
            // set default autoPanPadding to width controls
            if (
                !this._isAutoPanPaddingUserDefined &&
                    this._map._container.offsetWidth >= options.maxWidth + options.mapControlsWidth * 2
            ) {
                autoPanPadding[0] = options.mapControlsWidth;
            }

            var containerPos = map.layerPointToContainerPoint(layerPos),
                padding = L.point(autoPanPadding),
                paddingTL = L.point(options.autoPanPaddingTopLeft || padding),
                paddingBR = L.point(options.autoPanPaddingBottomRight || padding),
                size = map.getSize(),
                dx = 0,
                dy = 0;

            if (containerPos.x + containerWidth + paddingBR.x > size.x) { // right
                dx = containerPos.x + containerWidth - size.x + paddingBR.x;
            }
            if (containerPos.x - dx - paddingTL.x < 0) { // left
                dx = containerPos.x - paddingTL.x;
            }
            if (containerPos.y + containerHeight + paddingBR.y > size.y) { // bottom
                dy = containerPos.y + containerHeight - size.y + paddingBR.y;
            }
            if (containerPos.y - dy - paddingTL.y < 0) { // top
                dy = containerPos.y - paddingTL.y;
            }

            if (dx || dy) {
                map
                    .fire('autopanstart')
                    .panBy([dx, dy]);
            }
        },

        _bindAdjustPanOnTransitionEnd: function () {
            if (DG.DomUtil.TRANSITION) {
                DG.DomEvent.on(this._wrapper, DG.DomUtil.TRANSITION_END, this._adjustPan, this);
            } else {
                this._adjustPan();
            }
        },

        _isContentHeightEnough: function () { // () -> Boolean
            var options = this.options;

            if (!options.maxHeight) {
                return true;
            }

            var popupHeight = this._popupStructure.body ?
                this._popupStructure.body.offsetHeight + this._getDelta() :
                this._contentNode.offsetHeight;

            popupHeight += options.border * 2;

            return popupHeight <= options.maxHeight;
        },

        _initBaronScroller: function () {
            var contentNode = this._popupStructure.body.parentNode,
                scrollerWrapper = this._scrollerWrapper = DG.DomUtil.create('div', 'dg-scroller__wrapper', contentNode),
                scroller = this._scroller = DG.DomUtil.create('div', 'dg-scroller', scrollerWrapper),
                barWrapper = this._barWrapper = DG.DomUtil.create('div', 'dg-scroller__bar-wrapper', scroller),
                innerHeight = this.options.maxHeight - this.options.border * 2;

            this._scrollerBar = DG.DomUtil.create('div', 'dg-scroller__bar', barWrapper);
            scroller.appendChild(this._detachEl(this._popupStructure.body));

            innerHeight -= this._getDelta();
            scrollerWrapper.style.height = Math.max(18, innerHeight) + 'px';
            scrollerWrapper.style.width = contentNode.offsetWidth + 5 + 'px'; //TODO

            this._isBaronExist = true;

            this._switchEvents();
        },

        _onScroll: function (e) {
            this.fire('scroll', {originalEvent: e});
        },

        _onClick: function (e) {
            e.target = e.target || e.srcElement;

            if (!this._moving) {
                this.fire('click', {originalEvent: e});
            }
        },

        _onStart: function (e) {
            this._moved = false;

            if (this._moving) { return; }

            var first = e.touches ? e.touches[0] : e;

            this._startPoint = new DG.Point(first.clientX, first.clientY);

            this._toggleTouchEvents();
        },

        _onEnd: function (e) {
            this._toggleTouchEvents(true);

            this._onClick(e);

            this._moving = false;
        },

        _onMove: function (e) {

            if (e.touches && e.touches.length > 1) {
                this._moved = true;
                return;
            }

            var first = (e.touches && e.touches.length === 1 ? e.touches[0] : e),
                newPoint = DG.point(first.clientX, first.clientY),
                offset = Math.abs(newPoint.subtract(this._startPoint).y);

            if (!offset || offset < 10) { return; }

            this._moving = this._moved = true;

        },

        _initBaron: function () {
            var context = this._scrollerWrapper;
            this._baron = graf({
                scroller: '.dg-scroller',
                bar: '.dg-scroller__bar',
                track: '.dg-scroller__bar-wrapper',
                $: function (selector) {
                    var node = {}.toString.call(selector) === '[object String]' ?
                        context.querySelector(selector) : selector;

                    return new BaronDomHelper(node);
                },
                event: function (elem, event, func, mode) {
                    event.split(' ').forEach(function (type) {
                        DG.DomEvent[mode || 'on'](elem, type, func);
                    });
                }
            });
        },

        _initHeader: function () {
            this._popupStructure.header = DG.DomUtil.create('header', 'dg-popup__header', this._contentNode);
        },

        _initFooter: function () {
            this._popupStructure.footer = DG.DomUtil.create('footer', 'dg-popup__footer', this._contentNode);
        },

        _initBodyContainer: function () {
            this._popupStructure.wrapper = DG.DomUtil.create('div', 'dg-popup__container-wrapper', this._contentNode);
            this._popupStructure.body = DG.DomUtil.create('div', 'dg-popup__container', this._popupStructure.wrapper);
        },

        update: function () {
            if (!this._map) { return; }

            if (!DG.Browser.ielt9) {
                this._container.style.visibility = 'hidden';
            }
            this._switchEvents(true);

            this._clearNode(this._contentNode);
            this._isBaronExist = false;

            // init popup content dom structure
            if (this._headerContent) { this._initHeader(); }
            if (this._bodyContent) { this._initBodyContainer(); }
            if (this._footerContent) { this._initFooter(); }

            this._updatePopupStructure();
            this.resize();

            DG.DomEvent.on(this._wrapper, 'click', DG.DomEvent.stopPropagation);
            this._switchEvents();

            if (DG.Browser.ielt9) {
                var elem = this._popupStructure.footer;
                if (elem) {
                    elem.className += ' ie8';
                }
            }

            if (!DG.Browser.ielt9) {
                this._container.style.visibility = '';
            }
        },

        _getDelta: function () { // () -> Number
            var delta = 0,
                popup = this._popupStructure;

            if (popup.header) {
                delta += popup.header.offsetHeight;
            }
            if (popup.footer) {
                delta += popup.footer.offsetHeight;
            }

            return delta;
        },

        _updateLayout: function () {
            var opts = this.options,
                content = this._contentNode, // leaflet-popup-content
                wrapper = this._wrapper, // leaflet-popup-content-wrapper
                style = content.style,
                wrapperStyle = wrapper.style,
                width,
                scrolledClass = 'leaflet-popup-scrolled',
                result = false;

            style.margin = opts.border + 'px';

            DG.DomUtil.removeClass(content, scrolledClass);

            if (this._isContentHeightEnough()) {
                wrapperStyle.maxHeight = content.offsetHeight + opts.border * 2 + 'px';
            } else {
                wrapperStyle.maxHeight = opts.maxHeight + 'px';
                DG.DomUtil.addClass(content, scrolledClass);
                result = true;
            }

            var availableWidth = opts.autoPanPadding[0] * 2;

            if (opts.sprawling) {
                width = opts.maxWidth;

                width = Math.min(width, this._map._container.offsetWidth - availableWidth);
                width = Math.max(width, opts.minWidth);
            } else {
                wrapperStyle.width = '';

                style.whiteSpace = 'nowrap';
                width = wrapper.offsetWidth;
                style.whiteSpace = '';

                width = Math.min(width, this._map._container.offsetWidth - availableWidth);
                width = Math.min(Math.max(width, opts.minWidth), opts.maxWidth);
            }

            wrapperStyle.width = width + 'px';

            this._containerWidth = this._container.offsetWidth;

            return result;
        },

        _updatePopupStructure: function () {
            Object.keys(this._popupStructure).forEach(function (item) {
                this._insertContent(this['_' + item + 'Content'], this._popupStructure[item]);
            }, this);

            this.fire('contentupdate');
        },

        _insertContent: function (content, node) { // (String | DOMElement, DOMElement)
            if (!content || !node) { return; }

            if (typeof content === 'string') {
                node.innerHTML = content;
            } else {
                this._clearNode(node);
                node.appendChild(content);
            }
        },

        _clearNode: function (node) { // (DOMElement)
            while (node.hasChildNodes()) {
                node.removeChild(node.firstChild);
            }
        },

        _detachEl: function (elem) { // (DOMElement) -> DOMElement
            if (elem.parentNode) {
                elem.parentNode.removeChild(elem);
            }
            return elem;
        },

        _switchEvents: function (on) { // (Boolean)
            var switcher = on ? 'off' : 'on';

            if (!DG.Browser.touch) {
                DG.DomEvent[switcher](this._contentNode, 'click', this._onClick, this);
            } else {
                DG.DomEvent[switcher](this._contentNode, 'touchstart mousedown mousemove', this._onStart, this);
            }

            if (this._isBaronExist) {
                DG.DomEvent[switcher](this._scroller, 'scroll', this._onScroll, this);
            }
        },

        _toggleTouchEvents: function (on) {
            var switcher = on ? 'off' : 'on';

            DG.DomEvent
                [switcher](this._contentNode, 'touchmove', this._onMove, this)
                [switcher](this._contentNode, 'touchend', this._onEnd, this);
        }

    });
}());


DG.Map.include({
    _markerClass: 'dg-customization__marker_type_mushroom',
    _markerShowClass: 'dg-customization__marker_appear',
    _markerHideClass: 'dg-customization__marker_disappear',
    _dgHideClass: 'dg-popup_hidden_true',
    openPopup: function (popup, latlng, options) { // (Popup) or (String || HTMLElement, LatLng[, Object])
        if (!(popup instanceof L.Popup)) {
            var content = popup;

            popup = new L.Popup(options).setContent(content);
        }

        if (latlng) {
            popup.setLatLng(latlng);
        }

        if (this.hasLayer(popup)) {
            return this;
        }

        this.closePopup();
        this._popup = popup;

        if (popup._source && popup._source._icon) {
            if (popup._source._icon.className.indexOf(this._markerClass) !== -1) {
                DG.DomUtil.removeClass(popup._source._icon, this._markerShowClass);
                DG.DomUtil.addClass(popup._source._icon, this._markerHideClass);
            } else {
                DG.DomUtil.addClass(popup._source._icon, this._dgHideClass);
                if (popup._source._shadow) {
                    DG.DomUtil.addClass(popup._source._shadow, this._dgHideClass);
                }
            }
        }

        return this.addLayer(popup);
    },

    closePopup: function (popup) {  // (Popup) -> Popup
        if (!popup || popup === this._popup) {
            popup = this._popup;
            this._popup = null;
        }
        if (popup) {
            if (popup._source && popup._source._icon) {
                if (popup._source._icon.className.indexOf(this._markerClass) !== -1) {
                    DG.DomUtil.removeClass(popup._source._icon, this._markerHideClass);
                    DG.DomUtil.addClass(popup._source._icon, this._markerShowClass);
                } else {
                    DG.DomUtil.removeClass(popup._source._icon, this._dgHideClass);
                    if (popup._source._shadow) {
                        DG.DomUtil.removeClass(popup._source._shadow, this._dgHideClass);
                    }
                }
            }
            this.removeLayer(popup);
        }

        return this;
    }
});

DG.Dictionary = {};

DG.Dictionary.ru = {
    pluralRules: function (n) { // (Number)
        if (n % 10 === 1 && n % 100 !== 11) { // 1, 21
            return 0;
        }
        if ((n % 10 >= 2 && n % 10 <= 4 && (n % 10) % 1 === 0) && (n % 100 < 12 || n % 100 > 14)) { // 2, 3
            return 1;
        }

        if ((n % 10 === 0) || (n % 10 >= 5 && n % 10 <= 9 && (n % 10) % 1 === 0) || (n % 100 >= 11 && (n % 100) <= 14 && (n % 100) % 1 === 0)) { // 13, 17
            return 2;
        }
    }
};

DG.Dictionary.en = {
    pluralRules: function (n) { // (Number)
        if (n === 1) { // 1
            return 0;
        } else {
            return 1; //0, 2, 3, 4 ..
        }
    }
};

DG.Dictionary.it = {
    pluralRules: function (n) { // (Number)
        if (n === 1) { // 1
            return 0;
        } else {
            return 1; //0, 2, 3, 4 ..
        }
    }
};

DG.Dictionary.cs = {
    pluralRules: function (n) { // (Number)
        return (n === 1) ? 0 : (n >= 2 && n <= 4) ? 1 : 2;
    }
};

DG.Dictionary.es = {
    pluralRules: function (n) { // (Number)
        return (n >= 2) ? 1 : 0;
    }
};

DG.Locale = {
    t: function (msg, argument) { // (String, Number) -> String
        var result,
            lang = this._map.options.currentLang,
            msgIsset = false,
            dictionaryMsg,
            exp;
        if (typeof this.constructor.Dictionary[lang] === 'undefined') {
            lang = 'ru';
            this._map.setLang(lang);
        }
        dictionaryMsg = this.constructor.Dictionary[lang][msg];
        msgIsset = typeof dictionaryMsg !== 'undefined';
        if (!msgIsset) {
            return msg;
        }
        result = msgIsset ? dictionaryMsg : msg;

        if (argument !== undefined) {
            argument = parseInt(argument, 10);
            argument = isNaN(argument) ? 0 : argument;
            exp = this.constructor.Dictionary[lang].pluralRules(argument);
            result = dictionaryMsg[exp];
        }

        result = DG.Util.template(result, {n: argument});
        return result ? result : msg;
    }
};

function getPageLang() {
    var root = document.documentElement,
        lang = root.lang || (root.getAttributeNS && root.getAttributeNS('http://www.w3.org/XML/1998/namespace', 'lang')) || 'ru';

    return lang;
}

DG.Map.mergeOptions({
    currentLang: getPageLang()
});

DG.Map.include({

    setLang: function (lang) { // (String)
        if (lang && Object.prototype.toString.call(lang) === '[object String]') {
            this.options.currentLang = lang;
            this.fire('langchange', {'lang': lang});
        }
    },

    getLang: function () { // () -> String
        return this.options.currentLang;
    }
});

DG.RoundControl = DG.Control.extend({
    includes: DG.Mixin.Events,

    options: {
        position: 'topright',
        iconClass: 'default'
    },

    onAdd: function (map) {
        var controlClass = this._controlCLass = 'dg-control-round',
            controlIconClass = this._controlIconCLass = this._controlCLass + '__icon',
            container = DG.DomUtil.create('div', '');

        if (this._disable) {
            return container;
        }
        DG.DomUtil.addClass(container, controlClass);

        var link = this._link = DG.DomUtil.create(
            'a',
            controlIconClass + ' ' + controlIconClass + '_name_' + this.options.iconClass,
            container
        );

        link.href = '#';

        this._renderTranslation();

        this._map = map;

        DG.DomEvent
            .on(container, 'click', this._toggleControl, this)
            .on(container, 'dblclick', DG.DomEvent.stopPropagation)
            .on(link, 'mousedown', DG.DomEvent.stopPropagation);

        this.fireEvent('add');

        return container;
    },

    onRemove: function () {
        this.fireEvent('remove');
        DG.DomEvent.off(this._link, 'click', this._toggleControl);
    },

    setState: function (state) {
        if (!this._link || !this._container) {
            return this;
        }

        if (this._state) {
            DG.DomUtil.removeClass(this._container, this._controlCLass + '_state_' + this._state);
            DG.DomUtil.removeClass(this._link, this._controlIconCLass + '_state_' + this._state);

            this._state = null;
        }

        if (state) {
            this._state = state;

            DG.DomUtil.addClass(this._container, this._controlCLass + '_state_' + this._state);
            DG.DomUtil.addClass(this._link, this._controlIconCLass + '_state_' + this._state);
        }

        return this;
    },

    _toggleControl: function (e) {
        DG.DomEvent.stop(e);
        this.fireEvent('click');
    }
});

DG.RoundControl.include(DG.Locale);

DG.roundControl = function (options) {
    return new DG.RoundControl(options);
};

DG.ProjectDetector = DG.Handler.extend({
    initialize: function (map) { // (Object)
        this._map = map;
        this._osmViewport = false;
        this.project = null;
        this._loadProjectList();
    },

    addHooks: function () {
        this._map.on('move', this._projectWatch, this);
    },

    removeHooks: function () {
        this._map.off('move', this._projectWatch, this);
    },

    getProject: function () {
        if (!this.project) { return false; }

        return DG.Util.extend({}, this.project);
    },

    getProjectsList: function () {
        return this._projectList.slice(0);
    },

    isProjectHere: function (coords, project, checkMethod) {
        if (!coords) { return null; }

        if (!(coords instanceof DG.LatLng) && !(coords instanceof DG.LatLngBounds)) {
            coords = DG.latLng(coords);
        }

        coords = (coords instanceof DG.LatLngBounds) ?
            DG.latLngBounds(coords.getSouthWest().wrap(), coords.getNorthEast().wrap()) : coords.wrap();

        checkMethod = checkMethod || ((coords instanceof DG.LatLngBounds) ?  'intersects' : 'contains');

        if (project) {
            return this._testProject(checkMethod, coords, project);
        } else {
            return this._projectList.filter(this._testProject.bind(this, checkMethod, coords))[0];
        }
    },

    _projectWatch: function () {
        if (this._osmViewport === (this.project && this._boundInProject(this.project, 'contains'))) {
            this._osmViewport = !this._osmViewport;
            this._map.attributionControl._update(null, this._osmViewport);
        }

        if (this.project && this._boundInProject(this.project) && this._zoomInProject(this.project)) { return; }

        if (this.project) {
            this.project = null;
            this._map.fire('projectleave');
        }

        this._searchProject();

        if (this.project) {
            if (this._osmViewport === (this.project && this._boundInProject(this.project, 'contains'))) {
                this._osmViewport = !this._osmViewport;
            }
            this._map.attributionControl._update(null, this._osmViewport, this.project.country_code);
        }
    },

    _wktToBnd: function (wkt) {
        var arr,
            pointsArr,
            bracketsContent,
            regExp;

        wkt = wkt.replace(/, /g, ',');
        wkt.replace(' (', '(');

        arr = /^POLYGON\((.*)\)/.exec(wkt);
        regExp = /\((.*?)\)/g;

        bracketsContent = (regExp).exec(arr[1]);
        pointsArr = bracketsContent[1].split(',');

        // Create a LatLng array of all points in WKT
        pointsArr = pointsArr.map(function(pointString) {
            var numbers = pointString.split(' ');

            return DG.latLng(
                parseFloat(numbers[1]),
                parseFloat(numbers[0])
            );
        });

        var bound = DG.latLngBounds(pointsArr);

        return [
            [bound.getSouthWest().lat, bound.getSouthWest().lng],
            [bound.getNorthEast().lat, bound.getNorthEast().lng]
        ];
    },

    _checkProject: function (project) {
        function check(value) {
            return value !== undefined && value !== null;
        }

        return project &&
                project.bounds &&
                check(project.code) &&
                check(project.domain) &&
                check(project.country_code) &&
                project.zoom_level &&
                    check(project.zoom_level.min) &&
                    check(project.zoom_level.max) &&
                project.time_zone &&
                    check(project.time_zone.offset);
    },

    _loadProjectList: function () {
        var self = this;

        if (!DG.projectsList) {
            DG.projectsList = DG.fallbackProjectsList;
        }
        delete DG.fallbackProjectsList;

        this._projectList = DG.projectsList
            .filter(self._checkProject)
            .map(function (project) {
                var bound = self._wktToBnd(project.bounds);
                var latLngBounds = new DG.LatLngBounds(bound);

                /* eslint-disable camelcase */
                return {
                    code: project.code,
                    minZoom: project.zoom_level.min,
                    maxZoom: project.zoom_level.max,
                    timeOffset: project.time_zone.offset,
                    bound: bound,
                    latLngBounds: latLngBounds,
                    traffic: !!project.flags.traffic,
                    transport: !!project.flags.public_transport,
                    roads: !!project.flags.road_network,
                    country_code: project.country_code,
                    domain: project.domain
                };
                /* eslint-enable camelcase */
            });
    },

    _searchProject: function () {
        this._projectList
            .filter(function (project) {
                return (this._boundInProject(project) && this._zoomInProject(project));
            }, this)
            .some(function (project) {
                var self = this;

                this.project = project;
                setTimeout(function () {
                    self._map.fire('projectchange', {'getProject': self.getProject.bind(self)});
                }, 1);

                return true;
            }, this);
    },

    _boundInProject: function (project, checkMethod) {
        try {
            return this.isProjectHere(this._map.getBounds(), project, checkMethod);
        } catch (e) {
            return false;
        }
    },

    _testProject: function (method, coords, project) {
        return project.latLngBounds[method](coords);
    },

    _zoomInProject: function (project) {
        return (this._map.getZoom() >= project.minZoom);
    }
});

DG.Map.mergeOptions({
    projectDetector: true
});

DG.Map.addInitHook('addHandler', 'projectDetector', DG.ProjectDetector);

DG.configTheme = DG.configTheme || {};

DG.configTheme.markersData = {
    iconSize: [22, 34],
    className: 'dg-customization__marker dg-customization__marker_type_mushroom',
    iconAnchor: [10, 32]
};

//Inject observing localization change
var controlAddTo = DG.Control.prototype.addTo;

DG.Control.include({
    addTo: function (map) {
        map.on('langchange', this._renderTranslation, this);

        return controlAddTo.call(this, map);
    },
    _renderTranslation: function () {}
});

// Applies 2GIS divIcon to marker
DG.Marker.prototype.options.icon = DG.divIcon(DG.configTheme.markersData);

// Add some browser detection
DG.Browser.safari51 = DG.Browser.safari && navigator.userAgent.indexOf('Version/5.1') !== -1;

// Fix bug with tileLayer minZoom
// https://github.com/2gis/mapsapi/pull/13
DG.GridLayer.include({
    _update: function () {

        if (!this._map) { return; }

        var bounds = this._map.getPixelBounds(),
            zoom = this._map.getZoom(),
            tileSize = this._getTileSize();

        if (zoom > this.options.maxZoom ||
            zoom < this.options.minZoom) {
            this._clearBgBuffer();
            return;
        }

        // tile coordinates range for the current view
        var tileBounds = L.bounds(
            bounds.min.divideBy(tileSize).floor(),
            bounds.max.divideBy(tileSize).floor());

        this._addTiles(tileBounds);

        if (this.options.unloadInvisibleTiles) {
            this._removeOtherTiles(tileBounds);
        }
    }
});

// Fix for https://github.com/2gis/mapsapi/issues/111 , remove on the next leaflet version
L.Draggable.include({
    _onMove: function (e) {
        if (e.touches && e.touches.length > 1) {
            this._moved = true;
            return;
        }

        var first = (e.touches && e.touches.length === 1 ? e.touches[0] : e),
            newPoint = new L.Point(first.clientX, first.clientY),
            offset = newPoint.subtract(this._startPoint);

        if (!offset.x && !offset.y) { return; }
        if (L.Browser.touch && Math.abs(offset.x) + Math.abs(offset.y) < 3) { return; }

        L.DomEvent.preventDefault(e);

        if (!this._moved) {
            this.fire('dragstart');

            this._moved = true;
            this._startPos = L.DomUtil.getPosition(this._element).subtract(offset);

            L.DomUtil.addClass(document.body, 'leaflet-dragging');

            this._lastTarget = e.target || e.srcElement;
            L.DomUtil.addClass(this._lastTarget, 'leaflet-drag-target');
        }

        this._newPos = this._startPos.add(offset);
        this._moving = true;

        L.Util.cancelAnimFrame(this._animRequest);
        this._animRequest = L.Util.requestAnimFrame(this._updatePosition, this, true, this._dragStartTarget);
    },
    _onUp: function () {
        L.DomUtil.removeClass(document.body, 'leaflet-dragging');

        if (this._lastTarget) {
            L.DomUtil.removeClass(this._lastTarget, 'leaflet-drag-target');
            this._lastTarget = null;
        }

        for (var i in L.Draggable.MOVE) {
            L.DomEvent
                .off(document, L.Draggable.MOVE[i], this._onMove, this)
                .off(document, L.Draggable.END[i], this._onUp, this);
        }

        L.DomUtil.enableImageDrag();
        L.DomUtil.enableTextSelection();

        if (this._moved && this._moving) {
            // ensure drag is not fired after dragend
            L.Util.cancelAnimFrame(this._animRequest);

            this.fire('dragend', {
                distance: this._newPos.distanceTo(this._startPos)
            });
        }

        this._moving = false;
    }
});

var panBy = DG.Map.prototype.panBy,
    getBoundsZoom = DG.Map.prototype.getBoundsZoom;

// Restrict zoom level according to 2gis projects, in case if dgTileLayer is only one
DG.Map.include({

    // number of tileLayers without 2gis layers
    _tileLayersNumber: 0,

    _mapMaxZoomCache: undefined,

    //TODO try refactor it after up on new leaflet (> 0.7)
    initialize: function (id, options) { // (HTMLElement or String, Object)
        options = L.setOptions(this, options);

        this._initContainer(id);
        this._initLayout();

        // hack for https://github.com/Leaflet/Leaflet/issues/1980
        this._onResize = L.bind(this._onResize, this);

        this._initEvents();

        if (options.maxBounds) {
            this.setMaxBounds(options.maxBounds);
        }

        this._handlers = [];

        this._layers = {};
        this._zoomBoundLayers = {};

        this.callInitHooks();

        this._addLayers(options.layers);

        if (options.center && options.zoom !== undefined) {
            this.setView(L.latLng(options.center), options.zoom, {reset: true});
        }

        this._sizeChanged = true;
    },

    setView: function (center, zoom, options) {
        this._restrictZoom(center);

        zoom =  this._limitZoom(zoom === undefined ? this._zoom : zoom);
        center = this._limitCenter(DG.latLng(center), zoom, this.options.maxBounds);
        options = options || {};

        if (options.animate) {
            options.animate = this._testAnimation(center);
        }

        if (this._panAnim) {
            this._panAnim.stop();
        }

        if (this._loaded && !options.reset && options !== true) {

            if (options.animate !== undefined) {
                options.zoom = DG.extend({animate: options.animate}, options.zoom);
                options.pan = DG.extend({animate: options.animate}, options.pan);
            }

            // try animating pan or zoom
            var animated = (this._zoom !== zoom) ?
            this._tryAnimatedZoom && this._tryAnimatedZoom(center, zoom, options.zoom) :
                this._tryAnimatedPan(center, options.pan);

            if (animated) {
                // prevent resize handler call, the view will refresh after animation anyway
                clearTimeout(this._sizeTimer);
                return this;
            }
        }

        // animation didn't start, just reset the map view
        this._resetView(center, zoom);

        return this;
    },

    panBy: function (offset, options) {
        var map = panBy.call(this, offset, options);

        var zoom = this._restrictZoom(this.getCenter());
        if (this.getZoom() > zoom) {
            this.setZoom(zoom);
        }

        return map;
    },

    getBoundsZoom: function (bounds, inside, padding) {
        this._restrictZoom(bounds);
        return getBoundsZoom.call(this, bounds, inside, padding);
    },

    _testAnimation: function (coords) {//if we jump to other project - disable animation
        if (this.projectDetector.enabled()) {
            var projectFrom = this.projectDetector.getProject(),
                projectTo = this.projectDetector.isProjectHere(coords);

            if (projectFrom && projectTo) {
                return projectFrom.code === projectTo.code;
            }
        }

        return true;
    },

    _updateTileLayers: function (e) {
        if (!(e.layer instanceof DG.TileLayer) || e.layer._isDg) { return; }

        if (e.type === 'layeradd') {
            this._tileLayersNumber++;
        } else {
            this._tileLayersNumber--;
        }
    },

    _restrictZoom: function (coords) {
        if (this._layers &&
            this.projectDetector.enabled() &&
            (this._tileLayersNumber === 0)) {

            var mapOptions = this.options,
                isMapMaxZoom = !!mapOptions.maxZoom,
                dgTileLayer = this.baseLayer,
                project = this.projectDetector.isProjectHere(coords);
            if (isMapMaxZoom) {
                if (!this._mapMaxZoomCache) { this._mapMaxZoomCache = mapOptions.maxZoom; }
                mapOptions.maxZoom = (this._mapMaxZoomCache && project) ? this._mapMaxZoomCache :  '13';
                if (project) {
                    this._mapMaxZoomCache = mapOptions.maxZoom;
                }

                return mapOptions.maxZoom;
            } else {
                dgTileLayer.options.maxZoom = project ? project.maxZoom : '13';
                dgTileLayer.options.maxNativeZoom = dgTileLayer.options.maxZoom;
                this._updateZoomLevels();

                return dgTileLayer.options.maxZoom;
            }
        }
    },

    // Fix for https://github.com/2gis/mapsapi/issues/34
    // Remove on the next leaflet version
    // Add prepreclick event before preclick than geoclicker can track popup state
    // https://github.com/2gis/mapsapi/pull/96
    _fireMouseEvent: function (obj, e, type, propagate, latlng) {
        type = type || e.type;

        if (L.DomEvent._skipped(e)) { return; }

        if (type === 'click') {
            var draggableObj = obj.options.draggable === true ? obj : this;
            if (!e._simulated && ((draggableObj.dragging && draggableObj.dragging.moved()) ||
                (this.boxZoom && this.boxZoom.moved()))) {
                L.DomEvent.stopPropagation(e);
                return;
            }
            obj.fire('prepreclick');
            obj.fire('preclick');
        }

        if (!obj.listens(type, propagate)) { return; }

        if (type === 'contextmenu') {
            L.DomEvent.preventDefault(e);
        }
        if (type === 'click' || type === 'dblclick' || type === 'contextmenu') {
            L.DomEvent.stopPropagation(e);
        }

        var data = {
            originalEvent: e,
            containerPoint: this.mouseEventToContainerPoint(e)
        };

        data.layerPoint = this.containerPointToLayerPoint(data.containerPoint);
        data.latlng = latlng || this.layerPointToLatLng(data.layerPoint);

        obj.fire(type, data, propagate);
    }
});

DG.Map.addInitHook(function () {
    this.on('layeradd layerremove', this._updateTileLayers);
});

// fix bug with dragging map into new parallel world
// remove on next leaflet version
DG.Map.Drag.include({
    _onDrag: function () {
        if (this._map.options.inertia) {
            var time = this._lastTime = +new Date(),
                pos = this._lastPos = this._draggable._absPos || this._draggable._newPos;

            this._positions.push(pos);
            this._times.push(time);

            if (time - this._times[0] > 200) {
                this._positions.shift();
                this._times.shift();
            }
        }

        this._map
            .fire('move')
            .fire('drag');
    },
    _onPreDrag: function () {
        // TODO refactor to be able to adjust map pane position after zoom
        var worldWidth = this._worldWidth,
            halfWidth = Math.round(worldWidth / 2),
            dx = this._initialWorldOffset,
            x = this._draggable._newPos.x,
            newX1 = (x - halfWidth + dx) % worldWidth + halfWidth - dx,
            newX2 = (x + halfWidth + dx) % worldWidth - halfWidth - dx,
            newX = Math.abs(newX1 + dx) < Math.abs(newX2 + dx) ? newX1 : newX2;

        this._draggable._absPos = this._draggable._newPos.clone();
        this._draggable._newPos.x = newX;
    }
});

(function () {
    var errorUrl = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEAAQMAAABmvDolAAAAA1BMVEX28t5R0k5UAAAAH0lEQVR4Xu3AAQkAAADCMPunNsdhWxwAAAAAAAAAwAEhAAABg2UP5AAAAABJRU5ErkJggg==';
    var errorRuUrl = 'http://2gis.github.io/mapsapi/img/nomap_ru.png';

    var BaseLayer = DG.TileLayer.extend({
        initialize: function (url, options) {
            this._isDg = true;
            DG.TileLayer.prototype.initialize.call(this, url, options);
        }
    });

    DG.Map.addInitHook(function () {
        this.baseLayer = new BaseLayer('http://tile{s}.maps.2gis.com/tiles?x={x}&y={y}&z={z}&v=1', {
                subdomains: '0123',
                errorTileUrl: this.getLang() === 'ru' ? errorRuUrl : errorUrl,
                /* global true */
                detectRetina: true,
                maxZoom: 19,
                maxNativeZoom: 19
            }
        ).addTo(this);

        this.on('langchange', function(ev) {
            if (ev.lang === 'ru') {
                this.baseLayer.options.errorTileUrl = errorRuUrl;
            } else {
                this.baseLayer.options.errorTileUrl = errorUrl;
            }
        });
    });
})();

DG.Control.Zoom.include(DG.Locale);
DG.Control.Zoom.Dictionary = {};

DG.Control.Zoom.include({
    // TODO: think about pull request to leaflet with zoom control button's titles as options
    onAdd: function (map) {
        var zoomName = 'dg-zoom',
            buttonTemplate = '<div class="dg-control-round__icon ' + zoomName + '__control ' + zoomName + '__button ' + zoomName + '__button_type_{type}"></div>',
            container = DG.DomUtil.create('div', zoomName);

        this._map = map;

        this._zoomInButton = this._createButton(DG.Util.template(buttonTemplate, {type : 'in'}), this.t('zoom_in'), 'dg-control-round ' + zoomName + '__in', container, this._zoomIn, this);
        this._zoomOutButton = this._createButton(DG.Util.template(buttonTemplate, {type : 'out'}), this.t('zoom_out'), 'dg-control-round ' + zoomName + '__out', container, this._zoomOut, this);

        this._eventListeners = {};
        this._eventListeners.zoomend = this._eventListeners.zoomlevelschange = this._updateDisabled;
        this._updateDisabled();
        map.on(this._eventListeners, this);

        return container;
    },

    _originalCreateButton: DG.Control.Zoom.prototype._createButton,

    _createButton: function () {
        var args = Array.prototype.slice.call(arguments);
        var link = this._originalCreateButton.apply(this, args);

        var icon = link.children[0];
        var linkActiveClass = 'dg-control-round_state_active';
        var iconActiveClass = 'dg-control-round__icon_state_active';

        DG.DomEvent
            .on(link, 'touchstart', function () {
                DG.DomUtil.addClass(link, linkActiveClass);
                DG.DomUtil.addClass(icon, iconActiveClass);
            })
            .on(link, 'touchend touchcancel', function () {
                DG.DomUtil.removeClass(link, linkActiveClass);
                DG.DomUtil.removeClass(icon, iconActiveClass);
            });

        return link;
    },

    onRemove: function (map) {
        map.off(this._eventListeners, this);
    },

    _renderTranslation: function () {
        this._zoomInButton.title = this.t('zoom_in');
        this._zoomOutButton.title = this.t('zoom_out');
    }
});

DG.Control.Zoom.Dictionary.ru = {
    zoom_in : '',
    zoom_out : ''
};
DG.Control.Zoom.Dictionary.it = {
    zoom_in : 'Zoom avanti',
    zoom_out : 'Zoom indietro'
};
DG.Control.Zoom.Dictionary.cs = {
    zoom_in : 'Piblit',
    zoom_out : 'Oddlit'
};
DG.Control.Zoom.Dictionary.en = {
    zoom_in : 'Zoom in',
    zoom_out : 'Zoom out'
};
DG.Control.Zoom.Dictionary.es = {
    zoom_in : 'Acercar',
    zoom_out : 'Alejar'
};

/*! Dust - Asynchronous Templating - v2.6.1
* http://linkedin.github.io/dustjs/
* Copyright (c) 2015 Aleksander Williams; Released under the MIT License */
(function(root) {
  var dust = {
        "version": "2.6.1"
      },
      NONE = 'NONE',
      ERROR = 'ERROR',
      WARN = 'WARN',
      INFO = 'INFO',
      DEBUG = 'DEBUG',
      loggingLevels = [DEBUG, INFO, WARN, ERROR, NONE],
      EMPTY_FUNC = function() {},
      logger = {},
      originalLog,
      loggerContext;

  dust.debugLevel = NONE;

  dust.config = {
    whitespace: false,
    amd: false
  };

  // Directive aliases to minify code
  dust._aliases = {
    "write": "w",
    "end": "e",
    "map": "m",
    "render": "r",
    "reference": "f",
    "section": "s",
    "exists": "x",
    "notexists": "nx",
    "block": "b",
    "partial": "p",
    "helper": "h"
  };

  // Try to find the console in global scope
  if (root && root.console && root.console.log) {
    loggerContext = root.console;
    originalLog = root.console.log;
  }

  // robust logger for node.js, modern browsers, and IE <= 9.
  logger.log = loggerContext ? function() {
      // Do this for normal browsers
      if (typeof originalLog === 'function') {
        logger.log = function() {
          originalLog.apply(loggerContext, arguments);
        };
      } else {
        // Do this for IE <= 9
        logger.log = function() {
          var message = Array.prototype.slice.apply(arguments).join(' ');
          originalLog(message);
        };
      }
      logger.log.apply(this, arguments);
  } : function() { /* no op */ };

  /**
   * Log dust debug statements, info statements, warning statements, and errors.
   * Filters out the messages based on the dust.debuglevel.
   * This default implementation will print to the console if it exists.
   * @param {String|Error} message the message to print/throw
   * @param {String} type the severity of the message(ERROR, WARN, INFO, or DEBUG)
   * @public
   */
  dust.log = function(message, type) {
    type = type || INFO;
    if (dust.debugLevel !== NONE && dust.indexInArray(loggingLevels, type) >= dust.indexInArray(loggingLevels, dust.debugLevel)) {
      if(!dust.logQueue) {
        dust.logQueue = [];
      }
      dust.logQueue.push({message: message, type: type});
      logger.log('[DUST:' + type + ']', message);
    }
  };

  dust.helpers = {};

  dust.cache = {};

  dust.register = function(name, tmpl) {
    if (!name) {
      return;
    }
    dust.cache[name] = tmpl;
  };

  dust.render = function(name, context, callback) {
    var chunk = new Stub(callback).head;
    try {
      dust.load(name, chunk, Context.wrap(context, name)).end();
    } catch (err) {
      chunk.setError(err);
    }
  };

  dust.stream = function(name, context) {
    var stream = new Stream(),
        chunk = stream.head;
    dust.nextTick(function() {
      try {
        dust.load(name, stream.head, Context.wrap(context, name)).end();
      } catch (err) {
        chunk.setError(err);
      }
    });
    return stream;
  };

  dust.renderSource = function(source, context, callback) {
    return dust.compileFn(source)(context, callback);
  };

  dust.compileFn = function(source, name) {
    // name is optional. When name is not provided the template can only be rendered using the callable returned by this function.
    // If a name is provided the compiled template can also be rendered by name.
    name = name || null;
    var tmpl = dust.loadSource(dust.compile(source, name));
    return function(context, callback) {
      var master = callback ? new Stub(callback) : new Stream();
      dust.nextTick(function() {
        if(typeof tmpl === 'function') {
          tmpl(master.head, Context.wrap(context, name)).end();
        }
        else {
          dust.log(new Error('Template [' + name + '] cannot be resolved to a Dust function'), ERROR);
        }
      });
      return master;
    };
  };

  dust.load = function(name, chunk, context) {
    var tmpl = dust.cache[name];
    if (tmpl) {
      return tmpl(chunk, context);
    } else {
      if (dust.onLoad) {
        return chunk.map(function(chunk) {
          dust.onLoad(name, function(err, src) {
            if (err) {
              return chunk.setError(err);
            }
            if (!dust.cache[name]) {
              dust.loadSource(dust.compile(src, name));
            }
            dust.cache[name](chunk, context).end();
          });
        });
      }
      return chunk.setError(new Error('Template Not Found: ' + name));
    }
  };

  dust.loadSource = function(source, path) {
    return eval(source);
  };

  if (Array.isArray) {
    dust.isArray = Array.isArray;
  } else {
    dust.isArray = function(arr) {
      return Object.prototype.toString.call(arr) === '[object Array]';
    };
  }

  // indexOf shim for arrays for IE <= 8
  // source: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf
  dust.indexInArray = function(arr, item, fromIndex) {
    fromIndex = +fromIndex || 0;
    if (Array.prototype.indexOf) {
      return arr.indexOf(item, fromIndex);
    } else {
    if ( arr === undefined || arr === null ) {
      throw new TypeError( 'cannot call method "indexOf" of null' );
    }

    var length = arr.length; // Hack to convert object.length to a UInt32

    if (Math.abs(fromIndex) === Infinity) {
      fromIndex = 0;
    }

    if (fromIndex < 0) {
      fromIndex += length;
      if (fromIndex < 0) {
        fromIndex = 0;
      }
    }

    for (;fromIndex < length; fromIndex++) {
      if (arr[fromIndex] === item) {
        return fromIndex;
      }
    }

    return -1;
    }
  };

  dust.nextTick = (function() {
    return function(callback) {
      setTimeout(callback,0);
    };
  } )();

  dust.isEmpty = function(value) {
    if (dust.isArray(value) && !value.length) {
      return true;
    }
    if (value === 0) {
      return false;
    }
    return (!value);
  };

  // apply the filter chain and return the output string
  dust.filter = function(string, auto, filters) {
    if (filters) {
      for (var i=0, len=filters.length; i<len; i++) {
        var name = filters[i];
        if (name === 's') {
          auto = null;
        }
        else if (typeof dust.filters[name] === 'function') {
          string = dust.filters[name](string);
        }
        else {
          dust.log('Invalid filter [' + name + ']', WARN);
        }
      }
    }
    // by default always apply the h filter, unless asked to unescape with |s
    if (auto) {
      string = dust.filters[auto](string);
    }
    return string;
  };

  dust.filters = {
    h: function(value) { return dust.escapeHtml(value); },
    j: function(value) { return dust.escapeJs(value); },
    u: encodeURI,
    uc: encodeURIComponent,
    js: function(value) { return dust.escapeJSON(value); },
    jp: function(value) {
      if (!JSON) {dust.log('JSON is undefined.  JSON parse has not been used on [' + value + ']', WARN);
        return value;
      } else {
        return JSON.parse(value);
      }
    }
  };

  function Context(stack, global, blocks, templateName) {
    this.stack  = stack;
    this.global = global;
    this.blocks = blocks;
    this.templateName = templateName;
  }

  dust.makeBase = function(global) {
    return new Context(new Stack(), global);
  };

  Context.wrap = function(context, name) {
    if (context instanceof Context) {
      return context;
    }
    return new Context(new Stack(context), {}, null, name);
  };

  /**
   * Public API for getting a value from the context.
   * @method get
   * @param {string|array} path The path to the value. Supported formats are:
   * 'key'
   * 'path.to.key'
   * '.path.to.key'
   * ['path', 'to', 'key']
   * ['key']
   * @param {boolean} [cur=false] Boolean which determines if the search should be limited to the
   * current context (true), or if get should search in parent contexts as well (false).
   * @public
   * @returns {string|object}
   */
  Context.prototype.get = function(path, cur) {
    if (typeof path === 'string') {
      if (path[0] === '.') {
        cur = true;
        path = path.substr(1);
      }
      path = path.split('.');
    }
    return this._get(cur, path);
  };

  /**
   * Get a value from the context
   * @method _get
   * @param {boolean} cur Get only from the current context
   * @param {array} down An array of each step in the path
   * @private
   * @return {string | object}
   */
  Context.prototype._get = function(cur, down) {
    var ctx = this.stack,
        i = 1,
        value, first, len, ctxThis, fn;
    first = down[0];
    len = down.length;

    if (cur && len === 0) {
      ctxThis = ctx;
      ctx = ctx.head;
    } else {
      if (!cur) {
        // Search up the stack for the first value
        while (ctx) {
          if (ctx.isObject) {
            ctxThis = ctx.head;
            value = ctx.head[first];
            if (value !== undefined) {
              break;
            }
          }
          ctx = ctx.tail;
        }

        if (value !== undefined) {
          ctx = value;
        } else {
          ctx = this.global ? this.global[first] : undefined;
        }
      } else if (ctx) {
        // if scope is limited by a leading dot, don't search up the tree
        if(ctx.head) {
          ctx = ctx.head[first];
        } else {
          //context's head is empty, value we are searching for is not defined
          ctx = undefined;
        }
      }

      while (ctx && i < len) {
        ctxThis = ctx;
        ctx = ctx[down[i]];
        i++;
      }
    }

    // Return the ctx or a function wrapping the application of the context.
    if (typeof ctx === 'function') {
      fn = function() {
        try {
          return ctx.apply(ctxThis, arguments);
        } catch (err) {
          dust.log(err, ERROR);
          throw err;
        }
      };
      fn.__dustBody = !!ctx.__dustBody;
      return fn;
    } else {
      if (ctx === undefined) {
        dust.log('Cannot find the value for reference [{' + down.join('.') + '}] in template [' + this.getTemplateName() + ']');
      }
      return ctx;
    }
  };

  Context.prototype.getPath = function(cur, down) {
    return this._get(cur, down);
  };

  Context.prototype.push = function(head, idx, len) {
    return new Context(new Stack(head, this.stack, idx, len), this.global, this.blocks, this.getTemplateName());
  };

  Context.prototype.rebase = function(head) {
    return new Context(new Stack(head), this.global, this.blocks, this.getTemplateName());
  };

  Context.prototype.current = function() {
    return this.stack.head;
  };

  Context.prototype.getBlock = function(key, chk, ctx) {
    if (typeof key === 'function') {
      var tempChk = new Chunk();
      key = key(tempChk, this).data.join('');
    }

    var blocks = this.blocks;

    if (!blocks) {
      dust.log('No blocks for context[{' + key + '}] in template [' + this.getTemplateName() + ']', DEBUG);
      return;
    }
    var len = blocks.length, fn;
    while (len--) {
      fn = blocks[len][key];
      if (fn) {
        return fn;
      }
    }
  };

  Context.prototype.shiftBlocks = function(locals) {
    var blocks = this.blocks,
        newBlocks;

    if (locals) {
      if (!blocks) {
        newBlocks = [locals];
      } else {
        newBlocks = blocks.concat([locals]);
      }
      return new Context(this.stack, this.global, newBlocks, this.getTemplateName());
    }
    return this;
  };

  Context.prototype.getTemplateName = function() {
    return this.templateName;
  };

  function Stack(head, tail, idx, len) {
    this.tail = tail;
    this.isObject = head && typeof head === 'object';
    this.head = head;
    this.index = idx;
    this.of = len;
  }

  function Stub(callback) {
    this.head = new Chunk(this);
    this.callback = callback;
    this.out = '';
  }

  Stub.prototype.flush = function() {
    var chunk = this.head;

    while (chunk) {
      if (chunk.flushable) {
        this.out += chunk.data.join(''); //ie7 perf
      } else if (chunk.error) {
        this.callback(chunk.error);
        dust.log('Chunk error [' + chunk.error + '] thrown. Ceasing to render this template.', WARN);
        this.flush = EMPTY_FUNC;
        return;
      } else {
        return;
      }
      chunk = chunk.next;
      this.head = chunk;
    }
    this.callback(null, this.out);
  };

  function Stream() {
    this.head = new Chunk(this);
  }

  Stream.prototype.flush = function() {
    var chunk = this.head;

    while(chunk) {
      if (chunk.flushable) {
        this.emit('data', chunk.data.join('')); //ie7 perf
      } else if (chunk.error) {
        this.emit('error', chunk.error);
        dust.log('Chunk error [' + chunk.error + '] thrown. Ceasing to render this template.', WARN);
        this.flush = EMPTY_FUNC;
        return;
      } else {
        return;
      }
      chunk = chunk.next;
      this.head = chunk;
    }
    this.emit('end');
  };

  Stream.prototype.emit = function(type, data) {
    if (!this.events) {
      dust.log('No events to emit', INFO);
      return false;
    }
    var handler = this.events[type];
    if (!handler) {
      dust.log('Event type [' + type + '] does not exist', WARN);
      return false;
    }
    if (typeof handler === 'function') {
      handler(data);
    } else if (dust.isArray(handler)) {
      var listeners = handler.slice(0);
      for (var i = 0, l = listeners.length; i < l; i++) {
        listeners[i](data);
      }
    } else {
      dust.log('Event Handler [' + handler + '] is not of a type that is handled by emit', WARN);
    }
  };

  Stream.prototype.on = function(type, callback) {
    if (!this.events) {
      this.events = {};
    }
    if (!this.events[type]) {
      if(callback) {
        this.events[type] = callback;
      } else {
        dust.log('Callback for type [' + type + '] does not exist. Listener not registered.', WARN);
      }
    } else if(typeof this.events[type] === 'function') {
      this.events[type] = [this.events[type], callback];
    } else {
      this.events[type].push(callback);
    }
    return this;
  };

  Stream.prototype.pipe = function(stream) {
    this.on('data', function(data) {
      try {
        stream.write(data, 'utf8');
      } catch (err) {
        dust.log(err, ERROR);
      }
    }).on('end', function() {
      try {
        return stream.end();
      } catch (err) {
        dust.log(err, ERROR);
      }
    }).on('error', function(err) {
      stream.error(err);
    });
    return this;
  };

  function Chunk(root, next, taps) {
    this.root = root;
    this.next = next;
    this.data = []; //ie7 perf
    this.flushable = false;
    this.taps = taps;
  }

  Chunk.prototype.write = function(data) {
    var taps  = this.taps;

    if (taps) {
      data = taps.go(data);
    }
    this.data.push(data);
    return this;
  };

  Chunk.prototype.end = function(data) {
    if (data) {
      this.write(data);
    }
    this.flushable = true;
    this.root.flush();
    return this;
  };

  Chunk.prototype.map = function(callback) {
    var cursor = new Chunk(this.root, this.next, this.taps),
        branch = new Chunk(this.root, cursor, this.taps);

    this.next = branch;
    this.flushable = true;
    try {
      callback(branch);
    } catch(e) {
      dust.log(e, ERROR);
      branch.setError(e);
    }
    return cursor;
  };

  Chunk.prototype.tap = function(tap) {
    var taps = this.taps;

    if (taps) {
      this.taps = taps.push(tap);
    } else {
      this.taps = new Tap(tap);
    }
    return this;
  };

  Chunk.prototype.untap = function() {
    this.taps = this.taps.tail;
    return this;
  };

  Chunk.prototype.render = function(body, context) {
    return body(this, context);
  };

  Chunk.prototype.reference = function(elem, context, auto, filters) {
    if (typeof elem === 'function') {
      // Changed the function calling to use apply with the current context to make sure
      // that "this" is wat we expect it to be inside the function
      elem = elem.apply(context.current(), [this, context, null, {auto: auto, filters: filters}]);
      if (elem instanceof Chunk) {
        return elem;
      }
    }
    if (!dust.isEmpty(elem)) {
      return this.write(dust.filter(elem, auto, filters));
    } else {
      return this;
    }
  };

  Chunk.prototype.section = function(elem, context, bodies, params) {
    // anonymous functions
    if (typeof elem === 'function' && !elem.__dustBody) {
      try {
        elem = elem.apply(context.current(), [this, context, bodies, params]);
      } catch(e) {
        dust.log(e, ERROR);
        return this.setError(e);
      }
      // functions that return chunks are assumed to have handled the body and/or have modified the chunk
      // use that return value as the current chunk and go to the next method in the chain
      if (elem instanceof Chunk) {
        return elem;
      }
    }
    var body = bodies.block,
        skip = bodies['else'];

    // a.k.a Inline parameters in the Dust documentations
    if (params) {
      context = context.push(params);
    }

    /*
    Dust's default behavior is to enumerate over the array elem, passing each object in the array to the block.
    When elem resolves to a value or object instead of an array, Dust sets the current context to the value
    and renders the block one time.
    */
    //non empty array is truthy, empty array is falsy
    if (dust.isArray(elem)) {
      if (body) {
        var len = elem.length, chunk = this;
        if (len > 0) {
          // any custom helper can blow up the stack
          // and store a flattened context, guard defensively
          if(context.stack.head) {
            context.stack.head['$len'] = len;
          }
          for (var i=0; i<len; i++) {
            if(context.stack.head) {
              context.stack.head['$idx'] = i;
            }
            chunk = body(chunk, context.push(elem[i], i, len));
          }
          if(context.stack.head) {
            context.stack.head['$idx'] = undefined;
            context.stack.head['$len'] = undefined;
          }
          return chunk;
        }
        else if (skip) {
          return skip(this, context);
        }
      }
    } else if (elem  === true) {
     // true is truthy but does not change context
      if (body) {
        return body(this, context);
      }
    } else if (elem || elem === 0) {
       // everything that evaluates to true are truthy ( e.g. Non-empty strings and Empty objects are truthy. )
       // zero is truthy
       // for anonymous functions that did not returns a chunk, truthiness is evaluated based on the return value
      if (body) {
        return body(this, context.push(elem));
      }
     // nonexistent, scalar false value, scalar empty string, null,
     // undefined are all falsy
    } else if (skip) {
      return skip(this, context);
    }
    dust.log('Not rendering section (#) block in template [' + context.getTemplateName() + '], because above key was not found', DEBUG);
    return this;
  };

  Chunk.prototype.exists = function(elem, context, bodies) {
    var body = bodies.block,
        skip = bodies['else'];

    if (!dust.isEmpty(elem)) {
      if (body) {
        return body(this, context);
      }
    } else if (skip) {
      return skip(this, context);
    }
    dust.log('Not rendering exists (?) block in template [' + context.getTemplateName() + '], because above key was not found', DEBUG);
    return this;
  };

  Chunk.prototype.notexists = function(elem, context, bodies) {
    var body = bodies.block,
        skip = bodies['else'];

    if (dust.isEmpty(elem)) {
      if (body) {
        return body(this, context);
      }
    } else if (skip) {
      return skip(this, context);
    }
    dust.log('Not rendering not exists (^) block check in template [' + context.getTemplateName() + '], because above key was found', DEBUG);
    return this;
  };

  Chunk.prototype.block = function(elem, context, bodies) {
    var body = bodies.block;

    if (elem) {
      body = elem;
    }

    if (body) {
      return body(this, context);
    }
    return this;
  };

  Chunk.prototype.partial = function(elem, context, params) {
    var partialContext;
    //put the params context second to match what section does. {.} matches the current context without parameters
    // start with an empty context
    partialContext = dust.makeBase(context.global);
    partialContext.blocks = context.blocks;
    if (context.stack && context.stack.tail){
      // grab the stack(tail) off of the previous context if we have it
      partialContext.stack = context.stack.tail;
    }
    if (params){
      //put params on
      partialContext = partialContext.push(params);
    }

    if(typeof elem === 'string') {
      partialContext.templateName = elem;
    }

    //reattach the head
    partialContext = partialContext.push(context.stack.head);

    var partialChunk;
    if (typeof elem === 'function') {
      partialChunk = this.capture(elem, partialContext, function(name, chunk) {
        partialContext.templateName = partialContext.templateName || name;
        dust.load(name, chunk, partialContext).end();
      });
    } else {
      partialChunk = dust.load(elem, this, partialContext);
    }
    return partialChunk;
  };

  Chunk.prototype.helper = function(name, context, bodies, params) {
    var chunk = this;
    // handle invalid helpers, similar to invalid filters
    if(dust.helpers[name]) {
      try {
        return dust.helpers[name](chunk, context, bodies, params);
      } catch(e) {
        dust.log('Error in ' + name + ' helper: ' + e, ERROR);
        return chunk.setError(e);
      }
    } else {
      dust.log('Invalid helper [' + name + ']', WARN);
      return chunk;
    }
  };

  Chunk.prototype.capture = function(body, context, callback) {
    return this.map(function(chunk) {
      var stub = new Stub(function(err, out) {
        if (err) {
          chunk.setError(err);
        } else {
          callback(out, chunk);
        }
      });
      body(stub.head, context).end();
    });
  };

  Chunk.prototype.setError = function(err) {
    this.error = err;
    this.root.flush();
    return this;
  };

  // Chunk aliases
  for(var f in Chunk.prototype) {
    if(dust._aliases[f]) {
      Chunk.prototype[dust._aliases[f]] = Chunk.prototype[f];
    }
  }

  function Tap(head, tail) {
    this.head = head;
    this.tail = tail;
  }

  Tap.prototype.push = function(tap) {
    return new Tap(tap, this);
  };

  Tap.prototype.go = function(value) {
    var tap = this;

    while(tap) {
      value = tap.head(value);
      tap = tap.tail;
    }
    return value;
  };

  var HCHARS = /[&<>"']/,
      AMP    = /&/g,
      LT     = /</g,
      GT     = />/g,
      QUOT   = /\"/g,
      SQUOT  = /\'/g;

  dust.escapeHtml = function(s) {
    if (typeof s === "string" || (s && typeof s.toString === "function")) {
      if (typeof s !== "string") {
        s = s.toString();
      }
      if (!HCHARS.test(s)) {
        return s;
      }
      return s.replace(AMP,'&amp;').replace(LT,'&lt;').replace(GT,'&gt;').replace(QUOT,'&quot;').replace(SQUOT, '&#39;');
    }
    return s;
  };

  var BS = /\\/g,
      FS = /\//g,
      CR = /\r/g,
      LS = /\u2028/g,
      PS = /\u2029/g,
      NL = /\n/g,
      LF = /\f/g,
      SQ = /'/g,
      DQ = /"/g,
      TB = /\t/g;

  dust.escapeJs = function(s) {
    if (typeof s === 'string') {
      return s
        .replace(BS, '\\\\')
        .replace(FS, '\\/')
        .replace(DQ, '\\"')
        .replace(SQ, '\\\'')
        .replace(CR, '\\r')
        .replace(LS, '\\u2028')
        .replace(PS, '\\u2029')
        .replace(NL, '\\n')
        .replace(LF, '\\f')
        .replace(TB, '\\t');
    }
    return s;
  };

  dust.escapeJSON = function(o) {
    if (!JSON) {
      dust.log('JSON is undefined.  JSON stringify has not been used on [' + o + ']', WARN);
      return o;
    } else {
      return JSON.stringify(o)
        .replace(LS, '\\u2028')
        .replace(PS, '\\u2029')
        .replace(LT, '\\u003c');
    }
  };

  if (typeof define === "function" && define.amd && define.amd.dust === true) {
    define("dust.core", function() {
      return dust;
    });
  } else if (typeof exports === 'object') {
    module.exports = dust;
  } else {
    root.dust = dust;
  }

})((function(){return this;})());

if (typeof define === "function" && define.amd && define.amd.dust === true) {
    define(["require", "dust.core"], function(require, dust) {
        dust.onLoad = function(name, cb) {
            require([name], function() {
                cb();
            });
        };
        return dust;
    });
}

/*! dustjs-helpers - v1.6.1
* https://github.com/linkedin/dustjs-helpers
* Copyright (c) 2015 Aleksander Williams; Released under the MIT License */
(function(root, factory) {
  if (typeof define === 'function' && define.amd && define.amd.dust === true) {
    define(['dust.core'], factory);
  } else if (typeof exports === 'object') {
    module.exports = factory(require('dustjs-linkedin'));
  } else {
    factory(root.dust);
  }
}(this, function(dust) {

// Use dust's built-in logging when available
var _log = dust.log ? function(msg, level) {
  level = level || "INFO";
  dust.log(msg, level);
} : function() {};

var _deprecatedCache = {};
function _deprecated(target) {
  if(_deprecatedCache[target]) { return; }
  _log("Deprecation warning: " + target + " is deprecated and will be removed in a future version of dustjs-helpers", "WARN");
  _log("For help and a deprecation timeline, see https://github.com/linkedin/dustjs-helpers/wiki/Deprecated-Features#" + target.replace(/\W+/g, ""), "WARN");
  _deprecatedCache[target] = true;
}

function isSelect(context) {
  return context.stack.tail &&
         typeof context.stack.tail.head.__select__ !== "undefined";
}

function getSelectState(context) {
  return context.get('__select__');
}

function addSelectState(context, key) {
  var head = context.stack.head,
      newContext = context.rebase();

  if(context.stack && context.stack.tail) {
    newContext.stack = context.stack.tail;
  }

  return newContext
  .push({ "__select__": {
      isResolved: false,
      isDefaulted: false,
      isDeferredComplete: false,
      deferreds: [],
      key: key
    }
  })
  .push(head, context.stack.index, context.stack.of);
}

// Utility method : toString() equivalent for functions
function jsonFilter(key, value) {
  if (typeof value === "function") {
    //to make sure all environments format functions the same way
    return value.toString()
      //remove all leading and trailing whitespace
      .replace(/(^\s+|\s+$)/mg, '')
      //remove new line characters
      .replace(/\n/mg, '')
      //replace , and 0 or more spaces with ", "
      .replace(/,\s*/mg, ', ')
      //insert space between ){
      .replace(/\)\{/mg, ') {')
    ;
  }
  return value;
}

// Utility method: to invoke the given filter operation such as eq/gt etc
function filter(chunk, context, bodies, params, filterOp) {
  params = params || {};
  var body = bodies.block,
      actualKey,
      expectedValue,
      selectState,
      filterOpType = params.filterOpType || '';

  // Currently we first check for a key on the helper itself, then fall back to
  // looking for a key on the {@select} that contains it. This is undocumented
  // behavior that we may or may not support in the future. (If we stop supporting
  // it, just switch the order of the test below to check the {@select} first.)
  if (params.hasOwnProperty("key")) {
    actualKey = dust.helpers.tap(params.key, chunk, context);
  } else if (isSelect(context)) {
    selectState = getSelectState(context);
    actualKey = selectState.key;
    // Once one truth test in a select passes, short-circuit the rest of the tests
    if (selectState.isResolved) {
      filterOp = function() { return false; };
    }
  } else {
    _log("No key specified for filter in {@" + filterOpType + "}");
    return chunk;
  }
  expectedValue = dust.helpers.tap(params.value, chunk, context);
  // coerce both the actualKey and expectedValue to the same type for equality and non-equality compares
  if (filterOp(coerce(expectedValue, params.type, context), coerce(actualKey, params.type, context))) {
    if (isSelect(context)) {
      if(filterOpType === 'default') {
        selectState.isDefaulted = true;
      }
      selectState.isResolved = true;
    }
    // Helpers without bodies are valid due to the use of {@any} blocks
    if(body) {
      return chunk.render(body, context);
    } else {
      return chunk;
    }
  } else if (bodies['else']) {
    return chunk.render(bodies['else'], context);
  }
  return chunk;
}

function coerce(value, type, context) {
  if (typeof value !== "undefined") {
    switch (type || typeof value) {
      case 'number': return +value;
      case 'string': return String(value);
      case 'boolean':
        value = (value === 'false' ? false : value);
        return Boolean(value);
      case 'date': return new Date(value);
      case 'context': return context.get(value);
    }
  }

  return value;
}

var helpers = {

  // Utility helping to resolve dust references in the given chunk
  // uses the Chunk.render method to resolve value
  /*
   Reference resolution rules:
   if value exists in JSON:
    "" or '' will evaluate to false, boolean false, null, or undefined will evaluate to false,
    numeric 0 evaluates to true, so does, string "0", string "null", string "undefined" and string "false".
    Also note that empty array -> [] is evaluated to false and empty object -> {} and non-empty object are evaluated to true
    The type of the return value is string ( since we concatenate to support interpolated references

   if value does not exist in JSON and the input is a single reference: {x}
     dust render emits empty string, and we then return false

   if values does not exist in JSON and the input is interpolated references : {x} < {y}
     dust render emits <  and we return the partial output

  */
  "tap": function(input, chunk, context) {
    // return given input if there is no dust reference to resolve
    // dust compiles a string/reference such as {foo} to a function
    if (typeof input !== "function") {
      return input;
    }

    var dustBodyOutput = '',
      returnValue;

    //use chunk render to evaluate output. For simple functions result will be returned from render call,
    //for dust body functions result will be output via callback function
    returnValue = chunk.tap(function(data) {
      dustBodyOutput += data;
      return '';
    }).render(input, context);

    chunk.untap();

    //assume it's a simple function call if return result is not a chunk
    if (returnValue.constructor !== chunk.constructor) {
      //use returnValue as a result of tap
      return returnValue;
    } else if (dustBodyOutput === '') {
      return false;
    } else {
      return dustBodyOutput;
    }
  },

  "sep": function(chunk, context, bodies) {
    var body = bodies.block;
    if (context.stack.index === context.stack.of - 1) {
      return chunk;
    }
    if (body) {
      return body(chunk, context);
    } else {
      return chunk;
    }
  },

  "first": function(chunk, context, bodies) {
    if (context.stack.index === 0) {
      return bodies.block(chunk, context);
    }
    return chunk;
  },

  "last": function(chunk, context, bodies) {
    if (context.stack.index === context.stack.of - 1) {
      return bodies.block(chunk, context);
    }
    return chunk;
  },

  /**
   * contextDump helper
   * @param key specifies how much to dump.
   * "current" dumps current context. "full" dumps the full context stack.
   * @param to specifies where to write dump output.
   * Values can be "console" or "output". Default is output.
   */
  "contextDump": function(chunk, context, bodies, params) {
    var p = params || {},
      to = p.to || 'output',
      key = p.key || 'current',
      dump;
    to = dust.helpers.tap(to, chunk, context);
    key = dust.helpers.tap(key, chunk, context);
    if (key === 'full') {
      dump = JSON.stringify(context.stack, jsonFilter, 2);
    }
    else {
      dump = JSON.stringify(context.stack.head, jsonFilter, 2);
    }
    if (to === 'console') {
      _log(dump);
      return chunk;
    }
    else {
      // encode opening brackets when outputting to html
      dump = dump.replace(/</g, '\\u003c');

      return chunk.write(dump);
    }
  },
  /**
   if helper for complex evaluation complex logic expressions.
   Note : #1 if helper fails gracefully when there is no body block nor else block
          #2 Undefined values and false values in the JSON need to be handled specially with .length check
             for e.g @if cond=" '{a}'.length && '{b}'.length" is advised when there are chances of the a and b been
             undefined or false in the context
          #3 Use only when the default ? and ^ dust operators and the select fall short in addressing the given logic,
             since eval executes in the global scope
          #4 All dust references are default escaped as they are resolved, hence eval will block malicious scripts in the context
             Be mindful of evaluating a expression that is passed through the unescape filter -> |s
   @param cond, either a string literal value or a dust reference
                a string literal value, is enclosed in double quotes, e.g. cond="2>3"
                a dust reference is also enclosed in double quotes, e.g. cond="'{val}'' > 3"
    cond argument should evaluate to a valid javascript expression
   **/

  /**
   * math helper
   * @param key is the value to perform math against
   * @param method is the math method,  is a valid string supported by math helper like mod, add, subtract
   * @param operand is the second value needed for operations like mod, add, subtract, etc.
   * @param round is a flag to assure that an integer is returned
   */
  "math": function ( chunk, context, bodies, params ) {
    //key and method are required for further processing
    if( params && typeof params.key !== "undefined" && params.method ){
      var key  = params.key,
          method = params.method,
          // operand can be null for "abs", ceil and floor
          operand = params.operand,
          round = params.round,
          mathOut = null;

      key = parseFloat(dust.helpers.tap(key, chunk, context));
      operand = parseFloat(dust.helpers.tap(operand, chunk, context));
      //  TODO: handle  and tests for negatives and floats in all math operations
      switch(method) {
        case "mod":
          if(operand === 0 || operand === -0) {
            _log("Division by 0 in {@math} helper", "WARN");
          }
          mathOut = key % operand;
          break;
        case "add":
          mathOut = key + operand;
          break;
        case "subtract":
          mathOut = key - operand;
          break;
        case "multiply":
          mathOut = key * operand;
          break;
        case "divide":
          if(operand === 0 || operand === -0) {
            _log("Division by 0 in {@math} helper", "WARN");
          }
          mathOut = key / operand;
          break;
        case "ceil":
          mathOut = Math.ceil(key);
          break;
        case "floor":
          mathOut = Math.floor(key);
          break;
        case "round":
          mathOut = Math.round(key);
          break;
        case "abs":
          mathOut = Math.abs(key);
          break;
        case "toint":
          mathOut = parseInt(key, 10);
          break;
        default:
          _log("{@math}: method " + method + " not supported");
     }

      if (mathOut !== null){
        if (round) {
          mathOut = Math.round(mathOut);
        }
        if (bodies && bodies.block) {
          // with bodies act like the select helper with mathOut as the key
          // like the select helper bodies['else'] is meaningless and is ignored
          context = addSelectState(context, mathOut);
          return chunk.render(bodies.block, context);
        } else {
          // self closing math helper will return the calculated output
          return chunk.write(mathOut);
        }
       } else {
        return chunk;
      }
    }
    // no key parameter and no method
    else {
      _log("Key is a required parameter for math helper along with method/operand!");
    }
    return chunk;
  },
   /**
   select helper works with one of the eq/ne/gt/gte/lt/lte/default providing the functionality
   of branching conditions
   @param key,  ( required ) either a string literal value or a dust reference
                a string literal value, is enclosed in double quotes, e.g. key="foo"
                a dust reference may or may not be enclosed in double quotes, e.g. key="{val}" and key=val are both valid
   @param type (optional), supported types are  number, boolean, string, date, context, defaults to string
   **/
  "select": function(chunk, context, bodies, params) {
    var body = bodies.block,
        state, key, len, x;

    if (params.hasOwnProperty("key")) {
      key = dust.helpers.tap(params.key, chunk, context);
      // bodies['else'] is meaningless and is ignored
      if (body) {
        context = addSelectState(context, key);
        state = getSelectState(context);
        chunk = chunk.render(body, context);
        // Resolve any deferred blocks (currently just {@any} blocks)
        if(state.deferreds.length) {
          state.isDeferredComplete = true;
          for(x=0, len=state.deferreds.length; x<len; x++) {
            state.deferreds[x]();
          }
        }
      } else {
        _log("Missing body block in {@select}");
      }
    } else {
      _log("No key provided for {@select}", "WARN");
    }
    return chunk;
  },

  /**
   eq helper compares the given key is same as the expected value
   It can be used standalone or in conjunction with select for multiple branching
   @param key,  The actual key to be compared ( optional when helper used in conjunction with select)
                either a string literal value or a dust reference
                a string literal value, is enclosed in double quotes, e.g. key="foo"
                a dust reference may or may not be enclosed in double quotes, e.g. key="{val}" and key=val are both valid
   @param value, The expected value to compare to, when helper is used standalone or in conjunction with select
   @param type (optional), supported types are  number, boolean, string, date, context, defaults to string
   Note : use type="number" when comparing numeric
   **/
  "eq": function(chunk, context, bodies, params) {
    params.filterOpType = "eq";
    return filter(chunk, context, bodies, params, function(expected, actual) { return actual === expected; });
  },

  /**
   ne helper compares the given key is not the same as the expected value
   It can be used standalone or in conjunction with select for multiple branching
   @param key,  The actual key to be compared ( optional when helper used in conjunction with select)
                either a string literal value or a dust reference
                a string literal value, is enclosed in double quotes, e.g. key="foo"
                a dust reference may or may not be enclosed in double quotes, e.g. key="{val}" and key=val are both valid
   @param value, The expected value to compare to, when helper is used standalone or in conjunction with select
   @param type (optional), supported types are  number, boolean, string, date, context, defaults to string
   Note : use type="number" when comparing numeric
   **/
  "ne": function(chunk, context, bodies, params) {
    params.filterOpType = "ne";
    return filter(chunk, context, bodies, params, function(expected, actual) { return actual !== expected; });
  },

  /**
   lt helper compares the given key is less than the expected value
   It can be used standalone or in conjunction with select for multiple branching
   @param key,  The actual key to be compared ( optional when helper used in conjunction with select)
                either a string literal value or a dust reference
                a string literal value, is enclosed in double quotes, e.g. key="foo"
                a dust reference may or may not be enclosed in double quotes, e.g. key="{val}" and key=val are both valid
   @param value, The expected value to compare to, when helper is used standalone  or in conjunction with select
   @param type (optional), supported types are  number, boolean, string, date, context, defaults to string
   Note : use type="number" when comparing numeric
   **/
  "lt": function(chunk, context, bodies, params) {
    params.filterOpType = "lt";
    return filter(chunk, context, bodies, params, function(expected, actual) { return actual < expected; });
  },

  /**
   lte helper compares the given key is less or equal to the expected value
   It can be used standalone or in conjunction with select for multiple branching
   @param key,  The actual key to be compared ( optional when helper used in conjunction with select)
                either a string literal value or a dust reference
                a string literal value, is enclosed in double quotes, e.g. key="foo"
                a dust reference may or may not be enclosed in double quotes, e.g. key="{val}" and key=val are both valid
   @param value, The expected value to compare to, when helper is used standalone or in conjunction with select
   @param type (optional), supported types are  number, boolean, string, date, context, defaults to string
   Note : use type="number" when comparing numeric
  **/
  "lte": function(chunk, context, bodies, params) {
    params.filterOpType = "lte";
    return filter(chunk, context, bodies, params, function(expected, actual) { return actual <= expected; });
  },

  /**
   gt helper compares the given key is greater than the expected value
   It can be used standalone or in conjunction with select for multiple branching
   @param key,  The actual key to be compared ( optional when helper used in conjunction with select)
                either a string literal value or a dust reference
                a string literal value, is enclosed in double quotes, e.g. key="foo"
                a dust reference may or may not be enclosed in double quotes, e.g. key="{val}" and key=val are both valid
   @param value, The expected value to compare to, when helper is used standalone  or in conjunction with select
   @param type (optional), supported types are  number, boolean, string, date, context, defaults to string
   Note : use type="number" when comparing numeric
   **/
  "gt": function(chunk, context, bodies, params) {
    params.filterOpType = "gt";
    return filter(chunk, context, bodies, params, function(expected, actual) { return actual > expected; });
  },

 /**
   gte helper, compares the given key is greater than or equal to the expected value
   It can be used standalone or in conjunction with select for multiple branching
   @param key,  The actual key to be compared ( optional when helper used in conjunction with select)
                either a string literal value or a dust reference
                a string literal value, is enclosed in double quotes, e.g. key="foo"
                a dust reference may or may not be enclosed in double quotes, e.g. key="{val}" and key=val are both valid
   @param value, The expected value to compare to, when helper is used standalone or in conjunction with select
   @param type (optional), supported types are  number, boolean, string, date, context, defaults to string
   Note : use type="number" when comparing numeric
  **/
  "gte": function(chunk, context, bodies, params) {
    params.filterOpType = "gte";
    return filter(chunk, context, bodies, params, function(expected, actual) { return actual >= expected; });
  },

  /**
   * {@any}
   * Outputs as long as at least one truth test inside a {@select} has passed.
   * Must be contained inside a {@select} block.
   * The passing truth test can be before or after the {@any} block.
   */
  "any": function(chunk, context, bodies, params) {
    var selectState;

    if(!isSelect(context)) {
      _log("{@any} used outside of a {@select} block", "WARN");
    } else {
      selectState = getSelectState(context);
      if(selectState.isDeferredComplete) {
        _log("{@any} nested inside {@any} or {@none} block. It needs its own {@select} block", "WARN");
      } else {
        chunk = chunk.map(function(chunk) {
          selectState.deferreds.push(function() {
            if(selectState.isResolved && !selectState.isDefaulted) {
              chunk = chunk.render(bodies.block, context);
            }
            chunk.end();
          });
        });
      }
    }
    return chunk;
  },

  /**
   * {@none}
   * Outputs if no truth tests inside a {@select} pass.
   * Must be contained inside a {@select} block.
   * The position of the helper does not matter.
   */
  "none": function(chunk, context, bodies, params) {
    var selectState;

    if(!isSelect(context)) {
      _log("{@none} used outside of a {@select} block", "WARN");
    } else {
      selectState = getSelectState(context);
      if(selectState.isDeferredComplete) {
        _log("{@none} nested inside {@any} or {@none} block. It needs its own {@select} block", "WARN");
      } else {
        chunk = chunk.map(function(chunk) {
          selectState.deferreds.push(function() {
            if(!selectState.isResolved) {
              chunk = chunk.render(bodies.block, context);
            }
            chunk.end();
          });
        });
      }
    }
    return chunk;
  },

  /**
   * {@default}
   * Outputs if no truth test inside a {@select} has passed.
   * Must be contained inside a {@select} block.
   */
  "default": function(chunk, context, bodies, params) {
    params.filterOpType = "default";
    // Deprecated for removal in 1.7
    _deprecated("{@default}");
    if(!isSelect(context)) {
      _log("{@default} used outside of a {@select} block", "WARN");
      return chunk;
    }
    return filter(chunk, context, bodies, params, function() { return true; });
  },

  /**
  * size helper prints the size of the given key
  * Note : size helper is self closing and does not support bodies
  * @param key, the element whose size is returned
  */
  "size": function( chunk, context, bodies, params ) {
    var key, value=0, nr, k;
    params = params || {};
    key = params.key;
    if (!key || key === true) { //undefined, null, "", 0
      value = 0;
    }
    else if(dust.isArray(key)) { //array
      value = key.length;
    }
    else if (!isNaN(parseFloat(key)) && isFinite(key)) { //numeric values
      value = key;
    }
    else if (typeof key  === "object") { //object test
      //objects, null and array all have typeof ojbect...
      //null and array are already tested so typeof is sufficient http://jsperf.com/isobject-tests
      nr = 0;
      for(k in key){
        if(Object.hasOwnProperty.call(key,k)){
          nr++;
        }
      }
      value = nr;
    } else {
      value = (key + '').length; //any other value (strings etc.)
    }
    return chunk.write(value);
  }


};

  for(var key in helpers) {
    dust.helpers[key] = helpers[key];
  }

  return dust;

}));

DG.dust = function (tmpl) {
    return function (name, data) {
        if (!dust.cache[name]) {
            dust.loadSource(tmpl[name]);
        }

        var result;

        dust.render(name, data, function (err, html) {
            result = html;
        });

        return result;
    };
};

if (DG.debug) { dust.debugLevel = 'ERROR'; }

DG.Control.Attribution.include(DG.Locale);
DG.Control.Attribution.Dictionary = {};
DG.Control.Attribution.include({
    options: {
        position: 'bottomright'
    },

    _getLink: function (linkType) {
        /* eslint-disable camelcase */
        var dictionary = {
            ru: {
                copyright_logo: 'http://info.2gis.ru/?utm_source=copyright&utm_medium=map&utm_campaign=partners',
                copyright_apilink: 'http://api.2gis.ru/?utm_source=copyright&utm_medium=map&utm_campaign=partners',
                copyright_license: 'http://help.2gis.ru/licensing-agreement/'
            },

            it: {
                copyright_logo: 'http://2gis.it/?utm_source=copyright&utm_medium=map&utm_campaign=partners',
                copyright_apilink: 'http://2gis.it/?utm_source=copyright&utm_medium=map&utm_campaign=partners',
                copyright_license: 'http://2gis.it/'
            },

            cz: {
                copyright_logo: 'http://praha.2gis.cz/?utm_source=copyright&utm_medium=map&utm_campaign=partners',
                copyright_apilink: 'http://praha.2gis.cz/?utm_source=copyright&utm_medium=map&utm_campaign=partners',
                copyright_license: 'http://law.2gis.cz/licensing-agreement/'
            },

            cl: {
                copyright_logo: 'http://santiago.2gis.cl/?utm_source=copyright&utm_medium=map&utm_campaign=partners',
                copyright_apilink: 'http://santiago.2gis.cl/?utm_source=copyright&utm_medium=map&utm_campaign=partners',
                copyright_license: 'http://law.2gis.cl/licensing-agreement/'
            },

            cy: {
                copyright_logo: 'http://info.2gis.com.cy/lemesos?utm_source=copyright&utm_medium=map&utm_campaign=partners',
                copyright_apilink: 'http://info.2gis.com.cy/lemesos?utm_source=copyright&utm_medium=map&utm_campaign=partners',
                copyright_license: 'http://law.2gis.com.cy/licensing-agreement/'
            },

            ae: {
                copyright_logo: 'http://info.2gis.ae/dubai?utm_source=copyright&utm_medium=map&utm_campaign=partners',
                copyright_apilink: 'http://info.2gis.ae/dubai?utm_source=copyright&utm_medium=map&utm_campaign=partners',
                copyright_license: 'http://law.2gis.ae/licensing-agreement/'
            }
        };
        /* eslint-enable camelcase */

        var countryCode = (this._countryCode in dictionary) ? this._countryCode : 'ru';

        return dictionary[countryCode][linkType];
    },

    onAdd: function (map) {
        if (!map._copyright) {
            map._copyright = true;
            this._first = true;
        }

        this._container = DG.DomUtil.create('div', 'dg-attribution');
        DG.DomEvent.disableClickPropagation(this._container);

        for (var i in map._layers) {
            if (map._layers[i].getAttribution) {
                this.addAttribution(map._layers[i].getAttribution());
            }
        }

        this._update();

        return this._container;
    },

    _update: function (lang, osm, countryCode) {
        if (!this._map) { return; }

        if (typeof osm !== 'undefined') {
            this._osm = osm;
        }

        if (typeof countryCode !== 'undefined') {
            this._countryCode = countryCode;
        }

        var attribs = [];

        for (var i in this._attributions) {
            if (this._attributions[i]) {
                attribs.push(i);
            }
        }

        var prefixAndAttribs = [],
            copyright = '';

        if (this._first) {
            copyright = this._getAttributionHTML(lang);
        }

        if (this.options.prefix) {
            prefixAndAttribs.push(this.options.prefix);
        }
        if (attribs.length) {
            prefixAndAttribs.push(attribs.join(', '));
        }

        this._container.innerHTML = copyright + prefixAndAttribs.join(' | ');
    },
    /* global __DGAttribution_TMPL__ */
    _tmpl: DG.dust({"copyright":"(function(){dust.register(\"copyright\",body_0);function body_0(chk,ctx){return chk.write(\"<div class=\\\"dg-attribution__copyright\\\"><ul class=\\\"dg-attribution__links\\\"><li class=\\\"dg-attribution__link-item\\\">\").exists(ctx.get([\"osm\"], false),ctx,{\"block\":body_1},null).write(\"<a href=\\\"\").reference(ctx.get([\"copyright_apilink\"], false),ctx,\"h\").write(\"\\\" target=\\\"_blank\\\" class=\\\"dg-attribution__link\\\">\").notexists(ctx.get([\"osm\"], false),ctx,{\"block\":body_2},null).reference(ctx.get([\"API_2GIS\"], false),ctx,\"h\").write(\"</a></li><li class=\\\"dg-attribution__link-item\\\"><a href=\\\"\").reference(ctx.get([\"copyright_license\"], false),ctx,\"h\").write(\"\\\" target=\\\"_blank\\\" class=\\\"dg-attribution__link\\\">\").reference(ctx.get([\"license_agreement\"], false),ctx,\"h\").write(\"</a></li></ul><a href=\\\"\").reference(ctx.get([\"copyright_logo\"], false),ctx,\"h\").write(\"\\\" target=\\\"_blank\\\" class=\\\"dg-attribution__logo-url\\\"></a></div>\");}function body_1(chk,ctx){return chk.write(\" <a href=\\\"http://www.openstreetmap.org/copyright\\\" target=\\\"_blank\\\" class=\\\"dg-attribution__link\\\">OpenStreetMap contributors</a>, \");}function body_2(chk,ctx){return chk.reference(ctx.get([\"work_on\"], false),ctx,\"h\").write(\" \");}return body_0;})();"}),
    _getData: function (lang) {
        return {
            'osm': this._osm,
            'work_on': this.t('work_on'),
            'lang': lang || this._map.getLang(),
            'copyright_apilink': this._getLink('copyright_apilink'),
            'copyright_license': this._getLink('copyright_license'),
            'copyright_logo': this._getLink('copyright_logo'),
            'license_agreement': this.t('license_agreement'),
            'API_2GIS': this.t('API_2GIS')
        };
    },
    _getAttributionHTML: function (lang) {
        return this._tmpl('copyright', this._getData(lang));
    },
    _renderTranslation: function (e) {
        this._update(e.lang);
    }
});

DG.Map.addInitHook(function () {
    if (!this._copyright) {
        DG.control.attribution().addTo(this);
    }
});

DG.Control.Attribution.Dictionary.ru = {
    license_agreement: ' ',
    work_on: ' ',
    API_2GIS: 'API 2'
};

DG.Control.Attribution.Dictionary.it = {
	license_agreement : 'Accordo di licenza',
    work_on: ' ',
	API_2GIS: '2GIS API'
};

DG.Control.Attribution.Dictionary.cs = {
	license_agreement: 'Licenn smlouva',
	work_on: 'Pracuje na',
    API_2GIS: 'API 2GIS'
};

DG.Control.Attribution.Dictionary.en = {
    license_agreement: 'License agreement',
    work_on: 'Uses',
    API_2GIS: '2GIS API'
};

DG.Control.Attribution.Dictionary.es = {
	license_agreement : 'Acuerdo de licencia',
    work_on: ' ',
	API_2GIS: '2GIS API'
};

DG.Control.Location = DG.RoundControl.extend({

    statics: {
        Dictionary: {}
    },

    options: {
        iconClass: 'locate',
        position: DG.Browser.touch ? 'bottomright' : 'topleft',
        drawCircle: true,
        follow: true,  // follow with zoom and pan the user's location
        stopFollowingOnDrag: false, // if follow is true, stop following when map is dragged
        metric: true,
        onLocationError: function (/*err*/) {
            // this event is called in case of any location error
            // that is not a time out error.
            // console.log(err.message);
        },
        onLocationOutsideMapBounds: function (/*context*/) {
            // this event is repeatedly called when the location changes
            // console.log(context.t('outsideMapBoundsMsg'));
        },
        locateOptions: {}
    },

    initialize: function (options) {
        DG.Util.setOptions(this, options);

        if (!navigator.geolocation) {
            this._disable = true;
            return;
        }

        this._event = undefined;

        this._locateOptions = {
            watch: true,  // if you overwrite this, visualization cannot be updated
            setView: false,
            maximumAge: Infinity
        };
        DG.extend(this._locateOptions, this.options.locateOptions);

        this._resetVariables();

        this.on({
            'click': this._handleLocate,
            'add': this._initLocate
        });
    },

    _initLocate: function () {
        this._layer = new DG.LayerGroup();
        this._layer.addTo(this._map);

        // event hooks
        this._map.on({
            'locationfound': this._onLocationFound,
            'locationerror': this._onLocationError
        }, this);
    },

    _handleLocate: function () {
        if (this._active && (!this._event ||
            (this._map.getBounds().contains(this._event.latlng) ||
            this._isOutsideMapBounds()))) {
            this._stopLocate();
        } else {
            this._locateOnNextLocationFound = true;

            if (!this._active) {
                this._map.locate(this._locateOptions);
            }

            this._active = true;

            if (this.options.follow) {
                this._startFollowing();
            }

            this._clearError();

            if (this._event) {
                this._visualizeLocation();
            } else {
                this.setState('requesting');
            }
        }
    },

    _onLocationFound: function (e) {
        // no need to do anything if the location has not changed
        if (this._event &&
            (this._event.latlng.lat === e.latlng.lat &&
             this._event.latlng.lng === e.latlng.lng &&
             this._event.accuracy === e.accuracy)) {
            return;
        }

        if (!this._active) {
            return;
        }

        this._event = e;

        if (this.options.follow && this._following) {
            this._locateOnNextLocationFound = true;
        }

        this._visualizeLocation();
    },

    _startFollowing: function () {
        this._following = true;
        if (this.options.stopFollowingOnDrag) {
            this._map.on('dragstart', this._stopFollowing);
        }
    },

    _stopFollowing: function () {
        this._following = false;
        if (this.options.stopFollowingOnDrag) {
            this._map.off('dragstart', this._stopFollowing);
        }
        this._visualizeLocation();
    },

    _isOutsideMapBounds: function () {
        if (this._event === undefined) {
            return false;
        }
        return this._map.options.maxBounds &&
            !this._map.options.maxBounds.contains(this._event.latlng);
    },

    _visualizeLocation: function () {
        if (this._event.accuracy === undefined) {
            this._event.accuracy = 0;
        }

        var radius = this._event.accuracy;

        if (this._locateOnNextLocationFound) {
            if (this._isOutsideMapBounds()) {
                this.options.onLocationOutsideMapBounds(this);
            } else {
                /* global 13:false*/
                var zoom = this._map.projectDetector.getProject().maxZoom || 13;
                this._map.setView(this._event.latlng, zoom);
            }
            this._locateOnNextLocationFound = false;
        }

        // circle with the radius of the location's accuracy
        var style = {
            clickable: false,
            color: '#FFF',
            fillColor: '#FFF',
            fillOpacity: 0.4,
            weight: 0,
            opacity: 0.3
        };
        if (this.options.drawCircle) {
            if (!this._circle) {
                this._circle = DG.circle(this._event.latlng, radius, style)
                    .addTo(this._layer);
            } else {
                this._circle.setLatLng(this._event.latlng).setRadius(radius);
            }
        }

        var markerClass = 'dg-location__pin';

        markerClass += this._following ? (' ' + markerClass + 'state_following') : '';
        // small inner marker
        var m = {
            icon: DG.divIcon({
                className: markerClass,
                iconSize: [20, 20]
            })
        };

        if (!this._marker) {
            this._marker = DG.marker(this._event.latlng, m)
                .bindLabel(this.t('you_are_here'))
                .addTo(this._layer);
        } else {
            this._marker.setLatLng(this._event.latlng);
        }

        DG.DomEvent.on(this._marker, 'click', function () {
            this._map.fireEvent('dgLocateClick');
        }, this);

        if (!this._container) {
            return;
        }

        this.setState('active');
    },

    _resetVariables: function () {
        this._active = false;
        this._following = false;
    },


    _stopLocate: function () {
        this._map.stopLocate();
        this._map.off('dragstart', this._stopFollowing);

        this.setState();
        this._resetVariables();

        this._layer.clearLayers();
        this._marker = undefined;
        this._circle = undefined;
        this._event = undefined;
    },

    _onLocationError: function (err) {
        // ignore time out error if the location is watched
        if (err.code === 3 && this._locateOptions.watch) {
            return;
        }

        this._stopLocate();
        this._error = DG.DomUtil.create('div', 'dg-label dg-label_name_location-error', this._container);
        this._errorText = DG.DomUtil.create('div', 'dg-label__content', this._error);
        this._errorText.innerHTML = this.t('cant_find');

        var self = this;
        setTimeout(function () {
            self._clearError();
        }, 3000);

        //show location error
        this.options.onLocationError(err);
    },

    _clearError: function () {
        if (this._error) {
            this._container.removeChild(this._error);
            this._error = undefined;
            this._errorText = undefined;
        }
    },

    _renderTranslation: function () {
        if (this._link) {
            this._link.title = this.t('button_title');
        }
        if (this._marker) {
            this._marker.bindLabel(this.t('you_are_here'));
        }
    }
});

DG.control.location = function (options) {
    return new DG.Control.Location(options);
};

DG.Map.addInitHook(function () {
    if (this.options.locationControl) {
        this.locationControl = DG.control.location(this.options.locationControl);
        this.addControl(this.locationControl);
    }
});

DG.Control.Location.Dictionary.ru = {
	 cant_find : '    ',
	 you_are_here : ' ',
	 button_title : '   '
};
DG.Control.Location.Dictionary.it = {
	 cant_find : 'Non siamo riusciti a localizzarti',
	 you_are_here : 'Voi siete qui',
	 button_title : 'Trova la tua posizione sulla mappa'
};
DG.Control.Location.Dictionary.cs = {
	 cant_find : 'Nepodailo se nm urit Vai polohu',
	 you_are_here : 'Jste tady',
	 button_title : 'Urit Vai polohu na map'
};
DG.Control.Location.Dictionary.en = {
	 cant_find : 'We can\'t find you',
	 you_are_here : 'You are here',
	 button_title : 'Show your location'
};
DG.Control.Location.Dictionary.es = {
	 cant_find : 'No pudimos encontrarte',
	 you_are_here : 'T ests aqu',
	 button_title : 'Encontrarte en el mapa'
};
// Inspired by Sindre Sorhus screenfull
/*global Element */
DG.Screenfull = DG.Class.extend({
    _apiMap: [
        [
            'requestFullscreen',
            'exitFullscreen',
            'fullscreenElement',
            'fullscreenEnabled',
            'fullscreenchange',
            'fullscreenerror'
        ],
        [
            'webkitRequestFullscreen',
            'webkitExitFullscreen',
            'webkitFullscreenElement',
            'webkitFullscreenEnabled',
            'webkitfullscreenchange',
            'webkitfullscreenerror'

        ],
        [
            'mozRequestFullScreen',
            'mozCancelFullScreen',
            'mozFullScreenElement',
            'mozFullScreenEnabled',
            'mozfullscreenchange',
            'mozfullscreenerror'
        ],
        [
            'msRequestFullscreen',
            'msExitFullscreen',
            'msFullscreenElement',
            'msFullscreenEnabled',
            'MSFullscreenChange',
            'MSFullscreenError'
        ]
    ],

    initialize: function () {
        this.api = this._api();
    },

    request: function (elem) {
        var request = this.api.requestFullscreen;

        elem = elem || document.documentElement;
        elem[request](Element.ALLOW_KEYBOARD_INPUT);
    },

    exit: function () {
        document[this.api.exitFullscreen]();
    },

    isFullscreen: function () {
        return !!document[this.api.fullscreenElement];
    },

    isAvailable: function () {
        return Boolean(this.api);
    },

    _api: function () {
        var api = {},
            apiMap = this._apiMap;

        apiMap.forEach(function (val) {
            if (val && val[1] in document) {
                val.forEach(function (method, i) {
                    api[apiMap[0][i]] = method;
                });
            }
        });

        return api.requestFullscreen ? api : false;
    }
});

DG.screenfull = new DG.Screenfull();

DG.Control.Fullscreen = DG.RoundControl.extend({

    statics: {
        Dictionary: {}
    },

    options: {
        position: 'topright',
        iconClass: 'fullscreen'
    },

    initialize: function (options) {
        DG.Util.setOptions(this, options);
        this._isFullscreen = false;
        this.on('click', this._toggleFullscreen);
    },

    _toggleFullscreen: function () {
        if (!this._isFullscreen) {
            this._toggle(true, 'request', 'on', 'requestfullscreen');
        } else {
            this._toggle(false, 'exit', 'on', 'cancelfullscreen');
        }

        this._renderTranslation();
        this._map.invalidateSize();
    },

    _renderTranslation: function () {
        this._link.title = this.t(this._isFullscreen ? 'title_min' : 'title_max');
    },

    _toggle: function (isEnabled, method, list, event) {
        var container = this._map._container;

        this._isFullscreen = isEnabled;
        this.setState(isEnabled ? 'active' : '');

        DG.screenfull[method](container);
        DG.DomEvent[list](document, DG.screenfull.api.fullscreenchange, this._onFullScreenStateChange, this);
        this._map.fire(event);
    },

    _onFullScreenStateChange: function () {
        if (!DG.screenfull.isFullscreen()) {
            this._toggle(false, 'exit', 'on', 'cancelfullscreen');
        }
    }
});

DG.control.fullscreen = function (options) {
    return new DG.Control.Fullscreen(options);
};

DG.Map.mergeOptions({
    fullscreenControl: true
});

DG.Map.addInitHook(function () {
    if (this.options.fullscreenControl) {
        this.fullscreenControl = DG.control.fullscreen(this.options.fullscreenControl);

        if (DG.screenfull.isAvailable()) {
            this.addControl(this.fullscreenControl);
        }
    }
});

DG.Control.Fullscreen.Dictionary.ru = {
    title_max : '',
    title_min : ''
};

DG.Control.Fullscreen.Dictionary.it = {
    title_max : 'Espandi',
    title_min : 'Ripristina'
};

DG.Control.Fullscreen.Dictionary.cs = {
     title_max : 'Rozbalit',
     title_min : 'Obnovit'
};

DG.Control.Fullscreen.Dictionary.en = {
    title_max : 'Expand',
    title_min : 'Restore'
};

DG.Control.Fullscreen.Dictionary.es = {
    title_max : 'Maximizar',
    title_min : 'Restaurar'
};

DG.Meta = {};

DG.Meta.Layer = DG.Layer.extend({

    options: {
        tileSize: 256,

        minZoom: 0,
        maxZoom: 19,
        zoomOffset: 0,
        eventBubbling: 'transparent'
        // maxNativeZoom: <Number>,
        // detectRetina: <Number>,
        // zoomReverse: <Number>
        // attribution: <String>,
        // zIndex: <Number>,
        // bounds: <LatLngBounds>
    },

    initialize: function (source, options) { // (String, Object)
        DG.TileLayer.prototype.initialize.call(this, null, options);
        delete this._url;

        this._currentTile = false;
        this._currentTileData = false;
        this._hoveredObject = null;

        this._origin = DG.Meta.origin(source, {
            dataFilter: this.options.dataFilter
        });
    },

    getOrigin: function () { // () -> Object
        return this._origin;
    },

    onAdd: function (map) {
        this._reset();
        this._addDomEvents();

        map.on('rulerstart', this._removeDomEvents, this);
        map.on('rulerend', this._addDomEvents, this);
    },

    onRemove: function (map) {
        this._removeDomEvents();

        map.off('rulerstart', this._removeDomEvents, this);
        map.off('rulerend', this._addDomEvents, this);
    },

    getEvents: function () {
        var events = {
            viewreset: this._reset
        };

        return events;
    },

    _addDomEvents: function () {
        DG.DomEvent.on(this._map.getPane('tilePane'), this._domEvents, this);
    },

    _removeDomEvents: function () {
        DG.DomEvent.off(this._map.getPane('tilePane'), this._domEvents, this);
    },

    _getZoomForUrl: DG.TileLayer.prototype._getZoomForUrl,
    _getTileSize: DG.TileLayer.prototype._getTileSize,
    _getTileNumBounds: DG.GridLayer.prototype._getTileNumBounds,
    _isValidTile: DG.GridLayer.prototype._isValidTile,
    _wrapCoords: DG.GridLayer.prototype._wrapCoords,
    _resetWrap: DG.GridLayer.prototype._resetWrap,

    _domEvents: {
        mousemove: function (event) { // (MouseEvent)
            var tileSize = this._getTileSize(),
                layerPoint = this._map.mouseEventToLayerPoint(event),
                tileOriginPoint = this._map.getPixelOrigin().add(layerPoint),
                tileCoord = tileOriginPoint.divideBy(tileSize).floor(),
                mouseTileOffset,
                tileKey,
                hoveredObject,
                zoom = this._map.getZoom();

            if (zoom > (this.options.maxZoom + this.options.zoomOffset) ||
                zoom < (this.options.minZoom - this.options.zoomOffset) ||
                !this._isValidTile(tileCoord)) {
                return;
            }

            this._wrapCoords(tileCoord);

            tileCoord.z = this._getZoomForUrl();
            tileCoord.key = tileSize;
            tileKey = this._origin.getTileKey(tileCoord);

            if (tileKey !== this._currentTile) {
                this._currentTile = tileKey;
                this._currentTileData = false;
            }

            if (this._currentTileData === false) {
                this._currentTileData = this._origin.getTileData(tileCoord);
            } else {
                mouseTileOffset = DG.point(tileOriginPoint.x % tileSize, tileOriginPoint.y % tileSize);
                hoveredObject = this._getHoveredObject(tileCoord, mouseTileOffset);

                if (this._hoveredEntity !== hoveredObject) {
                    this._fireMouseEvent('mouseout', event);

                    this._hoveredEntity = hoveredObject;
                    this._fireMouseEvent('mouseover', event);
                }

                this._fireMouseEvent('mousemove', event);
            }
        },
        mouseout: function (event) {
            this._fireMouseEvent('mouseout', event);
            this._hoveredEntity = null;
            this._currentTile = false;
        },

        click: function (event) {
            this._fireMouseEvent('click', event);
        },

        dblclick: function (event) {
            this._fireMouseEvent('dblclick', event);
        },

        mousedown: function (event) {
            this._fireMouseEvent('mousedown', event);
        },

        contextmenu: function (event) {
            this._fireMouseEvent('contextmenu', event);
        }
    },

    _fireMouseEvent: function (type, mouseEvent) {
        if (this._hoveredEntity) {
            this.fire(type, {
                meta: this._hoveredEntity,
                latlng: this._map.mouseEventToLatLng(mouseEvent)
            });
            if (this.options.eventBubbling === 'layer') {
                DG.DomEvent.stop(mouseEvent);
            }
        }
    },

    _getHoveredObject: function (coords, mouseTileOffset) {
        for (var i = this._currentTileData.length - 1; i >= 0; i--) {
            if (DG.PolyUtil.contains(mouseTileOffset, this._currentTileData[i].geometry.coordinates[0])) {
                return this._currentTileData[i];
            }
        }

        return null;
    },

    _reset: function () {
        this._tileNumBounds = this._getTileNumBounds();
        this._resetWrap(this._tileNumBounds);
    }

});

DG.Meta.layer = function (source, options) {
    return new DG.Meta.Layer(source, options);
};

DG.Meta.Origin = DG.Class.extend({

    options: {
        subdomains: '0123',
        dataFilter: null
    },

    _url: false,

    initialize: function (url, options) { // (String, Object)
        this._url = url;
        this._requests = {};

        this._tileStorage = {};
        this._dataStorage = {};

        options = DG.setOptions(this, options);

        if (typeof options.subdomains === 'string') {
            options.subdomains = options.subdomains.split('');
        }
    },

    getTileData: function (coord) { // (Object) -> Object
        var tileKey = this.getTileKey(coord),
            self = this;

        if (typeof this._tileStorage[tileKey] === 'undefined' && typeof this._requests[tileKey] === 'undefined') {
            this._tileStorage[tileKey] = false;
            this._requests[tileKey] = this._requestData(coord).then(function (data) {
                self.setTileData(tileKey, self.options.dataFilter ? self.options.dataFilter(data, coord) : data);
                delete self._requests[tileKey];
            });
        }

        if (this._tileStorage[tileKey].constructor === Object) {
            return Object.keys(this._tileStorage[tileKey]).map(function (id) {
                return DG.extend({geometry: this._tileStorage[tileKey][id]}, this._dataStorage[id]);
            }, this);
        }

        return this._tileStorage[tileKey];
    },

    setTileData: function (key, data) { // (Object/String, Object) -> Object
        if (typeof key !== 'string') {
            key = this.getTileKey(key);
        }

        data.forEach(function (entity) {
            if (entity.geometry.constructor !== Object) {
                entity.geometry = DG.Wkt.toGeoJSON(entity.geometry);
            }
            if (!this._tileStorage[key]) {
                this._tileStorage[key] = {};
            }
            this._tileStorage[key][entity.id] = entity.geometry;
            delete entity.geometry;
            this._dataStorage[entity.id] = entity;
        }, this);

        return this;
    },

    flush: function () { // () -> Object
        this._tileStorage = {};
        this._dataStorage = {};
        Object.keys(this._requests).forEach(function (tileKey) {
            if (this[tileKey].abort) {
                this[tileKey].abort();
            }
        }, this._requests);

        return this;
    },

    setURL: function (url, flush) { // (String, Boolean) -> Object
        this._url = url;
        if (flush) {
            this.flush();
        }

        return this;
    },

    getTileKey: function (coord) { // (Object)-> String
        return [coord.x, coord.y, coord.z, coord.key].join(':');
    },

    _requestData: function (key) { // (String)
        if (this._url) {
            return this._performRequest(key);
        } else {
            return Promise.resolve([]);
        }
    },

    _performRequest: function (coords) { // (Object) -> Promise
        return DG.ajax(this._prepareURL(coords), {
            type: 'get',
            dataType: 'json'
        });
    },

    _prepareURL: function (coords) { // (Object) -> String
        return DG.Util.template(this._url, {
            x: coords.x,
            y: coords.y,
            z: coords.z,
            s: this._getSubdomain(coords)
        });
    },

    _getSubdomain: DG.TileLayer.prototype._getSubdomain

});

DG.Meta.origin = function (source, options) {
    return new DG.Meta.Origin(source, options);
};

// ray tracing method: http://algolist.ru/maths/geom/belong/poly2d.php

DG.PolyUtil.contains = function (point, geometry) { // (DG.LatLng, Array) -> Boolean
    var edges, i, len,
        parity = 0,
        vertices = [];

    for (i = 0, len = geometry.length; i < len; i++) {
        vertices.push(DG.point(geometry[i]));
    }

    edges = this._getEdges(vertices);
    for (i = 0, len = edges.length; i < len; i++) {
        switch (this._getEdgeType(edges[i], point)) {
            case 'TOUCHING':
                return true;
            case 'CROSSING':
                parity = 1 - parity;
                break;
        }
    }
    return parity ? true : false;
};

// returns array with edge objects
DG.PolyUtil._getEdges = function (vertices) { // (Array) -> Array
    var edges = [];
    var edge;
    var startPoint;
    var endPoint;

    for (var i = 0, len = vertices.length; i < len; i++) {
        startPoint = vertices[i];
        endPoint = (i !== len - 1) ? vertices[i + 1] : vertices[0];
        edge = {
            startPoint: startPoint,
            endPoint: endPoint
        };
        edges.push(edge);
    }

    return edges;
};

// result should be: 'CROSSING', 'INESSENTIAL' or 'TOUCHING'
DG.PolyUtil._getEdgeType = function (edge, point) { // (Object, DG.Point) -> String
    var pointPosition = this._classify(edge, point);
    switch (pointPosition) {
        case 'LEFT':
            return ((edge.startPoint.y < point.y) && (point.y <= edge.endPoint.y)) ? 'CROSSING' : 'INESSENTIAL';
        case 'RIGHT':
            return ((edge.endPoint.y < point.y) && (point.y <= edge.startPoint.y)) ? 'CROSSING' : 'INESSENTIAL';
        case 'BETWEEN':
        case 'ORIGIN':
        case 'DESTINATION':
            return 'TOUCHING';
        default:
            return 'INESSENTIAL';
    }
};

// determines the position of a point relative to the edge
// result should be: 'LEFT', 'RIGHT', 'BEHIND', 'BEYOND', 'ORIGIN', 'DESTINATION', 'BETWEEN'
DG.PolyUtil._classify = function (edge, point) { // (Object, DG.Point) -> String
    var a;
    var b;
    var sa;

    a = {
        x: edge.endPoint.x - edge.startPoint.x,
        y: edge.endPoint.y - edge.startPoint.y
    };
    b = {
        x: point.x - edge.startPoint.x,
        y: point.y - edge.startPoint.y
    };

    sa = a.x * b.y - b.x * a.y;
    if (sa > 0) {
        return 'LEFT';
    }
    if (sa < 0) {
        return 'RIGHT';
    }
    if ((a.x * b.x < 0) || (a.y * b.y < 0)) {
        return 'BEHIND';
    }
    if (this._getLengthSquared(a) < this._getLengthSquared(b)) {
        return 'BEYOND';
    }
    if (DG.PolyUtil._areEquals(edge.startPoint, point)) {
        return 'ORIGIN';
    }
    if (DG.PolyUtil._areEquals(edge.endPoint, point)) {
        return 'DESTINATION';
    }
    return 'BETWEEN';
};

DG.PolyUtil._getLengthSquared = function (point) { // (DG.Point) -> Number
    return Math.pow(point.x, 2) + Math.pow(point.y, 2);
};

DG.PolyUtil._areEquals = function (point1, point2) { // (DG.Point, DG.Point) -> Boolean
    return point1.x === point2.x && point1.y === point2.y;
};

/* global 15,true */

DG.Map.mergeOptions({
    poi: !DG.Browser.touch
});

DG.Poi = DG.Handler.extend({

    options: {
        disableLabel: false
    },

    statics: {
        metaURL: 'http://tile{s}.maps.2gis.com/?x={x}&y={y}&z={z}&v=1&type=poi'
    },

    initialize: function (map, options) { // (Object)
        this._map = map;
        DG.Util.setOptions(this, options);
        this._metaLayer = DG.Meta.layer(DG.Poi.metaURL, {
            minZoom: 15,
            maxNativeZoom: 19,
            detectRetina: true,
            eventBubbling: 'layer',
            dataFilter: DG.bind(this._processData, this)
        });
    },

    addHooks: function () {
        this._map.addLayer(this._metaLayer);
        if (!this.options.disableLabel) {
            this._labelHelper = DG.label();
            this._metaLayer.on(this._layerEventsListeners, this);
        }
    },

    removeHooks: function () {
        this._map.removeLayer(this._metaLayer);
        if (!this.options.disableLabel) {
            this._metaLayer.off(this._layerEventsListeners, this);
            this._map.removeLayer(this._labelHelper);
            this._labelHelper = null;
        }
    },

    getMetaLayer : function () {
        return this._metaLayer;
    },

    _processData : function (data, coord) {
        var map = this._map,
            tileOriginPoint = coord.multiplyBy(this._metaLayer._getTileSize());

        if (data.responseText === '') {
            return [];
        }

        return data.result.poi.map(function (item) {
            var geoJson = DG.Wkt.toGeoJSON(item.hover);

            geoJson.coordinates[0] = geoJson.coordinates[0].map(function (revertedLatlng) {
                return map
                        .project([revertedLatlng[1], revertedLatlng[0]]).round()
                        .subtract(tileOriginPoint);
            });
            return {
                id: item.id,
                hint: item.links[0].name,
                linked: item.links[0],
                geometry: geoJson
            };
        });
    },

    _layerEventsListeners : {
        mouseover: function (e) { // (Object)
            this._setCursor('pointer');
            this._labelHelper
                .setPosition(e.latlng)
                .setContent(e.meta.hint);
            this._map.addLayer(this._labelHelper);
        },

        mouseout: function () {
            this._setCursor('');
            this._map.removeLayer(this._labelHelper);
        },

        mousemove: function (e) { // (Object)
            this._labelHelper.setPosition(e.latlng);
        }
    },

    _setCursor: function (cursor) { // (String)
        this._map.getContainer().style.cursor = cursor;
    }

});

DG.Map.addInitHook('addHandler', 'poi', DG.Poi);

DG.Entrance = DG.Layer.extend({

    options: {
        vectors: []
    },

    statics: {
        SHOW_FROM_ZOOM: DG.Browser.svg ? 16 : 17
    },

    initialize: function (options) { // (Object)
        DG.setOptions(this, options);
    },

    onAdd: function (map) { // (DG.Map)
        this._map = map;
        this._initArrows().addTo(map);
        this._eventHandler = new DG.Entrance.EventHandler(map, this);
        this._eventHandler.enable();

        // hide without event by default
        this._arrows.eachLayer(function (arrow) {
            arrow.setStyle({visibility: 'hidden'});
        });
        this._isShown = false;
    },

    addTo: function (map) { // (DG.Map) -> DG.Entrance
        map.addLayer(this);
        return this;
    },

    onRemove: function () { // (DG.Map)
        this._isShown = false;
        this._removeArrows();
        this._map = null;
        this._eventHandler.disable();
        this._eventHandler = null;
        this._arrows = null;
    },

    removeFrom: function (map) { // (DG.Map) -> DG.Entrance
        map.removeLayer(this);
        return this;
    },

    show: function (fitBounds) { // () -> DG.Entrance
        if (!this._arrows) {
            return this;
        }
        if (fitBounds !== false) {
            this._fitBounds();
        }
        if (this._isAllowedZoom()) {
            this._arrows.eachLayer(function (arrow) {
                arrow.setStyle({visibility: 'visible'});
                if (DG.Path.ANIMATION_AVAILABLE) {
                    arrow.runAnimation('animateArrowPathGeom');
                }
            });
            if (!this._isShown) {
                this._map.fire('entranceshow');
                this._isShown = true;
            }
        }

        return this;
    },

    hide: function () { // () -> DG.Entrance

        if (this.isShown() && this._arrows) {
            this._arrows.eachLayer(function (arrow) {
                arrow.setStyle({visibility: 'hidden'});
            });
            this._isShown = false;
            this._map.fire('entrancehide');
        }

        return this;
    },

    isShown: function () { // () -> Boolean
        return this._isShown;
    },

    getBounds: function () { // () -> DG.LatLngBounds
        return this._arrows.getBounds();
    },

    _initArrows: function () { // () -> DG.FeatureGroup
        this._arrows = DG.featureGroup();

        this.options.vectors
            .map(function (vector) {
                return DG.Wkt.toLatLngs(vector);
            })
            .forEach(function (latlngs) {
                // stroke
                this._arrows.addLayer(DG.Entrance.arrow(latlngs, this._getArrowStrokeOptions()));
                // basis
                this._arrows.addLayer(DG.Entrance.arrow(latlngs, this._getArrowOptions()));
            }, this);

        return this._arrows;
    },

    _removeArrows: function () {
        this._map.removeLayer(this._arrows.clearLayers());
    },

    _getFitZoom: function () {
        return this._map.projectDetector.getProject().maxZoom || DG.Entrance.SHOW_FROM_ZOOM;
    },

    _fitBounds: function () {
        var map = this._map,
            fitZoom,
            bounds = this.getBounds();

        if (!map.getBounds().contains(bounds) || !this._isAllowedZoom()) {
            fitZoom = this._getFitZoom();
            if (!map.projectDetector.getProject()) {
                map.once('moveend', function () {
                    map.setZoom(this._getFitZoom());
                }, this);
            }
            map.setView(bounds.getCenter(), fitZoom, {
                animate : true
            });
        }
    },

    _isAllowedZoom: function () {
        return this._map.getZoom() >= DG.Entrance.SHOW_FROM_ZOOM;
    },

    _getArrowStrokeOptions: function () {
        return {
            clickable: false,
            color: '#fff',
            weight: 6,
            byZoom: {
                16: {
                    marker: {
                        viewBox: '0 0 24 24',
                        refX: 12,
                        refY: 12,
                        markerHeight: 24,
                        markerWidth: 24,
                        path: {
                            d:  'M9.313,18.984c2.246-1.468,7.101-5.562,' +
                                '7.101-5.562c0.781-0.781,0.781-2.047,0-' +
                                '2.828c0,0-5.242-4.023-7.101-5.102C9.74' +
                                ',5.354,8.583,5.93,8.125,6.5C7.902,6.77' +
                                '7,9,11.614,9,11.614v0.789c0,0-0.879,4.' +
                                '237-0.905,5.285C8.09,17.891,9.108,19.1' +
                                '18,9.313,18.984z'
                        }
                    },
                    lastPointOffset: 2,
                    vmlEndArrow: 'none',
                    weight: 6,
                    iconWidth: 4
                },
                17: {
                    marker: {
                        viewBox: '0 0 24 24',
                        refX: 12,
                        refY: 12,
                        markerHeight: 24,
                        markerWidth: 24,
                        path: {
                            d:  'M7.912,21.498c3.106-2.029,9.859-7.873,' +
                                '9.859-7.873c2.059-1.807,2.142-1.542,0.' +
                                '146-3.208c0,0-7.434-6.084-10.005-7.576' +
                                'C7.583,2.649,6.903,3.446,6.271,4.233c-' +
                                '0.308,0.384,2.209,6.051,2.209,6.051v3.' +
                                '388c0,0-2.215,4.583-2.25,6.03C6.222,19' +
                                '.986,7.629,21.684,7.912,21.498z'
                        }
                    },
                    lastPointOffset: 0,
                    vmlEndArrow: 'none',
                    weight: 7,
                    iconWidth: 6
                },
                18: {
                    marker: {
                        viewBox: '0 0 24 24',
                        refX: 12,
                        refY: 12,
                        markerHeight: 24,
                        markerWidth: 24,
                        path: {
                            d:  'M7.61,22.688c4.045-2.642,11.312-8.906,' +
                                '11.312-8.906c1.92-1.781,1.938-2-0.124-' +
                                '3.781c0,0-8.151-6.334-11.5-8.276C6.87,' +
                                '1.475,5.516,2.62,5.732,3.093c2.146,4.6' +
                                '94,2.063,4.741,2.612,7.469l0.016,2.75c' +
                                '0,0-1.573,5.458-2.619,7.958C5.599,21.6' +
                                '11,7.241,22.93,7.61,22.688z'
                        }
                    },
                    lastPointOffset: !DG.Browser.vml ? -5 : -2,
                    vmlEndArrow: 'none',
                    weight: 8,
                    iconWidth: 8
                },
                19: {
                    marker: {
                        viewBox: '0 0 24 24',
                        refX: 12,
                        refY: 12,
                        markerHeight: 27,
                        markerWidth: 27,
                        path: {
                            d:  'M6.254472,23.8475c4.560355,-2.972281 1' +
                                '2.747538,-10.032785 12.747538,-10.0327' +
                                '85c2.167521,-2.006556 2.178242,-2.2533' +
                                '53 -0.13949,-4.25991c0,0 -9.185101,-7.' +
                                '13562 -12.962148,-9.324594c-0.482861,-' +
                                '0.278985 -2.006558,1.008645 -1.759761,' +
                                '1.534428c2.414306,5.290015 2.414306,5.' +
                                '290015 3.272724,8.294486l0,3.433681c0,' +
                                '0 -2.081665,5.933829 -3.261997,8.75588' +
                                '9c-0.160951,0.386288 1.684652,1.867062' +
                                ' 2.103134,1.598804z'
                        }
                    },
                    lastPointOffset: !DG.Browser.vml ? -5 : -2,
                    vmlEndArrow: 'none',
                    weight: 10,
                    iconWidth: 12
                }
            }
        };
    },

    _getArrowOptions: function () {
        return {
            clickable: false,
            color: '#0085a0',
            weight: 3,
            byZoom: {
                16: {
                    marker: {
                        refX: 12,
                        refY: 12,
                        markerHeight: 24,
                        markerWidth: 24,
                        path: {
                            d:  'M11.068,13.011L9.5,17.285l6.379-5.169L9' +
                                '.313,7.19l1.717,3.824'
                        }
                    },
                    lastPointOffset: 2,
                    weight: 2,
                    iconWidth: 4
                },
                17: {
                    marker: {
                        refX: 12,
                        refY: 12,
                        markerHeight: 24,
                        markerWidth: 24,
                        path: {
                            d:  'M10.354,13.969l-2.184,5.18L16.993,12L7.' +
                                '912,5.188l2.38,4.781'
                        }
                    },
                    lastPointOffset: 0,
                    weight: 3,
                    iconWidth: 6
                },
                18: {
                    marker: {
                        refX: 12,
                        refY: 12,
                        markerHeight: 24,
                        markerWidth: 24,
                        path: {
                            d:  'M10.281,13.781L7.42,21.271l11.488-9.308' +
                                'L7.083,3.093L10.219,10'
                        }
                    },
                    lastPointOffset: !DG.Browser.vml ? -5 : 0,
                    weight: 4,
                    iconWidth: 8
                },
                19: {
                    marker: {
                        refX: 12,
                        refY: 12,
                        markerHeight: 27,
                        markerWidth: 27,
                        path: {
                            d:  'M9.344783,13.814714l-3.326375,8.476902' +
                                'l12.983603,-10.51565l-13.305513,-9.979' +
                                '137l3.648286,7.940389'
                        }
                    },
                    lastPointOffset: !DG.Browser.vml ? -5 : 0,
                    weight: 5,
                    iconWidth: 12
                }
            }
        };
    }
});

DG.Path.ANIMATION_AVAILABLE =
    DG.Browser.svg &&
    !DG.Browser.mobileWebkit &&
    navigator.userAgent.toLowerCase().indexOf('presto') === -1 &&
    Object.prototype.toString.call(
        DG.SVG.create('animate').beginElement) === '[object Function]';


DG.Path.include(!DG.Path.ANIMATION_AVAILABLE ? {} : {

    runAnimation: function () {
        var animationEl = this._animationEl = this._addAnimation();

        if (animationEl) {
            animationEl.beginElement();
            this._removeAnimation(animationEl);
        }

        return this;
    },

    stopAnimation: function (name) { // (String) -> DG.Path
        if (this.animations[name]) {
            this.animations[name].endElement();
        }
        return this;
    },

    _addAnimation: function () { // () -> SVGAnimateElement|null
        var animOptions = this.options.animation,
            points = this._rings[0],
            animationEl = null;

        if (animOptions && points.length > 0) {
            animationEl = DG.SVG.create('animate');

            // calculate values if attributeName: 'd' was used to animate
            if (animOptions.getValues) {
                animOptions.values = animOptions.getValues(points);
            }

            Object.keys(animOptions)
                .filter(function (name) {
                    return {}.toString.call(animOptions[name]) !== '[object Function]';
                })
                .forEach(function (name) {
                    animationEl.setAttribute(name, animOptions[name]);
                });

            this._path.appendChild(animationEl);
        }

        return animationEl;
    },

    _removeAnimation: function (animationEl) {
        this._map.once('zoomstart', function () {
            if (animationEl) {
                this._path.removeChild(animationEl);
            }
            this._animationEl = null;
        }, this);
    }
});

DG.Entrance.Arrow = DG.Polyline.extend({
    initialize: function (latlngs, options) { // (Array, Object)
        options = options || {};

        this._setLatLngs(latlngs);

        if (DG.Path.ANIMATION_AVAILABLE) {
            options.animation = this.getArrowAnimation(this._convertLatLngs(latlngs));
        }

        this._markers = [];

        L.setOptions(this, options);
    },

    onAdd: function (map) { // (DG.Map)
        var renderer = this._renderer = map.getArrowRenderer();
        renderer._initPath(this);

        // defined in children classes
        this._project();
        this._update();
        this._updateStyleByZoom();

        renderer._addPath(this);
        renderer._initMarkers(this);
    },

    onRemove: function (map) { // (DG.Map)
        DG.Polyline.prototype.onRemove.call(this, map);

        this._renderer._removeMarkers(this);
    },

    getEvents: function () {
        return {
            viewreset: this._project,
            move: this._update,
            zoomend: this._updateStyleByZoom
        };
    },

    _projectLatlngs: function (latlngs, result) {
        DG.Polyline.prototype._projectLatlngs.call(this, latlngs, result);
        this._offsetLastPathPoint();
    },

    _update: function () {
        DG.Polyline.prototype._update.call(this);

        this._renderer._updateMarker(this);
    },

    _updateStyleByZoom: function () {
        var optionsByZoom = this.options.byZoom,
            zoom = this._map.getZoom();

        this.setStyle(optionsByZoom[zoom]);
    },

    _offsetLastPathPoint: function () {
        var origPoints = this._rings[0],
            style = this.options.byZoom[this._map.getZoom()],
            pointsLen = origPoints.length,
            lastSegmentLen = origPoints[pointsLen - 1].distanceTo(origPoints[pointsLen - 2]),
            lastSegmentInPercents,
            offsetVector,
            offsetTo;

        if (style) {
            offsetVector = {
                x: origPoints[pointsLen - 1].x - origPoints[pointsLen - 2].x,
                y: origPoints[pointsLen - 1].y - origPoints[pointsLen - 2].y
            };

            //         
            if (lastSegmentLen > style.iconWidth) {
                lastSegmentInPercents = Math.abs(style.lastPointOffset / lastSegmentLen);

                offsetTo = {
                    x: offsetVector.x * lastSegmentInPercents,
                    y: offsetVector.y * lastSegmentInPercents
                };

                // move last point forward/back by offsetVector direction
                if (style.lastPointOffset > 0) {
                    origPoints[pointsLen - 1].x += offsetTo.x;
                    origPoints[pointsLen - 1].y += offsetTo.y;
                } else {
                    origPoints[pointsLen - 1].x -= offsetTo.x;
                    origPoints[pointsLen - 1].y -= offsetTo.y;
                }
            } else {
                //   ,    
                lastSegmentInPercents = lastSegmentLen / style.iconWidth;

                if (offsetVector.x !== 0) {
                    origPoints[pointsLen - 1].x = origPoints[pointsLen - 2].x + offsetVector.x / lastSegmentInPercents;
                }

                if (offsetVector.y !== 0) {
                    origPoints[pointsLen - 1].y = origPoints[pointsLen - 2].y + offsetVector.y / lastSegmentInPercents;
                }
            }
        }
    }

});

DG.Entrance.arrow = function (latlngs, options) {
    return new DG.Entrance.Arrow(latlngs, options);
};

DG.Entrance.Arrow.SVG = DG.SVG.extend({

    getEvents: function () {
        var events = {
            move: this._update
        };
        if (this._zoomAnimated) {
            events.zoomanim = this._animateZoom;
        }
        if (DG.Browser.ie) {
            events.moveend = events.mousemove = events.zoomend = this._refresh; //JSAPI-3379
        }
        return events;
    },

    _initMarkers: function (layer) {
        var marker, markerStyle,
            optionsByZoom =  layer.options.byZoom,
            id = layer._markerId = 'arrow-marker-' + DG.Util.stamp(layer);

        Object.keys(optionsByZoom).map(function (zoom) {
            marker = DG.SVG.create('marker');
            markerStyle = optionsByZoom[zoom].marker;

            Object.keys(markerStyle)
                .filter(function (key) {
                    return key !== 'polygon' && key !== 'path';
                })
                .forEach(function (key) {
                    marker.setAttribute(key, markerStyle[key]);
                });

            marker.id = id + '-' + zoom;
            marker.setAttribute('orient', 'auto');
            marker.setAttribute('markerUnits', 'userSpaceOnUse');
            marker.setAttribute('stroke-width', '0');

            if (markerStyle.path) {
                marker.appendChild(this._getMarkerChild('path', markerStyle.path, layer));
            }

            if (markerStyle.polygon) {
                marker.appendChild(this._getMarkerChild('polygon', markerStyle.polygon, layer));
            }


            layer._markers.push(marker);
            this._getDefs().appendChild(marker);
        }, this);

        this._updateMarker(layer);
    },

    _getMarkerChild: function (type, options, layer) {
        var markerPath = DG.SVG.create('path'),
            vector = (type === 'path') ? 'd' : 'points';

        markerPath.setAttribute(vector, options[vector]);

        markerPath.setAttribute('fill', options.color ? options.color : layer.options.color);

        return markerPath;
    },

    _getDefs: function () {
        this._defs = this._defs || DG.SVG.create('defs');
        if (!this._defs.parentNode) {
            this._container.appendChild(this._defs);
        }
        return this._defs;
    },

    _updateMarker: function (layer) {
        var zoom = layer._map.getZoom(),
            bound = layer._map.getBounds(),
            lastPoint = layer._latlngs[layer._latlngs.length - 1],
            url = (zoom >= DG.Entrance.SHOW_FROM_ZOOM && bound.contains(lastPoint)) ? layer._markerId + '-' + zoom : '';

        layer._path.setAttribute('marker-end', 'url(#' + url + ')');
    },

    _removeMarkers: function (layer) {
        var defs = this._getDefs(),
            markers = layer._markers;

        if (!defs && !markers) { return; }

        markers.forEach(function (marker) {
            defs.removeChild(marker);
        });
        markers.length = 0;
    },

    _refresh: function () {
        this._container.parentNode.insertBefore(this._container, this._container);
    },

    _updateStyle: function (layer) {
        var path = layer._path,
            options = layer.options;

        DG.SVG.prototype._updateStyle.call(this, layer);

        path.setAttribute('visibility', options.visibility);

        layer._markers.forEach(function (marker) {
            marker.setAttribute('fill-opacity', options.opacity);
        });

        this._updateMarker(layer);
    }
});


L.Map.include({
    getArrowRenderer: function () {
        var renderer = this._arrowRenderer;

        if (!renderer) {
            renderer = this._arrowRenderer = new DG.Entrance.Arrow.SVG();
        }

        if (!this.hasLayer(renderer)) {
            this.addLayer(renderer);
        }

        return renderer;
    }
});

// redefine some SVG methods to handle VML syntax which is similar but with some differences
DG.Entrance.Arrow.SVG.include(!L.Browser.vml ? {} : {

    _initMarkers: function (layer) {
        layer._markers = L.SVG.create('stroke');
        this._updateMarker(layer);
        layer._container.appendChild(layer._markers);
    },

    _updateMarker: function (layer) {
        var style = layer.options.byZoom[layer._map.getZoom()];

        layer._markers.endarrow =
            (style && style.vmlEndArrow) ? style.vmlEndArrow : 'classic';
    },

    _removeMarkers: function (layer) {
        layer._container.removeChild(layer._markers);
    },

    _updateStyle: function (layer) {
        var options = layer.options,
            container = layer._container;

        DG.SVG.prototype._updateStyle.call(this, layer);

        if (options.visibility) {
            container.style.visibility = options.visibility;
        }
    }
});

// Extends DG.Entrance.Arrow with SVG-specific animation options
if (DG.Browser.svg) {

    DG.Entrance.Arrow.include({

        getArrowAnimation: function (vertices) { // (Number) -> Object
            var animateArrow = {
                id: 'animateArrowPathGeom',
                attributeName: 'd',
                fill: 'freeze',
                begin: 'indefinite'
            };

            animateArrow.getValues = this._getAnimationValues(vertices.length);
            animateArrow.keyTimes = this._getAnimateTiming(vertices);
            animateArrow.dur = this._getAnimationTime(vertices.length);

            return animateArrow;
        },

        _getAnimationValues: function (verticesCount) {
            return (verticesCount === 2) ? this._getShakeAnimationValues : this._getSlideAnimationValues;
        },

        _getSlideAnimationValues: function (points) { // (Array) -> String
            var d = '',
                prevPoint = '',
                curPoint = '',
                M = 'M ' + points[0].x + ' ' + points[0].y,
                l = 'l -1 0';

            d = M + ' ' + l + '; ';
            for (var i = 1; i < points.length; i++) {
                curPoint += (points[i].x - points[i - 1].x) + ' ' + (points[i].y - points[i - 1].y);

                if (i === points.length - 1) {
                    curPoint = (points[i].x - points[i - 1].x) + ' ' + (points[i].y - points[i - 1].y);
                    d += M + ' l ' + prevPoint  + curPoint + ';';
                    break;
                }

                d += M + ' l ' + curPoint + '; ';
                d += M + ' l ' + curPoint + ' ' + l + '; ';
                curPoint += ' l ';
                prevPoint += (points[i].x - points[i - 1].x) + ' ' + (points[i].y - points[i - 1].y) + ' l ';
            }

            return d;
        },

        _getShakeAnimationValues: function (points) { // (Array) -> String
            var px0, py0,
                // config coefficient values for arrow animation
                relDiff = [1, 0.4, 1, 0.84, 1, 0.94, 1],
                dx = points[1].x - points[0].x,
                dy = points[1].y - points[0].y,
                l = ' l ' + dx + ' ' + dy;

            px0 = points[0].x - dx;
            py0 = points[0].y - dy;

            return relDiff.reduce(
                function (d, step) {
                    return d + ' M ' + (px0 + dx * step) + ' ' + (py0 + dy * step) + l + ';';
                },
                'M ' + px0 + ' ' + py0 + l + '; '
            );
        },

        _getPolylineLength: function (latlngs) {
            var len = 0;
            for (var i = 1; i < latlngs.length; i++) {
                len += latlngs[i - 1].distanceTo(latlngs[i]);
            }
            return len;
        },

        _getAnimateTiming: function (latlngs) {
            var resultArr = [0],
                polyLen = this._getPolylineLength(latlngs),
                result,
                segmentRatio,
                segmentLength;

            if (latlngs.length === 2) {
                result = '0; 0.33; 0.495; 0.66; 0.77; 0.88; 0.935; 1';
            }
            else if (latlngs.length === 3) {
                result = '0; 0.33; 0.34; 1';
            }
            else if (latlngs.length === 4) {
                result = '0; 0.25; 0.26; 0.5; 0.51; 1';
            }
            else {
                for (var i = 1; i < latlngs.length; i++) {
                    segmentLength = latlngs[i - 1].distanceTo(latlngs[i]);
                    segmentRatio = segmentLength / polyLen;

                    resultArr.push(resultArr[resultArr.length - 1] + segmentRatio);

                    if (i < latlngs.length - 1) {
                        // 2 points for each vertice (but not for first and last)
                        resultArr.push(resultArr[resultArr.length - 1]);
                    }
                    else {
                        // last point should be 1, but some times it looks like 0.9999...
                        resultArr[resultArr.length - 1] = 1;
                    }

                }
                result = resultArr.join('; ');
            }

            return result;
        },

        _getAnimationTime: function (verticesCount) {
            if (verticesCount === 2) { return '0.7s'; }
            else if (verticesCount === 3 || verticesCount === 4) { return '0.5s'; }
            else { return '0.7s'; }
        }
    });
}

DG.Entrance.EventHandler = DG.Handler.extend({

    initialize: function (map, entrance) { // (DG.Map, DG.Entrance)
        this._map = map;
        this._entrance = entrance;
    },

    addHooks: function () {
        this._map.on(this._events(), this);
    },

    removeHooks: function () {
        this._map.off(this._events(), this);
    },

    _events: function () {
        return {
            'layeradd': this._removeEntrance,
            'zoomend': this._showOrHideEntrance,
            'projectleave': this._showOrHideEntrance
        };
    },

    _showOrHideEntrance: function () { // (DG.Event)
        if (this._map.getZoom() >= DG.Entrance.SHOW_FROM_ZOOM) {
            this._entrance.show(false);
        }
        else {
            this._entrance.hide();
        }
    },

    _removeEntrance: function (e) { // (DG.LayerEvent)
        if (e.layer instanceof DG.Popup ||
            (e.layer instanceof DG.Entrance && e.layer !== this._entrance)) {

            this._entrance.removeFrom(this._map);
        }
    }
});

DG.Map.mergeOptions({
    geoclicker: false
});

DG.Geoclicker = DG.Handler.extend({
    clickCount: 0,
    pendingClick: 0,
    timeout: 250, // should be equal to 'delay' value in DoubleTap event

    initialize: function (map, options) { // (Object)
        this._map = map;
        this._controller = new DG.Geoclicker.Controller(map, options);
    },

    addHooks: function () {
        this._toggleEvents(true);

        this._map
            .on('rulerstart', this._pause, this)
            .on('rulerend', this._unpause, this);
    },

    removeHooks: function () {
        this._toggleEvents();

        this._map
            .off('rulerstart', this._pause, this)
            .off('rulerend', this._unpause, this);
    },

    _pause: function () {
        this._toggleEvents();
    },

    _unpause: function () {
        // Reenable event handling only in case geoclicker is enabled
        if (this.enabled()) {
            this._toggleEvents(true);
        }
    },

    _toggleEvents: function (flag) {
        this._map[flag ? 'on' : 'off'](this._mapEventsListeners, this);
        if (this._map.poi) {
            this._map.poi.getMetaLayer()[flag ? 'on' : 'off']('click', this._mapEventsListeners.click, this);
        }
    },

    getController: function () {
        return this._controller;
    },

    _checkOpenPopup: function () {
        if (DG.Browser.mobile && this._map._popup &&
            (this._map._popup.options.closeOnClick ||
            this._map.options.closePopupOnClick)) {
            this.popupWasOpen = true;
        }
    },

    _mapEventsListeners: {
        langchange: function () {
            this._controller.reinvokeHandler();
        },

        popupclose: function (e) { // (Object)
            this._controller.handlePopupClose(e.popup);
        },

        prepreclick: function () {
            this._checkOpenPopup();
        },

        click: function (e) { // (Object)
            if (this.clickCount === 0) {
                this.clickCount = 1;
                this._singleClick(e);
            } else {
                this.clickCount = 0;
                clearTimeout(this.pendingClick);
                this.popupWasOpen = false;
            }
        }
    },

    _singleClick: function (e) { // (Object)
        var self = this;

        clearTimeout(this.pendingClick);

        this.pendingClick = setTimeout(function () {
            // prepreclick event not available in meta layer
            if (e.meta) {
                self._checkOpenPopup();
                self._map.closePopup();
            }

            if (!self.popupWasOpen) {
                var zoom = self._map.getZoom();
                self._controller.handleClick(e.latlng, zoom, e.meta);
            }

            self.clickCount = 0;
            self.popupWasOpen = false;
        }, this.timeout);
    }
});

DG.Map.addInitHook('addHandler', 'geoclicker', DG.Geoclicker);

DG.Geoclicker.clampHelper = function (el, lineClamp) {
    var measure, text, lineWidth,
        lineStart, lineCount, wordStart,
        line, lineText, wasNewLine,
        ce = document.createElement.bind(document),
        ctn = document.createTextNode.bind(document);

    // measurement element is made a child of the clamped element to get it's style
    measure = ce('span');

    (function (s) {
        s.position = 'absolute'; // prevent page reflow
        s.whiteSpace = 'pre'; // cross-browser width results
        s.visibility = 'hidden'; // prevent drawing
        s.margin = '0 18px 8px 0';
    })(measure.style);

    // make sure the element belongs to the document
    if (!el.ownerDocument || el.ownerDocument !== document) {
        return;
    }
    // reset to safe starting values
    lineStart = wordStart = 0;
    lineCount = 1;
    wasNewLine = false;
    lineWidth = el.clientWidth;
    // get all the text, remove any line changes
    text = (el.textContent || el.innerText).replace(/\n/g, ' ');
    // remove all content
    while (el.firstChild !== null) {
        el.removeChild(el.firstChild);
    }
    // add measurement element within so it inherits styles
    el.appendChild(measure);
    // http://ejohn.org/blog/search-and-dont-replace/
    text.replace(/ |-/g, function (m, pos) {
        // ignore any further processing if we have total lines
        if (lineCount === lineClamp) {
            return;
        }
        // create a text node and place it in the measurement element
        measure.appendChild(ctn(text.substr(lineStart, pos - lineStart)));
        // have we exceeded allowed line width?
        if (lineWidth < measure.clientWidth) {
            if (wasNewLine) {
                // we have a long word so it gets a line of it's own
                lineText = text.substr(lineStart, pos + 1 - lineStart);
                // next line start position
                lineStart = pos + 1;
            } else {
                // grab the text until this word
                lineText = text.substr(lineStart, wordStart - lineStart);
                // next line start position
                lineStart = wordStart;
            }
            // create a line element
            line = ce('span');
            // add text to the line element
            line.appendChild(ctn(lineText));
            // add the line element to the container
            el.appendChild(line);
            line.className = 'dg-map-geoclicker__clamped-line';
            // yes, we created a new line
            wasNewLine = true;
            lineCount++;
        } else {
            // did not create a new line
            wasNewLine = false;
        }
        // remember last word start position
        wordStart = pos + 1;
        // clear measurement element
        measure.removeChild(measure.firstChild);
    });
    // remove the measurement element from the container
    el.removeChild(measure);
    // create the last line element
    line = ce('span');
    // give styles required for text-overflow to kick in
    line.className = 'dg-map-geoclicker__clamped-line dg-map-geoclicker__clamped-line_last';
    // add all remaining text to the line element
    line.appendChild(ctn(text.substr(lineStart)));
    // add the line element to the container
    el.appendChild(line);
};

DG.Geoclicker.Provider = {};

DG.Geoclicker.Provider.CatalogApi = DG.Class.extend({
    options: {
        urlGeoSearch: 'http://catalog.api.2gis.ru/2.0/geo/search',
        urlGeoGet: 'http://catalog.api.2gis.ru/2.0/geo/get',
        urlDetails: 'http://catalog.api.2gis.ru/2.0/catalog/branch/get',
        urlFirmsInHouse: 'http://catalog.api.2gis.ru/2.0/catalog/branch/list',
        data: {
            key: 'ruxlih0718'
        },
        geoFields: 'items.geometry.selection,items.links,items.adm_div,items.address,items.floors,items.description',
        firmInfoFields: 'items.reviews,items.photos,items.links,items.external_content',

        timeoutMs: 5000
    },

    initialize: function (map) { // (Object)
        this._map = map;
    },

    getLocations: function (options) { // (Object)
        // Callback will receive array of found results or void if errors occurred or nothing was found.
        var zoom = options.zoom,
            latlng = options.latlng,
            beforeRequest = options.beforeRequest || function () {},
            types = this.getTypesByZoom(zoom),
            q = latlng.lng + ',' + latlng.lat;

        if (!types) {
            return Promise.reject('no type');
        }

        beforeRequest();

        return this.geoSearch(q, types, zoom).then(DG.bind(function (result) {
            return this._filterResponse(result, types);
        }, this));
    },

    firmsInHouse: function (houseId, parameters) { // (String, Function, Number)
        parameters = parameters || {};

        /* eslint-disable camelcase */
        var params = DG.extend(this.options.data, {
            building_id: houseId,
            page: parameters.page || 1
        });
        /* eslint-enable camelcase */

        return this._performRequest(params, this.options.urlFirmsInHouse);
    },

    getFirmInfo: function (firmId) {
        return this._performRequest({
            type: 'filial',
            id: firmId,
            fields: this.options.firmInfoFields
        }, this.options.urlDetails);
    },

    geoSearch: function (q, types, zoomlevel) { // (String, String, Number)
        /* eslint-disable camelcase */
        var params = {
            point: q,
            type: types,
            zoom_level: zoomlevel,
            fields: this.options.geoFields
        };
        /* eslint-enable camelcase */

        return this._performRequest(params, this.options.urlGeoSearch);
    },

    geoGet: function (id) {
        var params = {
            id: id,
            fields: this.options.geoFields
        };

        return this._performRequest(params, this.options.urlGeoGet);
    },

    cancelLastRequest: function () {
        if (this._lastRequest) {
            this._lastRequest.abort();
        }
    },

    getTypesByZoom: function (zoom) { // (Number) -> String|Null
        var types = {
            'adm_div.settlement':   8,
            'adm_div.city':         8,
            'adm_div.division':     11,
            'adm_div.district':     12,
            'street':               14,
            'building':             14,
            'adm_div.place':        15,
            'poi':                  15,
            'attraction':           17
        },
        selectedTypes = [];

        Object.keys(types).forEach(function (type) {
            if (zoom >= types[type]) {
                selectedTypes.push(type);
            }
        });

        if (selectedTypes.length) {
            return selectedTypes.join(',');
        } else {
            return null;
        }
    },

    _performRequest: function (params, url) { // (Object, String, Function, Function)
        var source = this.options.data,
            data = DG.extend({ // TODO clone function should be used instead of manually copying
                key: source.key
            }, params),
            type = 'get';

        this.cancelLastRequest();

        if (!DG.ajax.corsSupport) {
            type = data.format = 'jsonp';
        }

        this._lastRequest = DG.ajax(url, {
            type: type,
            data: data,
            timeout: this.options.timeoutMs
        });

        return this._lastRequest;
    },

    _filterResponse: function (response, allowedTypes) { // (Object, Array) -> Boolean|Object
        var result = {}, i, item, found, data, type;

        if (this._isNotFound(response)) {
            return false;
        }

        data = response.result.items;

        for (i = data.length - 1; i >= 0; i--) {
            item = data[i];

            type = item.type;
            if (item.subtype) {
                type += '.' + item.subtype;
            }

            if (allowedTypes && allowedTypes.indexOf(type) === -1) {
                continue;
            }

            result[type] = item;
            found = true;
        }

        if (found) {
            return result;
        } else {
            return false;
        }
    },

    _isNotFound: function (response) { // (Object) -> Boolean
        return !response ||
               !!response.meta && !!response.meta.error ||
               !response.result ||
               !response.result.items ||
               !response.result.items.length;
    }

});

DG.Geoclicker.Handler = {};

DG.Geoclicker.Handler.Default = DG.Class.extend({

    includes: DG.Locale,

    statics: {
        Dictionary: {}
    },

    _eventHandlers: {},

    initialize: function (controller, view, map) { // (Object, Object, Object)
        this._controller = controller;
        this._view = view;
        this._map = map;
    },

    handle: function () { // () -> Promise
        return Promise.resolve({
            tmpl: 'popupHeader',
            data: {'title': this.t('we_have_not')}
        });
    },

    addClickEvent: function () {
        this._view._popup.on('click', this._runEventHandlers, this);
        this._map.once('popupclose', this._removeClickEvent, this);
    },

    _removeClickEvent: function () {
        this._view._popup.off('click', this._runEventHandlers, this);
    },

    _addEventHandler: function (el, handler) { // (String, Function)
        this._eventHandlers[el] = handler;
    },

    _runEventHandlers: function(e) {
        var target = e.originalEvent.target;

        for (var eventClass in this._eventHandlers) {
            if (this._eventHandlers.hasOwnProperty(eventClass) && target.className.indexOf(eventClass) > -1) {
                DG.DomEvent.preventDefault(e.originalEvent);
                this._eventHandlers[eventClass].call(this, target);
                return;
            }
        }
    },

    _clearEventHandlers: function () {
        this._eventHandlers = {};
    },

    _getDirectionsUrl: function (name) {
        return DG.Util.template('http://2gis.{domain}/{projectCode}/center/{center}/zoom/{zoom}/routeTab/rsType/{rsType}/to/{point}{name}', {
            'domain': this._map.projectDetector.getProject().domain,
            'projectCode': this._map.projectDetector.getProject().code,
            'center': this._map.getCenter().lng + ',' + this._map.getCenter().lat,
            'zoom': this._map.getZoom(),
            'name': encodeURIComponent(name),
            'rsType': this._map.projectDetector.getProject().transport ? 'bus' : 'car',
            'point': this._popup._latlng.lng + ',' + this._popup._latlng.lat
        });
    },

    _getDrilldown: function (object) {
        var admDivs = [],
            result;

        if (object.adm_div) {
            admDivs = object.adm_div
                .reduce(function(admDivs, admDiv) {
                    if (admDiv.name) {
                        admDivs.push(admDiv.name);
                    }

                    return admDivs;
                }, [])
                .reverse();
        }

        if (admDivs.length && object.address && object.address.postcode) {
            admDivs.push(object.address.postcode);
        }

        result = admDivs.join(', ');

        return result;
    }

});


DG.Geoclicker.Handler.HandlerExample = DG.Geoclicker.Handler.Default.extend({

    handle: function (results, type) { // (Object, String) -> Promise
        return Promise.resolve({
            tmpl: type + ':<br/>' + results[type].id
        });
    }
});

DG.Geoclicker.Handler.ApiError = DG.Geoclicker.Handler.Default.extend({
    handle: function () { // () -> Promise
        var header = this._view.render({
            tmpl: 'popupHeader',
            data: {
                title: this.t('apiErrorTitle')
            }
        });

        return Promise.resolve({
            header: header,
            tmpl: this.t('apiErrorBody')
        });
    }
});

DG.Geoclicker.Handler.CityArea = DG.Geoclicker.Handler.Default.extend({

    _polylineStyleDefault : {
        fillColor: '#ff9387',
        color: '#ff9387',
        clickable: false,
        noClip: true,
        opacity: 1
    },

    _polylineStyles : {
        11 : {
            fillOpacity: 0.18,
            weight: 1
        },
        12 : {
            fillOpacity: 0.12,
            weight: 1
        },
        13 : {
            fillOpacity: 0.08,
            weight: 2
        },
        18 : {
            fillOpacity: 0,
            weight: 3
        }
    },

    handle: function (results, type) { // (Object, String) -> Promise
        if (!results[type]) {
            return false;
        }

        if (!this._stylesInited) {
            this._initStyles();
        }

        this._popup = this._view.getPopup();

        this._geometryZoomStyle = this._getPolyStyleNum();
        this._geometry = DG.Wkt.geoJsonLayer(results[type].geometry.selection, {
            style: this._polylineStyles[this._geometryZoomStyle]
        }).addTo(this._map);

        this._map
            .on('zoomend', this._updateGeometry, this)
            .once('popupclose', this._clearPopup, this);

        return Promise.resolve(this._fillCityAreaObject(results, type));
    },

    _fillCityAreaObject: function (results, type) {
        var data = {
            name: this.t('noname'),
            drilldown: '',
            purpose: this.t(type),
            type: type.split('.').join('_')
        };

        data.drilldown = this._getDrilldown(results[type]);

        if (results[type].name) {
            data.name = results[type].name;
        }

        return {
            tmpl: 'cityarea',
            data: data,
            header: this._view.render({
                tmpl: 'popupHeader',
                data: {'title': data.name}
            })
        };
    },

    _initStyles : function () {
        this._stylesInited = true;

        Object.keys(this._polylineStyles).forEach(function (zoom) {
            DG.extend(this._polylineStyles[zoom], this._polylineStyleDefault);
        }, this);
    },

    _getPolyStyleNum: function () {
        var mapZoom = this._map.getZoom();

        return Object.keys(this._polylineStyles).filter(function (zoom) {
            return mapZoom <= zoom;
        })[0] || false;
    },

    _updateGeometry: function () {
        var newStyle = this._getPolyStyleNum();

        if (newStyle && newStyle !== this._geometryZoomStyle) {
            this._geometryZoomStyle = newStyle;
            this._geometry.setStyle(this._polylineStyles[newStyle]);
        }
    },

    _clearPopup: function () {
        this._map
                .removeLayer(this._geometry)
                .off('zoomend', this._updateGeometry, this);
    }

});

/*global FirmCard */
DG.Geoclicker.Handler.House = DG.Geoclicker.Handler.Default.extend({

    _firmsOnPage: 20,
    _scrollThrottleInterval: 400,
    _scrollHeightReserve: 60,

    options: {
        'showBooklet': true,
        'showPhotos': true,
        'showRouteSearch': true
    },

    handle: function (results) { // (Object) -> Promise
        if (!results.building) {
            return false;
        }

        // initialization setup
        this.firmCard = null;
        this._page = 1;
        this._houseObject = null;
        this._firmList = null;
        this._firmListObject = null;
        this._firmCardObject = null;
        this._onScroll = false;
        this._isFirmlistOpen = false;

        this._id = results.building.id;
        this._totalPages = 1;
        this._api = this._controller.getCatalogApi();
        this._popup = this._view.getPopup();
        this._initedPopupClose = false;
        this._directionsUrl = this._getDirectionsUrl(results.building.name);
        this._firmListLoader = this._view.initLoader(true);

        this._houseObject = this._fillHouseObject(results.building);

        return Promise.resolve(this._houseObject);
    },

    _isRouteSearchAllowed: function() { //() -> Boolean
        var project = this._controller.getMap().projectDetector.getProject();
        return project.transport || project.roads;
    },

    _firmCardSetup: function () { //() -> Object
        return {
            render: this._view._templates,
            lang: this._map.getLang(),
            domain: this._controller.getMap().projectDetector.getProject().domain,
            ajax: DG.bind(this._api.getFirmInfo, this._api),
            timezoneOffset: this._controller.getMap().projectDetector.getProject().timeOffset,
            map: this._map,
            popup: this._popup,
            isMobile: DG.Browser.mobile,
            showEntrance: DG.Entrance,
            gotoUrl: this._directionsUrl,
            onFirmReady: DG.bind(this._onFirmReady, this),
            onToggle: DG.bind(this._popup.resize, this._popup),
            showBooklet: this.options.showBooklet,
            showPhotos: this.options.showPhotos,
            showRouteSearch: this.options.showRouteSearch && this._isRouteSearchAllowed(),
            t: DG.bind(this.t, this)
        };
    },

    // init single firm card in case of poi
    _fillFirmCardObject: function (firmId) {
        var options = this._firmCardSetup();

        this.firmCard = new FirmCard(firmId, options);
        this._initPopupClose();
        return this.firmCard.getContainer();
    },

    _firmListSetup: function() {
        var options = this._firmCardSetup();

        DG.extend(options, {
            backBtn: DG.bind(this._showHousePopup, this),
            onFirmClick: DG.bind(this._onFirmListClick, this),
            onShowLess: DG.bind(this._showHousePopup, this),
            pasteLoader: DG.bind(this._pasteLoader, this)
        });

        return {
            firmCard: options,
            firmlistItemTmpl: 'firmlistItem',
            onListReady: DG.bind(this._renderFirmList, this)
        };
    },

    _initShortFirmList: function (firms) { //(Object) -> DOMElement
        var options = this._firmListSetup();

        this._shortFirmList = new FirmCard.List(firms, options);

        return this._shortFirmList.renderList();
    },

    _initFirmList: function (res) { //(Object) -> Promise
        if (!res) { return false; }

        var results = res.result.items,
            options = this._firmListSetup();

        options.firmCard.backBtn = DG.bind(this._showListPopup, this);

        this._shortFirmList._toggleEventHandlers(true);

        this._firmList = new FirmCard.List(results, options);

        this._firmListObject = this._fillFirmListObject(this._firmList.renderList());
        this._clearAndRenderPopup(this._firmListObject);
    },

    _fillFirmListObject: function (firmList) { //(DOMElement) -> Object
        var self = this;

        return {
            tmpl: firmList,
            header: this._header,
            footer: this._view.render({
                tmpl: 'popupFooterBtns',
                data: {
                    btns: [
                        {
                            name: 'back',
                            label: this.t('back_button'),
                            icon: true
                        }
                    ]
                }
            }),
            afterRender: function () {
                self._initPopupClose();

                if (self._totalPages > 1 && self._firmListLoader) {
                    // "this" here is self._firmListObject
                    this.tmpl.parentNode.appendChild(self._firmListLoader);
                }
            }
        };
    },

    _onFirmReady: function (firmContentObject) {
        var self = this;
        firmContentObject.afterRender = function () {
            var headerTitle = self._popup._popupStructure.header.firstChild;
            if (!DG.Browser.ielt9) {
                if (headerTitle.offsetHeight > 72) { //TODO: magic number
                    DG.DomUtil.addClass(headerTitle, 'dg-popup__header-teaser');
                    if (!DG.Browser.webkit) {
                        DG.Geoclicker.clampHelper(headerTitle, 3);
                    }
                }
            }
        };
        this._clearAndRenderPopup(firmContentObject);
    },

    _showHousePopup: function () {
        this._popup.off('scroll', this._onScroll);
        this._clearAndRenderPopup(this._houseObject);
        this._shortFirmList._toggleEventHandlers();
    },

    _onFirmListClick: function () {
        this._popup.off('scroll', this._onScroll);
    },

    _pasteLoader: function () {
        var loaderWrapper  = DG.DomUtil.create('div', 'dg-map-geoclicker__preloader-wrapper'),
            loader = this._view.initLoader();

        loaderWrapper.insertBefore(loader, loaderWrapper.firstChild);
        loaderWrapper.style.height = this._popup._contentNode.offsetHeight - 1 + 'px'; // MAGIC
        loaderWrapper.style.width = this._popup._contentNode.offsetWidth + 'px';
        this._clearAndRenderPopup({tmpl: loaderWrapper});
    },

    _initPopupClose: function () {
        if (this._initedPopupClose) { return; }

        this._controller.getMap().once('popupclose', DG.bind(this._onPopupClose, this));
        this._initedPopupClose = true;
    },

    _showListPopup: function () {
        var firmList = this._firmListObject;

        this._pasteLoader();

        if (!firmList) {
            firmList = this._api.firmsInHouse(this._id).then(DG.bind(this._initFirmList, this));
        } else {
            this._clearAndRenderPopup(firmList);
            this._firmList._toggleEventHandlers();
        }

        if (!this._onScroll) {
            this._onScroll = DG.Util.throttle(this._handlePopupScroll, this._scrollThrottleInterval, this);
        }

        this._popup.on('scroll', this._onScroll);
    },

    _renderFirmList: function () {
        if (!this._isFirmlistOpen) {
            this._popup.resize();
            this._isFirmlistOpen = true;
        }
    },

    _onPopupClose: function () {
        this._initedPopupClose = false;
        if (this._firmList) {
            this._firmList.clearList();
            this._firmList = null;
            this._popup.off('scroll', this._onScroll);
        }
        this._firmId = null;
        if (this.firmCard) {
            this.firmCard._toggleEventHandlers(true);
            this.firmCard = null;
        }
        this._firmListLoader = null;
        this._page = 1;
        this._clearEventHandlers();
    },

    _initShowMore: function () {
        var link = this._popup.findElement('.dg-popup__button_name_all');

        if (link) {
            this._addEventHandler('dg-popup__button_name_all', DG.bind(this._showListPopup, this));
        }
    },

    _clearAndRenderPopup: function (popupObject) {
        this._clearEventHandlers();
        this._popup.clear('header', 'footer');
        this._view.renderPopup(popupObject);
    },

    _appendFirmList: function (res) { // (Object)
        this._firmList.addFirms(res.result.items);
        this._popup._updateScrollPosition();
    },

    _handlePopupScroll: function (e) {
        var scroller = e.originalEvent.target || e.target._scroller;

        DG.DomEvent.stop(e);

        if (this._totalPages <= 1) { return; }
        if (scroller && scroller.scrollHeight <= scroller.scrollTop + scroller.offsetHeight + this._scrollHeightReserve) {
            this._handlePaging();
        }
    },

    _handlePaging: function () {
        this._page++;

        if (this._totalPages && this._page <= this._totalPages) {
            this._api.firmsInHouse(this._id, {page: this._page}).then(DG.bind(this._appendFirmList, this));
        }

        if (this._page === this._totalPages) {
            var loader = this._firmListLoader;

            if (loader && loader.parentNode) {
                loader.parentNode.removeChild(loader);
            }

            this._popup.off('scroll', this._onScroll);
        }
    }
});

DG.Geoclicker.Handler.House.include({
    _getAddressString: function (house) {
        if (!house.address || !house.address.components) {
            return '';
        }

        return house.address.components
            .filter(function (component) {
                return component.type === 'street_number';
            })
            .map(function (component) {
                return component.street + ', ' + component.number;
            })
            .join(' / ');
    },

    _fillBody: function (house) { // // (Object) -> (DOMElement)
        var data = {},
            wrapper = DG.DomUtil.create('div', 'dg-building-callout__body'),
            filials = house.links.branches;

        var drilldown = this._getDrilldown(house);

        if (house.building_name) {
            data.address = {
                header: this._getAddressString(house),
                drilldown: drilldown
            };
        } else if (drilldown) {
            data.address = {
                drilldown: drilldown
            };
        }

        data.purpose = house.purpose_name +
            (house.floors ? ', ' + this.t('n_floors', house.floors.ground_count) : '');

        if (house.links.branches.count > 0) {
            this._totalPages = Math.ceil(house.links.branches.count / this._firmsOnPage);
        }

        if (house.links.attractions && house.links.attractions.length) {
            data.attractions = house.links.attractions.reduce(function(attractions, attraction) {
                if (attraction.name) {
                    attractions.push(attraction.name);
                }

                return attractions;
            }, []);
        }

        wrapper.innerHTML = this._view.render({
            tmpl: 'house',
            data: data
        });

        if (filials.items) {
            wrapper.appendChild(this._initShortFirmList(filials.items));
        }

        return wrapper;
    },

    _fillHeader: function (house) { // (Object) -> (HTMLString)
        var header = {};

        if (house.building_name) {
            header.title = house.building_name;
        } else if (house.address && house.address.components) {
            header.title = this._getAddressString(house);
        } else {
            header.title = house.purpose_name;
        }

        this._header = this._view.render({
            tmpl: 'popupHeader',
            data: header
        });

        return this._header;
    },

    _fillFooter: function (house) { // (Object) -> (HTMLString)
        var btns = [];
        var houseFilials = house.links.branches;

        // Decide if we need to display 'more organisations' button
        if (
            houseFilials.items &&
            houseFilials.items.length &&
            houseFilials.count > houseFilials.items.length
        ) {
            btns.push(this._getShowAllData(houseFilials.count));
        }

        if (this._isRouteSearchAllowed()) {
            btns.push({
                name: 'goto',
                label: this.t('go_to'),
                icon: true,
                href: this._directionsUrl
            });
        }

        return this._view.render({
            tmpl: 'popupFooterBtns',
            data: {'btns': btns}
        });
    },

    _getShowAllData: function (filialsCount) {
        return {
            name: 'all',
            label: this.t('show_organization_in_building', filialsCount)
        };
    },

    _fillHouseObject: function (house) { // (Object) -> (Object)
        var self = this;

        return {
            header: this._fillHeader(house),
            tmpl: this._fillBody(house),
            footer: this._fillFooter(house),
            afterRender: function () {
                self._initShowMore();
                self._initPopupClose();
            }
        };
    }
});

DG.Geoclicker.Handler.Poi = DG.Geoclicker.Handler.House.extend({

    handle: function (results) { // (Object) -> Promise
        if (!results.poi) {
            return false;
        }

        // initialization setup
        this.firmCard = null;
        this._page = 1;
        this._houseObject = null;
        this._firmList = null;
        this._firmListObject = null;
        this._firmCardObject = null;
        this._onScroll = false;
        this._isFirmlistOpen = false;

        this._id = results.poi.reference.id;
        this._totalPages = 1;
        this._api = this._controller.getCatalogApi();
        this._popup = this._view.getPopup();
        this._initedPopupClose = false;
        this._directionsUrl = this._getDirectionsUrl(results.poi.reference.name);
        this._firmListLoader = this._view.initLoader(true);

        // If the POI refers to a building (e.g. galleries in Santiago),
        // show a building callout
        if (results.poi.reference.type === 'building') {
            var self = this;

            return self._api.geoGet(results.poi.reference.id)
                .then(function (result) {
                    self._houseObject = self._fillHouseObject(result.result.items[0]);
                    return Promise.resolve(self._houseObject);
                });
        }

        // Otherwise, show a firm callout
        if (results.poi.reference.type === 'branch') {
            this._fillFirmCardObject(results.poi.reference.id);
            return true;
        }

        return false;
    }

});

DG.Geoclicker.Handler.Sight = DG.Geoclicker.Handler.Default.extend({

    handle: function (results) { // (Object, String) -> Promise
        if (!results.attraction) {
            return false;
        }

        this._popup = this._view.getPopup();
        this._initedPopupClose = false;

        return Promise.resolve(this._fillSightObject(results));
    },

    _fillSightObject: function (results) { // (Object) -> Object
        var attraction = results.attraction,
            data = {},
            self = this,
            footer = {
                btns: [
                    {
                        name: 'goto',
                        label: this.t('go_to'),
                        icon: true
                    }
                ]
            };

        if (attraction.name) {
            data.buildingName = attraction.name;
            data.purpose = attraction.subtype_name;
        } else {
            data.buildingName = attraction.subtype_name;
        }

        data.description = attraction.description;

        data.drillDown = this._getDrilldown(attraction);

        if (this._checkDescFieldHeight(data.description)) {
            data.showMoreText = this.t('show_more_about_sight');
        }

        footer.btns[0].href = this._getDirectionsUrl(data.buildingName);

        return {
            tmpl: 'sight',
            data: data,
            header: this._view.render({
                tmpl: 'popupHeader',
                data: {'title': data.buildingName}
            }),
            footer: this._view.render({
                tmpl: 'popupFooterBtns',
                data: footer
            }),
            afterRender: function () {
                if (self._needShowMore) {
                    self._initShowMore();
                }
                self._initPopupClose();
            }
        };
    },

    _initPopupClose: function () {
        if (this._initedPopupClose) {
            return;
        }

        this._controller.getMap().once('popupclose', DG.bind(this._clearPopup, this));
        this._initedPopupClose = true;
    },

    _clearPopup: function () {
        this._initedPopupClose = false;
        this._clearEventHandlers();
    },

    _showMoreText: function () {
        this._desc.style.maxHeight = '100%';
        this._link.parentNode.removeChild(this._link);
        this._popup.resize();
    },

    _initShowMore: function () {
        this._link = this._popup.findElement('.dg-map-geoclicker__show-more-sights-link');
        this._desc = this._popup.findElement('.dg-map-geoclicker__sight-description');

        if (this._link && this._desc) {
            this._addEventHandler('dg-map-geoclicker__show-more-sights-link', DG.bind(this._showMoreText, this));
        }
    },

    _checkDescFieldHeight: function (desc) {
        var el = DG.DomUtil.create('div', ''),
            height;

        el.style.visibility = 'hidden';
        el.innerHTML = desc;

        this._popup._contentNode.appendChild(el);
        height = el.offsetHeight;
        this._popup._contentNode.removeChild(el);
        this._needShowMore = (height > 40);

        return this._needShowMore;
    }
});

DG.Geoclicker.View = DG.Class.extend({

    initialize: function (map, options) { // (Object, Object)
        this._map = map;
        this._popup = DG.popup({
            maxHeight: 300,
            minHeight: 50,
            maxWidth: 385,
            minWidth: 310,
            sprawling: true,
            closeOnClick: true
        });

        /*global __DGGeoclicker_TMPL__ */
        this._templates = DG.dust({"cityarea":"(function(){dust.register(\"cityarea\",body_0);function body_0(chk,ctx){return chk.write(\"<div class=\\\"dg-map-geoclicker__purpose dg-map-geoclicker__purpose_type_\").reference(ctx.get([\"type\"], false),ctx,\"h\").write(\"\\\">\").reference(ctx.get([\"purpose\"], false),ctx,\"h\").write(\"</div>\").section(ctx.get([\"drilldown\"], false),ctx,{\"block\":body_1},null);}function body_1(chk,ctx){return chk.write(\"<div class=\\\"dg-map-geoclicker__drilldown\\\">\").reference(ctx.get([\"drilldown\"], false),ctx,\"h\").write(\"</div>\");}return body_0;})();","firmCardAddr":"(function(){dust.register(\"firmCardAddr\",body_0);function body_0(chk,ctx){return chk.write(\"<address class=\\\"dg-firm-card__address dg-firm-card__icon\\\">\").reference(ctx.get([\"address\"], false),ctx,\"h\").section(ctx.get([\"comment\"], false),ctx,{\"block\":body_1},null).write(\"</address>\");}function body_1(chk,ctx){return chk.write(\"<span class=\\\"dg-firm-card__comment\\\">&mdash; \").reference(ctx.getPath(true, []),ctx,\"h\").write(\"</span>\");}return body_0;})();","firmCardContacts":"(function(){dust.register(\"firmCardContacts\",body_0);function body_0(chk,ctx){return chk.section(ctx.get([\"groups\"], false),ctx,{\"block\":body_1},null);}function body_1(chk,ctx){return chk.section(ctx.get([\"contacts\"], false),ctx,{\"block\":body_2},null);}function body_2(chk,ctx){return chk.helper(\"select\",ctx,{\"block\":body_3},{\"key\":ctx.get([\"type\"], false),\"type\":\"string\"});}function body_3(chk,ctx){return chk.helper(\"eq\",ctx,{\"block\":body_4},{\"value\":\"phone\",\"type\":\"string\"}).helper(\"eq\",ctx,{\"block\":body_6},{\"value\":\"fax\",\"type\":\"string\"}).helper(\"eq\",ctx,{\"block\":body_8},{\"value\":\"website\",\"type\":\"string\"}).helper(\"eq\",ctx,{\"block\":body_9},{\"value\":\"email\",\"type\":\"string\"});}function body_4(chk,ctx){return chk.write(\"<div class=\\\"dg-firm-card__phone dg-firm-card__icon\\\"><span class=\\\"dg-firm-card__phone-num\\\">\").reference(ctx.get([\"text\"], false),ctx,\"h\").section(ctx.get([\"comment\"], false),ctx,{\"block\":body_5},null).write(\"</span></div>\");}function body_5(chk,ctx){return chk.write(\"<span class=\\\"dg-firm-card__comment\\\" title=\\\"\").reference(ctx.getPath(true, []),ctx,\"h\").write(\"\\\">&mdash;&nbsp;&nbsp;\").reference(ctx.getPath(true, []),ctx,\"h\").write(\"</span>\");}function body_6(chk,ctx){return chk.write(\"<div class=\\\"dg-firm-card__phone dg-firm-card__icon\\\"><span class=\\\"dg-firm-card__phone-num\\\">\").reference(ctx.get([\"text\"], false),ctx,\"h\").section(ctx.get([\"comment\"], false),ctx,{\"block\":body_7},null).write(\"</span></div>\");}function body_7(chk,ctx){return chk.write(\"<span class=\\\"dg-firm-card__comment\\\" title=\\\"\").reference(ctx.getPath(true, []),ctx,\"h\").write(\"\\\">&mdash;&nbsp;&nbsp;\").reference(ctx.getPath(true, []),ctx,\"h\").write(\"</span>\");}function body_8(chk,ctx){return chk.write(\"<div class=\\\"dg-firm-card__link dg-firm-card__site dg-firm-card__icon\\\"><a href=\\\"\").reference(ctx.get([\"url\"], false),ctx,\"h\").write(\"\\\" target=\\\"_blank\\\" class=\\\"dg-link_scheme_dark dg-firm-card__sitelink\\\">\").reference(ctx.get([\"text\"], false),ctx,\"h\").write(\"</a></div>\");}function body_9(chk,ctx){return chk.write(\"<div class=\\\"dg-firm-card__link dg-firm-card__email dg-firm-card__icon\\\"><a href=\\\"mailto: \").reference(ctx.get([\"value\"], false),ctx,\"h\").write(\"\\\">\").reference(ctx.get([\"value\"], false),ctx,\"h\").write(\"</a></div>\");}return body_0;})();","firmCardHeader":"(function(){dust.register(\"firmCardHeader\",body_0);function body_0(chk,ctx){return chk.write(\"<div class=\\\"dg-popup__header-title dg-popup__header-title_for_firmcard\\\" title=\\\"\").reference(ctx.get([\"firmName\"], false),ctx,\"h\").write(\"\\\">\").reference(ctx.get([\"firmName\"], false),ctx,\"h\").write(\"</div>\").exists(ctx.get([\"links\"], false),ctx,{\"block\":body_1},null);}function body_1(chk,ctx){return chk.write(\"<div class=\\\"dg-popup__header-links\\\">\").section(ctx.get([\"links\"], false),ctx,{\"block\":body_2},null).write(\"</div>\");}function body_2(chk,ctx){return chk.helper(\"eq\",ctx,{\"else\":body_3,\"block\":body_6},{\"key\":body_7,\"value\":\"flamp_stars\",\"type\":\"string\"});}function body_3(chk,ctx){return chk.write(\"<a class=\\\"dg-popup__header-link dg-popup__link dg-popup__link_type_\").reference(ctx.get([\"name\"], false),ctx,\"h\").write(\"\\\"\").exists(ctx.get([\"href\"], false),ctx,{\"else\":body_4,\"block\":body_5},null).write(\">\").reference(ctx.get([\"label\"], false),ctx,\"h\").write(\"</a>\");}function body_4(chk,ctx){return chk.write(\"href=\\\"javascript:void(0)\\\"\");}function body_5(chk,ctx){return chk.write(\"href=\").reference(ctx.get([\"href\"], false),ctx,\"h\").write(\" target=\\\"_blank\\\"\");}function body_6(chk,ctx){return chk.write(\"<div class=\\\"dg-popup__rating\\\"><div class=\\\"dg-popup__rating-stars\\\" style=\\\"width: \").reference(ctx.get([\"width\"], false),ctx,\"h\").write(\"%\\\"></div></div>\");}function body_7(chk,ctx){return chk.reference(ctx.get([\"name\"], false),ctx,\"h\");}return body_0;})();","firmCardRubric":"(function(){dust.register(\"firmCardRubric\",body_0);function body_0(chk,ctx){return chk.section(ctx.get([\"rubrics\"], false),ctx,{\"block\":body_1},null);}function body_1(chk,ctx){return chk.write(\"<section class=\\\"dg-firm-card__rubrics\\\">\").exists(ctx.get([\"primary\"], false),ctx,{\"block\":body_2},null).exists(ctx.get([\"additional\"], false),ctx,{\"block\":body_4},null).write(\"</section>\");}function body_2(chk,ctx){return chk.write(\"<ul class=\\\"dg-firm-card__rubrics-list dg-firm-card__rubrics-list_type_primary\\\">\").section(ctx.get([\"primary\"], false),ctx,{\"block\":body_3},null).write(\"</ul>\");}function body_3(chk,ctx){return chk.write(\"<li class=\\\"dg-firm-card__rubrics-list-item\\\">\").reference(ctx.get([\"name\"], false),ctx,\"h\").write(\"</li>\");}function body_4(chk,ctx){return chk.write(\"<ul class=\\\"dg-firm-card__rubrics-list dg-firm-card__rubrics-list_type_additional\\\">\").section(ctx.get([\"additional\"], false),ctx,{\"block\":body_5},null).write(\"</ul>\");}function body_5(chk,ctx){return chk.write(\"<li class=\\\"dg-firm-card__rubrics-list-item\\\">\").reference(ctx.get([\"name\"], false),ctx,\"h\").write(\"</li>\");}return body_0;})();","firmCardSchedule":"(function(){dust.register(\"firmCardSchedule\",body_0);function body_0(chk,ctx){return chk.write(\"<div class=\\\"dg-firm-card__schedule dg-schedule dg-schedule_open_\").exists(ctx.getPath(false, [\"forecast\",\"open\"]),ctx,{\"else\":body_1,\"block\":body_2},null).write(\" dg-schedule_works-everyday_\").exists(ctx.getPath(false, [\"schedule\",\"everyday\"]),ctx,{\"else\":body_3,\"block\":body_4},null).write(\"\\\">\").exists(ctx.get([\"schedule\"], false),ctx,{\"block\":body_5},null).write(\"</div>\");}function body_1(chk,ctx){return chk.write(\"false\");}function body_2(chk,ctx){return chk.write(\"true\");}function body_3(chk,ctx){return chk.write(\"false\");}function body_4(chk,ctx){return chk.write(\"true\");}function body_5(chk,ctx){return chk.exists(ctx.getPath(false, [\"forecast\",\"today\"]),ctx,{\"block\":body_6},null).section(ctx.getPath(false, [\"forecast\",\"now\"]),ctx,{\"block\":body_10},null).notexists(ctx.getPath(false, [\"schedule\",\"everyday\"]),ctx,{\"block\":body_12},null);}function body_6(chk,ctx){return chk.write(\"<div class=\\\"dg-schedule__today\\\"><div class=\\\"dg-schedule__today-inner\\\">\").reference(ctx.getPath(false, [\"forecast\",\"today\",\"text\"]),ctx,\"h\").write(\"&nbsp;\").exists(ctx.getPath(false, [\"forecast\",\"today\",\"from\"]),ctx,{\"block\":body_7},null).exists(ctx.getPath(false, [\"schedule\",\"lunch\"]),ctx,{\"block\":body_8},null).write(\"</div></div>\");}function body_7(chk,ctx){return chk.reference(ctx.getPath(false, [\"forecast\",\"today\",\"from\"]),ctx,\"h\").write(\"&ndash;\").reference(ctx.getPath(false, [\"forecast\",\"today\",\"to\"]),ctx,\"h\");}function body_8(chk,ctx){return chk.write(\",&nbsp;\").reference(ctx.getPath(false, [\"forecast\",\"today\",\"lunchStr\"]),ctx,\"h\").write(\"&nbsp;\").section(ctx.getPath(false, [\"schedule\",\"lunch\"]),ctx,{\"block\":body_9},null);}function body_9(chk,ctx){return chk.reference(ctx.get([\"from\"], false),ctx,\"h\").write(\"&ndash;\").reference(ctx.get([\"to\"], false),ctx,\"h\");}function body_10(chk,ctx){return chk.write(\"<div class=\\\"dg-schedule__now\\\"><span class=\\\"dg-schedule__now-text\\\">\").reference(ctx.getPath(true, []),ctx,\"h\").section(ctx.getPath(false, [\"schedule\",\"comment\"]),ctx,{\"block\":body_11},null).write(\"</span></div>\");}function body_11(chk,ctx){return chk.write(\", \").reference(ctx.getPath(true, []),ctx,\"h\");}function body_12(chk,ctx){return chk.exists(ctx.getPath(false, [\"schedule\",\"week\"]),ctx,{\"block\":body_13},null);}function body_13(chk,ctx){return chk.exists(ctx.getPath(false, [\"schedule\",\"week\",\"evently\"]),ctx,{\"block\":body_14},null).exists(ctx.getPath(false, [\"schedule\",\"week\",\"table\"]),ctx,{\"block\":body_22},null);}function body_14(chk,ctx){return chk.write(\"<div class=\\\"dg-schedule__table\\\">\").section(ctx.getPath(false, [\"schedule\",\"week\",\"evently\"]),ctx,{\"block\":body_15},null).write(\"</div>\");}function body_15(chk,ctx){return chk.write(\"<div class=\\\"dg-schedule__string\\\">\").exists(ctx.get([\"alltime\"], false),ctx,{\"block\":body_16},null).exists(ctx.get([\"everyday\"], false),ctx,{\"else\":body_17,\"block\":body_18},null).exists(ctx.get([\"holiday\"], false),ctx,{\"else\":body_19,\"block\":body_21},null).write(\"</div>\");}function body_16(chk,ctx){return chk.reference(ctx.get([\"alltimeStr\"], false),ctx,\"h\");}function body_17(chk,ctx){return chk.reference(ctx.get([\"dayList\"], false),ctx,\"h\");}function body_18(chk,ctx){return chk.reference(ctx.getPath(false, [\"forecast\",\"today\",\"text\"]),ctx,\"h\");}function body_19(chk,ctx){return chk.write(\"<span class=\\\"schedule__string-time\\\">&nbsp;\").reference(ctx.get([\"from\"], false),ctx,\"h\").write(\"&ndash;\").reference(ctx.get([\"to\"], false),ctx,\"h\").write(\"</span>\").section(ctx.get([\"lunch\"], false),ctx,{\"block\":body_20},null);}function body_20(chk,ctx){return chk.write(\"<p>\").reference(ctx.get([\"lunchStr\"], false),ctx,\"h\").write(\"&mdash;<span class=\\\"schedule__string-time\\\">\").reference(ctx.get([\"from\"], false),ctx,\"h\").write(\"&ndash;\").reference(ctx.get([\"to\"], false),ctx,\"h\").write(\"</span></p>\");}function body_21(chk,ctx){return chk.write(\"&nbsp;&mdash;<span class=\\\"schedule__string-time\\\">&nbsp;\").reference(ctx.get([\"holidayStr\"], false),ctx,\"h\").write(\"</span>\");}function body_22(chk,ctx){return chk.write(\"<div><div class=\\\"dg-schedule__table\\\"><div class=\\\"dg-schedule__tc dg-schedule__tc_pre\\\"><div class=\\\"dg-schedule__day-name\\\">&nbsp;</div><div class=\\\"dg-schedule__table-clock dg-schedule__td\\\"></div>\").exists(ctx.getPath(false, [\"schedule\",\"week\",\"hasLunch\"]),ctx,{\"block\":body_23},null).write(\"</div>\").section(ctx.getPath(false, [\"schedule\",\"week\",\"table\"]),ctx,{\"block\":body_24},null).write(\"</div>  </div>\");}function body_23(chk,ctx){return chk.write(\"<div class=\\\"dg-schedule__table-lunch dg-schedule__td\\\"></div>\");}function body_24(chk,ctx){return chk.helper(\"if\",ctx,{\"block\":body_25},{\"cond\":body_26}).write(\"<div class=\\\"dg-schedule__tc\").exists(ctx.get([\"active\"], false),ctx,{\"block\":body_27},null).write(\"\\\"><div class=\\\"dg-schedule__day-name\\\">\").reference(ctx.get([\"key\"], false),ctx,\"h\").write(\"</div><div class=\\\"dg-schedule__td\\\">\").exists(ctx.get([\"from\"], false),ctx,{\"else\":body_28,\"block\":body_29},null).write(\"</div>\").section(ctx.get([\"lunch\"], false),ctx,{\"block\":body_30},null).write(\"</div> \").helper(\"if\",ctx,{\"block\":body_33},{\"cond\":body_34});}function body_25(chk,ctx){return chk.write(\"<span class=\\\"dg-schedule__table-cell-group\\\">\");}function body_26(chk,ctx){return chk.write(\"(\").reference(ctx.get([\"$idx\"], false),ctx,\"h\").write(\" == \").reference(ctx.get([\"$len\"], false),ctx,\"h\").write(\" - 2)\");}function body_27(chk,ctx){return chk.write(\" dg-schedule__tc_active_true\");}function body_28(chk,ctx){return chk.write(\"&ndash;\");}function body_29(chk,ctx){return chk.reference(ctx.get([\"from\"], false),ctx,\"h\").write(\" \").reference(ctx.get([\"to\"], false),ctx,\"h\");}function body_30(chk,ctx){return chk.write(\"<div class=\\\"dg-schedule__td\\\">\").exists(ctx.get([\"from\"], false),ctx,{\"else\":body_31,\"block\":body_32},null).write(\"</div>\");}function body_31(chk,ctx){return chk.write(\"&ndash;\");}function body_32(chk,ctx){return chk.reference(ctx.get([\"from\"], false),ctx,\"h\").write(\" \").reference(ctx.get([\"to\"], false),ctx,\"h\");}function body_33(chk,ctx){return chk.write(\"</span>\");}function body_34(chk,ctx){return chk.write(\"(\").reference(ctx.get([\"$idx\"], false),ctx,\"h\").write(\" == \").reference(ctx.get([\"$len\"], false),ctx,\"h\").write(\")\");}return body_0;})();","firmlistItem":"(function(){dust.register(\"firmlistItem\",body_0);function body_0(chk,ctx){return chk.write(\"<a id=\\\"\").reference(ctx.getPath(false, [\"firm\",\"id\"]),ctx,\"h\").write(\"\\\" class=\\\"dg-popup__link\\\" href=\\\"#\\\">\").reference(ctx.getPath(false, [\"firm\",\"name\"]),ctx,\"h\").write(\"</a>\");}return body_0;})();","frimCardPayments":"(function(){dust.register(\"frimCardPayments\",body_0);function body_0(chk,ctx){return chk.exists(ctx.get([\"payments\"], false),ctx,{\"block\":body_1},null);}function body_1(chk,ctx){return chk.write(\"<section class=\\\"dg-firm-card__aa\\\"><ul class=\\\"dg-firm-card__aa-list\\\">\").section(ctx.get([\"payments\"], false),ctx,{\"block\":body_2},null).write(\"</ul></section>\");}function body_2(chk,ctx){return chk.write(\"<li class=\\\"dg-firm-card__aa-list-item\\\">\").reference(ctx.getPath(true, []),ctx,\"h\").write(\"</li>\");}return body_0;})();","house":"(function(){dust.register(\"house\",body_0);function body_0(chk,ctx){return chk.section(ctx.get([\"address\"], false),ctx,{\"block\":body_1},null).section(ctx.get([\"purpose\"], false),ctx,{\"block\":body_4},null).section(ctx.get([\"attractions\"], false),ctx,{\"block\":body_5},null);}function body_1(chk,ctx){return chk.write(\"<address class=\\\"dg-map-geoclicker__address\\\">\").section(ctx.getPath(false, [\"address\",\"header\"]),ctx,{\"block\":body_2},null).section(ctx.getPath(false, [\"address\",\"drilldown\"]),ctx,{\"block\":body_3},null).write(\"</address>\");}function body_2(chk,ctx){return chk.write(\"<div class=\\\"dg-map-geoclicker__address-header\\\">\").reference(ctx.getPath(true, []),ctx,\"h\").write(\"</div>\");}function body_3(chk,ctx){return chk.write(\"<div class=\\\"dg-map-geoclicker__address-drilldown\\\">\").reference(ctx.getPath(true, []),ctx,\"h\").write(\"</div>\");}function body_4(chk,ctx){return chk.write(\"<div class=\\\"dg-map-geoclicker__purpose\\\">\").reference(ctx.getPath(true, []),ctx,\"h\").write(\"</div>\");}function body_5(chk,ctx){return chk.write(\"<div class=\\\"dg-map-geoclicker__purpose dg-map-geoclicker__purpose_type_sight\\\">\").reference(ctx.getPath(true, []),ctx,\"h\").write(\"</div>\");}return body_0;})();","loader":"(function(){dust.register(\"loader\",body_0);function body_0(chk,ctx){return chk.write(\"<div class=\\\"dg-preloader dg-preloader_scheme_regular dg-preloader_animation_\").exists(ctx.get([\"anim\"], false),ctx,{\"else\":body_1,\"block\":body_2},null).exists(ctx.get([\"small\"], false),ctx,{\"block\":body_3},null).write(\"\\\"></div>\");}function body_1(chk,ctx){return chk.write(\"false\");}function body_2(chk,ctx){return chk.write(\"true\");}function body_3(chk,ctx){return chk.write(\" dg-preloader_size_small\");}return body_0;})();","popupFooter":"(function(){dust.register(\"popupFooter\",body_0);function body_0(chk,ctx){return chk.write(\"<div class=\\\"dg-popup__footer-title\\\"><a class=\\\"dg-popup__show-less-house-link\\\" href=\\\"javascript:void(0)\\\">\").reference(ctx.get([\"hideFirmsText\"], false),ctx,\"h\").write(\"</a></div>\");}return body_0;})();","popupFooterBtns":"(function(){dust.register(\"popupFooterBtns\",body_0);function body_0(chk,ctx){return chk.exists(ctx.get([\"btns\"], false),ctx,{\"block\":body_1},null);}function body_1(chk,ctx){return chk.write(\"<footer class=\\\"dg-popup__footer-buttons\\\">\").section(ctx.get([\"btns\"], false),ctx,{\"block\":body_2},null).write(\"</footer>\");}function body_2(chk,ctx){return chk.write(\"<div class=\\\"dg-popup__footer-button-wrapper\\\"><a class=\\\"dg-popup__button_name_\").reference(ctx.get([\"name\"], false),ctx,\"h\").write(\" dg-popup__footer-button\").exists(ctx.get([\"icon\"], false),ctx,{\"block\":body_3},null).write(\"\\\"\").exists(ctx.get([\"href\"], false),ctx,{\"else\":body_4,\"block\":body_5},null).write(\">\").reference(ctx.get([\"label\"], false),ctx,\"h\").write(\"</a></div>\");}function body_3(chk,ctx){return chk.write(\" dg-popup__footer-icon-button\");}function body_4(chk,ctx){return chk.write(\"href=\\\"javascript:void(0)\\\"\");}function body_5(chk,ctx){return chk.write(\"href=\").reference(ctx.get([\"href\"], false),ctx,\"h\").write(\" target=\\\"_blank\\\"\");}return body_0;})();","popupHeader":"(function(){dust.register(\"popupHeader\",body_0);function body_0(chk,ctx){return chk.section(ctx.get([\"title\"], false),ctx,{\"block\":body_1},null);}function body_1(chk,ctx){return chk.write(\"<div class=\\\"dg-popup__header-title\\\">\").reference(ctx.getPath(true, []),ctx,\"h\").write(\"</div>\");}return body_0;})();","sight":"(function(){dust.register(\"sight\",body_0);function body_0(chk,ctx){return chk.section(ctx.get([\"purpose\"], false),ctx,{\"block\":body_1},null).section(ctx.get([\"address\"], false),ctx,{\"block\":body_2},null).section(ctx.get([\"description\"], false),ctx,{\"block\":body_5},null);}function body_1(chk,ctx){return chk.write(\"<div class=\\\"dg-map-geoclicker__purpose dg-map-geoclicker__purpose_type_sight\\\">\").reference(ctx.getPath(true, []),ctx,\"h\").write(\"</div>\");}function body_2(chk,ctx){return chk.write(\"<address class=\\\"dg-map-geoclicker__address\\\">\").section(ctx.getPath(false, [\"address\",\"header\"]),ctx,{\"block\":body_3},null).section(ctx.getPath(false, [\"address\",\"drilldown\"]),ctx,{\"block\":body_4},null).write(\"</address>\");}function body_3(chk,ctx){return chk.write(\"<div class=\\\"dg-map-geoclicker__address-header\\\">\").reference(ctx.getPath(true, []),ctx,\"h\").write(\"</div>\");}function body_4(chk,ctx){return chk.write(\"<div class=\\\"dg-map-geoclicker__address-drilldown\\\">\").reference(ctx.getPath(true, []),ctx,\"h\").write(\"</div>\");}function body_5(chk,ctx){return chk.write(\"<div class=\\\"dg-map-geoclicker__sight-description\\\">\").reference(ctx.getPath(true, []),ctx,\"h\").write(\"</div>\").section(ctx.get([\"showMoreText\"], false),ctx,{\"block\":body_6},null);}function body_6(chk,ctx){return chk.write(\"<a class=\\\"dg-map-geoclicker__show-more-sights-link\\\" href=\\\"javascript:void(0)\\\">\").reference(ctx.getPath(true, []),ctx,\"h\").write(\"</a>\");}return body_0;})();"});

        if (options) {
            DG.Util.setOptions(this, options);
        }
    },

    initLoader: function (isSmall) {
        var loader = document.createElement('div');
        loader.innerHTML = this._templates('loader',
            {
                small: isSmall,
                anim: this._detectCssAnimation()
            }
        );

        return loader.firstChild;
    },

    showPopup: function (latlng, content) { // (Object)
        this._popup
                .setContent(content)
                .setLatLng(latlng)
                .openOn(this._map);
    },

    render: function (options) { // (Object) -> String
        var html,
            data = {};

        options = options || {};
        options.tmpl = options.tmpl || '';

        if (options.data) {
            html = this._templates(options.tmpl, options.data);
        } else {
            html = options.tmpl;
        }

        if (options.beforeRender) {
            options.beforeRender();
        }

        if (options.popup) {
            if (options.header) {
                data.header = options.header;
            }
            if (options.footer) {
                data.footer = options.footer;
            }
            data.body = html;
            this._popup.setContent(data);
        }
        if (options.afterRender) {
            options.afterRender();
        }

        return html;
    },

    renderPopup: function (options) { // (Object) -> String
        options.popup = true;
        return this.render(options);
    },

    getPopup: function () { // () -> Object
        return this._popup;
    },

    _detectCssAnimation: function () {
        var animation = false,
            domPrefixes = 'Webkit Moz O ms Khtml'.split(' '),
            elm = document.createElement('div');

        if (elm.style.animationName) { animation = true; }

        if (animation === false) {
            for (var i = 0; i < domPrefixes.length; i++) {
                if (elm.style[domPrefixes[i] + 'AnimationName'] !== undefined) {
                    animation = true;
                    break;
                }
            }
        }
        return animation;
    }
});

DG.Geoclicker.Controller = DG.Class.extend({

    options: {
        // if handler worked successfully, it should return rendering object that will be processed in View , otherwise it should return false
        // default handler always should return rendering object
        'handlersSequence': {
            'poi': DG.Geoclicker.Handler.Poi,
            'attraction': DG.Geoclicker.Handler.Sight,
            'building': DG.Geoclicker.Handler.House,
            'street': DG.Geoclicker.Handler.CityArea,
            'adm_div.place': DG.Geoclicker.Handler.CityArea,
            'adm_div.district': DG.Geoclicker.Handler.CityArea,
            'adm_div.division': DG.Geoclicker.Handler.CityArea,
            'adm_div.settlement': DG.Geoclicker.Handler.CityArea,
            'adm_div.city': DG.Geoclicker.Handler.CityArea,

            'default': DG.Geoclicker.Handler.Default,

            'apiError': DG.Geoclicker.Handler.ApiError

//            station_platform
//            project
//            station
//            crossbroad
//            metro
        }
    },

    initialize: function (map, options) { // (Object, Object)
        this._options = options;
        this._handlers = {};
        this._catalogApi = new DG.Geoclicker.Provider.CatalogApi(map);
        this._map = map;
        this._view = new DG.Geoclicker.View(map);

        this._renderHandlerResult = DG.bind(this._renderHandlerResult, this);
        this._lastHandleClickArguments = null;
    },

    handlePopupClose: function (popup) { // (Object)
        if (popup === this._view.getPopup()) {
            this._lastHandleClickArguments = null;
            this._catalogApi.cancelLastRequest();
        }
    },

    handleClick: function (latlng, zoom, meta) { // (Object, Number, Object)
        var self = this,
            args = Array.prototype.slice.call(arguments, 0);

        function beforeRequest() {
            var loader = self._view.initLoader();
            self._view._popup.clear();
            self._view.showPopup(latlng, loader);
            self._lastHandleClickArguments = args;
        }

        if (meta && meta.linked) {
            beforeRequest();
            self.handleResponse({
                poi: {
                    reference: meta.linked
                }
            });
        } else {
            this._catalogApi.getLocations({
                latlng: latlng,
                zoom: zoom,
                beforeRequest: beforeRequest
            }).then(function (result) {
                self.handleResponse(result);
            }, function (error) {
                self.handleResponse(error);
            });
        }
    },

    handleResponse: function (result) { // (Object)
        var type;

        if (!result) {
            this._runHandler('default');
            return;
        }

        if (result === 'no type') {
            return;
        }

        if (result === 'aborted') {
            this._runHandler('apiError');
            return;
        }

        type = this.findHandler(result);

        while (type) {
            if (this._runHandler(type, result)) {
                return;
            }
            delete result[type];

            type = this.findHandler(result);
        }
        this._runHandler('default');
    },

    findHandler: function (result) { // (Object) -> String|Null
        for (var i in this.options.handlersSequence) {
            if (result[i]) {
                return i;
            }
        }

        return null;
    },

    getCatalogApi: function () { // () -> Object
        return this._catalogApi;
    },

    getMap: function () {
        return this._map;
    },

    reinvokeHandler: function () {
        if (this._lastHandleClickArguments) {
            this.handleClick.apply(this, this._lastHandleClickArguments);
        }
    },

    _runHandler: function (type, data) { // (String, Object) -> Boolean
        data = data || {};
        this._initHandlerOnce(type);
        this._handlers[type].addClickEvent();

        var handlerResult = this._handlers[type].handle(data, type);

        return handlerResult && handlerResult.then ?
            handlerResult.then(this._renderHandlerResult) :
            handlerResult;
    },

    _renderHandlerResult: function (result) {
        this._view.renderPopup(result);
    },

    _initHandlerOnce: function (type) { // (String)
        if (!this._handlers[type]) {
            this._handlers[type] = new this.options.handlersSequence[type](this, this._view, this._map, this._options);
        }
    }
});

DG.Geoclicker.Handler.Default.Dictionary.it = DG.extend({
    apiErrorTitle: 'Oh oh, c\'&nbsp;un&nbsp;errore',
    apiErrorBody: 'I nostri server si rifiutano di rispondere. Stiamo facendo del nostro meglio per convincerli a&nbsp;comportarsi bene. Ritorna tra qualche minuto.',
    we_have_not : 'Non disponiamo ancora di informazioni su questo posto',
    noname : 'Nome non indicato',
    'adm_div.place' : 'Luogo',
    'adm_div.division' : 'Zona',
    'adm_div.settlement' : 'Comune',
    street : 'Via',
    'adm_div.district' : 'Municipalit',
    'adm_div.city' : 'itt',
    go_to : 'Come arrivare',
    show_organization_in_building : ['{n} azienda in tutto', '{n} aziende in tutto'],
    show_more_about_sight : 'Maggiori informazioni',
    back_button: 'Indietro',
    n_floors : ['{n} piano', '{n} piani']
}, DG.Dictionary.it);

DG.Geoclicker.Handler.Default.Dictionary.ru = DG.extend({
    apiErrorTitle: ' ',
    apiErrorBody: '   .     ,   .  &nbsp; &nbsp; .',
    we_have_not : '      ',
    noname: ' ',
    'adm_div.place': '',
    'adm_div.division': '',
    'adm_div.settlement': ' ',
    street: '',
    'adm_div.district': '',
    'adm_div.city': '',
    go_to: ' ',
    show_organization_in_building: [' {n} ', ' {n} ', ' {n} '],
    show_more_about_sight: '',
    back_button: '',
    n_floors: ['{n} ', '{n} ', '{n} ']
}, DG.Dictionary.ru);

DG.Geoclicker.Handler.Default.Dictionary.en = DG.extend({
    apiErrorTitle: 'Oops! Error detected.',
    apiErrorBody: 'Our servers are not responding. We are doing our best to straighten them out. Please return to us in a few minutes.',
    we_have_not: 'We haven\'t collected info about this place yet',
    noname : 'No name',
    'adm_div.place' : 'Place',
    'adm_div.division' : 'Area',
    'adm_div.settlement' : 'Village',
    street : 'Street',
    'adm_div.district' : 'District',
    'adm_div.city' : 'City',
    go_to : 'Directions to here',
    show_organization_in_building : ['{n} organization total', '{n} organizations total'],
    back_button : 'Back',
    show_more_about_sight : 'More information',
    n_floors : ['{n} floor', '{n} floors']
}, DG.Dictionary.en);

DG.Geoclicker.Handler.Default.Dictionary.cs = DG.extend({
    apiErrorTitle: 'Chybika se&nbsp;vloudila',
    apiErrorBody: 'Nae servery odmtaj reagovat. Ji nyn vynakldme veker sil, abychom je pivedli k rozumu. Zkuste akci opakovat za nkolik minut.',
    we_have_not : 'O tomto mst zatm nemme informace',
    noname : 'Bez nzvu',
    'adm_div.place' : 'Msto',
    'adm_div.division' : 'Sprvn obvod',
    'adm_div.settlement' : 'Obec',
    street : 'Ulice',
    'adm_div.district' : 'Mstsk st',
    'adm_div.city' : 'Msto',
    go_to : 'Cesta sem',
    show_organization_in_building : ['Celkem {n} organizace', 'Celkem {n} organizace', 'Celkem {n} organizac'],
    back_button : 'Zpt',
    show_more_about_sight : 'Vce',
    n_floors : ['{n} patro', '{n} patra', '{n} pater']
}, DG.Dictionary.cs);

DG.Geoclicker.Handler.Default.Dictionary.es = DG.extend({
    apiErrorTitle: 'Vaya, ha ocurrido un error',
    apiErrorBody: 'Nuestros servidores se niegan a responder. Ya nos estamos esforzando por hacerlos entrar en razn. Vuelva con nosotrospasados unos minutos.',
    we_have_not : 'Todava no hemos recopilado la informacin sobre este lugar',
    noname : 'Sin nombre',
    'adm_div.place' : 'Lugar',
    'adm_div.division' : 'Comuna',
    'adm_div.settlement' : 'Poblacin',
    street : 'Calle',
    'adm_div.district' : 'Comuna',
    'adm_div.city' : 'Ciudad',
    go_to : 'Ir para all',
    show_organization_in_building : ['Total {n} organizacin', 'Total {n} organizaciones', 'Total {n} organizaciones'],
    show_more_about_sight : 'Read more',
    back_button: 'Atrs',
    n_floors : ['{n} piso', '{n} pisos']
}, DG.Dictionary.es);

var FirmCard = function (firm, options) {
    this._setOptions(options);
    this._firmContentObject = {};
    this._schedule = new FirmCard.Schedule({
        localLang: this.options.lang,
        dict: this.dict
    });

    this.render(firm);
};

FirmCard.prototype = {

    render: function (firmId) {
        if (!firmId) { return; }

        if (firmId !== this._firmId) {
            this._firmContentObject = {};
            this._renderCardById(firmId);
        } else {
            this._toggleEventHandlers();
        }

        return this._firmContentObject;
    },

    getSchedule: function () {
        return this._schedule;
    },

    getContainer: function () {
        return this._container;
    },

    _renderCardById: function (firmId) {
        var self = this;

        this.options.ajax(firmId).then(function (res) {
            if (!res) { return false; }
            var data = res.result.items;
            if (data !== 'undefined') {
                self._firmData = data[0];

                // Support for old WebAPI format.
                // TODO: remove this call after WebAPI release
                self._convertWebsite();

                self._firmId = firmId;
                self._renderFirmCard();
                self._toggleEventHandlers();
            }
        }, function (error) {
            self._renderError();
        });
    },

    _createFirmContainer: function () {
        var firm = document.createElement('div');
        firm.setAttribute('id', 'dg-map-firm-full-' + this._firmId);
        firm.setAttribute('class', 'dg-map-firm-full');

        return firm;
    },

    _getPaymentTypes: function (data) {
        var result = [],
            groupName = 'general_payment_type';

        if (!data.attribute_groups) {
            return result;
        }

        data.attribute_groups.forEach(function (group) {
            if (group.name) {
                return;
            }

            group.attributes.forEach(function (attr) {
                if (attr.tag.substring(0, groupName.length) === groupName) {
                    result.push(attr.name);
                }
            });
        });

        return result;
    },

    _groupRubrics: function (data) {
        var result = {
            primary: [],
            additional: []
        };

        if (!data.rubrics || !data.rubrics.length) {
            return result;
        }

        data.rubrics.forEach(function (rubric) {
            result[rubric.kind].push(rubric);
        });

        return result;
    },

    // Support for old WebAPI format.
    // TODO: remove this function after WebAPI release
    _convertWebsite: function () {
        if (!this._firmData.contact_groups) {
            return;
        }

        this._firmData.contact_groups.forEach(function (group) {
            if (!group.contacts) {
                return;
            }

            group.contacts.forEach(function (contact) {
                if (contact.type != 'website') {
                    return;
                }

                if (!contact.url) {
                    contact.url = contact.value;
                }
            });
        });
    },

    _renderFirmCard: function () {
        var firmCardBody, schedule, forecast, links, btns, paymentTypes, rubrics,
            data = this._firmData,
            container = this._container = this._createFirmContainer();

        schedule = this._schedule.transform(data.schedule, {
            zoneOffset: this.options.timezoneOffset,
            apiLang: this.options.lang,
            localLang: this.options.lang
        });

        forecast = this._schedule.forecast(schedule);

        paymentTypes = this._getPaymentTypes(data);
        rubrics = this._groupRubrics(data);

        firmCardBody = this._buildFirmCardBody(
            this._getConfigFirmCardBody(data, schedule, forecast, paymentTypes, rubrics)
        );

        links = this._fillHeaderLinks();
        btns = this._fillFooterButtons();

        //fill object for view render
        this._firmContentObject.header = this.options.render('firmCardHeader', {'firmName': data.name, 'links': links});
        container.innerHTML = firmCardBody;
        this._firmContentObject.tmpl = container;
        if (btns.length) {
            this._footerContainer = document.createElement('div');

            this._footerContainer.innerHTML = this.options.render('popupFooterBtns', {'btns': btns});
            this._firmContentObject.footer = this._footerContainer;
        }

        if (this.options.onFirmReady) {
            this.options.onFirmReady(this._firmContentObject);
        }
    },

    _renderError: function() {
        this._firmContentObject.header = this.options.render('popupHeader', {
            title: this.options.t('apiErrorTitle')
        });

        this._firmContentObject.tmpl = this.options.t('apiErrorBody');

        if (this.options.onFirmReady) {
            this.options.onFirmReady(this._firmContentObject);
        }
    },

    _getConfigFirmCardBody: function (data, schedule, forecast, attributes, rubrics) {
        return [
            {
                tmpl: 'firmCardAddr',
                data: {
                    address: data.address_name,
                    comment: data.address_comment
                }
            },
            {
                tmpl: 'firmCardContacts',
                data: {
                    groups: data.contact_groups
                }
            },
            {
                tmpl: 'firmCardSchedule',
                data: {
                    schedule: schedule,
                    forecast: forecast
                }
            },
            {
                tmpl: 'frimCardPayments',
                data: {
                    payments: attributes
                }
            },
            {
                tmpl: 'firmCardRubric',
                data: {
                    rubrics: rubrics
                }
            }
        ];
    },

    _buildFirmCardBody: function (parts) {
        var self = this;
        return parts.reduce(function (body, item) {
            var html = self.options.render(item.tmpl, item.data);
            return body + html;
        }, '');
    },

    _fillFooterButtons: function () {
        var btns = [];

        if (this.options.backBtn) {
            btns.push({ name: 'firm-card-back',
                        label: this.dict.t(this.options.lang, 'btnBack'),
                        icon: true
            });
        }

        if (this.options.showRouteSearch) {
            btns.push({ name: 'goto',
                        label: this.dict.t(this.options.lang, 'btnFindWay'),
                        icon: true,
                        href: this.options.gotoUrl
            });
        }

        if (
            this._firmData.links &&
                this._firmData.links.entrances &&
                this.options.showEntrance
        ) {
            btns.push({ name: 'show-entrance',
                        label: this.dict.t(this.options.lang, 'btnEntrance'),
                        icon: true
            });
        }

        return btns;
    },

    _fillHeaderLinks: function () {
        var links = [],
            reviewData = this._firmData.reviews,
            booklet,
            link;

        if (this._firmData.external_content) {
            this._firmData.external_content.forEach(function (el) {
                if (el && el.type == 'booklet') {
                    booklet = el;
                }
            });
        }

        if (reviewData && reviewData.is_reviewable) {
            links.push({
                name: 'flamp_stars',
                width: reviewData.rating * 20
            });
            links.push({
                name: 'flamp_reviews',
                label: this.dict.t(this.options.lang, 'linkReviews', reviewData.review_count ? reviewData.review_count : 0),
                href: FirmCard.DataHelper.getFlampUrl(this._firmId)
            });
        }

        // Retrieve photo data from external content block
        var photos;
        var externalContent = this._firmData.external_content;

        for (var i = 0; i < externalContent.length; i++) {
            if (
                externalContent[i].type == 'photo_album' &&
                externalContent[i].subtype == 'common'
            ) {
                photos = externalContent[i];
                break;
            }
        }

        if (!this.options.isMobile && photos && photos.count && this.options.showPhotos) {
            link = L.Util.template('http://2gis.{domain}/photos/{id}', {
                'id': this._firmId,
                'domain': this.options.domain
            });

            links.push({name: 'photos',
                href: link,
                label: this.dict.t(this.options.lang, 'linkPhoto', photos.count)
            });
        }

        if (!this.options.isMobile && booklet && booklet.url && this.options.showBooklet) {
            links.push({
                name: 'booklet',
                href:  booklet.url,
                label: this.dict.t(this.options.lang, 'linkBooklet')
            });
        }


        return links;
    },

    _events: {
        'dg-popup__button_name_firm-card-back': function() {
            this.options.backBtn();
            this._toggleEventHandlers(true);
        },
        'dg-popup__button_name_show-entrance': function() {
            var ent = new this.options.showEntrance({'vectors': this._firmData.links.entrances[0].geometry.vectors});
            ent.addTo(this.options.map).show();
            this._toggleEventHandlers(true);
        },
        'dg-schedule__today': function(target) {
            this._onToggleSchedule(target);
        }
    },

    _toggleEventHandlers: function (flag) {
        this.options.popup[flag ? 'off' : 'on']('click', this._onClick, this);
        this.options.map[flag ? 'off' : 'on']('popupclose', this._onClose, this);
    },

    _onClick: function (e) {
        var target = e.originalEvent.target;

        for (var eventClass in this._events) {
            if (this._events.hasOwnProperty(eventClass) && target.className.indexOf(eventClass) > -1) {
                DG.DomEvent.preventDefault(e.originalEvent);
                this._events[eventClass].call(this, target);
                return;
            }
        }
    },

    _onClose: function (e) {
        this._toggleEventHandlers(true);
    },

    _onToggleSchedule: function (target) {
        var schedule = this._container.querySelector('.dg-schedule__table'),
            forecast = this._container.querySelector('.dg-schedule__now'),
            showClass = ' dg-schedule__today_shown_true';

        if (!schedule) { return; }

        if (schedule.style.display === 'block') {
            schedule.style.display = 'none';
            forecast.style.display = 'block';
            target.className = target.className.replace(showClass, '');
        } else {
            forecast.style.display = 'none';
            schedule.style.display = 'block';
            target.className += showClass;
        }

        if (this.options.onToggle) {
            this.options.onToggle();
        }
    },

    _setOptions: function (options) {
        var option,
            options = options || {};

        this.options = options;
        options.lang = options.lang || 'ru';

        for (option in options) {
            if (options.hasOwnProperty(option)) {
                this.options[option] = options[option];
            }
        }
    },

    _hasTouch: function () {
        return (('ontouchstart' in window) ||
                (navigator.maxTouchPoints > 0) ||
                (navigator.msMaxTouchPoints > 0));
    }
};

FirmCard.DataHelper = {

	FLAMP_URL : 'http://flamp.ru/r/',
	FLAMP_GOOGLE_ANALYTICS : 'utm_source=api2gis&utm_medium=api&utm_campaign=geoclicker',

	payMethods : [
		'americanexpress',
		'cash',
		'dinersclub',
		'goldcrown',
		'internet',
		'mastercard',
		'noncash',
		'visa'
	],

	_msgs : {},

	getFlampUrl : function (id) {
	    return this.FLAMP_URL.concat(id, '?', this.FLAMP_GOOGLE_ANALYTICS);
	},

	msg : function (msg) {
		if (this._msgs.hasOwnProperty(msg)) {
			return this._msgs[msg];
		}
		console && console.log("Cant't find translation for '" + msg + "'.");
		return msg.toString().replace('_', ' ');
	},

	getProjectTime: function (timezoneOffset, time) {
        var now, utc;

        if (time) {
            now = new Date(time);
        } else {
            now = new Date();
        }

        if (timezoneOffset) {
            utc = now.getTime() + (now.getTimezoneOffset() * 60000);
            return new Date(utc + (60000 * timezoneOffset));
        } else {
            return now;
        }
    }
};

/* global
    FirmCard: false
*/
(function () {
    FirmCard.List = function (firms, options) {
        this._firms = {}; // {'firmID': firmDomObj}
        this._setOptions(options);

        this._container = options && options.container || document.createElement('ul');
        this._container.setAttribute('class', 'dg-building-callout__list');

        this._eventHandlersInited = false;
        this._firmCard = this._createFirm();
        this.renderList(firms);
    };

    FirmCard.List.prototype = {

        renderList: function (firms) {
            if (firms) {
                this._toggleEventHandlers();
                this.addFirms(firms);
            }
            if (this.options.onListReady) {
                this.options.onListReady(this._container);
            }

            return this._container;
        },

        _processFirms: function (firms, action) {
            if (!firms) { return; }
            var method = '_' + action + 'Firm';
            if (this._isArray(firms)) {
                for (var i = 0, l = firms.length; i < l; i++) {
                    this[method](firms[i]);
                }
            } else {
                this[method](firms);
            }

        },

        addFirms: function(firms) {
            this._processFirms(firms, 'add');
        },

        removeFirms: function(firms) {
            this._processFirms(firms, 'remove');
        },

        setLang: function (newLang) {
            this.options.firmCard.lang = newLang;
        },

        getLang: function () {
            return this.options.firmCard.lang;
        },

        getContainer: function () {
            return this._container;
        },

        clearList : function () {
            this._firms = {};
            this._toggleEventHandlers(true);
            this._clearContainer();
        },

        _removeFirm: function (id) {
            if (!this._firms[id]) { return false; }
            this._container.removeChild(this._firms[id]);
            delete this._firms[id];
        },

        _addFirm: function (firmData) {
            var tmpl = this.options.firmlistItemTmpl,
                domFirm, firm, content;

            firm = {
                name: firmData.name,
                id: firmData.id.split('_').slice(0, 1)
            };

            if (!(firm.id in this._firms)) {

                domFirm = this._createListItem();

                content = tmpl ? this.options.firmCard.render(tmpl, {'firm': firm}) : firm.name;

                domFirm.insertAdjacentHTML('beforeend', content);

                this._firms[firm.id] = domFirm;
                this._container.appendChild(domFirm);
            }
        },

        _createListItem: function () {
            var item = document.createElement('li');
            item.setAttribute('class', 'dg-building-callout__list-item');

            return item;
        },

        _isArray: function (obj) {
            return {}.toString.call(obj) === '[object Array]';
        },

        _createFirm: function (firmData) {
            return new FirmCard(firmData, this.options.firmCard);
        },

        _isEmptyObj: function (obj) {
            for (var prop in obj) {
                if (obj.hasOwnProperty(prop)) {
                    return false;
                }
            }

            return true;
        },

        _events: {
            'dg-popup__link': function(target) {
                var s = this._firmCard.render(target.id);

                this.options.firmCard[this._isEmptyObj(s) ? 'pasteLoader' : 'onFirmReady'](s);

                this.options.firmCard.onFirmClick && this.options.firmCard.onFirmClick();

                this._toggleEventHandlers(true);
            },
            'dg-building-callout__list-item': function(target) {
                target = target.children[0];

                this._events['dg-popup__link'].call(this, target);
            },
            'dg-popup__button_name_back': function() {
                this.options.firmCard.onShowLess();

                this._toggleEventHandlers(true);
            }
        },

        _toggleEventHandlers : function (flag) {
            this.options.firmCard.popup[flag ? 'off' : 'on']('click', this._onClick, this);
        },

        _onClick: function (e) {
            var target = e.originalEvent.target;

            for (var eventClass in this._events) {
                if (this._events.hasOwnProperty(eventClass) && target.className.indexOf(eventClass) > -1) {
                    DG.DomEvent.preventDefault(e.originalEvent);
                    this._events[eventClass].call(this, target);
                    return;
                }
            }
        },

        _clearContainer: function () {
            var container = this._container;

            while (container.hasChildNodes()) {
                container.removeChild(container.firstChild);
            }
        },

        _setOptions: function (options) {
            options || (options = {});
            this.options = options;
            this.options.firmCard || (this.options.firmCard = {});

            if (!options.firmCard.lang) {
                this.options.firmCard.lang = 'ru';
            }

            for (var option in options) {
                if (options.hasOwnProperty(option)) {
                    this.options[option] = options[option];
                }
            }
        }
    };
})();

/*global
    FirmCard:false
*/
FirmCard.Schedule = function (options) {
    options = options || {};

    this.localLang = options.localLang || 'ru';
    this.dict = options.dict;
    return this;
};

FirmCard.Schedule.prototype = {

    setLang: function (lang) {
        this.localLang = lang || 'ru';
        return this;
    },

    transform: function (model, params) {
        if (!model) {
            return;
        }
        params = params || {};

        function bind(fn, obj) { // (Function, Object) -> Function
            var args = arguments.length > 2 ? Array.prototype.slice.call(arguments, 2) : null;
            return function () {
                return fn.apply(obj, args || arguments);
            };
        }

        var todayKey, // Mon, Tue ...
            today, //   -   
            from, //      
            to, //      
            zoneOffset = params.zoneOffset || 0,
            schedule = {}, // -,   
            now = params.now || FirmCard.DataHelper.getProjectTime(zoneOffset).getTime(), // Current timestamp in milliseconds
            weekKeys = [], //   ,       . 0 -      (  Mon)
            weekKeysLocal = [],
            weekFullKeysLocal = [],
            weekKeysShort =  [ 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun' ],
            weekKeysFull = ['monday','tuesday','wednesday','thursday','friday','saturday','sunday'],
            localLang = params.localLang || this.localLang,
            localWorkingDays = params.localWorkingDays || [0, 1, 1, 1, 1, 1, 0],
            firstdayOffset = params.firstdayOffset || 1,
            minHoursToDisplayClosure = params.minHoursToDisplayClosure || 4,
            t = bind(this.dict.t, this.dict);


        function capitaliseFirstLetter(string) {
            return string.charAt(0).toUpperCase() + string.slice(1);
        }

        function getHours(str) {
            return str.substr(0, 2);
        }

        function getMinutes(str) {
            return str.substr(3, 2);
        }

        //         (25:00 -> 01:00)
        function formatTime(str) {
            var hours = +getHours(str) % 24 + '';

            if (hours.length === 1) {
                hours = '0' + hours;
            }

            return hours + ':' + getMinutes(str);
        }

        //  int      ( 0-6)
        function dayNum(n) {
            return n % 7;
        }


        /* jshint ignore:start */
        //    
        //   Underscore.js http://underscorejs.org/#last
        function getArrayLast(arr, n) {
            if ( arr == null ) return void 0;
            if (   n == null ) return arr[ arr.length - 1 ];
            return slice.call( arr, Math.max(arr.length - n , 0) );
        }


        //    
        //   Underscore.js http://underscorejs.org/#isEqual
        //     ,    Shedule.js
        function isEqual(obj1, obj2) {
            if ( obj1 === obj2 ) return true;
            if ( ! ( obj1 instanceof Object ) || ! ( obj2 instanceof Object ) ) return false;
            if ( obj1.constructor !== obj2.constructor ) return false;
            for ( var prop in obj1 ) {
                if ( ! obj1.hasOwnProperty( prop ) ) continue;
                if ( ! obj2.hasOwnProperty( prop ) ) return false;
                if ( obj1[ prop ] === obj2[ prop ] ) continue;
                if ( typeof( obj1[ prop ] ) !== "object" ) return false;
                if ( ! isEqual( obj1[ prop ],  obj2[ prop ] ) ) return false;
            }
            for ( prop in obj2 ) {
            if ( obj2.hasOwnProperty( prop ) && ! obj1.hasOwnProperty( prop ) ) return false;
            }

            return true;
        }

        // Generate an integer Array containing an arithmetic progression. A port of
        // the native Python `range()` function. See
        // [the Python documentation](http://docs.python.org/library/functions.html#range).
        function range(start, stop, step) {
        if (arguments.length <= 1) {
            stop = start || 0;
            start = 0;
        }
        step = arguments[2] || 1;

        var length = Math.max(Math.ceil((stop - start) / step), 0);
        var idx = 0;
        var range = new Array(length);
        while(idx < length) {
            range[idx++] = start;
            start += step;
        }

        return range;
        }


        //     
        //  Underscore.js http://underscorejs.org/#defaults
        function fillDefaults(obj) {
         var args = Array.prototype.slice.call(arguments, 1);
         args.forEach(function(source) {
            if (source) {
                for (var prop in source) {
                    if (obj[prop] === void 0) obj[prop] = source[prop];
                }
            }
        });
        return obj;
        }

        //    
        //  Underscore.js http://underscorejs.org/#sortBy
        function sortBy(obj, iterator){
            return pluck(obj.map( function(value, index, list) {
                return {
                        value: value,
                        index: index,
                        criteria: iterator.call(this, value, index, list)
                        };
                }).sort(function(left, right) {
                        var a = left.criteria;
                        var b = right.criteria;
                        if (a !== b) {
                        if (a > b || a === void 0) return 1;
                        if (a < b || b === void 0) return -1;
                        }
                return left.index - right.index;
                }), 'value');
        }

        /* jshint ignore:end */

        function pluck(arr, key){
            var i, rv = [];
            for (i = 0; i < arr.length; ++i) {
            rv[i] = arr[i][key];
            }
            return rv;
        }


        //          (string)
        //  ,  API    
        function getSortedTimePoints(day) {
            var points = [],
                from, to,
                deltaHours, deltaMinutes;

            if (!day || !day.working_hours) {
                return [];
            }

            for (var i = 0 ; i < day.working_hours.length ; i++) {
                from = day.working_hours[i].from;
                to = day.working_hours[i].to;

                deltaHours = getHours(to) - getHours(from);
                deltaMinutes = getMinutes(to) - getMinutes(from);
                if (deltaHours < 0 || (deltaHours === 0 && deltaMinutes <= 0)) { //  ""    "" -    
                    to = (+getHours(to) + 24) + ':' + getMinutes(to); // (01:00 -> 25:00)
                }

                points[i * 2] = {
                    time: from,
                    type: 'open'
                };
                points[i * 2 + 1] = {
                    time: to,
                    type: day.working_hours.length - 1 === i ? 'close' : 'lunch'
                };
            }

            return points;
        }

        //   timestamp  ,   ,     
        // ,  ,        ()    
        function getTimeStamps(model) {
            var timestamps = [],
                out = [],
                timePoints,
                num = weekKeys.indexOf(todayKey); //     (  )


            //       
            var j; //      weekKeys
            for (var i = 0 ; i < 7 ; i++) {
                j = dayNum(num + i);
                timePoints = getSortedTimePoints(model[weekKeys[j]]);
                //        timestamp
                timePoints.forEach(
                    /* jshint -W083 */
                    function (point) {
                    // now - !     timestamp      
                    //      ,   ,  ,    now
                    var tsp = new Date(now);
                    tsp.setDate(tsp.getDate()+i);
                    tsp.setHours(getHours(point.time));
                    tsp.setMinutes(getMinutes(point.time));
                    var ts = tsp.getTime();



                    timestamps.push({
                        ts: ts,
                        type: point.type
                    });

                    if (timestamps[timestamps.length - 1] && timestamps[timestamps.length - 2]) {
                        //     (    -   24:00   00:00)
                        if (timestamps[timestamps.length - 1].ts === timestamps[timestamps.length - 2].ts) {
                            timestamps.pop();
                            timestamps.pop();
                        }
                    }

                    if (timestamps[timestamps.length - 1] && timestamps[timestamps.length - 2]) {
                        //     ,      (  ([0])    !)
                        if (timestamps[timestamps.length - 1].ts <= now && timestamps[timestamps.length - 2].ts <= now) {
                            timestamps[timestamps.length - 1].ts += (7 * 24 * 60 * 60 * 1000);
                            timestamps[timestamps.length - 2].ts += (7 * 24 * 60 * 60 * 1000);
                        }
                    }
                }
                /* jshint +W083 */
                );
            }

            //   ,      
            timestamps = sortBy(timestamps, function (timestamp) { return timestamp.ts; });

            //     
            i = 0;
            while (i < timestamps.length) {
                if (timestamps[i + 1] && timestamps[i].ts === timestamps[i + 1].ts) {
                    i++;
                } else {
                    out.push(timestamps[i].ts);
                }
                i++;
            }

            //   -
            if (out.length === 2 && (out[1] - out[0]) === (7 * 24 * 60 * 60 * 1000)) {
                return [];
            }

            return timestamps;
        }

        function whenOpenInverse(h, d, num) {
            if (d === 1 && h > minHoursToDisplayClosure ) {
                return t(localLang, 'tommorow');
            } else if (d > 1) {
                /* jshint -W015 */
                switch (num) {
                    case 0: return t(localLang, 'nextSun');
                    case 1: return t(localLang, 'nextMon');
                    case 2: return t(localLang, 'nextTue');
                    case 3: return t(localLang, 'nextWed');
                    case 4: return t(localLang, 'nextThu');
                    case 5: return t(localLang, 'nextFri');
                    case 6: return t(localLang, 'nextSat');
                }
                /* jshint +W015 */
            }

            return;
        }


        //    ,       , 
        //@param timestampEnd  @param dateStart
        function dayInterval(timestampEnd, dateStart) {

            var oneDay = 1000 * 60 * 60 * 24,
                dateEnd = new Date(timestampEnd.ts);

            var diff;

            diff = Math.round((dateEnd - dateStart) / oneDay);

            if( timestampEnd.type==='open' && dateEnd.getHours() < 1 )
                { diff ++; }

            return diff;
        }


        //         
        function setTodayString(today) {

            var timePoints,
                periods = [],
                timestamps;

            schedule.now = {};

            // Timestamps  
            timestamps = getTimeStamps(model);

            if (!timestamps.length) {
                schedule.always = true; //   
                schedule.now.open = true;
            }


            for (var i = 0 ; i < timestamps.length ; i++) {
                //    i-1  i //       1
                if (now >= (timestamps[i - 1] && timestamps[i - 1].ts || 0) && now < timestamps[i].ts) {
                    var h = Math.floor((timestamps[i].ts - now) / (1000 * 60 * 60)), //     timestamp
                        m = Math.floor((timestamps[i].ts - now) / (1000 * 60) - h * 60), //   ( )   timestamp
                        dayNow = new Date(now),

                        //      
                        nowIsOpen = timestamps[i].type !== 'open';

                        //var d = dayOfYear(dayTs) - dayOfYear(dayNow);
                        //var d = dayInterval(dayTs, dayNow, nowIsOpen);
                        var d = dayInterval(timestamps[i], dayNow);



                    //     5
                    m = Math.floor(m / 10) * 10 ? Math.floor(m / 10) * 10 : 5;

                    schedule.now.open = nowIsOpen;
                    schedule.now.lunch = !!(timestamps[i - 1] && timestamps[i - 1].type === 'lunch' || getArrayLast(timestamps).type === 'lunch');

                    schedule.will = {
                        willType: timestamps[i].type,
                        d: d,
                        h: h,
                        m: m
                    };

                    //    
                    var willWhen = new Date(timestamps[i].ts);
                    schedule.will.when = whenOpenInverse(h, d, willWhen.getDay());


                    var willTill = new Date(timestamps[i].ts),
                        strHours = willTill.getHours(),
                        strMinutes = willTill.getMinutes();

                    if (strHours < 10) { strHours = '0' + strHours; }
                    if (strMinutes < 10) { strMinutes = '0' + strMinutes; }

                    schedule.will.till = strHours+':'+strMinutes;
                }
            }

            if (!today) {
                return; //     -  
            }

            timePoints = pluck(getSortedTimePoints(today), 'time');

            //      
            for (i = 2 ; i < timePoints.length ; i = i + 2) {
                periods.push({ from: timePoints[i - 1], to: timePoints[i] });
            }

            from = formatTime(timePoints[0]);
            to = formatTime(timePoints[timePoints.length - 1]);

            if (from === to) { // 
                schedule.today = {
                    alltime: true,
                    alltimeStr: t(localLang, 'worksAroundTheClock'),
                    from: '00:00',
                    to: '24:00'
                };
            } else { //  from  to
                schedule.today = {
                    from: from,
                    to: to
                };
            }

            if (periods.length > 0) { //   
                schedule.lunch = periods;
                schedule.lunchStr = t(localLang, 'lunch');
            }
        }

        //  --  
        function makeTable() {
            var column = [],
                hasLunch = false;

            for (var j = 0 ; j < 7 ; j++) {
                var dayKey = weekKeys[j],
                    lunchMaxLength = 0;

                column[j] = {};

                if (model[dayKey]) {
                    var day = model[dayKey],
                        timePoints = pluck(getSortedTimePoints(day), 'time'),
                        lunch = []; //   ( )  

                    //      
                    for (var i = 2 ; i < timePoints.length ; i = i + 2) {
                        hasLunch = true;
                        lunch.push({ from: timePoints[i - 1], to: timePoints[i] });
                    }
                    lunchMaxLength = Math.max(timePoints.length / 2, lunchMaxLength);

                    column[j] = {
                        from: formatTime(timePoints[0]),
                        to: formatTime(timePoints[timePoints.length - 1]),
                        lunch: lunch
                    };
                }

                if (dayKey === todayKey) { //    
                    column[j].active = true;
                }

                column[j].key = weekKeysLocal[j];
            }

            //     lunch
            column.forEach( function (col) {
                if (col.lunch) {
                    fillDefaults(col.lunch, range(1, lunchMaxLength));
                }
            });

            return {
                table: column,
                hasLunch: hasLunch
            };
        }

        //      model,   day
        function makeSimpleString(day, model) {
            var points,
                out = {
                    dayList: [],
                    lunch: []
                },
                lunchesTime = [];

            if (day && day.working_hours && day.working_hours.length) {
                points = pluck(getSortedTimePoints(day), 'time');
                points.forEach( function (point, key) {
                    if (key === 0) {
                        out.from = formatTime(point);
                    } else if (key === points.length - 1) {
                        out.to = formatTime(point);
                    } else {
                        lunchesTime.push(formatTime(point));
                    }
                });
                for (var i = 0; i < lunchesTime.length; i += 2) {
                    out.lunch.push({
                        from: lunchesTime[i],
                        to: lunchesTime[i + 1],
                        lunchStr: capitaliseFirstLetter(t(localLang, 'lunch'))
                    });
                }

                if (out.from == '00:00' && out.to == '00:00') {
                    out.to = '24:00';
                }

                if (day.round_the_clock) {
                    out.alltime = true;
                    out.alltimeStr = t(localLang, 'worksAroundTheClock');
                }
            } else { // 
                out.holiday = true;
            }

            //      
            var groupWorkingDays = [0, 0, 0, 0, 0, 0, 0]; //       
            var flow = 0;

            weekKeys.forEach( function (dayKey, numKey) { // 'Mon', 0
                if (isEqual(model[dayKey], day) || (!model[dayKey] && day === null)) {
                    out.dayList.push(weekFullKeysLocal[numKey]);
                    groupWorkingDays[dayNum(numKey + firstdayOffset)] = 1;
                    flow++;
                } else {
                    if (flow > 2) { //  2  
                        var lastDay = out.dayList.pop();

                        for (var i = 1 ; i < flow - 1 ; i++) {
                            out.dayList.pop();
                        }

                        out.dayList[out.dayList.length - 1] += '  ' + lastDay;
                    }

                    flow = 0;
                }
            });

            //         ,     ""
            out.budni = isEqual(localWorkingDays, groupWorkingDays);
            //    -   ,     ""
            out.everyday = ( Math.min.apply(Math, groupWorkingDays) === 1 );

            if ( out.holiday ) { out.holidayStr = t(localLang, 'restDay', out.dayList.length).slice(2); }

            //        
            out.dayList = out.dayList.join(', ');
            out.dayList = out.dayList.charAt(0).toUpperCase() + out.dayList.slice(1);


            return out;
        }

        //   simple      days
        function makeAdvancedString(days, model) {
            var out = [];

            for (var i = days.length - 1 ; i >= 0 ; i--) {
                out.push(makeSimpleString(days[i], model));
            }

            return out;
        }

        //    , 1 - .      0

        for (var i = 0 ; i < 7 ; i++) {
            weekKeys[i] = weekKeysShort[i];
            weekKeysLocal[i] = this.dict.t(localLang, weekKeysShort[i].toLowerCase());
            weekFullKeysLocal[i] = this.dict.t(localLang, weekKeysFull[i]);
        }

        //     (     )
        todayKey = weekKeysShort[(new Date(now).getDay()-firstdayOffset) % 7];
        today = model[todayKey]; //   -   
        setTodayString(today); //     - ,     

        //         
        var apiDifferentDays = [], //     
            apiScheduleDaysCount = 0, //      
            apiDifferentDaysCount = 0, //      
            differentWorkingHoursCount = []; //      

        Object.keys(model).forEach( function(day) {
            if (model[day] && model[day].working_hours) { //    ,     - 
                apiScheduleDaysCount++;
                if (!isEqual(model[day], getArrayLast(apiDifferentDays))) {
                    apiDifferentDays.push(model[day]);
                }
            }
        });

        apiDifferentDaysCount = apiDifferentDays.length;
        //       ,       -  (  )
        if (apiScheduleDaysCount < 7) {
            apiDifferentDaysCount++;
        }

        //    2,     -  
        if (apiDifferentDaysCount > 2) {
            schedule.week = makeTable(model);
        } else { // ,     

            // ,   
            if (apiDifferentDaysCount === 1) {
                schedule.week = {
                    evently: [makeSimpleString(model[weekKeys[0]], model)]
                };
            } else { //  ,     
                //           
                for (i = 0 ; i < apiDifferentDaysCount ; i++) {
                    differentWorkingHoursCount[i] = 0;

                    if (apiDifferentDays[i]) {
                        var points = pluck(getSortedTimePoints(apiDifferentDays[i]), 'time');

                        for (var j = 0 ; j < points.length ; j = j + 2) {
                            var hours = (getHours(points[j + 1]) + getMinutes(points[j + 1]) / 60) - (getHours(points[j]) + getMinutes(points[j]) / 60);
                            differentWorkingHoursCount[i] += hours;
                        }
                    } else { // 
                        apiDifferentDays[i] = null;
                    }
                }

                var apiSortedDifferentDays = sortBy(apiDifferentDays, function (day, key) {
                    return differentWorkingHoursCount[key];
                });

                schedule.week = {
                    evently: makeAdvancedString(apiSortedDifferentDays, model)
                };
            }
        }

        schedule.comment = model.comment;
        if (schedule.week && schedule.week.evently && schedule.week.evently.length === 1) {
            schedule.everyday = schedule.week.evently[0].everyday;
        }
        return schedule;
    },

    forecast: function (schedule, params) {
        var interval = '',
        open,
        today = {},
        nowText,
        maxHours = params && params.maxHours || 1;

        if (!schedule) {
            return {};
        }

        if (schedule.always) { //   -     
            return {
                today: {
                    text: this.dict.t(this.localLang, 'aroundTheClock')
                },
                open: true
            };
        }

        //   -      
        if (schedule.will && schedule.will.h < maxHours) {
            if (schedule.will.h) {
                interval += this.dict.t(this.localLang, 'nHours', schedule.will.h) + ' ';
            }

            if (schedule.will.m) {
                interval += this.dict.t(this.localLang, 'nMins', schedule.will.m);
            }
        }

        //   
        if (schedule.today) {
            today.text = this.dict.t(this.localLang, 'today');
            if (schedule.everyday) {
                today.text = this.dict.t(this.localLang, 'everyday');
            }
            today.from = schedule.today.from;
            today.to = schedule.today.to;
            today.lunch = schedule.lunch;
            if (today.lunch) {
                today.lunchStr = this.dict.t(this.localLang, 'lunch');
            }
        } else {
            today.text = this.dict.t(this.localLang, 'todayIsRestDay');
        }

        //    
        if (schedule.always) { //  ,   ""   
            today.text = this.dict.t(this.localLang, 'aroundTheClock');
            open = true;
        } else if (schedule.now) {
            open = schedule.now.open;
            if (open) { // 
                if (schedule.will && schedule.will.willType === 'lunch') {
                    //  -   
                    if (schedule.will && schedule.will.h < maxHours) {
                        //  maxHours     
                        nowText = this.dict.t(this.localLang, '_in') + ' ' + this.dict.t(this.localLang, 'nMins', interval) + this.dict.t(this.localLang, 'isClosingOnDinner');
                    } else {
                        //  maxHours     
                        nowText = this.dict.t(this.localLang, 'isOpen');
                    }

                } else {
                    //   
                    if (schedule.will.h < maxHours) {
                        //  maxHours   
                        nowText = this.dict.t(this.localLang, 'closeIn') + this.dict.t(this.localLang, 'nMins', interval);
                    } else {
                        //  maxHours   
                        nowText = this.dict.t(this.localLang, 'isOpen');
                    }
                }
            } else { // 
                if (schedule.will && schedule.will.when) {
                    //   
                    nowText = this.dict.t(this.localLang, 'open') + schedule.will.when;
                } else {
                    //  
                    if (schedule.now && schedule.now.lunch) {
                        //  
                        if (schedule.will.h < maxHours) {
                            //  maxHours    
                            nowText = this.dict.t(this.localLang, 'Lunch') + this.dict.t(this.localLang, 'openIn') + this.dict.t(this.localLang, 'nMins', interval);
                        } else {
                            //  maxHours    
                            nowText = this.dict.t(this.localLang, 'Lunch') + this.dict.t(this.localLang, 'openAt') + schedule.will.till;
                        }
                    } else {
                        //  
                        if (schedule.will && schedule.will.h < maxHours) {
                            //  maxHours   
                            nowText = this.dict.t(this.localLang, 'openIn') + this.dict.t(this.localLang, 'nMins', interval);
                        } else {
                            //  maxHours   
                            nowText = this.dict.t(this.localLang, 'openAt') + schedule.will.till;
                        }
                    }
                }
            }
        }

        return {
            today: today,
            now: nowText,
            open: open,
            week: schedule.week,
            comment: schedule.comment,
            everyday: schedule.everyday
        };
    }
};

/*global
    FirmCard:false
*/
// FirmCard.dictionary = {};

FirmCard.prototype.dict = {

    t: function (lang, msg, argument) { // (String, Number) -> String
        var result,
            msgIsset = false,
            dictionaryMsg,
            exp;

        if (typeof this[lang] === 'undefined') {
            lang = 'ru';
        }
        dictionaryMsg = this[lang][msg];
        msgIsset = typeof dictionaryMsg !== 'undefined';
        if (!msgIsset) {
            return msg;
        }
        result = msgIsset ? dictionaryMsg : msg;

        if (argument !== undefined) {
            argument = parseInt(argument, 10);
            argument = isNaN(argument) ? 0 : argument;
            exp = this[lang].pluralRules(argument);
            result = argument + ' ' + dictionaryMsg[exp];
        }
        return result ? result : msg;
    },

    ru: {
        pluralRules: function (n) { // (Number)
            if (n % 10 === 1 && n % 100 !== 11) { // 1, 21
                return 0;
            }
            if ((n % 10 >= 2 && n % 10 <= 4 && (n % 10) % 1 === 0) && (n % 100 < 12 || n % 100 > 14)) { // 2, 3
                return 1;
            }

            if ((n % 10 === 0) || (n % 10 >= 5 && n % 10 <= 9 && (n % 10) % 1 === 0) || (n % 100 >= 11 && (n % 100) <= 14 && (n % 100) % 1 === 0)) { // 13, 17
                return 2;
            }
        },

        btnBack: '',
        btnFindWay: ' ',
        btnEntrance: ' ',
        linkReviews: ['', '', ''],
        linkPhoto: ['', '', ''],
        linkBooklet: '',
        tommorow: '',
        afterTommorow: '',
        afterWeek: ' ',
        nextSun: ' ',
        nextMon: ' ',
        nextTue: ' ',
        nextWed: ' ',
        nextThu: ' ',
        nextFri: ' ',
        nextSat: ' ',
        willOpen: '',
        willClose: '',
        isOpen: '',
        openTill: '  ',
        closeIn: '  ',
        openAt: '  ',
        openIn: '  ',
        open: ' ',
        nHours: ['', '', ''],
        nMins: ['', '', ''],
        lunch: '',
        Lunch: '. ',
        workingDays: ' ',
        weekdays: ' ',
        restDay: ['', '',''],
        reviewsOnFlamp: '  ',
        writeReviewOnFlamp: '   ',
        payment: '',
        everyday: ' c',
        worksAroundTheClock: ' ',
        aroundTheClock: '',
        knowMore: ' ',
        toClose: ' ',
        monday: '',
        tuesday: '',
        wednesday: '',
        thursday: '',
        friday: '',
        saturday: '',
        sunday: '',
        mon: '',
        tue: '',
        wed: '',
        thu: '',
        fri: '',
        sat: '',
        sun: '',
        toLunch: ' ',
        today: '',
        lessThenHour: ' ',
        youCouldLate: '   ',
        workingTime: ' ',
        showAllOrgInRubric: '   ',
        todayIsRestDay: ' ',
        internet: '  ',
        noncash: ' ',
        goldcrown: ' ',
        dinersclub: 'Diners Club',
        mastercard: 'Mastercard',
        maestrocard: 'MaestroCard',
        visa: 'Visa',
        cash: ' ',
        americanexpress: 'American Express',
        hour : '',
        less: '',
        _in : '',
        isClosingOnDinner : '   '
    },

    it: {
        pluralRules: function (n) { // (Number)
            if (n === 1) { // 1
                return 0;
            } else {
                return 1; //0, 2, 3, 4 ..
            }
        },

        btnBack: 'Indietro',
        btnFindWay: 'Come arrivare ',
        btnEntrance: 'Trova l\'ingresso',
        linkReviews: ['recensione', 'recensioni'],
        linkPhoto: ['fotografia', 'fotografie'],
        linkBooklet: 'Sull\'azienda',
        tommorow: 'domani',
        afterTommorow: 'dopodomani',
        afterWeek: 'tra una settimana',
        nextSun: 'la domenica',
        nextMon: 'il lunedi',
        nextTue: 'il marted',
        nextWed: 'il mercoled',
        nextThu: 'il giovedi',
        nextFri: 'il venerd',
        nextSat: 'il sabato',
        willOpen: 'apre',
        willClose: 'ciuso',
        isOpen: 'Aperto',
        openTill: 'Aperto fino alle ',
        closeIn: 'Chiude tra ',
        openAt: 'Apre alle ',
        openIn: 'Apre tra ',
        open: 'Apre ',
        nHours: ['ora', 'ore'],
        nMins: ['minuto', 'minuti'],
        lunch: 'pausa pranzo',
        Lunch: 'Pausa pranzo. ',
        workingDays: 'Giorni feriali',
        weekdays: 'Giorni feriali',
        restDay: ['chiusura','chiusura'],
        reviewsOnFlamp: 'Recensioni su Flamp',
        writeReviewOnFlamp: 'Scrivi una recensione su Flamp',
        payment: 'pagamento',
        everyday: 'Ogni giorno dalole',
        worksAroundTheClock: 'Operativo 24 ore su 24',
        aroundTheClock: '24 ore su 24',
        knowMore: 'ulteriori informazioni',
        toClose: 'fino alla chiusura',
        monday: 'lunedi',
        tuesday: 'marted',
        wednesday: 'mercoled',
        thursday: 'giovedi',
        friday: 'venerd',
        saturday: 'sabato',
        sunday: 'domenica',
        mon: 'lun',
        tue: 'mar',
        wed: 'mer',
        thu: 'gio',
        fri: 'ven',
        sat: 'sab',
        sun: 'dom',
        toLunch: 'fino alla pausa pranzo',
        today: 'Oggi',
        lessThenHour: 'meno di un\'ora',
        youCouldLate: 'affrettarsi, chiusura imminente',
        workingTime: 'orario di lavoro',
        showAllOrgInRubric: 'Visualizza tutte le aziende della categoria',
        todayIsRestDay: 'oggi chiuso',
        internet: 'Pagamento on-line',
        noncash: 'Pagamento non in contanti',
        goldcrown: 'Zolotaja Korona',
        dinersclub: 'Diners Club',
        mastercard: 'MasterCard',
        maestrocard: 'MaestroCard',
        visa: 'Visa',
        cash: 'Pagamento in contanti',
        americanexpress: 'American Express',
        hour : 'un\'ora',
        less: 'meno di',
        _in : 'Tra',
        isClosingOnDinner : 'chiude per pausa pranzo'
    },

    en: {
        pluralRules: function (n) { // (Number)
            if (n === 1) { // 1
                return 0;
            } else {
                return 1; //0, 2, 3, 4 ..
            }
        },

        btnBack: 'Back',
        btnFindWay: 'Get here',
        btnEntrance: 'Find entrance',
        linkReviews: ['review', 'reviews'],
        linkPhoto: ['photo', 'photos'],
        linkBooklet: 'About company',
        tommorow: 'tomorrow',
        afterTommorow: 'the day after tomorrow',
        afterWeek: 'in a week',
        nextSun: 'on Sunday',
        nextMon: 'on Monday',
        nextTue: 'on Tuesday',
        nextWed: 'on Wednesday',
        nextThu: 'on Thursday',
        nextFri: 'on Friday',
        nextSat: 'on Saturday',
        willOpen: 'opens ',
        willClose: 'closes',
        isOpen: 'Open',
        openTill: 'Open till ',
        closeIn: 'Closes in ',
        openAt: 'Opens at ',
        openIn: 'Opens in ',
        open: 'Opens ',
        nHours: ['hour', 'hours'],
        nMins: ['minute', 'minutes'],
        lunch: 'lunch break',
        Lunch: 'Lunch break. ',
        workingDays: 'Working days',
        weekdays: 'Weekdays',
        restDay: ['day off','days off'],
        reviewsOnFlamp: 'Reviews on Flamp',
        writeReviewOnFlamp: 'Write a review on Flamp',
        payment: 'payment',
        everyday: 'Daily from',
        worksAroundTheClock: 'Open 24 hours',
        aroundTheClock: '24h',
        knowMore: 'see also',
        toClose: 'until closing',
        monday: 'Monday',
        tuesday: 'Tuesday',
        wednesday: 'Wednesday',
        thursday: 'Thursday',
        friday: 'Friday',
        saturday: 'Saturday',
        sunday: 'Sunday',
        mon: 'Mon',
        tue: 'Tue',
        wed: 'Wed',
        thu: 'Thu',
        fri: 'Fri',
        sat: 'Sat',
        sun: 'Sun',
        toLunch: 'until lunch',
        today: 'Today',
        lessThenHour: 'less then one hour',
        youCouldLate: 'you might be late',
        workingTime: 'working hours',
        showAllOrgInRubric: 'Show all organizations in the category',
        todayIsRestDay: 'closed today',
        internet: 'Online',
        noncash: ' No-cash',
        goldcrown: 'Golden Crown',
        dinersclub: 'Diners Club',
        mastercard: 'Mastercard',
        maestrocard: 'MaestroCard',
        visa: 'Visa',
        cash: 'Cash',
        americanexpress: 'American Express',
        hour : 'hour',
        less: 'less',
        _in : 'In',
        isClosingOnDinner : 'will be closing for lunch'
    },

    cs: {
        pluralRules: function (n) { // (Number)
            return (n === 1) ? 0 : (n >= 2 && n <= 4) ? 1 : 2;
        },

        btnBack: 'Zpt',
        btnFindWay: 'Jet sem',
        btnEntrance: 'Hledat vstup',
        linkReviews: ['recenze', 'recenze', 'recenz'],
        linkPhoto: ['fotografie', 'fotografie', 'fotografi'],
        linkBooklet: 'Letk',
        tommorow: 'ztra',
        afterTommorow: 'pozt',
        afterWeek: 'za tden',
        nextSun: 'v nedli',
        nextMon: 'v pondl',
        nextTue: 'v ter',
        nextWed: 've stedu',
        nextThu: 've tvrtek',
        nextFri: 'v ptek',
        nextSat: 'v sobotu',
        willOpen: 'oteve se',
        willClose: 'zave se',
        isOpen: 'Oteveno',
        openTill: 'Oteveno do ',
        closeIn: 'Zave se za ',
        openAt: 'Oteve se v ',
        openIn: 'Oteve se za ',
        open: 'Oteve se ',
        nHours: [ 'hodinu' , 'hodiny' , 'hodin' ],
        nMins: [ 'minutu' , 'minuty' , 'minut' ],
        lunch: 'poledn pestvka',
        Lunch: 'Poledn pestvka. ',
        workingDays: 'Vedn dny',
        weekdays: 'Vedn dny',
        restDay: ['zaveno', 'zaveno'],
        reviewsOnFlamp: 'Recenze na Flampu',
        writeReviewOnFlamp: 'Napsat recenzi na Flampu',
        payment: 'platba',
        everyday: 'Denn od ',
        worksAroundTheClock: 'Pracuje nonstop',
        aroundTheClock: 'Nonstop',
        knowMore: 'dozvdt se vce',
        toClose: 'do uzaven',
        monday: 'pondl',
        tuesday: 'ter',
        wednesday: 'steda',
        thursday: 'tvrtek',
        friday: 'ptek',
        saturday: 'sobota',
        sunday: 'nedle',
        mon: 'po',
        tue: 't',
        wed: 'st',
        thu: 't',
        fri: 'p',
        sat: 'so',
        sun: 'ne',
        toLunch: 'do poledn pestvky',
        today: 'Dnes',
        lessThenHour: 'mn ne hodinu',
        youCouldLate: 'nemuste to stihnout',
        workingTime: 'pracovn doba',
        showAllOrgInRubric: 'Zobrazit vechny organizace v rubrice',
        todayIsRestDay: 'Dnes je zaveno',
        internet: 'Platba prostednictvm Internetu',
        noncash: 'Bezhotovostn platba',
        goldcrown: 'Zolotaja Korona',
        dinersclub: 'Diners Club',
        mastercard: 'Mastercard',
        maestrocard: 'MaestroCard',
        visa: 'Visa',
        cash: 'Platba hotov',
        americanexpress: 'American Express',
        hour : 'hodinu',
        less: 'mn',
        _in : 'Za',
        isClosingOnDinner : 'zan poledn pestvka'
    },

    es: {
        pluralRules: function (n) { // (Number)
          return (n === 1) ? 0 : (n >= 2 && n <= 4) ? 1 : 2;
        },

        btnBack: 'Atrs',
        btnFindWay: 'Ir para all',
        btnEntrance: 'Buscar acceso',
        linkReviews: ['comentario', 'comentarios', 'comentarios'],
        linkPhoto: ['foto', 'fotos', 'fotos'],
        linkBooklet: 'Folleto',
        tommorow: 'maana',
        afterTommorow: 'pasado maana',
        afterWeek: 'en una semana ms',
        nextSun: 'el domingo',
        nextMon: 'el lunes',
        nextTue: 'el martes',
        nextWed: 'el mircoles',
        nextThu: 'el jueves',
        nextFri: 'el viernes',
        nextSat: 'el sbado',
        willOpen: 'se abrir',
        willClose: 'se cerrar',
        isOpen: 'Abierto',
        openTill: 'Abierto hasta ',
        closeIn: 'Se cerrar dentro de ',
        openAt: 'Se abrir el ',
        openIn: 'Se abrir dentro de ',
        open: 'Se abrir ',
        nHours: ['hora', 'horas', 'horas'],
        nMins: ['minuto', 'minutos', 'minutos'],
        lunch: 'hora de colacin',
        Lunch: 'Hora de colacin. ',
        workingDays: 'Das laborables',
        weekdays: 'Das laborables',
        restDay: ['cerrado','cerrado'],
        reviewsOnFlamp: 'Comentarios en Flamp',
        writeReviewOnFlamp: 'Escribir un comentario en Flamp',
        payment: 'pago',
        everyday: 'Cada da desde',
        worksAroundTheClock: 'Abierto las 24 horas',
        aroundTheClock: '24 horas',
        knowMore: 'para saber ms',
        toClose: 'hasta el cierre',
        monday: 'lunes',
        tuesday: 'martes',
        wednesday: 'mircoles',
        thursday: 'jueves',
        friday: 'viernes',
        saturday: 'sbado',
        sunday: 'domingo',
        mon: 'lun',
        tue: 'mar',
        wed: 'mi',
        thu: 'jue',
        fri: 'vie',
        sat: 'sb',
        sun: 'dom',
        toLunch: 'antes de la hora de colacin',
        today: 'Hoy',
        lessThenHour: 'menos de una hora',
        youCouldLate: 'puede ser que no alcanzas a llegar',
        workingTime: 'horario de trabajo',
        showAllOrgInRubric: 'Mostrar todas las empresas de la categora',
        todayIsRestDay: 'Hoy cerrado',
        internet: 'Pago por Internet',
        noncash: 'Pago sin efectivo',
        goldcrown: 'Zolotaya Korona',
        dinersclub: 'Diners Club',
        mastercard: 'Mastercard',
        maestrocard: 'MaestroCard',
        visa: 'Visa',
        cash: 'Pago en efectivo',
        americanexpress: 'American Express',
        hour : 'hora',
        less: 'menos de',
        _in : 'Dentro de',
        isClosingOnDinner : 'se cierra por hora de colacin'
    }
};

/* global 300000, 10,true */

DG.Traffic = DG.TileLayer.extend({

    options: {
        period: 0,
        disableLabel: false
    },

    statics: {
        Dictionary: {},
        tileUrl: 'http://traffic{s}.maps.2gis.com/{projectCode}/traffic/{z}/{x}/{y}/speed/{period}/{timestampString}',
        metaUrl: 'http://meta{s}.maps.2gis.com/{projectCode}/meta/{z}/{x}/{y}/graph_speed/{period}/{timestampString}',
        timeUrl: 'http://traffic{s}.maps.2gis.com/{projectCode}/meta/speed/time/',
        updateInterval: 300000,
        layersOptions: {
            errorTileUrl: 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7',
            subdomains: '012345679',
            maxNativeZoom: 18,
            detectRetina: true,
            minZoom: 10
        }
    },

    initialize: function (options) {
        options = DG.setOptions(this, DG.extend(options || {}, DG.Traffic.layersOptions));
        options.timestampString = options.period ? '' : ('?' +  (new Date()).getTime());
        this._metaLayer = DG.Meta.layer(null, {
            detectRetina: options.detectRetina,
            maxNativeZoom: options.maxNativeZoom,
            dataFilter: DG.bind(this._processData, this),
            minZoom: options.minZoom
        });
        this._isDg = true;
        this._onTimer = DG.bind(this._onTimer, this);
        DG.TileLayer.prototype.initialize.call(this, DG.Traffic.tileUrl, options);
    },

    // #setTime(day [0-6], time[0-23]) ????

    onAdd: function (map) {
        this._updateLayerProject();

        map
            .addLayer(this._metaLayer)
            .on('projectchange projectleave', this._onMapProjectChange, this);

        if (!this.options.disableLabel) {
            this._metaLayer.on(this._layerEventsListeners, this);
            this._labelHelper = DG.label();
        }

        if (DG.Traffic.updateInterval) {
            this._updateTimer = setInterval(this._onTimer, DG.Traffic.updateInterval);
        }

        DG.TileLayer.prototype.onAdd.call(this, map);
    },

    onRemove: function (map) {
        clearInterval(this._updateTimer);

        map
            .removeLayer(this._metaLayer)
            .off('projectchange projectleave', this._onMapProjectChange, this);

        if (!this.options.disableLabel) {
            this._metaLayer.off(this._layerEventsListeners, this);
            this._map.removeLayer(this._labelHelper);
            this._labelHelper = null;
        }

        DG.TileLayer.prototype.onRemove.call(this, map);
    },

    update: function () {
        var self = this;
        this._getTimestampString().then(
            function (response) {
                self.options.timestampString = '?' + response;
            },
            function () {
                self.options.timestampString = '?' + (new Date()).getTime();
            }).then(
            function () {
                self.fire('update', {timestamp: self.options.timestampString});
                self._layerEventsListeners.mouseout.call(self);
                self._metaLayer.getOrigin().setURL(self._prepareMetaURL(), self);
                self.redraw();
            }
        );
    },

    getSubdomain: function () {
        return DG.Traffic.layersOptions.subdomains[
            Math.floor(Math.random() * DG.Traffic.layersOptions.subdomains.length)
        ];
    },

    _getTimestampString: function () {
        return DG.ajax(
            DG.Util.template(
                DG.Traffic.timeUrl,
                DG.extend({
                    s : this.getSubdomain(),
                    projectCode: this._map.projectDetector.getProject().code
                }, this.options || {})),
            {type: 'get'}
        );
    },

    _onTimer: function () {
        if (this.options.period === 0) {
            this.update();
        }
    },

    _processData: function (trafficData, coord) {
        var map = this._map,
            tileOriginPoint = coord.multiplyBy(this._getTileSize()),
            hints = {};

        if (!DG.Util.isArray(trafficData)) {    // TODO remove
            return [];
        }

        trafficData[1].forEach(function (item) {
            this[item.graph_id] = item.speed_text;
        }, hints);

        return trafficData[0].map(function (item) {
            var geoJson = DG.Wkt.toGeoJSON(item.geometry[0].object[0]);

            geoJson.coordinates[0] = geoJson.coordinates[0].map(function (revertedLatlng) {
                return map
                        .project([revertedLatlng[1], revertedLatlng[0]]).round()
                        .subtract(tileOriginPoint);
            }); // TODO check with MultiPoigon and etc.
            return {
                id: item.graph_id,
                speed: hints[item.graph_id],
                geometry: geoJson
            };
        });
    },

    _prepareMetaURL: function () {
        return DG.Util.template(DG.Traffic.metaUrl, DG.extend({
            x: '{x}',
            y: '{y}',
            z: '{z}',
            s: '{s}'
        }, this.options));
    },

    _updateLayerProject: function () {
        var project = this._map.projectDetector.getProject();
        DG.setOptions(this, project && project.traffic ? {
                projectCode: project.code,
                bounds: project.latLngBounds,
                minZoom: Math.max(project.minZoom, DG.Traffic.layersOptions.minZoom),
                maxZoom: project.maxZoom
            } : {
                maxZoom: 0,
                minZoom: 0
            });
        this._metaLayer.getOrigin().setURL(this._prepareMetaURL());
    },

    _onMapProjectChange: function () {
        this._updateLayerProject();
        this.redraw();
    },

    _layerEventsListeners: {
        mouseover: function (e) { // (Object)
            this._setCursor('pointer');
            if (this._labelHelper && e.meta.speed) {
                this._labelHelper
                    .setPosition(e.latlng)
                    .setContent(e.meta.speed + ' ' + this.t('speed_unit_km_h'))
                    .addTo(this._map);
            }
        },
        mouseout: function () {
            this._setCursor('');
            if (this._labelHelper) {
                this._map.removeLayer(this._labelHelper);
            }
        },
        mousemove: function (e) {
            if (this._labelHelper) {
                this._labelHelper.setPosition(e.latlng);
            }
        }
    },

    _setCursor: function (cursor) { // (String)
        this._map.getContainer().style.cursor = cursor;
    }

});

DG.Traffic.include(DG.Locale);

DG.traffic = function (options) { // (Object)
    return new DG.Traffic(options);
};

DG.Traffic.Dictionary.ru = {
    speed_unit_km_h: '/'
};
DG.Traffic.Dictionary.it = {
    speed_unit_km_h: 'km/h'
};
DG.Traffic.Dictionary.cs = {
    speed_unit_km_h: 'km/h'
};
DG.Traffic.Dictionary.es = {
    speed_unit_km_h: 'km/h'
};
DG.Traffic.Dictionary.en = {
    speed_unit_km_h: 'km/h'
};
/* global 10 */

DG.Control.Traffic = DG.RoundControl.extend({

    options: {
        position: 'topright',
        iconClass: 'traffic'
    },

    statics: {
        Dictionary: {},
        scoreUrl: 'http://traffic{s}.maps.2gis.com/{projectCode}/meta/score/0/',
        trafficMinZoom: 10
    },

    initialize: function (options) {
        this._trafficClass = 'dg-traffic-control';
        this._controlHideClass = 'dg-control-round_is-hidden_true';

        DG.setOptions(this, options);
        DG.extend(this, {
            _active: false,
            _trafficLayer: null
        }).on(this._controlEvents, this);
    },

    _controlEvents: {
        add: function () {
            this._trafficLayer = DG.traffic();
            this._map.on('zoomend projectchange projectleave', this._updateControlVisibility, this);
        },
        click: function () {
            this._active = !this._active;

            if (this._active) {
                this.setState('active');
                this._showTraffic();
            } else {
                this.setState('');
                this._hideTraffic();
            }
        },
        remove: function () {
            this.off(this._controlEvents, this);
            this._map.off('zoomend projectchange projectleave', this._updateControlVisibility, this);
            if (this._active) {
                this._map.removeLayer(this._trafficLayer);
                this._active = false;
            }
            this._trafficLayer = null;
        }
    },

    _showTraffic: function () { // ()
        this._updateTrafficScore();
        this._map.addLayer(this._trafficLayer);
    },

    _hideTraffic: function () { // ()
        this._handleDom('remove');
        this._map.removeLayer(this._trafficLayer);
    },

    _handleDom: function (method, score) {
        var a = this._link;

        a.innerHTML = score || '';
        DG.DomUtil[method + 'Class'](a, this._trafficClass);
        DG.DomUtil[method + 'Class'](a, this._trafficClass + '_color_' + this._scoreRate);
    },

    _getTrafficColor: function (score) { // (Number) -> String
        var result = 'green';

        if (score > 7) {
            result = 'red';
        } else if (score > 4) {
            result = 'yellow';
        }

        return result;
    },

    _updateControlVisibility: function() {
        var project = this._map.projectDetector.getProject(),
            projectHasTraffic = project && project.traffic,
            method = ((this._map.getZoom() < DG.Control.Traffic.trafficMinZoom) ||
            (!projectHasTraffic)) ? 'addClass' : 'removeClass';

        DG.DomUtil[method](this._container, this._controlHideClass);
        if (this._active && projectHasTraffic) {
            this._updateTrafficScore();
        }
    },

    _updateTrafficScore: function() {
        var self = this;

        this._getTrafficScore().then(function (score) {
            score = parseInt(score, 10); // sometimes webapi returns something like '5,+'

            self._scoreRate = self._getTrafficColor(score);
            self._handleDom('add', score);
        });
    },

    _getTrafficScore: function () { // () -> Promise
        var url = DG.Util.template(
            DG.Control.Traffic.scoreUrl,
            {
                s: this._trafficLayer.getSubdomain(),
                projectCode: this._map.projectDetector.getProject().code
            }
        );

        return DG.ajax(url, {type: 'get'});
    },

    _renderTranslation: function () { // ()
        this._link.title = this.t('button_title');
    }
});

DG.control.traffic = function (options) {
    return new DG.Control.Traffic(options);
};

DG.Control.Traffic.Dictionary.ru = {
	button_title: ''
};

DG.Control.Traffic.Dictionary.it = {
	button_title: 'Colonna'
};

DG.Control.Traffic.Dictionary.cs = {
	button_title: 'Zcpy'
};

DG.Control.Traffic.Dictionary.es = {
	button_title: 'Taco'
};

DG.Control.Traffic.Dictionary.en = {
	button_title: 'Traffic'
};

DG.Ruler = DG.Layer.extend({

    options: {
        editable: true
    },

    includes: [DG.Locale],

    statics: {
        Dictionary: {}
    },

    initialize: function (latlngs, options) { // (Array, Object)
        DG.Util.setOptions(this, options);

        this._layers = {
            back : null,
            middle : null,
            front : null,
            mouse : null
        };
        this._points = [];

        this._layersContainer = DG.featureGroup();
        Object.keys(this._layers).forEach(function (name) {
            this._layersContainer.addLayer(this._layers[name] = DG.featureGroup());
        }, this);

        this._reset();

        if (DG.Browser.touch) {
            delete this._lineMouseEvents.mouseover;
            delete this._lineMouseEvents.mouseout;
            delete this._lineMouseEvents.mousemove;
        } else {
            delete this._lineMouseEvents.click;
        }

        if (latlngs && latlngs.length) {
            this.setLatLngs(latlngs);
        }
    },

    onAdd: function (map) { // (Map)
        this._map = map.on('langchange', this._updateDistance, this);

        // pane for the running label
        if (!this._map.getPane('rulerLabelPane')) {
            this._map.createPane('rulerLabelPane');
        }

        // pane with transperent vector for events handling (over running label)
        if (!this._map.getPane('rulerEventPane')) {
            this._map.createPane('rulerEventPane');
        }

        this._layersContainer.addTo(this._map);

        if (this._points.length) {
            this._layers.mouse.fire('layeradd');
            this._updateDistance();
        }

        this._layers.mouse.on(this._lineMouseEvents, this);
    },

    onRemove: function (map) { // (Map)
        map
            .off('langchange', this._updateDistance, this)
            .removeLayer(this._layersContainer);

        this._layers.mouse.off(this._lineMouseEvents, this);
        this._reset();
    },

    getTotalDistance: function () { // () -> Number
        return this._calcDistance();
    },

    spliceLatLngs: function (index) { // (Number, Number, args ...) -> Array
        var oldLength = this._points.length,
            mutationStart = index >= 0 ? Math.min(index, oldLength) : oldLength - index,
            removed = Array.prototype.splice.apply(this._points, arguments).map(function (point) {
                this._layers.mouse.removeLayer(point);
                return point.off().getLatLng();
            }, this),
            length = this._points.length;

        if (length) {
            for (var i = mutationStart; i < length; i++) {
                if (!(this._points[i] instanceof DG.Ruler.LayeredMarker)) {
                    this._points[i] = this._createPoint(this._points[i], this.options.iconStyles.large)
                        .on(this._pointEvents, this)
                        .once('add', this._addCloseHandler, this)
                        .addTo(this._layers.mouse, this._layers);
                }
                if (i && !this._points[i - 1]._legs) {
                    this._addLegs(this._points[i - 1]);
                }
                this._points[i].setPointStyle(this.options.iconStyles[i && i < length - 1 ? 'small' : 'large']);
                this._points[i]._pos = i;
            }
            this._removeLegs(this._points[length - 1]);
            if (oldLength > 0 && oldLength < length) {
                this._points[oldLength - 1].collapse();
            }
            if (this._points[mutationStart]) {
                this._updateLegs(this._points[mutationStart]);
            }
            if (mutationStart > 1) {
                this._points[mutationStart - 1].setPointStyle(this.options.iconStyles.small);
            }
            this._updateDistance();
            this._normalizeRulerPoints();
        }
        if (DG.Browser.touch && this._lineMarkerHelper) {
            this._lineMarkerHelper.collapse();
        }
        this._fireChangeEvent();
        return removed;
    },

    addLatLng: function (latlng) { // (LatLng) -> Ruler
        var lastPoint = this._points[this._points.length - 1] || null;
        latlng = DG.latLng(latlng);

        if (lastPoint) {
            latlng = this._normalizeLatLng(latlng, lastPoint.getLatLng());
        }

        this.spliceLatLngs(this._points.length, 0, latlng);
        return this;
    },

    getLatLngs: function () { // () -> Array
        return this._points.map(function (point) {
            return point.getLatLng();
        });
    },

    setLatLngs: function (latlngs) { // (Array) -> Ruler
        var args = latlngs.slice();
        args.unshift(0, this._points.length);
        this.spliceLatLngs.apply(this, args);
        return this;
    },

    _reset: function () { // ()
        DG.extend(this, {
            _lineMarkerHelper: null,
            _morphingNow: false
        });
    },

    _lineMouseEvents: {
        click: function (event) {
            var target = event.layer;
            if (target instanceof DG.Marker && target._pos !== this._points.length - 1) {
                if (this._lineMarkerHelper) {
                    this._lineMarkerHelper.collapse();
                }
                target.setText(this._getFormatedDistance(target));
                this._lineMarkerHelper = target;
            } else if (target instanceof DG.Path && this.options.editable) {
                var latlng = event.latlng,
                    insertPos = target._point._pos + 1;
                this.spliceLatLngs(insertPos, 0, latlng);
            }
        },
        mouseover: function (event) { // (MouseEvent)
            var target = event.layer;

            target._hovered = true;
            if (this._morphingNow) {
                return;
            }
            if (target instanceof DG.Marker && target._pos !== this._points.length - 1) {
                target.setText(this._getFormatedDistance(target));
            } else if (target instanceof DG.Path && !this._lineMarkerHelper) {
                var point = target._point;

                this._lineMarkerHelper = this._addRunningLabel(
                    this._nearestPoint(point._legs.middle, event.latlng),
                    point
                );
            }
        },
        mouseout: function (event) { // (MouseEvent)
            var target = event.layer,
                originalEv = event.originalEvent;

            target._hovered = false;
            if (this._morphingNow || target._pos === this._points.length - 1) {
                return;
            }
            if (target instanceof DG.Marker) {
                // collapse only when we move out from label container (if browser support relatedTarget)
                if (!originalEv.relatedTarget ||
                    (originalEv.relatedTarget !== target.querySelector('container') &&
                    originalEv.relatedTarget.parentNode !== target.querySelector('container'))) {
                    target.collapse();
                }
            } else {
                this._removeRunningLabel();
            }
        },
        mousemove: function (event) { // (MouseEvent)
            if (this._morphingNow || !this._lineMarkerHelper) {
                return;
            }

            var point = event.layer._point,
                latlng = this._nearestPoint(point._legs.middle, event.latlng);

            this._lineMarkerHelper
                    .setLatLng(latlng)
                    .setText(this._getFormatedDistance(point, point.getLatLng().distanceTo(latlng)));
        },
        layeradd: function () { // ()
            Object.keys(this._layers).forEach(function (name) {
                this._layers[name].bringToFront();
            }, this);
        }
    },

    _fireChangeEvent: function () {
        this.fire('changed', {latlngs : this.getLatLngs()});
    },

    _addRunningLabel: function (latlng, previousPoint) { // (LatLng, Ruler.LayeredMarker)
        var point = this._createPoint(latlng).addTo(this._layers.mouse, this._layers);
        this._map.getPane('rulerLabelPane').appendChild(point._icon);
        return point.setText(this._getFormatedDistance(previousPoint, previousPoint.getLatLng().distanceTo(latlng)));
    },

    _removeRunningLabel: function () { // ()
        if (this._lineMarkerHelper) {
            this._layers.mouse.removeLayer(this._lineMarkerHelper);
            this._lineMarkerHelper = null;
        }
    },

    _insertPointInLine: function (event) { // (MouseEvent)
        var latlng = this._lineMarkerHelper.getLatLng(),
            insertPos = event.target._point._pos + 1,
            point;

        if (L.Browser.ie) {
            var path = event.originalEvent.target || event.originalEvent.srcElement,
                parent = path.parentNode;
            parent.appendChild(path); // IE click event leaking problem solution: we reappend mousedown event target element
        }

        L.DomEvent.stopPropagation(event.originalEvent);

        this.spliceLatLngs(insertPos, 0, latlng);
        point = this._points[insertPos];
        point.setText(this._getFormatedDistance(point));

        if (document.createEvent) {
            var e = document.createEvent('MouseEvents');
            e.initMouseEvent('mousedown', false, false, document.defaultView, 1, 0, 0, 0, 0, false, false, false, false, 1, point._icon);
            point._icon.dispatchEvent(e);
        } else {
            point._icon.fireEvent('onMouseDown', DG.extend(document.createEventObject(), {
                button: 1,
                bubbles: false,
                cancelable: false
            }));
        }
        this._removeRunningLabel();

        this._updateLegs(point);
    },

    // Find the point on given polyline which is closest to given latlng
    _nearestPoint: function (polyline, latlng) { // (Polyline, LatLng) -> LatLng
        var self = this;

        // Convert everything to pixel coordinates
        var point = this._project(latlng);
        var linePoints = polyline.getLatLngs().map(function (latlng) {
            return self._project(latlng);
        });

        // First look for closest polyline segment
        var minDistance;
        var closestSegmentIndex;
        for (var i = 0; i < linePoints.length - 1; i++) {
            var distance = DG.LineUtil.pointToSegmentDistance(
                point,
                linePoints[i],
                linePoints[i + 1]
            );

            if (minDistance === undefined || distance < minDistance) {
                minDistance = distance;
                closestSegmentIndex = i;
            }
        }

        // Then look for closest point on that segment
        var closestPoint = DG.LineUtil.closestPointOnSegment(
            point,
            linePoints[closestSegmentIndex],
            linePoints[closestSegmentIndex + 1]
        );

        // Convert back to LatLng
        return this._unproject(closestPoint);
    },

    _addCloseHandler: function (event) { // (Event)
        event.target
                .on('click', this._deletePoint, this)
                .querySelector('remove-link').style.display = 'inline-block';
    },

    _createPoint: function (latlng, style) { // (LatLng, Object) -> Ruler.LayeredMarker
        var pointStyle = style ? style : this.options.iconStyles.large,
            layers = {};
        Object.keys(pointStyle).forEach(function (layer) {
            layers[layer] = DG.circleMarker(latlng, pointStyle[layer]);
        });

        return DG.Ruler.layeredMarker(latlng, {
            layers : layers,
            draggable : this.options.editable
        });
    },

    // Moves curr LatLng to correct world if necessary so that ruler section
    // between curr and base can be plotted correctly. Returns a new LatLng
    // object.
    _normalizeLatLng: function (curr, base) { // (LatLng, LatLng) -> LatLng
        var diff = (curr.lng < base.lng) ? 360 : -360;

        var newLng = curr.lng;
        while (Math.abs(newLng - base.lng) > 180) {
            newLng += diff;
        }

        return DG.latLng(curr.lat, newLng);
    },

    // Rearranges ruler points between worlds based on point param so that all
    // ruler sections can be plotted correctly.
    _normalizeRulerPoints: function (point) { // (Ruler.LayeredMarker)
        point = point || this._points[0];

        var self = this;
        var position = point._pos;
        var changedPoints = [];
        var i, currPoint, prevPoint, latlng, normalized;

        // Check points to the right
        for (i = position + 1; i < this._points.length; i++) {
            currPoint = this._points[i];
            prevPoint = this._points[i - 1];

            latlng = currPoint.getLatLng();
            normalized = this._normalizeLatLng(latlng, prevPoint.getLatLng());

            if (!normalized.equals(latlng)) {
                currPoint.setLatLng(normalized);
                changedPoints.push(i);
            }
        }

        // Check points to the left
        for (i = position - 1; i >= 0; i--) {
            currPoint = this._points[i];
            prevPoint = this._points[i + 1];

            latlng = currPoint.getLatLng();
            normalized = this._normalizeLatLng(latlng, prevPoint.getLatLng());

            if (!normalized.equals(latlng)) {
                currPoint.setLatLng(normalized);
                changedPoints.push(i);
            }
        }

        // Update legs of all points that changed position
        changedPoints.sort().reduce(function (previous, current) {
            var skipPrevious = previous && previous === current - 1;

            self._updateLegs(self._points[current], skipPrevious);

            return current;
        }, null);
    },

    _pointEvents: {
        drag: function (event) { // (Event)
            var point = event.target;

            this._normalizeRulerPoints(point);

            if (!DG.Browser.touch && point !== this._points[this._points.length - 1]) {
                point.setText(this._getFormatedDistance(point));
            }

            this._updateLegs(point);
            this._updateDistance();
        },
        dragend: function (event) { // (Event)
            var point = event.target;
            this._morphingNow = false;
            if (!point._hovered && point !== this._points[this._points.length - 1]) {
                point.collapse();
            }
            this._fireChangeEvent();
        },
        dragstart: function () { // ()
            if (DG.Browser.touch && this._lineMarkerHelper) {
                this._lineMarkerHelper.collapse();
            }
            this._morphingNow = true;
        }
    },

    _deletePoint: function (event) { // (MouseEvent)
        var originalEvent = event.originalEvent,
            target = originalEvent.target  || originalEvent.srcElement;

        if (target.className !== 'dg-ruler__label-remove-link' &&
            target.className !== 'dg-ruler__remove-link-overlay') {
            return;
        }
        DG.DomEvent.stop(event.originalEvent);
        this.spliceLatLngs(event.target._pos, 1);
    },

    _degToRad: function (deg) {
        return (Math.PI / 180) * deg;
    },

    _radToDeg: function (rad) {
        return (180 / Math.PI) * rad;
    },

    // Map-independent project method
    _project: function (latlng) {
        if (this._map) {
            return this._map.project(latlng);
        }

        return DG.CRS.EPSG3857.latLngToPoint(latlng, 1);
    },

    // Map-independent unproject method
    _unproject: function (point) {
        if (this._map) {
            return this._map.unproject(point);
        }

        return DG.CRS.EPSG3857.pointToLatLng(point, 1);
    },

    // Calculates the size of angle point1-point-point2
    _calcAngle: function (point, point1, point2) { // (LatLng, LatLng, LatLng) -> Number
        point1 = this._normalizeLatLng(point1, point);
        point2 = this._normalizeLatLng(point2, point);

        point = this._project(point);
        point1 = this._project(point1);
        point2 = this._project(point2);

        var x1 = point1.x - point.x;
        var x2 = point2.x - point.x;
        var y1 = point1.y - point.y;
        var y2 = point2.y - point.y;

        var dotProduct = x1 * x2 + y1 * y2;
        var mag1 = Math.sqrt(x1 * x1 + y1 * y1);
        var mag2 = Math.sqrt(x2 * x2 + y2 * y2);

        return Math.acos(dotProduct / (mag1 * mag2));
    },

    // Calculates the midpoint on the great circle between two LatLngs
    _calcMidPoint: function (latlng1, latlng2) { // (LatLng, LatLng) -> LatLng
        var lon1 = this._degToRad(latlng1.lng);
        var lat1 = this._degToRad(latlng1.lat);

        var lon2 = this._degToRad(latlng2.lng);
        var lat2 = this._degToRad(latlng2.lat);

        // Based on formulae from
        // http://williams.best.vwh.net/avform.htm#Intermediate
        var d = Math.acos(Math.sin(lat1) * Math.sin(lat2) +
            Math.cos(lat1) * Math.cos(lat2) * Math.cos(lon1 - lon2));

        // Split the arc in half
        var f = 0.5;

        var A = Math.sin((1 - f) * d) / Math.sin(d);
        var B = Math.sin(f * d) / Math.sin(d);

        var x = A * Math.cos(lat1) * Math.cos(lon1) +
            B * Math.cos(lat2) * Math.cos(lon2);

        var y = A * Math.cos(lat1) * Math.sin(lon1) +
            B * Math.cos(lat2) * Math.sin(lon2);

        var z = A * Math.sin(lat1) + B * Math.sin(lat2);

        var lat = Math.atan2(z, Math.sqrt(x * x + y * y));
        var lon = Math.atan2(y, x);

        return DG.latLng(this._radToDeg(lat), this._radToDeg(lon));
    },

    // Adaptive sampling algorithm based on
    // http://ariel.chronotext.org/dd/defigueiredo93adaptive.pdf
    _adaptiveSample: function (left, right, depth, middle) { // (LatLng, LatLng, Number[, LatLng]) -> LatLng[]
        if (depth > 9) {
            // Max recursion depth reached
            return [];
        }

        middle = middle || this._calcMidPoint(left, right);

        var leftMiddle = this._calcMidPoint(left, middle);
        var rightMiddle = this._calcMidPoint(middle, right);

        var angle1 = this._calcAngle(leftMiddle, middle, left);
        var angle2 = this._calcAngle(middle, left, right);
        var angle3 = this._calcAngle(rightMiddle, middle, right);

        // left --- leftMiddle --- middle --- rightMiddle --- right
        //            angle1       angle2       angle3

        var minAngle = 3.1;
        if (angle1 > minAngle && angle2 > minAngle && angle3 > minAngle) {
            // This section is straight enough, no intermediate points needed.
            return [];
        } else {
            // Angles are too small. Recursively sample halves of this section.
            var result = [];
            result = result.concat(this._adaptiveSample(left, middle, depth + 1, leftMiddle));
            result.push(middle);
            result = result.concat(this._adaptiveSample(middle, right, depth + 1, rightMiddle));

            return result;
        }
    },

    // Calculates the great circle arc between two LatLngs.
    _calcGreatCircle: function (latlng1, latlng2) { // (LatLng, LatLng) -> LatLng[]
        latlng2 = this._normalizeLatLng(latlng2, latlng1);

        // Special case: points are close to each other (within 1 degree)
        if (latlng1.equals(latlng2, 1)) {
            return [latlng1, latlng2];
        }

        // Special case: the great circle crosses a pole
        if (Math.abs(latlng2.lng - latlng1.lng) == 180) {
            // North or south pole?
            var latitude = (latlng1.lat + latlng2.lat > 0) ? 90 : -90;

            return [
                latlng1,
                DG.latLng(latitude, latlng1.lng),
                DG.latLng(latitude, latlng2.lng),
                latlng2
            ];
        }

        var result = [];

        result.push(latlng1);
        result = result.concat(this._adaptiveSample(latlng1, latlng2, 0));
        result.push(latlng2);

        // Make sure the arc doesn't jump between worlds
        for (var i = 1; i < result.length; i++) {
            result[i] = this._normalizeLatLng(result[i], result[i - 1]);
        }

        return result;
    },

    _addLegs: function (point) {
        var pathStyles = this.options.pathStyles;

        var greatCirclePoints = this._calcGreatCircle(
            point.getLatLng(),
            this._points[point._pos + 1].getLatLng()
        );

        point._legs = {};
        Object.keys(pathStyles).forEach(function (layer) {
            point._legs[layer] = DG.polyline(greatCirclePoints, pathStyles[layer]).addTo(this._layers[layer]);
        }, this);

        point._legs.mouse._point = point.once('remove', this._clearRemovingPointLegs, this);

        if (this.options.editable && !DG.Browser.touch) {
            point._legs.mouse.on('mousedown', this._insertPointInLine, this);
        }

        if (this._map) {
            this._layers.mouse.addLayer(point._legs.mouse);
        }
    },

    _clearRemovingPointLegs: function (event) { // (Event)
        this._removeLegs(event.target);
    },

    _removeLegs: function (point) { // (Ruler.LayeredMarker)
        if (point._legs) {
            Object.keys(point._legs).forEach(function (layer) {
                this._layers[layer].removeLayer(point._legs[layer]);
            }, this);
            point._legs = null;
        }
    },

    _updateLegs: function (point, skipPrevious) { // (Ruler.LayeredMarker, Boolean)
        var latlng = point.getLatLng(),
            previousPoint = this._points[point._pos - 1],
            nextPoint = this._points[point._pos + 1],
            self = this,
            newPoints;

        if (previousPoint && !skipPrevious) {
            newPoints = self._calcGreatCircle(previousPoint.getLatLng(), latlng);

            Object.keys(previousPoint._legs).forEach(function (layer) {
                previousPoint._legs[layer].setLatLngs(newPoints);
            });
        }

        if (nextPoint) {
            newPoints = self._calcGreatCircle(latlng, nextPoint.getLatLng());

            Object.keys(point._legs).forEach(function (layer) {
                point._legs[layer].setLatLngs(newPoints);
            });
        }
    },

    _calcDistance: function (finishPoint, tail) { // (Ruler.LayeredMarker, Number) -> Number
        var distance = tail ? tail : 0,
            calcTo = finishPoint ? finishPoint._pos : this._points.length - 1;

        for (var i = 0; i < calcTo; i++) {
            distance += this._points[i].getLatLng().distanceTo(this._points[i + 1].getLatLng());
        }

        return distance;
    },

    _getFormatedDistance: function () { // () -> String
        var distance = this._calcDistance.apply(this, arguments),
            units = 'm';

        if (distance > 1000) {
            distance /= 1000;
            units = 'km';
            if (distance > 1000) {
                distance = distance.toFixed();
                distance = distance.slice(0, -3) + ' ' + distance.slice(-3);
            } else {
                distance = distance.toFixed(2).split('.').join(this.t('delimiter'));
            }
        } else {
            distance = Math.round(distance);
        }

        return [distance || 0, ' ', this.t(units)].join('');
    },

    _updateDistance: function () { // ()
        if (this._map && this._points.length) {
            this._points[this._points.length - 1].setText(this._getFormatedDistance());
        }
    }
});

DG.ruler = function (latlngs, options) { // (Array, Object)
    return new DG.Ruler(latlngs, options);
};

DG.Ruler.LayeredMarker = DG.Marker.extend({

    /*global {"RulerLayeredMarker":"(function(){dust.register(\"RulerLayeredMarker\",body_0);function body_0(chk,ctx){return chk.write(\"<img class=\\\"dg-ruler__label-spacer\\\" src=\\\"\").reference(ctx.get([\"blankgif\"], false),ctx,\"h\").write(\"\\\" width=\\\"26\\\" height=\\\"26\\\" /><div class=\\\"dg-ruler__label-container\\\"><div class=\\\"dg-ruler__point\\\"></div><span class=\\\"dg-ruler__label-distance\\\">0 </span><span class=\\\"dg-ruler__label-remove-link\\\"></span><div class=\\\"dg-ruler__remove-link-overlay\\\"></div></div>\");}return body_0;})();"}:false */

    options: {
        draggable: false,
        keyboard: false,
        riseOnHover: true,
        iconHTML: DG.dust({"RulerLayeredMarker":"(function(){dust.register(\"RulerLayeredMarker\",body_0);function body_0(chk,ctx){return chk.write(\"<img class=\\\"dg-ruler__label-spacer\\\" src=\\\"\").reference(ctx.get([\"blankgif\"], false),ctx,\"h\").write(\"\\\" width=\\\"26\\\" height=\\\"26\\\" /><div class=\\\"dg-ruler__label-container\\\"><div class=\\\"dg-ruler__point\\\"></div><span class=\\\"dg-ruler__label-distance\\\">0 </span><span class=\\\"dg-ruler__label-remove-link\\\"></span><div class=\\\"dg-ruler__remove-link-overlay\\\"></div></div>\");}return body_0;})();"})('RulerLayeredMarker', {
            blankgif : 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7'
        })
    },

    statics: {
        domClass : 'dg-ruler__label'
    },

    addTo : function (map, layers) {
        Object.keys(this._layers).forEach(function (name) {
            layers[name].addLayer(this._layers[name]);
        }, this);

        this._viewport = layers;
        return DG.Marker.prototype.addTo.call(this.on('move', this._onMove), map);
    },

    onRemove : function (map) {
        Object.keys(this._layers).forEach(function (name) {
            this._viewport[name].removeLayer(this._layers[name]);
        }, this);
        this.off('move', this._onMove);
        this._viewport = null;
        this._style = null;
        return DG.Marker.prototype.onRemove.call(this, map);
    },

    setText : function (text) {
        if (this._iconCollapsed) {
            this.expand();
        }
        this._iconNodes.label.innerHTML = text;
        return this;
    },

    setPointStyle : function (style) {
        if (this._style !== style) {
            Object.keys(this._style = style).forEach(function (name) {
                this._layers[name].setStyle(style[name]);
            }, this);
        }
        return this;
    },

    expand : function () {
        this._iconCollapsed = false;
        this._iconNodes.container.style.display = 'block';
        this._iconNodes.spacer.style.display = 'none';
        return this;
    },

    collapse : function () {
        this._iconCollapsed = true;
        this._iconNodes.container.style.display = 'none';
        this._iconNodes.spacer.style.display = 'block';
        return this;
    },

    querySelector : function (selector) {
        return this._icon.querySelector('.' + DG.Ruler.LayeredMarker.domClass + '-' + selector);
    },

    _onMove : function (event) {
        var latlng = event.latlng;
        Object.keys(this._layers).forEach(function (name) {
            this._layers[name].setLatLng(latlng);
        }, this);
    },

    _initIcon : function () {
        DG.Marker.prototype._initIcon.call(this);
        this._iconCollapsed = true;
        this._icon.style.width = '';
        this._iconNodes = {
            label : this.querySelector('distance'),
            spacer : this.querySelector('spacer'),
            container : this.querySelector('container')
        };
    },

    _afterInit : function () {
        this._layers = this.options.layers || null;
        this.options.icon = DG.divIcon({
            className: DG.Ruler.LayeredMarker.domClass,
            iconSize: [26, 26],
            iconAnchor: [13, 13],
            html: this.options.iconHTML
        });
    }

});

DG.Ruler.LayeredMarker.addInitHook('_afterInit');

DG.Ruler.layeredMarker = function (latlng, options) {
    return new DG.Ruler.LayeredMarker(latlng, options);
};

var rulerRenderer = DG.svg({pane: 'rulerLabelPane'});

DG.Ruler.mergeOptions({
    pathStyles: {
        back: {
            color: '#fff',
            opacity: 1,
            weight: 12,
            pointerEvents: 'none',
            noClip: true,
            renderer: rulerRenderer,
            smoothFactor: 0
        },
        middle: {
            color: '#0da5d5',
            opacity: 1,
            weight: 4,
            pointerEvents: 'none',
            noClip: true,
            renderer: rulerRenderer,
            smoothFactor: 0
        },
        mouse: {
            color: '#fff',
            opacity: DG.Browser.vml ? 0.1 : 0,
            weight: DG.Browser.touch ? 40 : 20,
            pointerEvents: 'painted',
            noClip: true,
            renderer: DG.svg({pane: 'rulerEventPane'}),
            smoothFactor: 0
        }
    },
    iconStyles: {
        large: {
            back: {
                color: '#fff',
                opacity: 1,
                fillColor: '#fff',
                fillOpacity: 1,
                weight: 1,
                radius: 13,
                renderer: rulerRenderer
            },
            middle: {
                color: '#0da5d5',
                opacity: 1,
                fillColor: '#0da5d5',
                fillOpacity: 1,
                weight: 1,
                radius: 9,
                renderer: rulerRenderer
            },
            front: {
                color: '#fff',
                opacity: 1,
                fillColor: '#0da5d5',
                fillOpacity: 1,
                weight: 4,
                radius: 5,
                renderer: rulerRenderer
            }
        },
        small: {
            back: {
                color: '#fff',
                opacity: 1,
                fillColor: '#fff',
                fillOpacity: 1,
                weight: 1,
                radius: 9,
                renderer: rulerRenderer
            },
            middle: {
                color: '#0da5d5',
                opacity: 1,
                fillColor: '#0da5d5',
                fillOpacity: 1,
                weight: 1,
                radius: 5,
                renderer: rulerRenderer
            },
            front: {
                color: '#fff',
                opacity: 1,
                fillColor: '#0da5d5',
                fillOpacity: 1,
                weight: 4,
                radius: 2,
                renderer: rulerRenderer
            }
        }
    }
});

DG.Ruler.Dictionary.ru = {
	km : '',
	m : '',
	delimiter : ','
};

DG.Ruler.Dictionary.it = {
	km : 'km',
	m : 'm',
	delimiter : ','
};
DG.Ruler.Dictionary.cs = {
	km: 'km',
	m: 'm',
	delimiter: ','
};
DG.Ruler.Dictionary.es = {
	km : 'km',
	m : 'm',
	delimiter : ','
};
DG.Ruler.Dictionary.en = {
	km : 'km',
	m : 'm',
	delimiter : '.'
};

DG.Control.Ruler = DG.RoundControl.extend({

    options: {
        position: 'topright',
        iconClass: 'ruler'
    },

    statics: {
        Dictionary: {}
    },

    initialize: function (options) {
        DG.setOptions(this, options);
        DG.extend(this, {
            _active: false,
            _drawingHelper: null,
            _geoclickerNeedRestore: false
        }).on(this._controlEvents, this);
    },

    _controlEvents: {
        add: function () {
            this._drawingHelper = DG.ruler([]);
        },
        click: function () {
            this._active = !this._active;

            if (this._active) {
                this.setState('active');
                this._startDrawing();
            } else {
                this.setState('');
                this._finishDrawing();
            }
        },
        remove: function () {
            this.off(this._controlEvents, this);
            if (this._active) {
                this._map.removeLayer(this._drawingHelper);
                this._active = false;
            }
            this._drawingHelper = null;
        }
    },

    _startDrawing: function () { // ()
        this._map
            .addLayer(this._drawingHelper)
            .on('click', this._handleMapClick, this);

        this._map.fire('rulerstart');
    },

    _finishDrawing: function () { // ()
        this._map
            .off('click', this._handleMapClick, this)
            .removeLayer(this._drawingHelper);

        this._drawingHelper.setLatLngs([]);

        this._map.fire('rulerend');
    },

    _handleMapClick: function (event) { // (MouseEvents)
        this._drawingHelper.addLatLng(event.latlng);
    },

    _renderTranslation: function () { // ()
        this._link.title = this.t('button_title');
    }
});

DG.control.ruler = function (options) {
    return new DG.Control.Ruler(options);
};

DG.Control.Ruler.Dictionary.ru = {
	button_title: ''
};
DG.Control.Ruler.Dictionary.it = {
	button_title : 'Righello'
};
DG.Control.Ruler.Dictionary.cs = {
	button_title: 'Pravtko'
};
DG.Control.Ruler.Dictionary.es = {
	button_title : 'Regla'
};

DG.Control.Ruler.Dictionary.en = {
	button_title : 'Ruler'
};DG.fallbackProjectsList = JSON.parse('[{"id":"99","name":"Dubai","type":"region","country_code":"ae","code":"dubai","domain":"ae","zoom_level":{"min":9,"max":18},"flags":{"public_transport":true,"metro":true,"road_network":true,"flamp":false},"time_zone":{"offset":240,"name":"Asia/Dubai"},"bounds":"POLYGON((54.869563 25.350048,55.674294 25.359495,55.680597 24.772487,54.879687 24.763287,54.869563 25.350048))"},{"id":"104","name":"Lefkosia","type":"region","country_code":"cy","code":"nicosia","domain":"com.cy","zoom_level":{"min":11,"max":19},"flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":false},"time_zone":{"offset":180,"name":"Asia/Nicosia"},"bounds":"POLYGON((33.269298 35.198771,33.444017 35.198256,33.443116 35.031957,33.268751 35.032469,33.269298 35.198771))"},{"id":"93","name":"Lemesos","type":"region","country_code":"cy","code":"limassol","domain":"com.cy","zoom_level":{"min":11,"max":19},"flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":false},"time_zone":{"offset":180,"name":"Asia/Nicosia"},"bounds":"POLYGON((32.818314 34.770361,33.190735 34.770347,33.190216 34.543829,32.818807 34.543842,32.818314 34.770361))"},{"id":"92","name":"Praha","type":"region","country_code":"cz","code":"praha","domain":"cz","zoom_level":{"min":10,"max":18},"flags":{"public_transport":true,"metro":true,"road_network":true,"flamp":false},"time_zone":{"offset":120,"name":"Europe/Prague"},"bounds":"POLYGON((14.215528 50.17879,14.713797 50.181086,14.715245 49.937173,14.219495 49.934897,14.215528 50.17879))"},{"id":"101","name":"Santiago","type":"region","country_code":"cl","code":"santiago","domain":"cl","zoom_level":{"min":9,"max":19},"flags":{"public_transport":true,"metro":true,"road_network":true,"flamp":false},"time_zone":{"offset":-240,"name":"America/Santiago"},"bounds":"POLYGON((-70.849333 -33.293334,-70.477276 -33.298315,-70.483526 -33.665691,-70.857156 -33.660641,-70.849333 -33.293334))"},{"id":"66","name":"Venezia e Padova","type":"region","country_code":"it","code":"padova","domain":"it","zoom_level":{"min":9,"max":18},"flags":{"public_transport":true,"metro":false,"road_network":false,"flamp":false},"time_zone":{"offset":120,"name":"Europe/Rome"},"bounds":"POLYGON((11.381405 45.733677,12.61199 45.701369,12.572035 45.071338,11.355023 45.102947,11.381405 45.733677))"},{"id":"69","name":"","type":"region","country_code":"ru","code":"abakan","domain":"ru","zoom_level":{"min":9,"max":18},"flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":true},"time_zone":{"offset":420,"name":"Asia/Krasnoyarsk"},"bounds":"POLYGON((91.144335 53.893079,91.817626 53.901599,91.826689 53.577496,91.158554 53.569076,91.144335 53.893079))"},{"id":"67","name":"","type":"region","country_code":"kz","code":"almaty","domain":"kz","zoom_level":{"min":9,"max":18},"flags":{"public_transport":true,"metro":true,"road_network":true,"flamp":false},"time_zone":{"offset":360,"name":"Asia/Qyzylorda"},"bounds":"POLYGON((76.725996 43.469106,77.1084 43.462692,77.096182 43.108051,76.715991 43.114387,76.725996 43.469106))"},{"id":"108","name":"","type":"region","country_code":"ru","code":"almetevsk","domain":"ru","zoom_level":{"min":9,"max":17},"flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":true},"time_zone":{"offset":180,"name":"Europe/Moscow"},"bounds":"POLYGON((52.206024 54.949956,52.478673 54.946945,52.473189 54.796869,52.20155 54.799862,52.206024 54.949956))"},{"id":"106","name":"","type":"region","country_code":"ru","code":"armawir","domain":"ru","zoom_level":{"min":9,"max":18},"flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":true},"time_zone":{"offset":180,"name":"Europe/Moscow"},"bounds":"POLYGON((40.876282 45.249443,41.322578 45.241236,41.301688 44.721791,40.8594 44.729852,40.876282 45.249443))"},{"id":"49","name":"","type":"region","country_code":"ru","code":"arkhangelsk","domain":"ru","zoom_level":{"min":9,"max":18},"flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":true},"time_zone":{"offset":180,"name":"Europe/Moscow"},"bounds":"POLYGON((39.467082 64.829966,41.321175 64.81257,41.276671 64.284305,39.458118 64.301294,39.467082 64.829966))"},{"id":"8","name":"","type":"region","country_code":"ru","code":"astrakhan","domain":"ru","zoom_level":{"min":9,"max":18},"flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":true,"has_net_booklet":true},"time_zone":{"offset":180,"name":"Europe/Moscow"},"bounds":"POLYGON((47.863046 46.503348,48.172299 46.511418,48.185812 46.249257,47.878031 46.241259,47.863046 46.503348))"},{"id":"4","name":"","type":"region","country_code":"ru","code":"barnaul","domain":"ru","zoom_level":{"min":9,"max":18},"flags":{"public_transport":true,"metro":false,"road_network":true,"traffic":true,"flamp":true,"has_net_booklet":true},"time_zone":{"offset":360,"name":"Asia/Omsk"},"bounds":"POLYGON((83.463814 53.486694,84.087934 53.472187,84.065362 53.158598,83.445792 53.172941,83.463814 53.486694))"},{"id":"46","name":"","type":"region","country_code":"ru","code":"belgorod","domain":"ru","zoom_level":{"min":9,"max":18},"flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":true},"time_zone":{"offset":180,"name":"Europe/Moscow"},"bounds":"POLYGON((36.419278 50.695,36.719872 50.701271,36.729779 50.495879,36.430487 50.489654,36.419278 50.695))"},{"id":"20","name":"","type":"region","country_code":"ru","code":"biysk","domain":"ru","zoom_level":{"min":9,"max":18},"flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":true,"has_net_booklet":true},"time_zone":{"offset":360,"name":"Asia/Omsk"},"bounds":"POLYGON((84.568894 52.63167,85.467428 52.646705,85.492485 51.91455,84.608614 51.899905,84.568894 52.63167))"},{"id":"52","name":"","type":"region","country_code":"ru","code":"blagoveshensk","domain":"ru","zoom_level":{"min":9,"max":18},"flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":true,"has_net_booklet":true},"time_zone":{"offset":540,"name":"Asia/Yakutsk"},"bounds":"POLYGON((127.345035 50.596534,127.754667 50.601634,127.764413 50.228495,127.357983 50.223462,127.345035 50.596534))"},{"id":"51","name":"","type":"region","country_code":"ru","code":"bratsk","domain":"ru","zoom_level":{"min":9,"max":18},"flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":true},"time_zone":{"offset":480,"name":"Asia/Irkutsk"},"bounds":"POLYGON((101.08963 56.502619,102.059777 56.482497,102.016051 55.929923,101.059738 55.949632,101.08963 56.502619))"},{"id":"62","name":"","type":"region","country_code":"ru","code":"bryansk","domain":"ru","zoom_level":{"min":9,"max":18},"flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":true,"has_net_booklet":true},"time_zone":{"offset":180,"name":"Europe/Moscow"},"bounds":"POLYGON((34.122949 53.431556,34.604425 53.426058,34.593689 53.138522,34.115433 53.143963,34.122949 53.431556))"},{"id":"77","name":" ","type":"region","country_code":"ru","code":"v_novgorod","domain":"ru","zoom_level":{"min":9,"max":18},"flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":true,"has_net_booklet":true},"time_zone":{"offset":180,"name":"Europe/Moscow"},"bounds":"POLYGON((31.131394 58.678746,31.505415 58.683631,31.514694 58.465262,31.142992 58.460419,31.131394 58.678746))"},{"id":"25","name":"","type":"region","country_code":"ru","code":"vladivostok","domain":"ru","zoom_level":{"min":9,"max":18},"flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":true},"time_zone":{"offset":600,"name":"Asia/Vladivostok"},"bounds":"POLYGON((131.592018 43.61615,132.343685 43.596619,132.300602 42.803446,131.558591 42.822446,131.592018 43.61615))"},{"id":"59","name":"","type":"region","country_code":"ru","code":"vladimir","domain":"ru","zoom_level":{"min":9,"max":18},"flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":true},"time_zone":{"offset":180,"name":"Europe/Moscow"},"bounds":"POLYGON((40.178443 56.46782,40.695168 56.461839,40.676114 56.02824,40.165193 56.034124,40.178443 56.46782))"},{"id":"33","name":"","type":"region","country_code":"ru","code":"volgograd","domain":"ru","zoom_level":{"min":9,"max":18},"flags":{"public_transport":true,"metro":false,"road_network":true,"traffic":true,"flamp":true,"has_net_booklet":true},"time_zone":{"offset":180,"name":"Europe/Moscow"},"bounds":"POLYGON((43.970586 48.922097,44.93003 48.92667,44.930865 48.318601,43.982875 48.314124,43.970586 48.922097))"},{"id":"78","name":"","type":"region","country_code":"ru","code":"vologda","domain":"ru","zoom_level":{"min":9,"max":18},"flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":true},"time_zone":{"offset":180,"name":"Europe/Moscow"},"bounds":"POLYGON((39.611585 59.337288,40.077939 59.334266,40.072156 59.150523,39.608303 59.153523,39.611585 59.337288))"},{"id":"31","name":"","type":"region","country_code":"ru","code":"voronezh","domain":"ru","zoom_level":{"min":9,"max":18},"flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":true},"time_zone":{"offset":180,"name":"Europe/Moscow"},"bounds":"POLYGON((38.991159 51.910995,39.613084 51.909398,39.607251 51.475591,38.991243 51.477162,38.991159 51.910995))"},{"id":"27","name":"-","type":"region","country_code":"ru","code":"gornoaltaysk","domain":"ru","zoom_level":{"min":9,"max":18},"flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":true,"has_net_booklet":true},"time_zone":{"offset":360,"name":"Asia/Omsk"},"bounds":"POLYGON((85.48461 52.148049,86.447524 52.15649,86.458369 51.25739,85.514346 51.249215,85.48461 52.148049))"},{"id":"105","name":"","type":"region","country_code":"ua","code":"dnepropetrovsk","domain":"ua","zoom_level":{"min":9,"max":18},"flags":{"public_transport":true,"metro":true,"road_network":true,"flamp":false},"time_zone":{"offset":180,"name":"Europe/Kiev"},"bounds":"POLYGON((34.749305 48.687967,35.296754 48.67835,35.281569 48.341385,34.737734 48.350889,34.749305 48.687967))"},{"id":"79","name":"","type":"region","country_code":"ua","code":"donetsk","domain":"ua","zoom_level":{"min":9,"max":18},"flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":false},"time_zone":{"offset":180,"name":"Europe/Kiev"},"bounds":"POLYGON((37.510511 48.182783,38.240528 48.189925,38.246188 47.802815,37.521609 47.795769,37.510511 48.182783))"},{"id":"9","name":"","type":"region","country_code":"ru","code":"ekaterinburg","domain":"ru","zoom_level":{"min":9,"max":18},"flags":{"public_transport":true,"metro":true,"road_network":true,"traffic":true,"flamp":true,"has_net_booklet":true},"time_zone":{"offset":300,"name":"Asia/Yekaterinburg"},"bounds":"POLYGON((59.714357 57.010251,60.919831 57.036097,60.943224 56.611802,59.751258 56.586369,59.714357 57.010251))"},{"id":"65","name":"","type":"region","country_code":"ru","code":"ivanovo","domain":"ru","zoom_level":{"min":9,"max":18},"flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":true},"time_zone":{"offset":180,"name":"Europe/Moscow"},"bounds":"POLYGON((40.806876 57.089556,41.189405 57.083456,41.17815 56.891313,40.797585 56.897369,40.806876 57.089556))"},{"id":"41","name":"","type":"region","country_code":"ru","code":"izhevsk","domain":"ru","zoom_level":{"min":9,"max":18},"flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":true},"time_zone":{"offset":240,"name":"Europe/Samara"},"bounds":"POLYGON((52.95169 57.057889,53.495625 57.04823,53.470393 56.667543,52.931947 56.677063,52.95169 57.057889))"},{"id":"11","name":"","type":"region","country_code":"ru","code":"irkutsk","domain":"ru","zoom_level":{"min":9,"max":18},"flags":{"public_transport":true,"metro":false,"road_network":true,"traffic":true,"flamp":true,"has_net_booklet":true},"time_zone":{"offset":480,"name":"Asia/Irkutsk"},"bounds":"POLYGON((103.618853 52.641505,104.97019 52.649551,104.970807 51.718225,103.647397 51.710443,103.618853 52.641505))"},{"id":"70","name":"-","type":"region","country_code":"ru","code":"yoshkarola","domain":"ru","zoom_level":{"min":9,"max":18},"flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":true},"time_zone":{"offset":180,"name":"Europe/Moscow"},"bounds":"POLYGON((47.588902 56.761482,48.153297 56.748478,48.133249 56.507529,47.572432 56.520416,47.588902 56.761482))"},{"id":"21","name":"","type":"region","country_code":"ru","code":"kazan","domain":"ru","zoom_level":{"min":9,"max":18},"flags":{"public_transport":true,"metro":true,"road_network":true,"traffic":true,"flamp":true,"has_net_booklet":true},"time_zone":{"offset":180,"name":"Europe/Moscow"},"bounds":"POLYGON((48.29118 55.977651,49.519957 55.998532,49.535477 55.587187,48.319555 55.566624,48.29118 55.977651))"},{"id":"40","name":"","type":"region","country_code":"ru","code":"kaliningrad","domain":"ru","zoom_level":{"min":9,"max":18},"flags":{"public_transport":true,"metro":false,"road_network":true,"traffic":true,"flamp":true,"has_net_booklet":true},"time_zone":{"offset":120,"name":"Europe/Kaliningrad"},"bounds":"POLYGON((19.839082 55.05047,20.659199 55.055528,20.663516 54.5391,19.853784 54.534137,19.839082 55.05047))"},{"id":"61","name":"","type":"region","country_code":"ru","code":"kaluga","domain":"ru","zoom_level":{"min":9,"max":18},"flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":true},"time_zone":{"offset":180,"name":"Europe/Moscow"},"bounds":"POLYGON((35.894812 54.75546,36.455305 54.768523,36.482233 54.33388,35.92765 54.321024,35.894812 54.75546))"},{"id":"109","name":"-","type":"region","country_code":"ru","code":"k_uralskiy","domain":"ru","zoom_level":{"min":9,"max":17},"flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":true,"has_net_booklet":true},"time_zone":{"offset":300,"name":"Asia/Yekaterinburg"},"bounds":"POLYGON((61.715751 56.571122,62.254705 56.57552,62.260467 56.279794,61.725677 56.275445,61.715751 56.571122))"},{"id":"84","name":"","type":"region","country_code":"kz","code":"karaganda","domain":"kz","zoom_level":{"min":9,"max":18},"flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":false},"time_zone":{"offset":360,"name":"Asia/Qyzylorda"},"bounds":"POLYGON((72.860052 50.123995,73.394974 50.132623,73.41063 49.658415,72.880917 49.64993,72.860052 50.123995))"},{"id":"5","name":"","type":"region","country_code":"ru","code":"kemerovo","domain":"ru","zoom_level":{"min":9,"max":18},"flags":{"public_transport":true,"metro":false,"road_network":true,"traffic":true,"flamp":true,"has_net_booklet":true},"time_zone":{"offset":420,"name":"Asia/Krasnoyarsk"},"bounds":"POLYGON((85.945012 55.531762,86.258641 55.534061,86.263664 55.26479,85.952159 55.262514,85.945012 55.531762))"},{"id":"58","name":"","type":"region","country_code":"ru","code":"kirov","domain":"ru","zoom_level":{"min":9,"max":18},"flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":true},"time_zone":{"offset":180,"name":"Europe/Moscow"},"bounds":"POLYGON((49.036766 58.786454,49.936128 58.797004,49.947791 58.410879,49.058278 58.400486,49.036766 58.786454))"},{"id":"94","name":"--","type":"region","country_code":"ru","code":"komsomolsk","domain":"ru","zoom_level":{"min":9,"max":18},"flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":true},"time_zone":{"offset":600,"name":"Asia/Vladivostok"},"bounds":"POLYGON((136.792391 50.721413,137.258493 50.713313,137.233696 50.189815,136.772704 50.197767,136.792391 50.721413))"},{"id":"34","name":"","type":"region","country_code":"ru","code":"kostroma","domain":"ru","zoom_level":{"min":9,"max":18},"flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":true},"time_zone":{"offset":180,"name":"Europe/Moscow"},"bounds":"POLYGON((40.733014 57.924383,41.151865 57.917978,41.137488 57.675732000000004,40.721431 57.682077,40.733014 57.924383))"},{"id":"23","name":"","type":"region","country_code":"ru","code":"krasnodar","domain":"ru","zoom_level":{"min":9,"max":18},"flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":true},"time_zone":{"offset":180,"name":"Europe/Moscow"},"bounds":"POLYGON((38.650083 45.265382,39.378568 45.26529,39.376448 44.943556,38.652043 44.943646,38.650083 45.265382))"},{"id":"7","name":"","type":"region","country_code":"ru","code":"krasnoyarsk","domain":"ru","zoom_level":{"min":9,"max":18},"flags":{"public_transport":true,"metro":false,"road_network":true,"traffic":true,"flamp":true,"has_net_booklet":true},"time_zone":{"offset":420,"name":"Asia/Krasnoyarsk"},"bounds":"POLYGON((92.126846 56.306635,93.59929 56.308263,93.591657 55.813004,92.137966 55.811406,92.126846 56.306635))"},{"id":"10","name":"","type":"region","country_code":"ru","code":"kurgan","domain":"ru","zoom_level":{"min":9,"max":18},"flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":true,"has_net_booklet":true},"time_zone":{"offset":300,"name":"Asia/Yekaterinburg"},"bounds":"POLYGON((65.163162 55.530273,65.482856 55.524208,65.473103 55.368657,65.154662 55.374687,65.163162 55.530273))"},{"id":"73","name":"","type":"region","country_code":"ru","code":"kursk","domain":"ru","zoom_level":{"min":9,"max":18},"flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":true},"time_zone":{"offset":180,"name":"Europe/Moscow"},"bounds":"POLYGON((35.889369 51.829944,36.419837 51.842787,36.435346 51.569517,35.908055 51.556799,35.889369 51.829944))"},{"id":"86","name":"-","type":"region","country_code":"ru","code":"lenkuz","domain":"ru","zoom_level":{"min":9,"max":18},"flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":true},"time_zone":{"offset":420,"name":"Asia/Novokuznetsk"},"bounds":"POLYGON((85.750103 54.768861,86.495701 54.774252,86.502903 54.184679,85.767947 54.179404,85.750103 54.768861))"},{"id":"56","name":"","type":"region","country_code":"ru","code":"lipetsk","domain":"ru","zoom_level":{"min":9,"max":18},"flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":true,"has_net_booklet":true},"time_zone":{"offset":180,"name":"Europe/Moscow"},"bounds":"POLYGON((39.376422 52.719879,39.82336 52.717618,39.819113 52.490547,39.37448 52.49279,39.376422 52.719879))"},{"id":"26","name":"","type":"region","country_code":"ru","code":"magnitogorsk","domain":"ru","zoom_level":{"min":9,"max":18},"flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":true},"time_zone":{"offset":300,"name":"Asia/Yekaterinburg"},"bounds":"POLYGON((58.547823 53.927025,59.504226 53.910884,59.464288 53.229865,58.523119 53.245612,58.547823 53.927025))"},{"id":"87","name":"","type":"region","country_code":"ru","code":"miass","domain":"ru","zoom_level":{"min":9,"max":18},"flags":{"public_transport":true,"metro":false,"road_network":false,"flamp":true},"time_zone":{"offset":300,"name":"Asia/Yekaterinburg"},"bounds":"POLYGON((59.545734 55.280218,60.258398 55.263265,60.228026 54.888193,59.521985 54.904912,59.545734 55.280218))"},{"id":"32","name":"","type":"region","country_code":"ru","code":"moscow","domain":"ru","zoom_level":{"min":9,"max":18},"flags":{"public_transport":true,"metro":true,"road_network":true,"traffic":true,"flamp":true,"has_net_booklet":true},"time_zone":{"offset":180,"name":"Europe/Moscow"},"bounds":"POLYGON((36.758963 56.091685,38.205281 56.109465,38.225024 55.121151,36.814587 55.104013,36.758963 56.091685))"},{"id":"96","name":"","type":"region","country_code":"ru","code":"murmansk","domain":"ru","zoom_level":{"min":9,"max":17},"flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":true},"time_zone":{"offset":180,"name":"Europe/Moscow"},"bounds":"POLYGON((32.701158 69.064619,33.225325 69.064731,33.222253 68.761176,32.705233 68.761065,32.701158 69.064619))"},{"id":"29","name":" ","type":"region","country_code":"ru","code":"nabchelny","domain":"ru","zoom_level":{"min":9,"max":18},"flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":true,"has_net_booklet":true},"time_zone":{"offset":180,"name":"Europe/Moscow"},"bounds":"POLYGON((51.717261 55.865183,52.62818 55.856503,52.614937 55.536675,51.711425 55.545253,51.717261 55.865183))"},{"id":"82","name":"","type":"region","country_code":"ru","code":"nahodka","domain":"ru","zoom_level":{"min":10,"max":18},"flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":true},"time_zone":{"offset":600,"name":"Asia/Vladivostok"},"bounds":"POLYGON((132.750811 42.90212,133.241339 42.91071,133.248191 42.668281,132.759571 42.659764,132.750811 42.90212))"},{"id":"12","name":"","type":"region","country_code":"ru","code":"nizhnevartovsk","domain":"ru","zoom_level":{"min":9,"max":18},"flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":true},"time_zone":{"offset":300,"name":"Asia/Yekaterinburg"},"bounds":"POLYGON((75.931826 61.190935,77.028583 61.178948,77.007766 60.851181,75.922257 60.863009,75.931826 61.190935))"},{"id":"19","name":" ","type":"region","country_code":"ru","code":"n_novgorod","domain":"ru","zoom_level":{"min":9,"max":18},"flags":{"public_transport":true,"metro":true,"road_network":true,"traffic":true,"flamp":true,"has_net_booklet":true},"time_zone":{"offset":180,"name":"Europe/Moscow"},"bounds":"POLYGON((43.297073 56.468016,44.247071 56.477411,44.254811 56.081492,43.31457 56.072236,43.297073 56.468016))"},{"id":"45","name":" ","type":"region","country_code":"ru","code":"ntagil","domain":"ru","zoom_level":{"min":9,"max":18},"flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":true,"has_net_booklet":true},"time_zone":{"offset":300,"name":"Asia/Yekaterinburg"},"bounds":"POLYGON((59.788601 58.091707,60.347887 58.078228,60.317394 57.749299,59.763185 57.762607,59.788601 58.091707))"},{"id":"6","name":"","type":"region","country_code":"ru","code":"novokuznetsk","domain":"ru","zoom_level":{"min":9,"max":18},"flags":{"public_transport":true,"metro":false,"road_network":true,"traffic":true,"flamp":true,"has_net_booklet":true},"time_zone":{"offset":420,"name":"Asia/Novokuznetsk"},"bounds":"POLYGON((86.510624 54.121371,87.463656 54.121473,87.456823 53.497654,86.517836 53.497554,86.510624 54.121371))"},{"id":"74","name":"","type":"region","country_code":"ru","code":"novorossiysk","domain":"ru","zoom_level":{"min":9,"max":18},"flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":true},"time_zone":{"offset":180,"name":"Europe/Moscow"},"bounds":"POLYGON((36.936306 45.204638,38.668167 45.222804,38.673277 44.323572,36.968059 44.305963,36.936306 45.204638))"},{"id":"1","name":"","type":"region","country_code":"ru","code":"novosibirsk","domain":"ru","zoom_level":{"min":9,"max":18},"flags":{"public_transport":true,"metro":true,"road_network":true,"traffic":true,"flamp":true,"has_net_booklet":true},"time_zone":{"offset":360,"name":"Asia/Novosibirsk"},"bounds":"POLYGON((82.532331 55.249038,83.396534 55.235123,83.356355 54.553032,82.506623 54.566601,82.532331 55.249038))"},{"id":"76","name":"","type":"region","country_code":"ru","code":"norilsk","domain":"ru","zoom_level":{"min":9,"max":18},"flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":true},"time_zone":{"offset":420,"name":"Asia/Krasnoyarsk"},"bounds":"POLYGON((85.986318 69.559455,88.551918 69.555507,88.529535 69.242435,86.000942 69.246318,85.986318 69.559455))"},{"id":"103","name":"","type":"region","country_code":"ru","code":"noyabrsk","domain":"ru","zoom_level":{"min":9,"max":18},"flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":true},"time_zone":{"offset":300,"name":"Asia/Yekaterinburg"},"bounds":"POLYGON((74.30478 63.879187,76.263372 63.875343,76.226155 63.018251,74.325265 63.021954,74.30478 63.879187))"},{"id":"14","name":"","type":"region","country_code":"ua","code":"odessa","domain":"ua","zoom_level":{"min":9,"max":18},"flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":false},"time_zone":{"offset":180,"name":"Europe/Kiev"},"bounds":"POLYGON((30.512168 46.64901,30.896094 46.656718,30.911286 46.261025,30.530126 46.253422,30.512168 46.64901))"},{"id":"2","name":"","type":"region","country_code":"ru","code":"omsk","domain":"ru","zoom_level":{"min":9,"max":18},"flags":{"public_transport":true,"metro":false,"road_network":true,"traffic":true,"flamp":true,"has_net_booklet":true},"time_zone":{"offset":360,"name":"Asia/Omsk"},"bounds":"POLYGON((72.883518 55.40568,73.752471 55.417631,73.771665 54.796804,72.916062 54.785124,72.883518 55.40568))"},{"id":"48","name":"","type":"region","country_code":"ru","code":"orenburg","domain":"ru","zoom_level":{"min":9,"max":18},"flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":true,"has_net_booklet":true},"time_zone":{"offset":300,"name":"Asia/Yekaterinburg"},"bounds":"POLYGON((54.920411 51.927322,55.487422 51.935975,55.496231 51.672052,54.932517 51.663479,54.920411 51.927322))"},{"id":"71","name":"","type":"region","country_code":"ru","code":"orel","domain":"ru","zoom_level":{"min":9,"max":18},"flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":true},"time_zone":{"offset":180,"name":"Europe/Moscow"},"bounds":"POLYGON((35.870923 53.103739,36.315298 53.092181,36.295963 52.838995,35.85417 52.850448,35.870923 53.103739))"},{"id":"42","name":"","type":"region","country_code":"ru","code":"penza","domain":"ru","zoom_level":{"min":9,"max":18},"flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":true},"time_zone":{"offset":180,"name":"Europe/Moscow"},"bounds":"POLYGON((44.795477 53.349082,45.358809 53.348717,45.356452 53.065566,44.796821 53.065926,44.795477 53.349082))"},{"id":"16","name":"","type":"region","country_code":"ru","code":"perm","domain":"ru","zoom_level":{"min":9,"max":18},"flags":{"public_transport":true,"metro":false,"road_network":true,"traffic":true,"flamp":true,"has_net_booklet":true},"time_zone":{"offset":300,"name":"Asia/Yekaterinburg"},"bounds":"POLYGON((55.610475 58.236816,56.656815 58.243911,56.66204 57.69294,55.631622 57.685995,55.610475 58.236816))"},{"id":"80","name":"","type":"region","country_code":"ru","code":"petrozavodsk","domain":"ru","zoom_level":{"min":9,"max":18},"flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":true},"time_zone":{"offset":180,"name":"Europe/Moscow"},"bounds":"POLYGON((34.102723 61.959477,34.70885 61.953295,34.694352 61.691472,34.093364 61.697587,34.102723 61.959477))"},{"id":"95","name":"-","type":"region","country_code":"ru","code":"p_kamchatskiy","domain":"ru","zoom_level":{"min":9,"max":17},"flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":true},"time_zone":{"offset":720,"name":"Asia/Kamchatka"},"bounds":"POLYGON((158.195687 53.346954,159.025519 53.349662,159.02523 52.858368,158.204799 52.855708,158.195687 53.346954))"},{"id":"90","name":"","type":"region","country_code":"ru","code":"pskov","domain":"ru","zoom_level":{"min":9,"max":18},"flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":true},"time_zone":{"offset":180,"name":"Europe/Moscow"},"bounds":"POLYGON((28.168619 57.889106,28.491531 57.885724,28.484999 57.727138,28.1635 57.7305,28.168619 57.889106))"},{"id":"89","name":" ()","type":"region","country_code":"ru","code":"minvody","domain":"ru","zoom_level":{"min":9,"max":18},"flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":true},"time_zone":{"offset":180,"name":"Europe/Moscow"},"bounds":"POLYGON((42.596866 44.289522,43.518712 44.305202,43.530679 43.823418,42.616267 43.807998,42.596866 44.289522))"},{"id":"24","name":"--","type":"region","country_code":"ru","code":"rostov","domain":"ru","zoom_level":{"min":9,"max":18},"flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":true,"has_net_booklet":true},"time_zone":{"offset":180,"name":"Europe/Moscow"},"bounds":"POLYGON((39.358722 47.368152,39.924838 47.364983,39.919435 47.053314,39.356627 47.05645,39.358722 47.368152))"},{"id":"44","name":"","type":"region","country_code":"ru","code":"ryazan","domain":"ru","zoom_level":{"min":9,"max":18},"flags":{"public_transport":true,"metro":false,"road_network":true,"traffic":true,"flamp":true,"has_net_booklet":true},"time_zone":{"offset":180,"name":"Europe/Moscow"},"bounds":"POLYGON((39.40589 54.882191,39.992107 54.878818,39.982606 54.487343,39.402002 54.490668,39.40589 54.882191))"},{"id":"18","name":"","type":"region","country_code":"ru","code":"samara","domain":"ru","zoom_level":{"min":9,"max":18},"flags":{"public_transport":true,"metro":true,"road_network":true,"traffic":true,"flamp":true,"has_net_booklet":true},"time_zone":{"offset":240,"name":"Europe/Samara"},"bounds":"POLYGON((49.777726 53.708125,50.516957 53.713386,50.524471 53.044185,49.796735 53.03905,49.777726 53.708125))"},{"id":"38","name":"-","type":"region","country_code":"ru","code":"spb","domain":"ru","zoom_level":{"min":9,"max":18},"flags":{"public_transport":true,"metro":true,"road_network":true,"traffic":true,"flamp":true,"has_net_booklet":true},"time_zone":{"offset":180,"name":"Europe/Moscow"},"bounds":"POLYGON((29.410888 60.259339,30.98445 60.292561,31.027971 59.567535,29.488251 59.535262,29.410888 60.259339))"},{"id":"85","name":"","type":"region","country_code":"ru","code":"saransk","domain":"ru","zoom_level":{"min":9,"max":18},"flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":true},"time_zone":{"offset":180,"name":"Europe/Moscow"},"bounds":"POLYGON((44.867017 54.301903,45.51172 54.300891,45.507836 53.984632,44.868026 53.985633,44.867017 54.301903))"},{"id":"43","name":"","type":"region","country_code":"ru","code":"saratov","domain":"ru","zoom_level":{"min":9,"max":18},"flags":{"public_transport":true,"metro":false,"road_network":true,"traffic":true,"flamp":true,"has_net_booklet":true},"time_zone":{"offset":180,"name":"Europe/Moscow"},"bounds":"POLYGON((45.7361 51.699809,46.314773 51.694758,46.304971 51.353163,45.730611 51.358153,45.7361 51.699809))"},{"id":"63","name":"","type":"region","country_code":"ru","code":"smolensk","domain":"ru","zoom_level":{"min":9,"max":18},"flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":true},"time_zone":{"offset":180,"name":"Europe/Moscow"},"bounds":"POLYGON((31.755002 54.885154,32.265103 54.889311,32.268673 54.692002,31.761048 54.687875,31.755002 54.885154))"},{"id":"30","name":"","type":"region","country_code":"ru","code":"sochi","domain":"ru","zoom_level":{"min":9,"max":18},"flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":true},"time_zone":{"offset":180,"name":"Europe/Moscow"},"bounds":"POLYGON((38.93648 44.354812,40.488511 44.34513,40.464281 43.36325,38.937514 43.372607,38.93648 44.354812))"},{"id":"57","name":"","type":"region","country_code":"ru","code":"stavropol","domain":"ru","zoom_level":{"min":9,"max":18},"flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":true},"time_zone":{"offset":180,"name":"Europe/Moscow"},"bounds":"POLYGON((41.658117 45.252393,42.307255 45.269558,42.324115 44.909882,41.679025 44.89293,41.658117 45.252393))"},{"id":"60","name":" ","type":"region","country_code":"ru","code":"staroskol","domain":"ru","zoom_level":{"min":10,"max":18},"flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":true},"time_zone":{"offset":180,"name":"Europe/Moscow"},"bounds":"POLYGON((37.744862 51.375661,37.979312 51.377938,37.982166 51.249129,37.748371 51.246862,37.744862 51.375661))"},{"id":"54","name":"","type":"region","country_code":"ru","code":"sterlitamak","domain":"ru","zoom_level":{"min":9,"max":18},"flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":true},"time_zone":{"offset":300,"name":"Asia/Yekaterinburg"},"bounds":"POLYGON((55.805672 53.734238,56.123975 53.736987,56.13283 53.305583,55.817744 53.302876,55.805672 53.734238))"},{"id":"39","name":"","type":"region","country_code":"ru","code":"surgut","domain":"ru","zoom_level":{"min":9,"max":18},"flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":true},"time_zone":{"offset":300,"name":"Asia/Yekaterinburg"},"bounds":"POLYGON((72.38176 61.388553,73.781358 61.408288,73.797164 60.996565,72.41568 60.977161,72.38176 61.388553))"},{"id":"72","name":"","type":"region","country_code":"ru","code":"syktyvkar","domain":"ru","zoom_level":{"min":9,"max":18},"flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":true},"time_zone":{"offset":180,"name":"Europe/Moscow"},"bounds":"POLYGON((50.431525 61.921812,51.27508 61.92271,51.271963 61.571227,50.437968 61.570342,50.431525 61.921812))"},{"id":"81","name":"","type":"region","country_code":"ru","code":"tambov","domain":"ru","zoom_level":{"min":9,"max":18},"flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":true},"time_zone":{"offset":180,"name":"Europe/Moscow"},"bounds":"POLYGON((41.282289 52.826563,41.60158 52.819991,41.58624 52.561316,41.268828 52.567827,41.282289 52.826563))"},{"id":"47","name":"","type":"region","country_code":"ru","code":"tver","domain":"ru","zoom_level":{"min":9,"max":17},"flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":true,"has_net_booklet":true},"time_zone":{"offset":180,"name":"Europe/Moscow"},"bounds":"POLYGON((35.531082 56.998794,36.290293 57.017546,36.3143 56.68411,35.561787 56.665594,35.531082 56.998794))"},{"id":"97","name":"","type":"region","country_code":"ru","code":"tobolsk","domain":"ru","zoom_level":{"min":9,"max":17},"flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":true},"time_zone":{"offset":300,"name":"Asia/Yekaterinburg"},"bounds":"POLYGON((68.027461 58.334051,68.627747 58.337205,68.630591 58.064257,68.03489 58.061137,68.027461 58.334051))"},{"id":"22","name":"","type":"region","country_code":"ru","code":"togliatti","domain":"ru","zoom_level":{"min":9,"max":18},"flags":{"public_transport":true,"metro":false,"road_network":true,"traffic":true,"flamp":true},"time_zone":{"offset":240,"name":"Europe/Samara"},"bounds":"POLYGON((48.961827 53.69702,49.777726 53.708125,49.796735 53.03905,48.993508 53.028211,48.961827 53.69702))"},{"id":"3","name":"","type":"region","country_code":"ru","code":"tomsk","domain":"ru","zoom_level":{"min":9,"max":18},"flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":true,"has_net_booklet":true},"time_zone":{"offset":360,"name":"Asia/Omsk"},"bounds":"POLYGON((84.768656 56.588195,85.235419 56.595694,85.246532 56.355457,84.782704 56.348026,84.768656 56.588195))"},{"id":"36","name":"","type":"region","country_code":"ru","code":"tula","domain":"ru","zoom_level":{"min":9,"max":18},"flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":true},"time_zone":{"offset":180,"name":"Europe/Moscow"},"bounds":"POLYGON((37.414045 54.309532,38.415847 54.318543,38.421585 53.908416,37.429616 53.899539,37.414045 54.309532))"},{"id":"13","name":"","type":"region","country_code":"ru","code":"tyumen","domain":"ru","zoom_level":{"min":9,"max":18},"flags":{"public_transport":true,"metro":false,"road_network":true,"traffic":true,"flamp":true,"has_net_booklet":true},"time_zone":{"offset":300,"name":"Asia/Yekaterinburg"},"bounds":"POLYGON((65.263355 57.26989,66.690851 57.236046,66.609235 56.397678,65.213221 56.430463,65.263355 57.26989))"},{"id":"37","name":"-","type":"region","country_code":"ru","code":"ulanude","domain":"ru","zoom_level":{"min":9,"max":18},"flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":true},"time_zone":{"offset":480,"name":"Asia/Irkutsk"},"bounds":"POLYGON((107.376889 52.056483,107.990789 52.042492,107.96757 51.691351,107.358424 51.705168,107.376889 52.056483))"},{"id":"55","name":"","type":"region","country_code":"ru","code":"ulyanovsk","domain":"ru","zoom_level":{"min":9,"max":18},"flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":true,"has_net_booklet":true},"time_zone":{"offset":180,"name":"Europe/Moscow"},"bounds":"POLYGON((48.031111 54.455092,48.755444 54.470724,48.774425 54.120417,48.056197 54.104983,48.031111 54.455092))"},{"id":"83","name":"","type":"region","country_code":"ru","code":"ussuriysk","domain":"ru","zoom_level":{"min":9,"max":18},"flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":true},"time_zone":{"offset":600,"name":"Asia/Vladivostok"},"bounds":"POLYGON((131.749241 43.961672,132.129905 43.971877,132.142052 43.718194,131.762993 43.708079,131.749241 43.961672))"},{"id":"91","name":"-","type":"region","country_code":"kz","code":"ustkam","domain":"kz","zoom_level":{"min":9,"max":18},"flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":false},"time_zone":{"offset":360,"name":"Asia/Qyzylorda"},"bounds":"POLYGON((82.450724 50.059192,82.805718 50.054212,82.798391 49.857959,82.444837 49.862905,82.450724 50.059192))"},{"id":"17","name":"","type":"region","country_code":"ru","code":"ufa","domain":"ru","zoom_level":{"min":9,"max":18},"flags":{"public_transport":true,"metro":false,"road_network":true,"traffic":true,"flamp":true},"time_zone":{"offset":300,"name":"Asia/Yekaterinburg"},"bounds":"POLYGON((55.715089999999996 54.952485,56.304346 54.957284,56.312416 54.48324,55.729992 54.478524,55.715089999999996 54.952485))"},{"id":"35","name":"","type":"region","country_code":"ru","code":"khabarovsk","domain":"ru","zoom_level":{"min":9,"max":18},"flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":true},"time_zone":{"offset":600,"name":"Asia/Vladivostok"},"bounds":"POLYGON((134.873582 48.607104,135.259036 48.606882,135.257422 48.288578,134.87437 48.288797,134.873582 48.607104))"},{"id":"110","name":"","type":"region","country_code":"ua","code":"kharkov","domain":"ua","zoom_level":{"min":9,"max":17},"flags":{"public_transport":true,"metro":true,"road_network":true,"flamp":false},"time_zone":{"offset":180,"name":"Europe/Kiev"},"bounds":"POLYGON((36.031103 50.115121,36.467033 50.125456,36.481687 49.845767,36.048271 49.835534,36.031103 50.115121))"},{"id":"53","name":"","type":"region","country_code":"ru","code":"cheboksary","domain":"ru","zoom_level":{"min":9,"max":18},"flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":true},"time_zone":{"offset":180,"name":"Europe/Moscow"},"bounds":"POLYGON((47.00778 56.342026,47.60576 56.33089,47.58216 55.980845,46.989586 55.991836,47.00778 56.342026))"},{"id":"15","name":"","type":"region","country_code":"ru","code":"chelyabinsk","domain":"ru","zoom_level":{"min":9,"max":18},"flags":{"public_transport":true,"metro":false,"road_network":true,"traffic":true,"flamp":true,"has_net_booklet":true},"time_zone":{"offset":300,"name":"Asia/Yekaterinburg"},"bounds":"POLYGON((61.185486 55.312905,61.734408 55.319826,61.74458 54.997301,61.200066 54.990462,61.185486 55.312905))"},{"id":"64","name":"","type":"region","country_code":"ru","code":"chita","domain":"ru","zoom_level":{"min":9,"max":18},"flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":true},"time_zone":{"offset":480,"name":"Asia/Chita"},"bounds":"POLYGON((113.113845 52.186114,113.639184 52.175527,113.624543 51.926502,113.102112 51.936996,113.113845 52.186114))"},{"id":"88","name":"-","type":"region","country_code":"ru","code":"yuzhnosakhalinsk","domain":"ru","zoom_level":{"min":9,"max":18},"flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":true},"time_zone":{"offset":600,"name":"Asia/Vladivostok"},"bounds":"POLYGON((142.47294 47.515634,142.971758 47.50814,142.937954 46.583209,142.44768 46.590465,142.47294 47.515634))"},{"id":"50","name":"","type":"region","country_code":"ru","code":"yakutsk","domain":"ru","zoom_level":{"min":9,"max":18},"flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":true},"time_zone":{"offset":540,"name":"Asia/Yakutsk"},"bounds":"POLYGON((129.532475 62.187831,129.992303 62.185302,129.979868 61.800501,129.525802 61.80299,129.532475 62.187831))"},{"id":"28","name":"","type":"region","country_code":"ru","code":"yaroslavl","domain":"ru","zoom_level":{"min":9,"max":18},"flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":true},"time_zone":{"offset":180,"name":"Europe/Moscow"},"bounds":"POLYGON((39.722892 57.776199,40.012883 57.774213,40.005807 57.519309,39.717841 57.521275,39.722892 57.776199))"}]')}(this, document));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInZlbmRvcnMvbGVhZmxldC9kaXN0L2xlYWZsZXQtc3JjLmpzIiwibm9kZV9tb2R1bGVzL2h0bWw1c2hpdi9kaXN0L2h0bWw1c2hpdi5qcyIsInZlbmRvcnMvcG9seWZpbGxzL2VzNS5qcyIsInZlbmRvcnMvcG9seWZpbGxzL3Byb21pc2UuanMiLCJzcmMvREdDb3JlL3NyYy9ER0NvcmUuanMiLCJzcmMvREdDb3JlL3NyYy9ER3RoZW4uanMiLCJzcmMvREdDb3JlL3NyYy9ER3BsdWdpbi5qcyIsInNyYy9ER0FqYXgvc3JjL0RHQWpheC5qcyIsInNyYy9ER0xhYmVsL3NyYy9ER0xhYmVsLmpzIiwic3JjL0RHTGFiZWwvc3JjL01hcmtlci5ER0xhYmVsLmpzIiwic3JjL0RHTGFiZWwvc3JjL1BhdGguREdMYWJlbC5qcyIsInNyYy9ER1drdC9ER1drdC5qcyIsInNyYy9ER1BvcHVwL3NraW4vYmFzaWMvc2tpbi5jb25maWcuanMiLCJ2ZW5kb3JzL2Jhcm9uL2Jhcm9uLmpzIiwic3JjL0RHUG9wdXAvc3JjL0RHUG9wdXAuanMiLCJzcmMvREdMb2NhbGUvc3JjL0RHRGljdGlvbmFyeS5qcyIsInNyYy9ER0xvY2FsZS9zcmMvREdMb2NhbGUuanMiLCJzcmMvREdSb3VuZENvbnRyb2wvc3JjL0RHUm91bmRDb250cm9sLmpzIiwic3JjL0RHUHJvamVjdERldGVjdG9yL3NyYy9ER1Byb2plY3REZXRlY3Rvci5qcyIsInNyYy9ER0N1c3RvbWl6YXRpb24vc2tpbi9iYXNpYy9za2luLmNvbmZpZy5qcyIsInNyYy9ER0N1c3RvbWl6YXRpb24vc3JjL0RHQ3VzdG9taXphdGlvbi5qcyIsInNyYy9ER0N1c3RvbWl6YXRpb24vc3JjL0RHTWFwLmpzIiwic3JjL0RHQ3VzdG9taXphdGlvbi9zcmMvREdNYXAuQmFzZUxheWVyLmpzIiwic3JjL0RHWm9vbUNvbnRyb2wvc3JjL0RHWm9vbUNvbnRyb2wuanMiLCJzcmMvREdab29tQ29udHJvbC9sYW5nL3J1LmpzIiwic3JjL0RHWm9vbUNvbnRyb2wvbGFuZy9pdC5qcyIsInNyYy9ER1pvb21Db250cm9sL2xhbmcvY3MuanMiLCJzcmMvREdab29tQ29udHJvbC9sYW5nL2VuLmpzIiwic3JjL0RHWm9vbUNvbnRyb2wvbGFuZy9lcy5qcyIsIm5vZGVfbW9kdWxlcy9kdXN0anMtbGlua2VkaW4vZGlzdC9kdXN0LWNvcmUuanMiLCJub2RlX21vZHVsZXMvZHVzdGpzLWhlbHBlcnMvZGlzdC9kdXN0LWhlbHBlcnMuanMiLCJzcmMvREdEdXN0L3NyYy9ER0R1c3QuanMiLCJzcmMvREdBdHRyaWJ1dGlvbi9zcmMvREdBdHRyaWJ1dGlvbi5qcyIsInNyYy9ER0F0dHJpYnV0aW9uL2xhbmcvcnUuanMiLCJzcmMvREdBdHRyaWJ1dGlvbi9sYW5nL2l0LmpzIiwic3JjL0RHQXR0cmlidXRpb24vbGFuZy9jcy5qcyIsInNyYy9ER0F0dHJpYnV0aW9uL2xhbmcvZW4uanMiLCJzcmMvREdBdHRyaWJ1dGlvbi9sYW5nL2VzLmpzIiwic3JjL0RHTG9jYXRpb24vc3JjL0RHTG9jYXRpb24uanMiLCJzcmMvREdMb2NhdGlvbi9sYW5nL3J1LmpzIiwic3JjL0RHTG9jYXRpb24vbGFuZy9pdC5qcyIsInNyYy9ER0xvY2F0aW9uL2xhbmcvY3MuanMiLCJzcmMvREdMb2NhdGlvbi9sYW5nL2VuLmpzIiwic3JjL0RHTG9jYXRpb24vbGFuZy9lcy5qcyIsInNyYy9ER0Z1bGxTY3JlZW4vc3JjL0RHU2NyZWVuZnVsbC5qcyIsInNyYy9ER0Z1bGxTY3JlZW4vc3JjL0RHRnVsbFNjcmVlbi5qcyIsInNyYy9ER0Z1bGxTY3JlZW4vbGFuZy9ydS5qcyIsInNyYy9ER0Z1bGxTY3JlZW4vbGFuZy9pdC5qcyIsInNyYy9ER0Z1bGxTY3JlZW4vbGFuZy9jcy5qcyIsInNyYy9ER0Z1bGxTY3JlZW4vbGFuZy9lbi5qcyIsInNyYy9ER0Z1bGxTY3JlZW4vbGFuZy9lcy5qcyIsInNyYy9ER01ldGEvc3JjL0RHTWV0YS5MYXllci5qcyIsInNyYy9ER01ldGEvc3JjL0RHTWV0YS5PcmlnaW4uanMiLCJzcmMvREdNZXRhL3NyYy9Qb2x5VXRpbENvbnRhaW5zLmpzIiwic3JjL0RHUG9pL3NyYy9ER1BvaS5qcyIsInNyYy9ER0VudHJhbmNlL3NyYy9ER0VudHJhbmNlLmpzIiwic3JjL0RHRW50cmFuY2Uvc3JjL1BhdGhBbmltYXRpb24uanMiLCJzcmMvREdFbnRyYW5jZS9zcmMvQXJyb3cuanMiLCJzcmMvREdFbnRyYW5jZS9zcmMvQXJyb3dTVkcuanMiLCJzcmMvREdFbnRyYW5jZS9zcmMvQXJyb3dTVkcuVk1MLmpzIiwic3JjL0RHRW50cmFuY2Uvc3JjL0Fycm93U3ZnQW5pbWF0aW9uT3B0aW9ucy5qcyIsInNyYy9ER0VudHJhbmNlL3NyYy9FdmVudEhhbmRsZXIuanMiLCJzcmMvREdHZW9jbGlja2VyL3NyYy9ER0dlb2NsaWNrZXIuanMiLCJzcmMvREdHZW9jbGlja2VyL3NyYy9DbGFtcEhlbHBlci5qcyIsInNyYy9ER0dlb2NsaWNrZXIvc3JjL3Byb3ZpZGVyL1Byb3ZpZGVyLmpzIiwic3JjL0RHR2VvY2xpY2tlci9zcmMvcHJvdmlkZXIvQ2F0YWxvZ0FwaS5qcyIsInNyYy9ER0dlb2NsaWNrZXIvc3JjL2hhbmRsZXIvSGFuZGxlci5qcyIsInNyYy9ER0dlb2NsaWNrZXIvc3JjL2hhbmRsZXIvRGVmYXVsdC5qcyIsInNyYy9ER0dlb2NsaWNrZXIvc3JjL2hhbmRsZXIvQXBpRXJyb3IuanMiLCJzcmMvREdHZW9jbGlja2VyL3NyYy9oYW5kbGVyL0NpdHlBcmVhLmpzIiwic3JjL0RHR2VvY2xpY2tlci9zcmMvaGFuZGxlci9Ib3VzZS5qcyIsInNyYy9ER0dlb2NsaWNrZXIvc3JjL2hhbmRsZXIvSG91c2UuVmlldy5qcyIsInNyYy9ER0dlb2NsaWNrZXIvc3JjL2hhbmRsZXIvUE9JLmpzIiwic3JjL0RHR2VvY2xpY2tlci9zcmMvaGFuZGxlci9TaWdodC5qcyIsInNyYy9ER0dlb2NsaWNrZXIvc3JjL1ZpZXcuanMiLCJzcmMvREdHZW9jbGlja2VyL3NyYy9Db250cm9sbGVyLmpzIiwic3JjL0RHR2VvY2xpY2tlci9sYW5nL2l0LmpzIiwic3JjL0RHR2VvY2xpY2tlci9sYW5nL3J1LmpzIiwic3JjL0RHR2VvY2xpY2tlci9sYW5nL2VuLmpzIiwic3JjL0RHR2VvY2xpY2tlci9sYW5nL2NzLmpzIiwic3JjL0RHR2VvY2xpY2tlci9sYW5nL2VzLmpzIiwidmVuZG9ycy9maXJtY2FyZC9zcmMvRmlybUNhcmQuanMiLCJ2ZW5kb3JzL2Zpcm1jYXJkL3NyYy9GaXJtQ2FyZC5EYXRhSGVscGVyLmpzIiwidmVuZG9ycy9maXJtY2FyZC9zcmMvRmlybUxpc3QuanMiLCJ2ZW5kb3JzL2Zpcm1jYXJkL3NyYy9TY2hlZHVsZS5qcyIsInZlbmRvcnMvZmlybWNhcmQvc3JjL0RpY3Rpb25hcnkuanMiLCJzcmMvREdUcmFmZmljL3NyYy9ER1RyYWZmaWMuanMiLCJzcmMvREdUcmFmZmljL2xhbmcvcnUuanMiLCJzcmMvREdUcmFmZmljL2xhbmcvaXQuanMiLCJzcmMvREdUcmFmZmljL2xhbmcvY3MuanMiLCJzcmMvREdUcmFmZmljL2xhbmcvZXMuanMiLCJzcmMvREdUcmFmZmljL2xhbmcvZW4uanMiLCJzcmMvREdUcmFmZmljQ29udHJvbC9zcmMvQ29udHJvbC5UcmFmZmljLmpzIiwic3JjL0RHVHJhZmZpY0NvbnRyb2wvbGFuZy9ydS5qcyIsInNyYy9ER1RyYWZmaWNDb250cm9sL2xhbmcvaXQuanMiLCJzcmMvREdUcmFmZmljQ29udHJvbC9sYW5nL2NzLmpzIiwic3JjL0RHVHJhZmZpY0NvbnRyb2wvbGFuZy9lcy5qcyIsInNyYy9ER1RyYWZmaWNDb250cm9sL2xhbmcvZW4uanMiLCJzcmMvREdSdWxlci9zcmMvUnVsZXIuanMiLCJzcmMvREdSdWxlci9zcmMvTGF5ZXJlZE1hcmtlci5qcyIsInNyYy9ER1J1bGVyL3NyYy9HZW9tZXRyeVN0eWxlcy5qcyIsInNyYy9ER1J1bGVyL2xhbmcvcnUuanMiLCJzcmMvREdSdWxlci9sYW5nL2l0LmpzIiwic3JjL0RHUnVsZXIvbGFuZy9jcy5qcyIsInNyYy9ER1J1bGVyL2xhbmcvZXMuanMiLCJzcmMvREdSdWxlci9sYW5nL2VuLmpzIiwic3JjL0RHUnVsZXJDb250cm9sL3NyYy9Db250cm9sLlJ1bGVyLmpzIiwic3JjL0RHUnVsZXJDb250cm9sL2xhbmcvcnUuanMiLCJzcmMvREdSdWxlckNvbnRyb2wvbGFuZy9pdC5qcyIsInNyYy9ER1J1bGVyQ29udHJvbC9sYW5nL2NzLmpzIiwic3JjL0RHUnVsZXJDb250cm9sL2xhbmcvZXMuanMiLCJzcmMvREdSdWxlckNvbnRyb2wvbGFuZy9lbi5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNsaVJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNsVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ2xVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUM5cUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNuRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDN0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDbGNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUN6SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3JJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUM5TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUN0OEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ2hwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUM5RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUM3TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNoSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3JPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUN2REE7QUFDQTtBQUNBO0FBQ0E7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDMzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDaGxCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUN2SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUMzUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDL0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNuRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUM3S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUN4SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQzFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDcEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUN0VEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ2hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDaEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDaklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUMzSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDN0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNyRkE7QUFDQTtBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDakxBO0FBQ0E7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDcEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUM1R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3hSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNuSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDNUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3JHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3pKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQzlZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDekxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDanZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNqY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ2hOQTtBQUNBO0FBQ0E7QUNGQTtBQUNBO0FBQ0E7QUNGQTtBQUNBO0FBQ0E7QUNGQTtBQUNBO0FBQ0E7QUNGQTtBQUNBO0FBQ0E7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQzlIQTtBQUNBO0FBQ0E7QUFDQTtBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUMvcUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUMxR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUM3RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUMzRUE7QUFDQTtBQUNBO0FDRkE7QUFDQTtBQUNBO0FDRkE7QUFDQTtBQUNBO0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUNIQTtBQUNBO0FBQ0EiLCJmaWxlIjoic2NyaXB0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXHJcbnZhciBMID0ge1xyXG5cdHZlcnNpb246ICcwLjgtZGV2J1xyXG59O1xyXG5cclxuZnVuY3Rpb24gZXhwb3NlKCkge1xyXG5cdHZhciBvbGRMID0gd2luZG93Lkw7XHJcblxyXG5cdEwubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdHdpbmRvdy5MID0gb2xkTDtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH07XHJcblxyXG5cdHdpbmRvdy5MID0gTDtcclxufVxyXG5cclxuLy8gZGVmaW5lIExlYWZsZXQgZm9yIE5vZGUgbW9kdWxlIHBhdHRlcm4gbG9hZGVycywgaW5jbHVkaW5nIEJyb3dzZXJpZnlcclxuaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcclxuXHRtb2R1bGUuZXhwb3J0cyA9IEw7XHJcblxyXG4vLyBkZWZpbmUgTGVhZmxldCBhcyBhbiBBTUQgbW9kdWxlXHJcbn0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XHJcblx0ZGVmaW5lKEwpO1xyXG5cclxuLy8gZGVmaW5lIExlYWZsZXQgYXMgYSBnbG9iYWwgTCB2YXJpYWJsZSwgc2F2aW5nIHRoZSBvcmlnaW5hbCBMIHRvIHJlc3RvcmUgbGF0ZXIgaWYgbmVlZGVkXHJcbn0gZWxzZSB7XHJcblx0ZXhwb3NlKCk7XHJcbn1cclxuXG4vKlxyXG4gKiBMLlV0aWwgY29udGFpbnMgdmFyaW91cyB1dGlsaXR5IGZ1bmN0aW9ucyB1c2VkIHRocm91Z2hvdXQgTGVhZmxldCBjb2RlLlxyXG4gKi9cclxuXHJcbkwuVXRpbCA9IHtcclxuXHQvLyBleHRlbmQgYW4gb2JqZWN0IHdpdGggcHJvcGVydGllcyBvZiBvbmUgb3IgbW9yZSBvdGhlciBvYmplY3RzXHJcblx0ZXh0ZW5kOiBmdW5jdGlvbiAoZGVzdCkge1xyXG5cdFx0dmFyIHNvdXJjZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpLFxyXG5cdFx0ICAgIGksIGosIGxlbiwgc3JjO1xyXG5cclxuXHRcdGZvciAoaiA9IDAsIGxlbiA9IHNvdXJjZXMubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcclxuXHRcdFx0c3JjID0gc291cmNlc1tqXTtcclxuXHRcdFx0Zm9yIChpIGluIHNyYykge1xyXG5cdFx0XHRcdGRlc3RbaV0gPSBzcmNbaV07XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiBkZXN0O1xyXG5cdH0sXHJcblxyXG5cdC8vIGNyZWF0ZSBhbiBvYmplY3QgZnJvbSBhIGdpdmVuIHByb3RvdHlwZVxyXG5cdGNyZWF0ZTogT2JqZWN0LmNyZWF0ZSB8fCAoZnVuY3Rpb24gKCkge1xyXG5cdFx0ZnVuY3Rpb24gRigpIHt9XHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gKHByb3RvKSB7XHJcblx0XHRcdEYucHJvdG90eXBlID0gcHJvdG87XHJcblx0XHRcdHJldHVybiBuZXcgRigpO1xyXG5cdFx0fTtcclxuXHR9KSgpLFxyXG5cclxuXHQvLyBiaW5kIGEgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdpdGggYSBnaXZlbiBjb250ZXh0XHJcblx0YmluZDogZnVuY3Rpb24gKGZuLCBvYmopIHtcclxuXHRcdHZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcclxuXHJcblx0XHRpZiAoZm4uYmluZCkge1xyXG5cdFx0XHRyZXR1cm4gZm4uYmluZC5hcHBseShmbiwgc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRyZXR1cm4gZm4uYXBwbHkob2JqLCBhcmdzLmxlbmd0aCA/IGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSkgOiBhcmd1bWVudHMpO1xyXG5cdFx0fTtcclxuXHR9LFxyXG5cclxuXHQvLyByZXR1cm4gdW5pcXVlIElEIG9mIGFuIG9iamVjdFxyXG5cdHN0YW1wOiBmdW5jdGlvbiAob2JqKSB7XHJcblx0XHQvLyBqc2hpbnQgY2FtZWxjYXNlOiBmYWxzZVxyXG5cdFx0b2JqLl9sZWFmbGV0X2lkID0gb2JqLl9sZWFmbGV0X2lkIHx8ICsrTC5VdGlsLmxhc3RJZDtcclxuXHRcdHJldHVybiBvYmouX2xlYWZsZXRfaWQ7XHJcblx0fSxcclxuXHJcblx0bGFzdElkOiAwLFxyXG5cclxuXHQvLyByZXR1cm4gYSBmdW5jdGlvbiB0aGF0IHdvbid0IGJlIGNhbGxlZCBtb3JlIG9mdGVuIHRoYW4gdGhlIGdpdmVuIGludGVydmFsXHJcblx0dGhyb3R0bGU6IGZ1bmN0aW9uIChmbiwgdGltZSwgY29udGV4dCkge1xyXG5cdFx0dmFyIGxvY2ssIGFyZ3MsIHdyYXBwZXJGbiwgbGF0ZXI7XHJcblxyXG5cdFx0bGF0ZXIgPSBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdC8vIHJlc2V0IGxvY2sgYW5kIGNhbGwgaWYgcXVldWVkXHJcblx0XHRcdGxvY2sgPSBmYWxzZTtcclxuXHRcdFx0aWYgKGFyZ3MpIHtcclxuXHRcdFx0XHR3cmFwcGVyRm4uYXBwbHkoY29udGV4dCwgYXJncyk7XHJcblx0XHRcdFx0YXJncyA9IGZhbHNlO1xyXG5cdFx0XHR9XHJcblx0XHR9O1xyXG5cclxuXHRcdHdyYXBwZXJGbiA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0aWYgKGxvY2spIHtcclxuXHRcdFx0XHQvLyBjYWxsZWQgdG9vIHNvb24sIHF1ZXVlIHRvIGNhbGwgbGF0ZXJcclxuXHRcdFx0XHRhcmdzID0gYXJndW1lbnRzO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHQvLyBjYWxsIGFuZCBsb2NrIHVudGlsIGxhdGVyXHJcblx0XHRcdFx0Zm4uYXBwbHkoY29udGV4dCwgYXJndW1lbnRzKTtcclxuXHRcdFx0XHRzZXRUaW1lb3V0KGxhdGVyLCB0aW1lKTtcclxuXHRcdFx0XHRsb2NrID0gdHJ1ZTtcclxuXHRcdFx0fVxyXG5cdFx0fTtcclxuXHJcblx0XHRyZXR1cm4gd3JhcHBlckZuO1xyXG5cdH0sXHJcblxyXG5cdC8vIHdyYXAgdGhlIGdpdmVuIG51bWJlciB0byBsaWUgd2l0aGluIGEgY2VydGFpbiByYW5nZSAodXNlZCBmb3Igd3JhcHBpbmcgbG9uZ2l0dWRlKVxyXG5cdHdyYXBOdW06IGZ1bmN0aW9uICh4LCByYW5nZSwgaW5jbHVkZU1heCkge1xyXG5cdFx0dmFyIG1heCA9IHJhbmdlWzFdLFxyXG5cdFx0ICAgIG1pbiA9IHJhbmdlWzBdLFxyXG5cdFx0ICAgIGQgPSBtYXggLSBtaW47XHJcblx0XHRyZXR1cm4geCA9PT0gbWF4ICYmIGluY2x1ZGVNYXggPyB4IDogKCh4IC0gbWluKSAlIGQgKyBkKSAlIGQgKyBtaW47XHJcblx0fSxcclxuXHJcblx0Ly8gZG8gbm90aGluZyAodXNlZCBhcyBhIG5vb3AgdGhyb3VnaG91dCB0aGUgY29kZSlcclxuXHRmYWxzZUZuOiBmdW5jdGlvbiAoKSB7IHJldHVybiBmYWxzZTsgfSxcclxuXHJcblx0Ly8gcm91bmQgYSBnaXZlbiBudW1iZXIgdG8gYSBnaXZlbiBwcmVjaXNpb25cclxuXHRmb3JtYXROdW06IGZ1bmN0aW9uIChudW0sIGRpZ2l0cykge1xyXG5cdFx0dmFyIHBvdyA9IE1hdGgucG93KDEwLCBkaWdpdHMgfHwgNSk7XHJcblx0XHRyZXR1cm4gTWF0aC5yb3VuZChudW0gKiBwb3cpIC8gcG93O1xyXG5cdH0sXHJcblxyXG5cdC8vIHRyaW0gd2hpdGVzcGFjZSBmcm9tIGJvdGggc2lkZXMgb2YgYSBzdHJpbmdcclxuXHR0cmltOiBmdW5jdGlvbiAoc3RyKSB7XHJcblx0XHRyZXR1cm4gc3RyLnRyaW0gPyBzdHIudHJpbSgpIDogc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKTtcclxuXHR9LFxyXG5cclxuXHQvLyBzcGxpdCBhIHN0cmluZyBpbnRvIHdvcmRzXHJcblx0c3BsaXRXb3JkczogZnVuY3Rpb24gKHN0cikge1xyXG5cdFx0cmV0dXJuIEwuVXRpbC50cmltKHN0cikuc3BsaXQoL1xccysvKTtcclxuXHR9LFxyXG5cclxuXHQvLyBzZXQgb3B0aW9ucyB0byBhbiBvYmplY3QsIGluaGVyaXRpbmcgcGFyZW50J3Mgb3B0aW9ucyBhcyB3ZWxsXHJcblx0c2V0T3B0aW9uczogZnVuY3Rpb24gKG9iaiwgb3B0aW9ucykge1xyXG5cdFx0aWYgKCFvYmouaGFzT3duUHJvcGVydHkoJ29wdGlvbnMnKSkge1xyXG5cdFx0XHRvYmoub3B0aW9ucyA9IG9iai5vcHRpb25zID8gTC5VdGlsLmNyZWF0ZShvYmoub3B0aW9ucykgOiB7fTtcclxuXHRcdH1cclxuXHRcdGZvciAodmFyIGkgaW4gb3B0aW9ucykge1xyXG5cdFx0XHRvYmoub3B0aW9uc1tpXSA9IG9wdGlvbnNbaV07XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gb2JqLm9wdGlvbnM7XHJcblx0fSxcclxuXHJcblx0Ly8gbWFrZSBhbiBVUkwgd2l0aCBHRVQgcGFyYW1ldGVycyBvdXQgb2YgYSBzZXQgb2YgcHJvcGVydGllcy92YWx1ZXNcclxuXHRnZXRQYXJhbVN0cmluZzogZnVuY3Rpb24gKG9iaiwgZXhpc3RpbmdVcmwsIHVwcGVyY2FzZSkge1xyXG5cdFx0dmFyIHBhcmFtcyA9IFtdO1xyXG5cdFx0Zm9yICh2YXIgaSBpbiBvYmopIHtcclxuXHRcdFx0cGFyYW1zLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KHVwcGVyY2FzZSA/IGkudG9VcHBlckNhc2UoKSA6IGkpICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KG9ialtpXSkpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuICgoIWV4aXN0aW5nVXJsIHx8IGV4aXN0aW5nVXJsLmluZGV4T2YoJz8nKSA9PT0gLTEpID8gJz8nIDogJyYnKSArIHBhcmFtcy5qb2luKCcmJyk7XHJcblx0fSxcclxuXHJcblx0Ly8gc3VwZXItc2ltcGxlIHRlbXBsYXRpbmcgZmFjaWxpdHksIHVzZWQgZm9yIFRpbGVMYXllciBVUkxzXHJcblx0dGVtcGxhdGU6IGZ1bmN0aW9uIChzdHIsIGRhdGEpIHtcclxuXHRcdHJldHVybiBzdHIucmVwbGFjZShMLlV0aWwudGVtcGxhdGVSZSwgZnVuY3Rpb24gKHN0ciwga2V5KSB7XHJcblx0XHRcdHZhciB2YWx1ZSA9IGRhdGFba2V5XTtcclxuXHJcblx0XHRcdGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdObyB2YWx1ZSBwcm92aWRlZCBmb3IgdmFyaWFibGUgJyArIHN0cik7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG5cdFx0XHRcdHZhbHVlID0gdmFsdWUoZGF0YSk7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIHZhbHVlO1xyXG5cdFx0fSk7XHJcblx0fSxcclxuXHJcblx0dGVtcGxhdGVSZTogL1xceyAqKFtcXHdfXSspICpcXH0vZyxcclxuXHJcblx0aXNBcnJheTogQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAob2JqKSB7XHJcblx0XHRyZXR1cm4gKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBBcnJheV0nKTtcclxuXHR9LFxyXG5cclxuXHQvLyBtaW5pbWFsIGltYWdlIFVSSSwgc2V0IHRvIGFuIGltYWdlIHdoZW4gZGlzcG9zaW5nIHRvIGZsdXNoIG1lbW9yeVxyXG5cdGVtcHR5SW1hZ2VVcmw6ICdkYXRhOmltYWdlL2dpZjtiYXNlNjQsUjBsR09EbGhBUUFCQUFEL0FDd0FBQUFBQVFBQkFBQUNBRHM9J1xyXG59O1xyXG5cclxuKGZ1bmN0aW9uICgpIHtcclxuXHQvLyBpbnNwaXJlZCBieSBodHRwOi8vcGF1bGlyaXNoLmNvbS8yMDExL3JlcXVlc3RhbmltYXRpb25mcmFtZS1mb3Itc21hcnQtYW5pbWF0aW5nL1xyXG5cclxuXHRmdW5jdGlvbiBnZXRQcmVmaXhlZChuYW1lKSB7XHJcblx0XHRyZXR1cm4gd2luZG93Wyd3ZWJraXQnICsgbmFtZV0gfHwgd2luZG93Wydtb3onICsgbmFtZV0gfHwgd2luZG93WydtcycgKyBuYW1lXTtcclxuXHR9XHJcblxyXG5cdHZhciBsYXN0VGltZSA9IDA7XHJcblxyXG5cdC8vIGZhbGxiYWNrIGZvciBJRSA3LThcclxuXHRmdW5jdGlvbiB0aW1lb3V0RGVmZXIoZm4pIHtcclxuXHRcdHZhciB0aW1lID0gK25ldyBEYXRlKCksXHJcblx0XHQgICAgdGltZVRvQ2FsbCA9IE1hdGgubWF4KDAsIDE2IC0gKHRpbWUgLSBsYXN0VGltZSkpO1xyXG5cclxuXHRcdGxhc3RUaW1lID0gdGltZSArIHRpbWVUb0NhbGw7XHJcblx0XHRyZXR1cm4gd2luZG93LnNldFRpbWVvdXQoZm4sIHRpbWVUb0NhbGwpO1xyXG5cdH1cclxuXHJcblx0dmFyIHJlcXVlc3RGbiA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgZ2V0UHJlZml4ZWQoJ1JlcXVlc3RBbmltYXRpb25GcmFtZScpIHx8IHRpbWVvdXREZWZlcixcclxuXHQgICAgY2FuY2VsRm4gPSB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUgfHwgZ2V0UHJlZml4ZWQoJ0NhbmNlbEFuaW1hdGlvbkZyYW1lJykgfHxcclxuXHQgICAgICAgICAgICAgICBnZXRQcmVmaXhlZCgnQ2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lJykgfHwgZnVuY3Rpb24gKGlkKSB7IHdpbmRvdy5jbGVhclRpbWVvdXQoaWQpOyB9O1xyXG5cclxuXHJcblx0TC5VdGlsLnJlcXVlc3RBbmltRnJhbWUgPSBmdW5jdGlvbiAoZm4sIGNvbnRleHQsIGltbWVkaWF0ZSwgZWxlbWVudCkge1xyXG5cdFx0aWYgKGltbWVkaWF0ZSAmJiByZXF1ZXN0Rm4gPT09IHRpbWVvdXREZWZlcikge1xyXG5cdFx0XHRmbi5jYWxsKGNvbnRleHQpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cmV0dXJuIHJlcXVlc3RGbi5jYWxsKHdpbmRvdywgTC5iaW5kKGZuLCBjb250ZXh0KSwgZWxlbWVudCk7XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0TC5VdGlsLmNhbmNlbEFuaW1GcmFtZSA9IGZ1bmN0aW9uIChpZCkge1xyXG5cdFx0aWYgKGlkKSB7XHJcblx0XHRcdGNhbmNlbEZuLmNhbGwod2luZG93LCBpZCk7XHJcblx0XHR9XHJcblx0fTtcclxufSkoKTtcclxuXHJcbi8vIHNob3J0Y3V0cyBmb3IgbW9zdCB1c2VkIHV0aWxpdHkgZnVuY3Rpb25zXHJcbkwuZXh0ZW5kID0gTC5VdGlsLmV4dGVuZDtcclxuTC5iaW5kID0gTC5VdGlsLmJpbmQ7XHJcbkwuc3RhbXAgPSBMLlV0aWwuc3RhbXA7XHJcbkwuc2V0T3B0aW9ucyA9IEwuVXRpbC5zZXRPcHRpb25zO1xyXG5cbi8qXHJcbiAqIEwuQ2xhc3MgcG93ZXJzIHRoZSBPT1AgZmFjaWxpdGllcyBvZiB0aGUgbGlicmFyeS5cclxuICogVGhhbmtzIHRvIEpvaG4gUmVzaWcgYW5kIERlYW4gRWR3YXJkcyBmb3IgaW5zcGlyYXRpb24hXHJcbiAqL1xyXG5cclxuTC5DbGFzcyA9IGZ1bmN0aW9uICgpIHt9O1xyXG5cclxuTC5DbGFzcy5leHRlbmQgPSBmdW5jdGlvbiAocHJvcHMpIHtcclxuXHJcblx0Ly8gZXh0ZW5kZWQgY2xhc3Mgd2l0aCB0aGUgbmV3IHByb3RvdHlwZVxyXG5cdHZhciBOZXdDbGFzcyA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHQvLyBjYWxsIHRoZSBjb25zdHJ1Y3RvclxyXG5cdFx0aWYgKHRoaXMuaW5pdGlhbGl6ZSkge1xyXG5cdFx0XHR0aGlzLmluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBjYWxsIGFsbCBjb25zdHJ1Y3RvciBob29rc1xyXG5cdFx0aWYgKHRoaXMuX2luaXRIb29rcy5sZW5ndGgpIHtcclxuXHRcdFx0dGhpcy5jYWxsSW5pdEhvb2tzKCk7XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0Ly8ganNoaW50IGNhbWVsY2FzZTogZmFsc2VcclxuXHR2YXIgcGFyZW50UHJvdG8gPSBOZXdDbGFzcy5fX3N1cGVyX18gPSB0aGlzLnByb3RvdHlwZTtcclxuXHJcblx0dmFyIHByb3RvID0gTC5VdGlsLmNyZWF0ZShwYXJlbnRQcm90byk7XHJcblx0cHJvdG8uY29uc3RydWN0b3IgPSBOZXdDbGFzcztcclxuXHJcblx0TmV3Q2xhc3MucHJvdG90eXBlID0gcHJvdG87XHJcblxyXG5cdC8vaW5oZXJpdCBwYXJlbnQncyBzdGF0aWNzXHJcblx0Zm9yICh2YXIgaSBpbiB0aGlzKSB7XHJcblx0XHRpZiAodGhpcy5oYXNPd25Qcm9wZXJ0eShpKSAmJiBpICE9PSAncHJvdG90eXBlJykge1xyXG5cdFx0XHROZXdDbGFzc1tpXSA9IHRoaXNbaV07XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvLyBtaXggc3RhdGljIHByb3BlcnRpZXMgaW50byB0aGUgY2xhc3NcclxuXHRpZiAocHJvcHMuc3RhdGljcykge1xyXG5cdFx0TC5leHRlbmQoTmV3Q2xhc3MsIHByb3BzLnN0YXRpY3MpO1xyXG5cdFx0ZGVsZXRlIHByb3BzLnN0YXRpY3M7XHJcblx0fVxyXG5cclxuXHQvLyBtaXggaW5jbHVkZXMgaW50byB0aGUgcHJvdG90eXBlXHJcblx0aWYgKHByb3BzLmluY2x1ZGVzKSB7XHJcblx0XHRMLlV0aWwuZXh0ZW5kLmFwcGx5KG51bGwsIFtwcm90b10uY29uY2F0KHByb3BzLmluY2x1ZGVzKSk7XHJcblx0XHRkZWxldGUgcHJvcHMuaW5jbHVkZXM7XHJcblx0fVxyXG5cclxuXHQvLyBtZXJnZSBvcHRpb25zXHJcblx0aWYgKHByb3RvLm9wdGlvbnMpIHtcclxuXHRcdHByb3BzLm9wdGlvbnMgPSBMLlV0aWwuZXh0ZW5kKEwuVXRpbC5jcmVhdGUocHJvdG8ub3B0aW9ucyksIHByb3BzLm9wdGlvbnMpO1xyXG5cdH1cclxuXHJcblx0Ly8gbWl4IGdpdmVuIHByb3BlcnRpZXMgaW50byB0aGUgcHJvdG90eXBlXHJcblx0TC5leHRlbmQocHJvdG8sIHByb3BzKTtcclxuXHJcblx0cHJvdG8uX2luaXRIb29rcyA9IFtdO1xyXG5cclxuXHQvLyBhZGQgbWV0aG9kIGZvciBjYWxsaW5nIGFsbCBob29rc1xyXG5cdHByb3RvLmNhbGxJbml0SG9va3MgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2luaXRIb29rc0NhbGxlZCkgeyByZXR1cm47IH1cclxuXHJcblx0XHRpZiAocGFyZW50UHJvdG8uY2FsbEluaXRIb29rcykge1xyXG5cdFx0XHRwYXJlbnRQcm90by5jYWxsSW5pdEhvb2tzLmNhbGwodGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5faW5pdEhvb2tzQ2FsbGVkID0gdHJ1ZTtcclxuXHJcblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gcHJvdG8uX2luaXRIb29rcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRwcm90by5faW5pdEhvb2tzW2ldLmNhbGwodGhpcyk7XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0cmV0dXJuIE5ld0NsYXNzO1xyXG59O1xyXG5cclxuXHJcbi8vIG1ldGhvZCBmb3IgYWRkaW5nIHByb3BlcnRpZXMgdG8gcHJvdG90eXBlXHJcbkwuQ2xhc3MuaW5jbHVkZSA9IGZ1bmN0aW9uIChwcm9wcykge1xyXG5cdEwuZXh0ZW5kKHRoaXMucHJvdG90eXBlLCBwcm9wcyk7XHJcbn07XHJcblxyXG4vLyBtZXJnZSBuZXcgZGVmYXVsdCBvcHRpb25zIHRvIHRoZSBDbGFzc1xyXG5MLkNsYXNzLm1lcmdlT3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0TC5leHRlbmQodGhpcy5wcm90b3R5cGUub3B0aW9ucywgb3B0aW9ucyk7XHJcbn07XHJcblxyXG4vLyBhZGQgYSBjb25zdHJ1Y3RvciBob29rXHJcbkwuQ2xhc3MuYWRkSW5pdEhvb2sgPSBmdW5jdGlvbiAoZm4pIHsgLy8gKEZ1bmN0aW9uKSB8fCAoU3RyaW5nLCBhcmdzLi4uKVxyXG5cdHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcclxuXHJcblx0dmFyIGluaXQgPSB0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicgPyBmbiA6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXNbZm5dLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG5cdH07XHJcblxyXG5cdHRoaXMucHJvdG90eXBlLl9pbml0SG9va3MgPSB0aGlzLnByb3RvdHlwZS5faW5pdEhvb2tzIHx8IFtdO1xyXG5cdHRoaXMucHJvdG90eXBlLl9pbml0SG9va3MucHVzaChpbml0KTtcclxufTtcclxuXG4vKlxyXG4gKiBMLkV2ZW50ZWQgaXMgYSBiYXNlIGNsYXNzIHRoYXQgTGVhZmxldCBjbGFzc2VzIGluaGVyaXQgZnJvbSB0byBoYW5kbGUgY3VzdG9tIGV2ZW50cy5cclxuICovXHJcblxyXG5MLkV2ZW50ZWQgPSBMLkNsYXNzLmV4dGVuZCh7XHJcblxyXG5cdG9uOiBmdW5jdGlvbiAodHlwZXMsIGZuLCBjb250ZXh0KSB7XHJcblxyXG5cdFx0Ly8gdHlwZXMgY2FuIGJlIGEgbWFwIG9mIHR5cGVzL2hhbmRsZXJzXHJcblx0XHRpZiAodHlwZW9mIHR5cGVzID09PSAnb2JqZWN0Jykge1xyXG5cdFx0XHRmb3IgKHZhciB0eXBlIGluIHR5cGVzKSB7XHJcblx0XHRcdFx0Ly8gd2UgZG9uJ3QgcHJvY2VzcyBzcGFjZS1zZXBhcmF0ZWQgZXZlbnRzIGhlcmUgZm9yIHBlcmZvcm1hbmNlO1xyXG5cdFx0XHRcdC8vIGl0J3MgYSBob3QgcGF0aCBzaW5jZSBMYXllciB1c2VzIHRoZSBvbihvYmopIHN5bnRheFxyXG5cdFx0XHRcdHRoaXMuX29uKHR5cGUsIHR5cGVzW3R5cGVdLCBmbik7XHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHQvLyB0eXBlcyBjYW4gYmUgYSBzdHJpbmcgb2Ygc3BhY2Utc2VwYXJhdGVkIHdvcmRzXHJcblx0XHRcdHR5cGVzID0gTC5VdGlsLnNwbGl0V29yZHModHlwZXMpO1xyXG5cclxuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHR5cGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0dGhpcy5fb24odHlwZXNbaV0sIGZuLCBjb250ZXh0KTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdG9mZjogZnVuY3Rpb24gKHR5cGVzLCBmbiwgY29udGV4dCkge1xyXG5cclxuXHRcdGlmICghdHlwZXMpIHtcclxuXHRcdFx0Ly8gY2xlYXIgYWxsIGxpc3RlbmVycyBpZiBjYWxsZWQgd2l0aG91dCBhcmd1bWVudHNcclxuXHRcdFx0ZGVsZXRlIHRoaXMuX2V2ZW50cztcclxuXHJcblx0XHR9IGVsc2UgaWYgKHR5cGVvZiB0eXBlcyA9PT0gJ29iamVjdCcpIHtcclxuXHRcdFx0Zm9yICh2YXIgdHlwZSBpbiB0eXBlcykge1xyXG5cdFx0XHRcdHRoaXMuX29mZih0eXBlLCB0eXBlc1t0eXBlXSwgZm4pO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dHlwZXMgPSBMLlV0aWwuc3BsaXRXb3Jkcyh0eXBlcyk7XHJcblxyXG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gdHlwZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0XHR0aGlzLl9vZmYodHlwZXNbaV0sIGZuLCBjb250ZXh0KTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIGF0dGFjaCBsaXN0ZW5lciAod2l0aG91dCBzeW50YWN0aWMgc3VnYXIgbm93KVxyXG5cdF9vbjogZnVuY3Rpb24gKHR5cGUsIGZuLCBjb250ZXh0KSB7XHJcblxyXG5cdFx0dmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fSxcclxuXHRcdCAgICBjb250ZXh0SWQgPSBjb250ZXh0ICYmIGNvbnRleHQgIT09IHRoaXMgJiYgTC5zdGFtcChjb250ZXh0KTtcclxuXHJcblx0XHRpZiAoY29udGV4dElkKSB7XHJcblx0XHRcdC8vIHN0b3JlIGxpc3RlbmVycyB3aXRoIGN1c3RvbSBjb250ZXh0IGluIGEgc2VwYXJhdGUgaGFzaCAoaWYgaXQgaGFzIGFuIGlkKTtcclxuXHRcdFx0Ly8gZ2l2ZXMgYSBtYWpvciBwZXJmb3JtYW5jZSBib29zdCB3aGVuIGZpcmluZyBhbmQgcmVtb3ZpbmcgZXZlbnRzIChlLmcuIG9uIG1hcCBvYmplY3QpXHJcblxyXG5cdFx0XHR2YXIgaW5kZXhLZXkgPSB0eXBlICsgJ19pZHgnLFxyXG5cdFx0XHQgICAgaW5kZXhMZW5LZXkgPSB0eXBlICsgJ19sZW4nLFxyXG5cdFx0XHQgICAgdHlwZUluZGV4ID0gZXZlbnRzW2luZGV4S2V5XSA9IGV2ZW50c1tpbmRleEtleV0gfHwge30sXHJcblx0XHRcdCAgICBpZCA9IEwuc3RhbXAoZm4pICsgJ18nICsgY29udGV4dElkO1xyXG5cclxuXHRcdFx0aWYgKCF0eXBlSW5kZXhbaWRdKSB7XHJcblx0XHRcdFx0dHlwZUluZGV4W2lkXSA9IHtmbjogZm4sIGN0eDogY29udGV4dH07XHJcblxyXG5cdFx0XHRcdC8vIGtlZXAgdHJhY2sgb2YgdGhlIG51bWJlciBvZiBrZXlzIGluIHRoZSBpbmRleCB0byBxdWlja2x5IGNoZWNrIGlmIGl0J3MgZW1wdHlcclxuXHRcdFx0XHRldmVudHNbaW5kZXhMZW5LZXldID0gKGV2ZW50c1tpbmRleExlbktleV0gfHwgMCkgKyAxO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Ly8gaW5kaXZpZHVhbCBsYXllcnMgbW9zdGx5IHVzZSBcInRoaXNcIiBmb3IgY29udGV4dCBhbmQgZG9uJ3QgZmlyZSBsaXN0ZW5lcnMgdG9vIG9mdGVuXHJcblx0XHRcdC8vIHNvIHNpbXBsZSBhcnJheSBtYWtlcyB0aGUgbWVtb3J5IGZvb3RwcmludCBiZXR0ZXIgd2hpbGUgbm90IGRlZ3JhZGluZyBwZXJmb3JtYW5jZVxyXG5cclxuXHRcdFx0ZXZlbnRzW3R5cGVdID0gZXZlbnRzW3R5cGVdIHx8IFtdO1xyXG5cdFx0XHRldmVudHNbdHlwZV0ucHVzaCh7Zm46IGZufSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X29mZjogZnVuY3Rpb24gKHR5cGUsIGZuLCBjb250ZXh0KSB7XHJcblx0XHR2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzLFxyXG5cdFx0ICAgIGluZGV4S2V5ID0gdHlwZSArICdfaWR4JyxcclxuXHRcdCAgICBpbmRleExlbktleSA9IHR5cGUgKyAnX2xlbic7XHJcblxyXG5cdFx0aWYgKCFldmVudHMpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0aWYgKCFmbikge1xyXG5cdFx0XHQvLyBjbGVhciBhbGwgbGlzdGVuZXJzIGZvciBhIHR5cGUgaWYgZnVuY3Rpb24gaXNuJ3Qgc3BlY2lmaWVkXHJcblx0XHRcdGRlbGV0ZSBldmVudHNbdHlwZV07XHJcblx0XHRcdGRlbGV0ZSBldmVudHNbaW5kZXhLZXldO1xyXG5cdFx0XHRkZWxldGUgZXZlbnRzW2luZGV4TGVuS2V5XTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBjb250ZXh0SWQgPSBjb250ZXh0ICYmIGNvbnRleHQgIT09IHRoaXMgJiYgTC5zdGFtcChjb250ZXh0KSxcclxuXHRcdCAgICBsaXN0ZW5lcnMsIGksIGxlbiwgbGlzdGVuZXIsIGlkO1xyXG5cclxuXHRcdGlmIChjb250ZXh0SWQpIHtcclxuXHRcdFx0aWQgPSBMLnN0YW1wKGZuKSArICdfJyArIGNvbnRleHRJZDtcclxuXHRcdFx0bGlzdGVuZXJzID0gZXZlbnRzW2luZGV4S2V5XTtcclxuXHJcblx0XHRcdGlmIChsaXN0ZW5lcnMgJiYgbGlzdGVuZXJzW2lkXSkge1xyXG5cdFx0XHRcdGxpc3RlbmVyID0gbGlzdGVuZXJzW2lkXTtcclxuXHRcdFx0XHRkZWxldGUgbGlzdGVuZXJzW2lkXTtcclxuXHRcdFx0XHRldmVudHNbaW5kZXhMZW5LZXldLS07XHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRsaXN0ZW5lcnMgPSBldmVudHNbdHlwZV07XHJcblxyXG5cdFx0XHRpZiAobGlzdGVuZXJzKSB7XHJcblx0XHRcdFx0Zm9yIChpID0gMCwgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0XHRpZiAobGlzdGVuZXJzW2ldLmZuID09PSBmbikge1xyXG5cdFx0XHRcdFx0XHRsaXN0ZW5lciA9IGxpc3RlbmVyc1tpXTtcclxuXHRcdFx0XHRcdFx0bGlzdGVuZXJzLnNwbGljZShpLCAxKTtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gc2V0IHRoZSByZW1vdmVkIGxpc3RlbmVyIHRvIG5vb3Agc28gdGhhdCdzIG5vdCBjYWxsZWQgaWYgcmVtb3ZlIGhhcHBlbnMgaW4gZmlyZVxyXG5cdFx0aWYgKGxpc3RlbmVyKSB7XHJcblx0XHRcdGxpc3RlbmVyLmZuID0gTC5VdGlsLmZhbHNlRm47XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0ZmlyZTogZnVuY3Rpb24gKHR5cGUsIGRhdGEsIHByb3BhZ2F0ZSkge1xyXG5cdFx0aWYgKCF0aGlzLmxpc3RlbnModHlwZSwgcHJvcGFnYXRlKSkgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdHZhciBldmVudCA9IEwuVXRpbC5leHRlbmQoe30sIGRhdGEsIHt0eXBlOiB0eXBlLCB0YXJnZXQ6IHRoaXN9KSxcclxuXHRcdCAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XHJcblxyXG5cdFx0aWYgKGV2ZW50cykge1xyXG5cdFx0ICAgIHZhciB0eXBlSW5kZXggPSBldmVudHNbdHlwZSArICdfaWR4J10sXHJcblx0XHQgICAgICAgIGksIGxlbiwgbGlzdGVuZXJzLCBpZDtcclxuXHJcblx0XHRcdGlmIChldmVudHNbdHlwZV0pIHtcclxuXHRcdFx0XHQvLyBtYWtlIHN1cmUgYWRkaW5nL3JlbW92aW5nIGxpc3RlbmVycyBpbnNpZGUgb3RoZXIgbGlzdGVuZXJzIHdvbid0IGNhdXNlIGluZmluaXRlIGxvb3BcclxuXHRcdFx0XHRsaXN0ZW5lcnMgPSBldmVudHNbdHlwZV0uc2xpY2UoKTtcclxuXHJcblx0XHRcdFx0Zm9yIChpID0gMCwgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0XHRsaXN0ZW5lcnNbaV0uZm4uY2FsbCh0aGlzLCBldmVudCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBmaXJlIGV2ZW50IGZvciB0aGUgY29udGV4dC1pbmRleGVkIGxpc3RlbmVycyBhcyB3ZWxsXHJcblx0XHRcdGZvciAoaWQgaW4gdHlwZUluZGV4KSB7XHJcblx0XHRcdFx0dHlwZUluZGV4W2lkXS5mbi5jYWxsKHR5cGVJbmRleFtpZF0uY3R4LCBldmVudCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAocHJvcGFnYXRlKSB7XHJcblx0XHRcdC8vIHByb3BhZ2F0ZSB0aGUgZXZlbnQgdG8gcGFyZW50cyAoc2V0IHdpdGggYWRkRXZlbnRQYXJlbnQpXHJcblx0XHRcdHRoaXMuX3Byb3BhZ2F0ZUV2ZW50KGV2ZW50KTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRsaXN0ZW5zOiBmdW5jdGlvbiAodHlwZSwgcHJvcGFnYXRlKSB7XHJcblx0XHR2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xyXG5cclxuXHRcdGlmIChldmVudHMgJiYgKGV2ZW50c1t0eXBlXSB8fCBldmVudHNbdHlwZSArICdfbGVuJ10pKSB7IHJldHVybiB0cnVlOyB9XHJcblxyXG5cdFx0aWYgKHByb3BhZ2F0ZSkge1xyXG5cdFx0XHQvLyBhbHNvIGNoZWNrIHBhcmVudHMgZm9yIGxpc3RlbmVycyBpZiBldmVudCBwcm9wYWdhdGVzXHJcblx0XHRcdGZvciAodmFyIGlkIGluIHRoaXMuX2V2ZW50UGFyZW50cykge1xyXG5cdFx0XHRcdGlmICh0aGlzLl9ldmVudFBhcmVudHNbaWRdLmxpc3RlbnModHlwZSwgcHJvcGFnYXRlKSkgeyByZXR1cm4gdHJ1ZTsgfVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fSxcclxuXHJcblx0b25jZTogZnVuY3Rpb24gKHR5cGVzLCBmbiwgY29udGV4dCkge1xyXG5cclxuXHRcdGlmICh0eXBlb2YgdHlwZXMgPT09ICdvYmplY3QnKSB7XHJcblx0XHRcdGZvciAodmFyIHR5cGUgaW4gdHlwZXMpIHtcclxuXHRcdFx0XHR0aGlzLm9uY2UodHlwZSwgdHlwZXNbdHlwZV0sIGZuKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgaGFuZGxlciA9IEwuYmluZChmdW5jdGlvbiAoKSB7XHJcblx0XHRcdHRoaXNcclxuXHRcdFx0ICAgIC5vZmYodHlwZXMsIGZuLCBjb250ZXh0KVxyXG5cdFx0XHQgICAgLm9mZih0eXBlcywgaGFuZGxlciwgY29udGV4dCk7XHJcblx0XHR9LCB0aGlzKTtcclxuXHJcblx0XHQvLyBhZGQgYSBsaXN0ZW5lciB0aGF0J3MgZXhlY3V0ZWQgb25jZSBhbmQgcmVtb3ZlZCBhZnRlciB0aGF0XHJcblx0XHRyZXR1cm4gdGhpc1xyXG5cdFx0ICAgIC5vbih0eXBlcywgZm4sIGNvbnRleHQpXHJcblx0XHQgICAgLm9uKHR5cGVzLCBoYW5kbGVyLCBjb250ZXh0KTtcclxuXHR9LFxyXG5cclxuXHQvLyBhZGRzIGEgcGFyZW50IHRvIHByb3BhZ2F0ZSBldmVudHMgdG8gKHdoZW4geW91IGZpcmUgd2l0aCB0cnVlIGFzIGEgM3JkIGFyZ3VtZW50KVxyXG5cdGFkZEV2ZW50UGFyZW50OiBmdW5jdGlvbiAob2JqKSB7XHJcblx0XHR0aGlzLl9ldmVudFBhcmVudHMgPSB0aGlzLl9ldmVudFBhcmVudHMgfHwge307XHJcblx0XHR0aGlzLl9ldmVudFBhcmVudHNbTC5zdGFtcChvYmopXSA9IG9iajtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdHJlbW92ZUV2ZW50UGFyZW50OiBmdW5jdGlvbiAob2JqKSB7XHJcblx0XHRpZiAodGhpcy5fZXZlbnRQYXJlbnRzKSB7XHJcblx0XHRcdGRlbGV0ZSB0aGlzLl9ldmVudFBhcmVudHNbTC5zdGFtcChvYmopXTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF9wcm9wYWdhdGVFdmVudDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdGZvciAodmFyIGlkIGluIHRoaXMuX2V2ZW50UGFyZW50cykge1xyXG5cdFx0XHR0aGlzLl9ldmVudFBhcmVudHNbaWRdLmZpcmUoZS50eXBlLCBMLmV4dGVuZCh7bGF5ZXI6IGUudGFyZ2V0fSwgZSksIHRydWUpO1xyXG5cdFx0fVxyXG5cdH1cclxufSk7XHJcblxyXG52YXIgcHJvdG8gPSBMLkV2ZW50ZWQucHJvdG90eXBlO1xyXG5cclxuLy8gYWxpYXNlczsgd2Ugc2hvdWxkIGRpdGNoIHRob3NlIGV2ZW50dWFsbHlcclxucHJvdG8uYWRkRXZlbnRMaXN0ZW5lciA9IHByb3RvLm9uO1xyXG5wcm90by5yZW1vdmVFdmVudExpc3RlbmVyID0gcHJvdG8uY2xlYXJBbGxFdmVudExpc3RlbmVycyA9IHByb3RvLm9mZjtcclxucHJvdG8uYWRkT25lVGltZUV2ZW50TGlzdGVuZXIgPSBwcm90by5vbmNlO1xyXG5wcm90by5maXJlRXZlbnQgPSBwcm90by5maXJlO1xyXG5wcm90by5oYXNFdmVudExpc3RlbmVycyA9IHByb3RvLmxpc3RlbnM7XHJcblxyXG5MLk1peGluID0ge0V2ZW50czogcHJvdG99O1xyXG5cbi8qXHJcbiAqIEwuQnJvd3NlciBoYW5kbGVzIGRpZmZlcmVudCBicm93c2VyIGFuZCBmZWF0dXJlIGRldGVjdGlvbnMgZm9yIGludGVybmFsIExlYWZsZXQgdXNlLlxyXG4gKi9cclxuXHJcbihmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHZhciB1YSA9IG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKSxcclxuXHQgICAgZG9jID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LFxyXG5cclxuXHQgICAgaWUgPSAnQWN0aXZlWE9iamVjdCcgaW4gd2luZG93LFxyXG5cclxuXHQgICAgd2Via2l0ICAgID0gdWEuaW5kZXhPZignd2Via2l0JykgIT09IC0xLFxyXG5cdCAgICBwaGFudG9tanMgPSB1YS5pbmRleE9mKCdwaGFudG9tJykgIT09IC0xLFxyXG5cdCAgICBhbmRyb2lkMjMgPSB1YS5zZWFyY2goJ2FuZHJvaWQgWzIzXScpICE9PSAtMSxcclxuXHQgICAgY2hyb21lICAgID0gdWEuaW5kZXhPZignY2hyb21lJykgIT09IC0xLFxyXG5cclxuXHQgICAgbW9iaWxlID0gdHlwZW9mIG9yaWVudGF0aW9uICE9PSAndW5kZWZpbmVkJyxcclxuXHQgICAgbXNQb2ludGVyID0gbmF2aWdhdG9yLm1zUG9pbnRlckVuYWJsZWQgJiYgbmF2aWdhdG9yLm1zTWF4VG91Y2hQb2ludHMgJiYgIXdpbmRvdy5Qb2ludGVyRXZlbnQsXHJcblx0ICAgIHBvaW50ZXIgPSAod2luZG93LlBvaW50ZXJFdmVudCAmJiBuYXZpZ2F0b3IucG9pbnRlckVuYWJsZWQgJiYgbmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzKSB8fCBtc1BvaW50ZXIsXHJcblxyXG5cdCAgICBpZTNkID0gaWUgJiYgKCd0cmFuc2l0aW9uJyBpbiBkb2Muc3R5bGUpLFxyXG5cdCAgICB3ZWJraXQzZCA9ICgnV2ViS2l0Q1NTTWF0cml4JyBpbiB3aW5kb3cpICYmICgnbTExJyBpbiBuZXcgd2luZG93LldlYktpdENTU01hdHJpeCgpKSAmJiAhYW5kcm9pZDIzLFxyXG5cdCAgICBnZWNrbzNkID0gJ01velBlcnNwZWN0aXZlJyBpbiBkb2Muc3R5bGUsXHJcblx0ICAgIG9wZXJhM2QgPSAnT1RyYW5zaXRpb24nIGluIGRvYy5zdHlsZTtcclxuXHJcblxyXG5cdHZhciByZXRpbmEgPSAnZGV2aWNlUGl4ZWxSYXRpbycgaW4gd2luZG93ICYmIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvID4gMTtcclxuXHJcblx0aWYgKCFyZXRpbmEgJiYgJ21hdGNoTWVkaWEnIGluIHdpbmRvdykge1xyXG5cdFx0dmFyIG1hdGNoZXMgPSB3aW5kb3cubWF0Y2hNZWRpYSgnKG1pbi1yZXNvbHV0aW9uOjE0NGRwaSknKTtcclxuXHRcdHJldGluYSA9IG1hdGNoZXMgJiYgbWF0Y2hlcy5tYXRjaGVzO1xyXG5cdH1cclxuXHJcblx0dmFyIHRvdWNoID0gIXdpbmRvdy5MX05PX1RPVUNIICYmICFwaGFudG9tanMgJiYgKHBvaW50ZXIgfHwgJ29udG91Y2hzdGFydCcgaW4gd2luZG93IHx8XHJcblx0XHRcdCh3aW5kb3cuRG9jdW1lbnRUb3VjaCAmJiBkb2N1bWVudCBpbnN0YW5jZW9mIHdpbmRvdy5Eb2N1bWVudFRvdWNoKSk7XHJcblxyXG5cdEwuQnJvd3NlciA9IHtcclxuXHRcdGllOiBpZSxcclxuXHRcdGllbHQ5OiBpZSAmJiAhZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcixcclxuXHRcdHdlYmtpdDogd2Via2l0LFxyXG5cdFx0Z2Vja286ICh1YS5pbmRleE9mKCdnZWNrbycpICE9PSAtMSkgJiYgIXdlYmtpdCAmJiAhd2luZG93Lm9wZXJhICYmICFpZSxcclxuXHRcdGFuZHJvaWQ6IHVhLmluZGV4T2YoJ2FuZHJvaWQnKSAhPT0gLTEsXHJcblx0XHRhbmRyb2lkMjM6IGFuZHJvaWQyMyxcclxuXHRcdGNocm9tZTogY2hyb21lLFxyXG5cdFx0c2FmYXJpOiAhY2hyb21lICYmIHVhLmluZGV4T2YoJ3NhZmFyaScpICE9PSAtMSxcclxuXHJcblx0XHRpZTNkOiBpZTNkLFxyXG5cdFx0d2Via2l0M2Q6IHdlYmtpdDNkLFxyXG5cdFx0Z2Vja28zZDogZ2Vja28zZCxcclxuXHRcdG9wZXJhM2Q6IG9wZXJhM2QsXHJcblx0XHRhbnkzZDogIXdpbmRvdy5MX0RJU0FCTEVfM0QgJiYgKGllM2QgfHwgd2Via2l0M2QgfHwgZ2Vja28zZCB8fCBvcGVyYTNkKSAmJiAhcGhhbnRvbWpzLFxyXG5cclxuXHRcdG1vYmlsZTogbW9iaWxlLFxyXG5cdFx0bW9iaWxlV2Via2l0OiBtb2JpbGUgJiYgd2Via2l0LFxyXG5cdFx0bW9iaWxlV2Via2l0M2Q6IG1vYmlsZSAmJiB3ZWJraXQzZCxcclxuXHRcdG1vYmlsZU9wZXJhOiBtb2JpbGUgJiYgd2luZG93Lm9wZXJhLFxyXG5cclxuXHRcdHRvdWNoOiAhIXRvdWNoLFxyXG5cdFx0bXNQb2ludGVyOiAhIW1zUG9pbnRlcixcclxuXHRcdHBvaW50ZXI6ICEhcG9pbnRlcixcclxuXHJcblx0XHRyZXRpbmE6ICEhcmV0aW5hXHJcblx0fTtcclxuXHJcbn0oKSk7XHJcblxuLypcclxuICogTC5Qb2ludCByZXByZXNlbnRzIGEgcG9pbnQgd2l0aCB4IGFuZCB5IGNvb3JkaW5hdGVzLlxyXG4gKi9cclxuXHJcbkwuUG9pbnQgPSBmdW5jdGlvbiAoLypOdW1iZXIqLyB4LCAvKk51bWJlciovIHksIC8qQm9vbGVhbiovIHJvdW5kKSB7XHJcblx0dGhpcy54ID0gKHJvdW5kID8gTWF0aC5yb3VuZCh4KSA6IHgpO1xyXG5cdHRoaXMueSA9IChyb3VuZCA/IE1hdGgucm91bmQoeSkgOiB5KTtcclxufTtcclxuXHJcbkwuUG9pbnQucHJvdG90eXBlID0ge1xyXG5cclxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIG5ldyBMLlBvaW50KHRoaXMueCwgdGhpcy55KTtcclxuXHR9LFxyXG5cclxuXHQvLyBub24tZGVzdHJ1Y3RpdmUsIHJldHVybnMgYSBuZXcgcG9pbnRcclxuXHRhZGQ6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fYWRkKEwucG9pbnQocG9pbnQpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBkZXN0cnVjdGl2ZSwgdXNlZCBkaXJlY3RseSBmb3IgcGVyZm9ybWFuY2UgaW4gc2l0dWF0aW9ucyB3aGVyZSBpdCdzIHNhZmUgdG8gbW9kaWZ5IGV4aXN0aW5nIHBvaW50XHJcblx0X2FkZDogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHR0aGlzLnggKz0gcG9pbnQueDtcclxuXHRcdHRoaXMueSArPSBwb2ludC55O1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0c3VidHJhY3Q6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fc3VidHJhY3QoTC5wb2ludChwb2ludCkpO1xyXG5cdH0sXHJcblxyXG5cdF9zdWJ0cmFjdDogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHR0aGlzLnggLT0gcG9pbnQueDtcclxuXHRcdHRoaXMueSAtPSBwb2ludC55O1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0ZGl2aWRlQnk6IGZ1bmN0aW9uIChudW0pIHtcclxuXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX2RpdmlkZUJ5KG51bSk7XHJcblx0fSxcclxuXHJcblx0X2RpdmlkZUJ5OiBmdW5jdGlvbiAobnVtKSB7XHJcblx0XHR0aGlzLnggLz0gbnVtO1xyXG5cdFx0dGhpcy55IC89IG51bTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdG11bHRpcGx5Qnk6IGZ1bmN0aW9uIChudW0pIHtcclxuXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX211bHRpcGx5QnkobnVtKTtcclxuXHR9LFxyXG5cclxuXHRfbXVsdGlwbHlCeTogZnVuY3Rpb24gKG51bSkge1xyXG5cdFx0dGhpcy54ICo9IG51bTtcclxuXHRcdHRoaXMueSAqPSBudW07XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRyb3VuZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fcm91bmQoKTtcclxuXHR9LFxyXG5cclxuXHRfcm91bmQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMueCA9IE1hdGgucm91bmQodGhpcy54KTtcclxuXHRcdHRoaXMueSA9IE1hdGgucm91bmQodGhpcy55KTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdGZsb29yOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLl9mbG9vcigpO1xyXG5cdH0sXHJcblxyXG5cdF9mbG9vcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy54ID0gTWF0aC5mbG9vcih0aGlzLngpO1xyXG5cdFx0dGhpcy55ID0gTWF0aC5mbG9vcih0aGlzLnkpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Y2VpbDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fY2VpbCgpO1xyXG5cdH0sXHJcblxyXG5cdF9jZWlsOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLnggPSBNYXRoLmNlaWwodGhpcy54KTtcclxuXHRcdHRoaXMueSA9IE1hdGguY2VpbCh0aGlzLnkpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0ZGlzdGFuY2VUbzogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHRwb2ludCA9IEwucG9pbnQocG9pbnQpO1xyXG5cclxuXHRcdHZhciB4ID0gcG9pbnQueCAtIHRoaXMueCxcclxuXHRcdCAgICB5ID0gcG9pbnQueSAtIHRoaXMueTtcclxuXHJcblx0XHRyZXR1cm4gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xyXG5cdH0sXHJcblxyXG5cdGVxdWFsczogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHRwb2ludCA9IEwucG9pbnQocG9pbnQpO1xyXG5cclxuXHRcdHJldHVybiBwb2ludC54ID09PSB0aGlzLnggJiZcclxuXHRcdCAgICAgICBwb2ludC55ID09PSB0aGlzLnk7XHJcblx0fSxcclxuXHJcblx0Y29udGFpbnM6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0cG9pbnQgPSBMLnBvaW50KHBvaW50KTtcclxuXHJcblx0XHRyZXR1cm4gTWF0aC5hYnMocG9pbnQueCkgPD0gTWF0aC5hYnModGhpcy54KSAmJlxyXG5cdFx0ICAgICAgIE1hdGguYWJzKHBvaW50LnkpIDw9IE1hdGguYWJzKHRoaXMueSk7XHJcblx0fSxcclxuXHJcblx0dG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiAnUG9pbnQoJyArXHJcblx0XHQgICAgICAgIEwuVXRpbC5mb3JtYXROdW0odGhpcy54KSArICcsICcgK1xyXG5cdFx0ICAgICAgICBMLlV0aWwuZm9ybWF0TnVtKHRoaXMueSkgKyAnKSc7XHJcblx0fVxyXG59O1xyXG5cclxuTC5wb2ludCA9IGZ1bmN0aW9uICh4LCB5LCByb3VuZCkge1xyXG5cdGlmICh4IGluc3RhbmNlb2YgTC5Qb2ludCkge1xyXG5cdFx0cmV0dXJuIHg7XHJcblx0fVxyXG5cdGlmIChMLlV0aWwuaXNBcnJheSh4KSkge1xyXG5cdFx0cmV0dXJuIG5ldyBMLlBvaW50KHhbMF0sIHhbMV0pO1xyXG5cdH1cclxuXHRpZiAoeCA9PT0gdW5kZWZpbmVkIHx8IHggPT09IG51bGwpIHtcclxuXHRcdHJldHVybiB4O1xyXG5cdH1cclxuXHRyZXR1cm4gbmV3IEwuUG9pbnQoeCwgeSwgcm91bmQpO1xyXG59O1xyXG5cbi8qXHJcbiAqIEwuQm91bmRzIHJlcHJlc2VudHMgYSByZWN0YW5ndWxhciBhcmVhIG9uIHRoZSBzY3JlZW4gaW4gcGl4ZWwgY29vcmRpbmF0ZXMuXHJcbiAqL1xyXG5cclxuTC5Cb3VuZHMgPSBmdW5jdGlvbiAoYSwgYikgeyAvLyhQb2ludCwgUG9pbnQpIG9yIFBvaW50W11cclxuXHRpZiAoIWEpIHsgcmV0dXJuOyB9XHJcblxyXG5cdHZhciBwb2ludHMgPSBiID8gW2EsIGJdIDogYTtcclxuXHJcblx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0dGhpcy5leHRlbmQocG9pbnRzW2ldKTtcclxuXHR9XHJcbn07XHJcblxyXG5MLkJvdW5kcy5wcm90b3R5cGUgPSB7XHJcblx0Ly8gZXh0ZW5kIHRoZSBib3VuZHMgdG8gY29udGFpbiB0aGUgZ2l2ZW4gcG9pbnRcclxuXHRleHRlbmQ6IGZ1bmN0aW9uIChwb2ludCkgeyAvLyAoUG9pbnQpXHJcblx0XHRwb2ludCA9IEwucG9pbnQocG9pbnQpO1xyXG5cclxuXHRcdGlmICghdGhpcy5taW4gJiYgIXRoaXMubWF4KSB7XHJcblx0XHRcdHRoaXMubWluID0gcG9pbnQuY2xvbmUoKTtcclxuXHRcdFx0dGhpcy5tYXggPSBwb2ludC5jbG9uZSgpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dGhpcy5taW4ueCA9IE1hdGgubWluKHBvaW50LngsIHRoaXMubWluLngpO1xyXG5cdFx0XHR0aGlzLm1heC54ID0gTWF0aC5tYXgocG9pbnQueCwgdGhpcy5tYXgueCk7XHJcblx0XHRcdHRoaXMubWluLnkgPSBNYXRoLm1pbihwb2ludC55LCB0aGlzLm1pbi55KTtcclxuXHRcdFx0dGhpcy5tYXgueSA9IE1hdGgubWF4KHBvaW50LnksIHRoaXMubWF4LnkpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Z2V0Q2VudGVyOiBmdW5jdGlvbiAocm91bmQpIHsgLy8gKEJvb2xlYW4pIC0+IFBvaW50XHJcblx0XHRyZXR1cm4gbmV3IEwuUG9pbnQoXHJcblx0XHQgICAgICAgICh0aGlzLm1pbi54ICsgdGhpcy5tYXgueCkgLyAyLFxyXG5cdFx0ICAgICAgICAodGhpcy5taW4ueSArIHRoaXMubWF4LnkpIC8gMiwgcm91bmQpO1xyXG5cdH0sXHJcblxyXG5cdGdldEJvdHRvbUxlZnQ6IGZ1bmN0aW9uICgpIHsgLy8gLT4gUG9pbnRcclxuXHRcdHJldHVybiBuZXcgTC5Qb2ludCh0aGlzLm1pbi54LCB0aGlzLm1heC55KTtcclxuXHR9LFxyXG5cclxuXHRnZXRUb3BSaWdodDogZnVuY3Rpb24gKCkgeyAvLyAtPiBQb2ludFxyXG5cdFx0cmV0dXJuIG5ldyBMLlBvaW50KHRoaXMubWF4LngsIHRoaXMubWluLnkpO1xyXG5cdH0sXHJcblxyXG5cdGdldFNpemU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLm1heC5zdWJ0cmFjdCh0aGlzLm1pbik7XHJcblx0fSxcclxuXHJcblx0Y29udGFpbnM6IGZ1bmN0aW9uIChvYmopIHsgLy8gKEJvdW5kcykgb3IgKFBvaW50KSAtPiBCb29sZWFuXHJcblx0XHR2YXIgbWluLCBtYXg7XHJcblxyXG5cdFx0aWYgKHR5cGVvZiBvYmpbMF0gPT09ICdudW1iZXInIHx8IG9iaiBpbnN0YW5jZW9mIEwuUG9pbnQpIHtcclxuXHRcdFx0b2JqID0gTC5wb2ludChvYmopO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0b2JqID0gTC5ib3VuZHMob2JqKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAob2JqIGluc3RhbmNlb2YgTC5Cb3VuZHMpIHtcclxuXHRcdFx0bWluID0gb2JqLm1pbjtcclxuXHRcdFx0bWF4ID0gb2JqLm1heDtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdG1pbiA9IG1heCA9IG9iajtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gKG1pbi54ID49IHRoaXMubWluLngpICYmXHJcblx0XHQgICAgICAgKG1heC54IDw9IHRoaXMubWF4LngpICYmXHJcblx0XHQgICAgICAgKG1pbi55ID49IHRoaXMubWluLnkpICYmXHJcblx0XHQgICAgICAgKG1heC55IDw9IHRoaXMubWF4LnkpO1xyXG5cdH0sXHJcblxyXG5cdGludGVyc2VjdHM6IGZ1bmN0aW9uIChib3VuZHMpIHsgLy8gKEJvdW5kcykgLT4gQm9vbGVhblxyXG5cdFx0Ym91bmRzID0gTC5ib3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHR2YXIgbWluID0gdGhpcy5taW4sXHJcblx0XHQgICAgbWF4ID0gdGhpcy5tYXgsXHJcblx0XHQgICAgbWluMiA9IGJvdW5kcy5taW4sXHJcblx0XHQgICAgbWF4MiA9IGJvdW5kcy5tYXgsXHJcblx0XHQgICAgeEludGVyc2VjdHMgPSAobWF4Mi54ID49IG1pbi54KSAmJiAobWluMi54IDw9IG1heC54KSxcclxuXHRcdCAgICB5SW50ZXJzZWN0cyA9IChtYXgyLnkgPj0gbWluLnkpICYmIChtaW4yLnkgPD0gbWF4LnkpO1xyXG5cclxuXHRcdHJldHVybiB4SW50ZXJzZWN0cyAmJiB5SW50ZXJzZWN0cztcclxuXHR9LFxyXG5cclxuXHRpc1ZhbGlkOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gISEodGhpcy5taW4gJiYgdGhpcy5tYXgpO1xyXG5cdH1cclxufTtcclxuXHJcbkwuYm91bmRzID0gZnVuY3Rpb24gKGEsIGIpIHsgLy8gKEJvdW5kcykgb3IgKFBvaW50LCBQb2ludCkgb3IgKFBvaW50W10pXHJcblx0aWYgKCFhIHx8IGEgaW5zdGFuY2VvZiBMLkJvdW5kcykge1xyXG5cdFx0cmV0dXJuIGE7XHJcblx0fVxyXG5cdHJldHVybiBuZXcgTC5Cb3VuZHMoYSwgYik7XHJcbn07XHJcblxuLypcclxuICogTC5UcmFuc2Zvcm1hdGlvbiBpcyBhbiB1dGlsaXR5IGNsYXNzIHRvIHBlcmZvcm0gc2ltcGxlIHBvaW50IHRyYW5zZm9ybWF0aW9ucyB0aHJvdWdoIGEgMmQtbWF0cml4LlxyXG4gKi9cclxuXHJcbkwuVHJhbnNmb3JtYXRpb24gPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkge1xyXG5cdHRoaXMuX2EgPSBhO1xyXG5cdHRoaXMuX2IgPSBiO1xyXG5cdHRoaXMuX2MgPSBjO1xyXG5cdHRoaXMuX2QgPSBkO1xyXG59O1xyXG5cclxuTC5UcmFuc2Zvcm1hdGlvbi5wcm90b3R5cGUgPSB7XHJcblx0dHJhbnNmb3JtOiBmdW5jdGlvbiAocG9pbnQsIHNjYWxlKSB7IC8vIChQb2ludCwgTnVtYmVyKSAtPiBQb2ludFxyXG5cdFx0cmV0dXJuIHRoaXMuX3RyYW5zZm9ybShwb2ludC5jbG9uZSgpLCBzY2FsZSk7XHJcblx0fSxcclxuXHJcblx0Ly8gZGVzdHJ1Y3RpdmUgdHJhbnNmb3JtIChmYXN0ZXIpXHJcblx0X3RyYW5zZm9ybTogZnVuY3Rpb24gKHBvaW50LCBzY2FsZSkge1xyXG5cdFx0c2NhbGUgPSBzY2FsZSB8fCAxO1xyXG5cdFx0cG9pbnQueCA9IHNjYWxlICogKHRoaXMuX2EgKiBwb2ludC54ICsgdGhpcy5fYik7XHJcblx0XHRwb2ludC55ID0gc2NhbGUgKiAodGhpcy5fYyAqIHBvaW50LnkgKyB0aGlzLl9kKTtcclxuXHRcdHJldHVybiBwb2ludDtcclxuXHR9LFxyXG5cclxuXHR1bnRyYW5zZm9ybTogZnVuY3Rpb24gKHBvaW50LCBzY2FsZSkge1xyXG5cdFx0c2NhbGUgPSBzY2FsZSB8fCAxO1xyXG5cdFx0cmV0dXJuIG5ldyBMLlBvaW50KFxyXG5cdFx0ICAgICAgICAocG9pbnQueCAvIHNjYWxlIC0gdGhpcy5fYikgLyB0aGlzLl9hLFxyXG5cdFx0ICAgICAgICAocG9pbnQueSAvIHNjYWxlIC0gdGhpcy5fZCkgLyB0aGlzLl9jKTtcclxuXHR9XHJcbn07XHJcblxuLypcclxuICogTC5Eb21VdGlsIGNvbnRhaW5zIHZhcmlvdXMgdXRpbGl0eSBmdW5jdGlvbnMgZm9yIHdvcmtpbmcgd2l0aCBET00uXHJcbiAqL1xyXG5cclxuTC5Eb21VdGlsID0ge1xyXG5cdGdldDogZnVuY3Rpb24gKGlkKSB7XHJcblx0XHRyZXR1cm4gdHlwZW9mIGlkID09PSAnc3RyaW5nJyA/IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKSA6IGlkO1xyXG5cdH0sXHJcblxyXG5cdGdldFN0eWxlOiBmdW5jdGlvbiAoZWwsIHN0eWxlKSB7XHJcblxyXG5cdFx0dmFyIHZhbHVlID0gZWwuc3R5bGVbc3R5bGVdIHx8IChlbC5jdXJyZW50U3R5bGUgJiYgZWwuY3VycmVudFN0eWxlW3N0eWxlXSk7XHJcblxyXG5cdFx0aWYgKCghdmFsdWUgfHwgdmFsdWUgPT09ICdhdXRvJykgJiYgZG9jdW1lbnQuZGVmYXVsdFZpZXcpIHtcclxuXHRcdFx0dmFyIGNzcyA9IGRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUoZWwsIG51bGwpO1xyXG5cdFx0XHR2YWx1ZSA9IGNzcyA/IGNzc1tzdHlsZV0gOiBudWxsO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB2YWx1ZSA9PT0gJ2F1dG8nID8gbnVsbCA6IHZhbHVlO1xyXG5cdH0sXHJcblxyXG5cdGNyZWF0ZTogZnVuY3Rpb24gKHRhZ05hbWUsIGNsYXNzTmFtZSwgY29udGFpbmVyKSB7XHJcblxyXG5cdFx0dmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcclxuXHRcdGVsLmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcclxuXHJcblx0XHRpZiAoY29udGFpbmVyKSB7XHJcblx0XHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChlbCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGVsO1xyXG5cdH0sXHJcblxyXG5cdHJlbW92ZTogZnVuY3Rpb24gKGVsKSB7XHJcblx0XHR2YXIgcGFyZW50ID0gZWwucGFyZW50Tm9kZTtcclxuXHRcdGlmIChwYXJlbnQpIHtcclxuXHRcdFx0cGFyZW50LnJlbW92ZUNoaWxkKGVsKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHR0b0Zyb250OiBmdW5jdGlvbiAoZWwpIHtcclxuXHRcdGVsLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQoZWwpO1xyXG5cdH0sXHJcblxyXG5cdHRvQmFjazogZnVuY3Rpb24gKGVsKSB7XHJcblx0XHR2YXIgcGFyZW50ID0gZWwucGFyZW50Tm9kZTtcclxuXHRcdHBhcmVudC5pbnNlcnRCZWZvcmUoZWwsIHBhcmVudC5maXJzdENoaWxkKTtcclxuXHR9LFxyXG5cclxuXHRoYXNDbGFzczogZnVuY3Rpb24gKGVsLCBuYW1lKSB7XHJcblx0XHRpZiAoZWwuY2xhc3NMaXN0ICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0cmV0dXJuIGVsLmNsYXNzTGlzdC5jb250YWlucyhuYW1lKTtcclxuXHRcdH1cclxuXHRcdHZhciBjbGFzc05hbWUgPSBMLkRvbVV0aWwuZ2V0Q2xhc3MoZWwpO1xyXG5cdFx0cmV0dXJuIGNsYXNzTmFtZS5sZW5ndGggPiAwICYmIG5ldyBSZWdFeHAoJyhefFxcXFxzKScgKyBuYW1lICsgJyhcXFxcc3wkKScpLnRlc3QoY2xhc3NOYW1lKTtcclxuXHR9LFxyXG5cclxuXHRhZGRDbGFzczogZnVuY3Rpb24gKGVsLCBuYW1lKSB7XHJcblx0XHRpZiAoZWwuY2xhc3NMaXN0ICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0dmFyIGNsYXNzZXMgPSBMLlV0aWwuc3BsaXRXb3JkcyhuYW1lKTtcclxuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGNsYXNzZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0XHRlbC5jbGFzc0xpc3QuYWRkKGNsYXNzZXNbaV0pO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2UgaWYgKCFMLkRvbVV0aWwuaGFzQ2xhc3MoZWwsIG5hbWUpKSB7XHJcblx0XHRcdHZhciBjbGFzc05hbWUgPSBMLkRvbVV0aWwuZ2V0Q2xhc3MoZWwpO1xyXG5cdFx0XHRMLkRvbVV0aWwuc2V0Q2xhc3MoZWwsIChjbGFzc05hbWUgPyBjbGFzc05hbWUgKyAnICcgOiAnJykgKyBuYW1lKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRyZW1vdmVDbGFzczogZnVuY3Rpb24gKGVsLCBuYW1lKSB7XHJcblx0XHRpZiAoZWwuY2xhc3NMaXN0ICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0ZWwuY2xhc3NMaXN0LnJlbW92ZShuYW1lKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdEwuRG9tVXRpbC5zZXRDbGFzcyhlbCwgTC5VdGlsLnRyaW0oKCcgJyArIEwuRG9tVXRpbC5nZXRDbGFzcyhlbCkgKyAnICcpLnJlcGxhY2UoJyAnICsgbmFtZSArICcgJywgJyAnKSkpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdHNldENsYXNzOiBmdW5jdGlvbiAoZWwsIG5hbWUpIHtcclxuXHRcdGlmIChlbC5jbGFzc05hbWUuYmFzZVZhbCA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdGVsLmNsYXNzTmFtZSA9IG5hbWU7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHQvLyBpbiBjYXNlIG9mIFNWRyBlbGVtZW50XHJcblx0XHRcdGVsLmNsYXNzTmFtZS5iYXNlVmFsID0gbmFtZTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRnZXRDbGFzczogZnVuY3Rpb24gKGVsKSB7XHJcblx0XHRyZXR1cm4gZWwuY2xhc3NOYW1lLmJhc2VWYWwgPT09IHVuZGVmaW5lZCA/IGVsLmNsYXNzTmFtZSA6IGVsLmNsYXNzTmFtZS5iYXNlVmFsO1xyXG5cdH0sXHJcblxyXG5cdHNldE9wYWNpdHk6IGZ1bmN0aW9uIChlbCwgdmFsdWUpIHtcclxuXHJcblx0XHRpZiAoJ29wYWNpdHknIGluIGVsLnN0eWxlKSB7XHJcblx0XHRcdGVsLnN0eWxlLm9wYWNpdHkgPSB2YWx1ZTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCdmaWx0ZXInIGluIGVsLnN0eWxlKSB7XHJcblxyXG5cdFx0XHR2YXIgZmlsdGVyID0gZmFsc2UsXHJcblx0XHRcdCAgICBmaWx0ZXJOYW1lID0gJ0RYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0LkFscGhhJztcclxuXHJcblx0XHRcdC8vIGZpbHRlcnMgY29sbGVjdGlvbiB0aHJvd3MgYW4gZXJyb3IgaWYgd2UgdHJ5IHRvIHJldHJpZXZlIGEgZmlsdGVyIHRoYXQgZG9lc24ndCBleGlzdFxyXG5cdFx0XHR0cnkge1xyXG5cdFx0XHRcdGZpbHRlciA9IGVsLmZpbHRlcnMuaXRlbShmaWx0ZXJOYW1lKTtcclxuXHRcdFx0fSBjYXRjaCAoZSkge1xyXG5cdFx0XHRcdC8vIGRvbid0IHNldCBvcGFjaXR5IHRvIDEgaWYgd2UgaGF2ZW4ndCBhbHJlYWR5IHNldCBhbiBvcGFjaXR5LFxyXG5cdFx0XHRcdC8vIGl0IGlzbid0IG5lZWRlZCBhbmQgYnJlYWtzIHRyYW5zcGFyZW50IHBuZ3MuXHJcblx0XHRcdFx0aWYgKHZhbHVlID09PSAxKSB7IHJldHVybjsgfVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YWx1ZSA9IE1hdGgucm91bmQodmFsdWUgKiAxMDApO1xyXG5cclxuXHRcdFx0aWYgKGZpbHRlcikge1xyXG5cdFx0XHRcdGZpbHRlci5FbmFibGVkID0gKHZhbHVlICE9PSAxMDApO1xyXG5cdFx0XHRcdGZpbHRlci5PcGFjaXR5ID0gdmFsdWU7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0ZWwuc3R5bGUuZmlsdGVyICs9ICcgcHJvZ2lkOicgKyBmaWx0ZXJOYW1lICsgJyhvcGFjaXR5PScgKyB2YWx1ZSArICcpJztcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdHRlc3RQcm9wOiBmdW5jdGlvbiAocHJvcHMpIHtcclxuXHJcblx0XHR2YXIgc3R5bGUgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGU7XHJcblxyXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRpZiAocHJvcHNbaV0gaW4gc3R5bGUpIHtcclxuXHRcdFx0XHRyZXR1cm4gcHJvcHNbaV07XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHR9LFxyXG5cclxuXHRzZXRUcmFuc2Zvcm06IGZ1bmN0aW9uIChlbCwgb2Zmc2V0LCBzY2FsZSkge1xyXG5cdFx0dmFyIHBvcyA9IG9mZnNldCB8fCBuZXcgTC5Qb2ludCgwLCAwKSxcclxuXHRcdFx0aXMzZCA9IEwuQnJvd3Nlci53ZWJraXQzZCxcclxuXHRcdCAgICBvcGVuID0gJ3RyYW5zbGF0ZScgKyAoaXMzZCA/ICczZCcgOiAnJykgKyAnKCcsXHJcblx0XHQgICAgY2xvc2UgPSAoaXMzZCA/ICcsMCcgOiAnJykgKyAnKSc7XHJcblxyXG5cdFx0ZWwuc3R5bGVbTC5Eb21VdGlsLlRSQU5TRk9STV0gPVxyXG5cdFx0XHRvcGVuICsgcG9zLnggKyAncHgsJyArIHBvcy55ICsgJ3B4JyArIGNsb3NlICsgKHNjYWxlID8gJyBzY2FsZSgnICsgc2NhbGUgKyAnKScgOiAnJyk7XHJcblx0fSxcclxuXHJcblx0c2V0UG9zaXRpb246IGZ1bmN0aW9uIChlbCwgcG9pbnQsIG5vM2QpIHsgLy8gKEhUTUxFbGVtZW50LCBQb2ludFssIEJvb2xlYW5dKVxyXG5cclxuXHRcdC8vIGpzaGludCBjYW1lbGNhc2U6IGZhbHNlXHJcblx0XHRlbC5fbGVhZmxldF9wb3MgPSBwb2ludDtcclxuXHJcblx0XHRpZiAoTC5Ccm93c2VyLmFueTNkICYmICFubzNkKSB7XHJcblx0XHRcdEwuRG9tVXRpbC5zZXRUcmFuc2Zvcm0oZWwsIHBvaW50KTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGVsLnN0eWxlLmxlZnQgPSBwb2ludC54ICsgJ3B4JztcclxuXHRcdFx0ZWwuc3R5bGUudG9wID0gcG9pbnQueSArICdweCc7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Z2V0UG9zaXRpb246IGZ1bmN0aW9uIChlbCkge1xyXG5cdFx0Ly8gdGhpcyBtZXRob2QgaXMgb25seSB1c2VkIGZvciBlbGVtZW50cyBwcmV2aW91c2x5IHBvc2l0aW9uZWQgdXNpbmcgc2V0UG9zaXRpb24sXHJcblx0XHQvLyBzbyBpdCdzIHNhZmUgdG8gY2FjaGUgdGhlIHBvc2l0aW9uIGZvciBwZXJmb3JtYW5jZVxyXG5cclxuXHRcdC8vIGpzaGludCBjYW1lbGNhc2U6IGZhbHNlXHJcblx0XHRyZXR1cm4gZWwuX2xlYWZsZXRfcG9zO1xyXG5cdH1cclxufTtcclxuXHJcblxyXG4oZnVuY3Rpb24gKCkge1xyXG5cdC8vIHByZWZpeCBzdHlsZSBwcm9wZXJ0eSBuYW1lc1xyXG5cclxuXHRMLkRvbVV0aWwuVFJBTlNGT1JNID0gTC5Eb21VdGlsLnRlc3RQcm9wKFxyXG5cdFx0XHRbJ3RyYW5zZm9ybScsICdXZWJraXRUcmFuc2Zvcm0nLCAnT1RyYW5zZm9ybScsICdNb3pUcmFuc2Zvcm0nLCAnbXNUcmFuc2Zvcm0nXSk7XHJcblxyXG5cclxuXHQvLyB3ZWJraXRUcmFuc2l0aW9uIGNvbWVzIGZpcnN0IGJlY2F1c2Ugc29tZSBicm93c2VyIHZlcnNpb25zIHRoYXQgZHJvcCB2ZW5kb3IgcHJlZml4IGRvbid0IGRvXHJcblx0Ly8gdGhlIHNhbWUgZm9yIHRoZSB0cmFuc2l0aW9uZW5kIGV2ZW50LCBpbiBwYXJ0aWN1bGFyIHRoZSBBbmRyb2lkIDQuMSBzdG9jayBicm93c2VyXHJcblxyXG5cdHZhciB0cmFuc2l0aW9uID0gTC5Eb21VdGlsLlRSQU5TSVRJT04gPSBMLkRvbVV0aWwudGVzdFByb3AoXHJcblx0XHRcdFsnd2Via2l0VHJhbnNpdGlvbicsICd0cmFuc2l0aW9uJywgJ09UcmFuc2l0aW9uJywgJ01velRyYW5zaXRpb24nLCAnbXNUcmFuc2l0aW9uJ10pO1xyXG5cclxuXHRMLkRvbVV0aWwuVFJBTlNJVElPTl9FTkQgPVxyXG5cdFx0XHR0cmFuc2l0aW9uID09PSAnd2Via2l0VHJhbnNpdGlvbicgfHwgdHJhbnNpdGlvbiA9PT0gJ09UcmFuc2l0aW9uJyA/IHRyYW5zaXRpb24gKyAnRW5kJyA6ICd0cmFuc2l0aW9uZW5kJztcclxuXHJcblxyXG5cdGlmICgnb25zZWxlY3RzdGFydCcgaW4gZG9jdW1lbnQpIHtcclxuXHRcdEwuRG9tVXRpbC5kaXNhYmxlVGV4dFNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0TC5Eb21FdmVudC5vbih3aW5kb3csICdzZWxlY3RzdGFydCcsIEwuRG9tRXZlbnQucHJldmVudERlZmF1bHQpO1xyXG5cdFx0fTtcclxuXHRcdEwuRG9tVXRpbC5lbmFibGVUZXh0U2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRMLkRvbUV2ZW50Lm9mZih3aW5kb3csICdzZWxlY3RzdGFydCcsIEwuRG9tRXZlbnQucHJldmVudERlZmF1bHQpO1xyXG5cdFx0fTtcclxuXHJcblx0fSBlbHNlIHtcclxuXHRcdHZhciB1c2VyU2VsZWN0UHJvcGVydHkgPSBMLkRvbVV0aWwudGVzdFByb3AoXHJcblx0XHRcdFsndXNlclNlbGVjdCcsICdXZWJraXRVc2VyU2VsZWN0JywgJ09Vc2VyU2VsZWN0JywgJ01velVzZXJTZWxlY3QnLCAnbXNVc2VyU2VsZWN0J10pO1xyXG5cclxuXHRcdEwuRG9tVXRpbC5kaXNhYmxlVGV4dFNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0aWYgKHVzZXJTZWxlY3RQcm9wZXJ0eSkge1xyXG5cdFx0XHRcdHZhciBzdHlsZSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZTtcclxuXHRcdFx0XHR0aGlzLl91c2VyU2VsZWN0ID0gc3R5bGVbdXNlclNlbGVjdFByb3BlcnR5XTtcclxuXHRcdFx0XHRzdHlsZVt1c2VyU2VsZWN0UHJvcGVydHldID0gJ25vbmUnO1xyXG5cdFx0XHR9XHJcblx0XHR9O1xyXG5cdFx0TC5Eb21VdGlsLmVuYWJsZVRleHRTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdGlmICh1c2VyU2VsZWN0UHJvcGVydHkpIHtcclxuXHRcdFx0XHRkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGVbdXNlclNlbGVjdFByb3BlcnR5XSA9IHRoaXMuX3VzZXJTZWxlY3Q7XHJcblx0XHRcdFx0ZGVsZXRlIHRoaXMuX3VzZXJTZWxlY3Q7XHJcblx0XHRcdH1cclxuXHRcdH07XHJcblx0fVxyXG5cclxuXHRMLkRvbVV0aWwuZGlzYWJsZUltYWdlRHJhZyA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdEwuRG9tRXZlbnQub24od2luZG93LCAnZHJhZ3N0YXJ0JywgTC5Eb21FdmVudC5wcmV2ZW50RGVmYXVsdCk7XHJcblx0fTtcclxuXHRMLkRvbVV0aWwuZW5hYmxlSW1hZ2VEcmFnID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0TC5Eb21FdmVudC5vZmYod2luZG93LCAnZHJhZ3N0YXJ0JywgTC5Eb21FdmVudC5wcmV2ZW50RGVmYXVsdCk7XHJcblx0fTtcclxufSkoKTtcclxuXG4vKlxyXG4gKiBMLkxhdExuZyByZXByZXNlbnRzIGEgZ2VvZ3JhcGhpY2FsIHBvaW50IHdpdGggbGF0aXR1ZGUgYW5kIGxvbmdpdHVkZSBjb29yZGluYXRlcy5cclxuICovXHJcblxyXG5MLkxhdExuZyA9IGZ1bmN0aW9uIChsYXQsIGxuZywgYWx0KSB7XHJcblx0aWYgKGlzTmFOKGxhdCkgfHwgaXNOYU4obG5nKSkge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIExhdExuZyBvYmplY3Q6ICgnICsgbGF0ICsgJywgJyArIGxuZyArICcpJyk7XHJcblx0fVxyXG5cclxuXHR0aGlzLmxhdCA9ICtsYXQ7XHJcblx0dGhpcy5sbmcgPSArbG5nO1xyXG5cclxuXHRpZiAoYWx0ICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdHRoaXMuYWx0ID0gK2FsdDtcclxuXHR9XHJcbn07XHJcblxyXG5MLkxhdExuZy5wcm90b3R5cGUgPSB7XHJcblx0ZXF1YWxzOiBmdW5jdGlvbiAob2JqLCBtYXhNYXJnaW4pIHtcclxuXHRcdGlmICghb2JqKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cclxuXHRcdG9iaiA9IEwubGF0TG5nKG9iaik7XHJcblxyXG5cdFx0dmFyIG1hcmdpbiA9IE1hdGgubWF4KFxyXG5cdFx0ICAgICAgICBNYXRoLmFicyh0aGlzLmxhdCAtIG9iai5sYXQpLFxyXG5cdFx0ICAgICAgICBNYXRoLmFicyh0aGlzLmxuZyAtIG9iai5sbmcpKTtcclxuXHJcblx0XHRyZXR1cm4gbWFyZ2luIDw9IChtYXhNYXJnaW4gPT09IHVuZGVmaW5lZCA/IDEuMEUtOSA6IG1heE1hcmdpbik7XHJcblx0fSxcclxuXHJcblx0dG9TdHJpbmc6IGZ1bmN0aW9uIChwcmVjaXNpb24pIHtcclxuXHRcdHJldHVybiAnTGF0TG5nKCcgK1xyXG5cdFx0ICAgICAgICBMLlV0aWwuZm9ybWF0TnVtKHRoaXMubGF0LCBwcmVjaXNpb24pICsgJywgJyArXHJcblx0XHQgICAgICAgIEwuVXRpbC5mb3JtYXROdW0odGhpcy5sbmcsIHByZWNpc2lvbikgKyAnKSc7XHJcblx0fSxcclxuXHJcblx0ZGlzdGFuY2VUbzogZnVuY3Rpb24gKG90aGVyKSB7XHJcblx0XHRyZXR1cm4gTC5DUlMuRWFydGguZGlzdGFuY2UodGhpcywgTC5sYXRMbmcob3RoZXIpKTtcclxuXHR9LFxyXG5cclxuXHR3cmFwOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gTC5DUlMuRWFydGgud3JhcExhdExuZyh0aGlzKTtcclxuXHR9XHJcbn07XHJcblxyXG5cclxuLy8gY29uc3RydWN0cyBMYXRMbmcgd2l0aCBkaWZmZXJlbnQgc2lnbmF0dXJlc1xyXG4vLyAoTGF0TG5nKSBvciAoW051bWJlciwgTnVtYmVyXSkgb3IgKE51bWJlciwgTnVtYmVyKSBvciAoT2JqZWN0KVxyXG5cclxuTC5sYXRMbmcgPSBmdW5jdGlvbiAoYSwgYikge1xyXG5cdGlmIChhIGluc3RhbmNlb2YgTC5MYXRMbmcpIHtcclxuXHRcdHJldHVybiBhO1xyXG5cdH1cclxuXHRpZiAoTC5VdGlsLmlzQXJyYXkoYSkgJiYgdHlwZW9mIGFbMF0gIT09ICdvYmplY3QnKSB7XHJcblx0XHRpZiAoYS5sZW5ndGggPT09IDMpIHtcclxuXHRcdFx0cmV0dXJuIG5ldyBMLkxhdExuZyhhWzBdLCBhWzFdLCBhWzJdKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBuZXcgTC5MYXRMbmcoYVswXSwgYVsxXSk7XHJcblx0fVxyXG5cdGlmIChhID09PSB1bmRlZmluZWQgfHwgYSA9PT0gbnVsbCkge1xyXG5cdFx0cmV0dXJuIGE7XHJcblx0fVxyXG5cdGlmICh0eXBlb2YgYSA9PT0gJ29iamVjdCcgJiYgJ2xhdCcgaW4gYSkge1xyXG5cdFx0cmV0dXJuIG5ldyBMLkxhdExuZyhhLmxhdCwgJ2xuZycgaW4gYSA/IGEubG5nIDogYS5sb24pO1xyXG5cdH1cclxuXHRpZiAoYiA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRyZXR1cm4gbnVsbDtcclxuXHR9XHJcblx0cmV0dXJuIG5ldyBMLkxhdExuZyhhLCBiKTtcclxufTtcclxuXHJcblxuLypcclxuICogTC5MYXRMbmdCb3VuZHMgcmVwcmVzZW50cyBhIHJlY3Rhbmd1bGFyIGFyZWEgb24gdGhlIG1hcCBpbiBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZXMuXHJcbiAqL1xyXG5cclxuTC5MYXRMbmdCb3VuZHMgPSBmdW5jdGlvbiAoc291dGhXZXN0LCBub3J0aEVhc3QpIHsgLy8gKExhdExuZywgTGF0TG5nKSBvciAoTGF0TG5nW10pXHJcblx0aWYgKCFzb3V0aFdlc3QpIHsgcmV0dXJuOyB9XHJcblxyXG5cdHZhciBsYXRsbmdzID0gbm9ydGhFYXN0ID8gW3NvdXRoV2VzdCwgbm9ydGhFYXN0XSA6IHNvdXRoV2VzdDtcclxuXHJcblx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGxhdGxuZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdHRoaXMuZXh0ZW5kKGxhdGxuZ3NbaV0pO1xyXG5cdH1cclxufTtcclxuXHJcbkwuTGF0TG5nQm91bmRzLnByb3RvdHlwZSA9IHtcclxuXHJcblx0Ly8gZXh0ZW5kIHRoZSBib3VuZHMgdG8gY29udGFpbiB0aGUgZ2l2ZW4gcG9pbnQgb3IgYm91bmRzXHJcblx0ZXh0ZW5kOiBmdW5jdGlvbiAob2JqKSB7IC8vIChMYXRMbmcpIG9yIChMYXRMbmdCb3VuZHMpXHJcblx0XHR2YXIgc3cgPSB0aGlzLl9zb3V0aFdlc3QsXHJcblx0XHRcdG5lID0gdGhpcy5fbm9ydGhFYXN0LFxyXG5cdFx0XHRzdzIsIG5lMjtcclxuXHJcblx0XHRpZiAob2JqIGluc3RhbmNlb2YgTC5MYXRMbmcpIHtcclxuXHRcdFx0c3cyID0gb2JqO1xyXG5cdFx0XHRuZTIgPSBvYmo7XHJcblxyXG5cdFx0fSBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBMLkxhdExuZ0JvdW5kcykge1xyXG5cdFx0XHRzdzIgPSBvYmouX3NvdXRoV2VzdDtcclxuXHRcdFx0bmUyID0gb2JqLl9ub3J0aEVhc3Q7XHJcblxyXG5cdFx0XHRpZiAoIXN3MiB8fCAhbmUyKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cmV0dXJuIG9iaiA/IHRoaXMuZXh0ZW5kKEwubGF0TG5nKG9iaikgfHwgTC5sYXRMbmdCb3VuZHMob2JqKSkgOiB0aGlzO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICghc3cgJiYgIW5lKSB7XHJcblx0XHRcdHRoaXMuX3NvdXRoV2VzdCA9IG5ldyBMLkxhdExuZyhzdzIubGF0LCBzdzIubG5nKTtcclxuXHRcdFx0dGhpcy5fbm9ydGhFYXN0ID0gbmV3IEwuTGF0TG5nKG5lMi5sYXQsIG5lMi5sbmcpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0c3cubGF0ID0gTWF0aC5taW4oc3cyLmxhdCwgc3cubGF0KTtcclxuXHRcdFx0c3cubG5nID0gTWF0aC5taW4oc3cyLmxuZywgc3cubG5nKTtcclxuXHRcdFx0bmUubGF0ID0gTWF0aC5tYXgobmUyLmxhdCwgbmUubGF0KTtcclxuXHRcdFx0bmUubG5nID0gTWF0aC5tYXgobmUyLmxuZywgbmUubG5nKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBleHRlbmQgdGhlIGJvdW5kcyBieSBhIHBlcmNlbnRhZ2VcclxuXHRwYWQ6IGZ1bmN0aW9uIChidWZmZXJSYXRpbykgeyAvLyAoTnVtYmVyKSAtPiBMYXRMbmdCb3VuZHNcclxuXHRcdHZhciBzdyA9IHRoaXMuX3NvdXRoV2VzdCxcclxuXHRcdCAgICBuZSA9IHRoaXMuX25vcnRoRWFzdCxcclxuXHRcdCAgICBoZWlnaHRCdWZmZXIgPSBNYXRoLmFicyhzdy5sYXQgLSBuZS5sYXQpICogYnVmZmVyUmF0aW8sXHJcblx0XHQgICAgd2lkdGhCdWZmZXIgPSBNYXRoLmFicyhzdy5sbmcgLSBuZS5sbmcpICogYnVmZmVyUmF0aW87XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBMLkxhdExuZ0JvdW5kcyhcclxuXHRcdCAgICAgICAgbmV3IEwuTGF0TG5nKHN3LmxhdCAtIGhlaWdodEJ1ZmZlciwgc3cubG5nIC0gd2lkdGhCdWZmZXIpLFxyXG5cdFx0ICAgICAgICBuZXcgTC5MYXRMbmcobmUubGF0ICsgaGVpZ2h0QnVmZmVyLCBuZS5sbmcgKyB3aWR0aEJ1ZmZlcikpO1xyXG5cdH0sXHJcblxyXG5cdGdldENlbnRlcjogZnVuY3Rpb24gKCkgeyAvLyAtPiBMYXRMbmdcclxuXHRcdHJldHVybiBuZXcgTC5MYXRMbmcoXHJcblx0XHQgICAgICAgICh0aGlzLl9zb3V0aFdlc3QubGF0ICsgdGhpcy5fbm9ydGhFYXN0LmxhdCkgLyAyLFxyXG5cdFx0ICAgICAgICAodGhpcy5fc291dGhXZXN0LmxuZyArIHRoaXMuX25vcnRoRWFzdC5sbmcpIC8gMik7XHJcblx0fSxcclxuXHJcblx0Z2V0U291dGhXZXN0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fc291dGhXZXN0O1xyXG5cdH0sXHJcblxyXG5cdGdldE5vcnRoRWFzdDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX25vcnRoRWFzdDtcclxuXHR9LFxyXG5cclxuXHRnZXROb3J0aFdlc3Q6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBuZXcgTC5MYXRMbmcodGhpcy5nZXROb3J0aCgpLCB0aGlzLmdldFdlc3QoKSk7XHJcblx0fSxcclxuXHJcblx0Z2V0U291dGhFYXN0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gbmV3IEwuTGF0TG5nKHRoaXMuZ2V0U291dGgoKSwgdGhpcy5nZXRFYXN0KCkpO1xyXG5cdH0sXHJcblxyXG5cdGdldFdlc3Q6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9zb3V0aFdlc3QubG5nO1xyXG5cdH0sXHJcblxyXG5cdGdldFNvdXRoOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fc291dGhXZXN0LmxhdDtcclxuXHR9LFxyXG5cclxuXHRnZXRFYXN0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fbm9ydGhFYXN0LmxuZztcclxuXHR9LFxyXG5cclxuXHRnZXROb3J0aDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX25vcnRoRWFzdC5sYXQ7XHJcblx0fSxcclxuXHJcblx0Y29udGFpbnM6IGZ1bmN0aW9uIChvYmopIHsgLy8gKExhdExuZ0JvdW5kcykgb3IgKExhdExuZykgLT4gQm9vbGVhblxyXG5cdFx0aWYgKHR5cGVvZiBvYmpbMF0gPT09ICdudW1iZXInIHx8IG9iaiBpbnN0YW5jZW9mIEwuTGF0TG5nKSB7XHJcblx0XHRcdG9iaiA9IEwubGF0TG5nKG9iaik7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRvYmogPSBMLmxhdExuZ0JvdW5kcyhvYmopO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBzdyA9IHRoaXMuX3NvdXRoV2VzdCxcclxuXHRcdCAgICBuZSA9IHRoaXMuX25vcnRoRWFzdCxcclxuXHRcdCAgICBzdzIsIG5lMjtcclxuXHJcblx0XHRpZiAob2JqIGluc3RhbmNlb2YgTC5MYXRMbmdCb3VuZHMpIHtcclxuXHRcdFx0c3cyID0gb2JqLmdldFNvdXRoV2VzdCgpO1xyXG5cdFx0XHRuZTIgPSBvYmouZ2V0Tm9ydGhFYXN0KCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRzdzIgPSBuZTIgPSBvYmo7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIChzdzIubGF0ID49IHN3LmxhdCkgJiYgKG5lMi5sYXQgPD0gbmUubGF0KSAmJlxyXG5cdFx0ICAgICAgIChzdzIubG5nID49IHN3LmxuZykgJiYgKG5lMi5sbmcgPD0gbmUubG5nKTtcclxuXHR9LFxyXG5cclxuXHRpbnRlcnNlY3RzOiBmdW5jdGlvbiAoYm91bmRzKSB7IC8vIChMYXRMbmdCb3VuZHMpXHJcblx0XHRib3VuZHMgPSBMLmxhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cclxuXHRcdHZhciBzdyA9IHRoaXMuX3NvdXRoV2VzdCxcclxuXHRcdCAgICBuZSA9IHRoaXMuX25vcnRoRWFzdCxcclxuXHRcdCAgICBzdzIgPSBib3VuZHMuZ2V0U291dGhXZXN0KCksXHJcblx0XHQgICAgbmUyID0gYm91bmRzLmdldE5vcnRoRWFzdCgpLFxyXG5cclxuXHRcdCAgICBsYXRJbnRlcnNlY3RzID0gKG5lMi5sYXQgPj0gc3cubGF0KSAmJiAoc3cyLmxhdCA8PSBuZS5sYXQpLFxyXG5cdFx0ICAgIGxuZ0ludGVyc2VjdHMgPSAobmUyLmxuZyA+PSBzdy5sbmcpICYmIChzdzIubG5nIDw9IG5lLmxuZyk7XHJcblxyXG5cdFx0cmV0dXJuIGxhdEludGVyc2VjdHMgJiYgbG5nSW50ZXJzZWN0cztcclxuXHR9LFxyXG5cclxuXHR0b0JCb3hTdHJpbmc6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBbdGhpcy5nZXRXZXN0KCksIHRoaXMuZ2V0U291dGgoKSwgdGhpcy5nZXRFYXN0KCksIHRoaXMuZ2V0Tm9ydGgoKV0uam9pbignLCcpO1xyXG5cdH0sXHJcblxyXG5cdGVxdWFsczogZnVuY3Rpb24gKGJvdW5kcykgeyAvLyAoTGF0TG5nQm91bmRzKVxyXG5cdFx0aWYgKCFib3VuZHMpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblxyXG5cdFx0Ym91bmRzID0gTC5sYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5fc291dGhXZXN0LmVxdWFscyhib3VuZHMuZ2V0U291dGhXZXN0KCkpICYmXHJcblx0XHQgICAgICAgdGhpcy5fbm9ydGhFYXN0LmVxdWFscyhib3VuZHMuZ2V0Tm9ydGhFYXN0KCkpO1xyXG5cdH0sXHJcblxyXG5cdGlzVmFsaWQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiAhISh0aGlzLl9zb3V0aFdlc3QgJiYgdGhpcy5fbm9ydGhFYXN0KTtcclxuXHR9XHJcbn07XHJcblxyXG4vL1RPRE8gSW50ZXJuYXRpb25hbCBkYXRlIGxpbmU/XHJcblxyXG5MLmxhdExuZ0JvdW5kcyA9IGZ1bmN0aW9uIChhLCBiKSB7IC8vIChMYXRMbmdCb3VuZHMpIG9yIChMYXRMbmcsIExhdExuZylcclxuXHRpZiAoIWEgfHwgYSBpbnN0YW5jZW9mIEwuTGF0TG5nQm91bmRzKSB7XHJcblx0XHRyZXR1cm4gYTtcclxuXHR9XHJcblx0cmV0dXJuIG5ldyBMLkxhdExuZ0JvdW5kcyhhLCBiKTtcclxufTtcclxuXG4vKlxyXG4gKiBTaW1wbGUgZXF1aXJlY3Rhbmd1bGFyIChQbGF0ZSBDYXJyZWUpIHByb2plY3Rpb24sIHVzZWQgYnkgQ1JTIGxpa2UgRVBTRzo0MzI2IGFuZCBTaW1wbGUuXHJcbiAqL1xyXG5cclxuTC5Qcm9qZWN0aW9uID0ge307XHJcblxyXG5MLlByb2plY3Rpb24uTG9uTGF0ID0ge1xyXG5cdHByb2plY3Q6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHJldHVybiBuZXcgTC5Qb2ludChsYXRsbmcubG5nLCBsYXRsbmcubGF0KTtcclxuXHR9LFxyXG5cclxuXHR1bnByb2plY3Q6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0cmV0dXJuIG5ldyBMLkxhdExuZyhwb2ludC55LCBwb2ludC54KTtcclxuXHR9LFxyXG5cclxuXHRib3VuZHM6IEwuYm91bmRzKFstMTgwLCAtOTBdLCBbMTgwLCA5MF0pXHJcbn07XHJcblxuLypcclxuICogU3BoZXJpY2FsIE1lcmNhdG9yIGlzIHRoZSBtb3N0IHBvcHVsYXIgbWFwIHByb2plY3Rpb24sIHVzZWQgYnkgRVBTRzozODU3IENSUyB1c2VkIGJ5IGRlZmF1bHQuXHJcbiAqL1xyXG5cclxuTC5Qcm9qZWN0aW9uLlNwaGVyaWNhbE1lcmNhdG9yID0ge1xyXG5cclxuXHRSOiA2Mzc4MTM3LFxyXG5cclxuXHRwcm9qZWN0OiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHR2YXIgZCA9IE1hdGguUEkgLyAxODAsXHJcblx0XHQgICAgbWF4ID0gMSAtIDFFLTE1LFxyXG5cdFx0ICAgIHNpbiA9IE1hdGgubWF4KE1hdGgubWluKE1hdGguc2luKGxhdGxuZy5sYXQgKiBkKSwgbWF4KSwgLW1heCk7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBMLlBvaW50KFxyXG5cdFx0XHRcdHRoaXMuUiAqIGxhdGxuZy5sbmcgKiBkLFxyXG5cdFx0XHRcdHRoaXMuUiAqIE1hdGgubG9nKCgxICsgc2luKSAvICgxIC0gc2luKSkgLyAyKTtcclxuXHR9LFxyXG5cclxuXHR1bnByb2plY3Q6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0dmFyIGQgPSAxODAgLyBNYXRoLlBJO1xyXG5cclxuXHRcdHJldHVybiBuZXcgTC5MYXRMbmcoXHJcblx0XHRcdCgyICogTWF0aC5hdGFuKE1hdGguZXhwKHBvaW50LnkgLyB0aGlzLlIpKSAtIChNYXRoLlBJIC8gMikpICogZCxcclxuXHRcdFx0cG9pbnQueCAqIGQgLyB0aGlzLlIpO1xyXG5cdH0sXHJcblxyXG5cdGJvdW5kczogKGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBkID0gNjM3ODEzNyAqIE1hdGguUEk7XHJcblx0XHRyZXR1cm4gTC5ib3VuZHMoWy1kLCAtZF0sIFtkLCBkXSk7XHJcblx0fSkoKVxyXG59O1xyXG5cbi8qXHJcbiAqIEwuQ1JTIGlzIHRoZSBiYXNlIG9iamVjdCBmb3IgYWxsIGRlZmluZWQgQ1JTIChDb29yZGluYXRlIFJlZmVyZW5jZSBTeXN0ZW1zKSBpbiBMZWFmbGV0LlxyXG4gKi9cclxuXHJcbkwuQ1JTID0ge1xyXG5cdC8vIGNvbnZlcnRzIGdlbyBjb29yZHMgdG8gcGl4ZWwgb25lc1xyXG5cdGxhdExuZ1RvUG9pbnQ6IGZ1bmN0aW9uIChsYXRsbmcsIHpvb20pIHtcclxuXHRcdHZhciBwcm9qZWN0ZWRQb2ludCA9IHRoaXMucHJvamVjdGlvbi5wcm9qZWN0KGxhdGxuZyksXHJcblx0XHQgICAgc2NhbGUgPSB0aGlzLnNjYWxlKHpvb20pO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnRyYW5zZm9ybWF0aW9uLl90cmFuc2Zvcm0ocHJvamVjdGVkUG9pbnQsIHNjYWxlKTtcclxuXHR9LFxyXG5cclxuXHQvLyBjb252ZXJ0cyBwaXhlbCBjb29yZHMgdG8gZ2VvIGNvb3Jkc1xyXG5cdHBvaW50VG9MYXRMbmc6IGZ1bmN0aW9uIChwb2ludCwgem9vbSkge1xyXG5cdFx0dmFyIHNjYWxlID0gdGhpcy5zY2FsZSh6b29tKSxcclxuXHRcdCAgICB1bnRyYW5zZm9ybWVkUG9pbnQgPSB0aGlzLnRyYW5zZm9ybWF0aW9uLnVudHJhbnNmb3JtKHBvaW50LCBzY2FsZSk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMucHJvamVjdGlvbi51bnByb2plY3QodW50cmFuc2Zvcm1lZFBvaW50KTtcclxuXHR9LFxyXG5cclxuXHQvLyBjb252ZXJ0cyBnZW8gY29vcmRzIHRvIHByb2plY3Rpb24tc3BlY2lmaWMgY29vcmRzIChlLmcuIGluIG1ldGVycylcclxuXHRwcm9qZWN0OiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5wcm9qZWN0aW9uLnByb2plY3QobGF0bG5nKTtcclxuXHR9LFxyXG5cclxuXHQvLyBjb252ZXJ0cyBwcm9qZWN0ZWQgY29vcmRzIHRvIGdlbyBjb29yZHNcclxuXHR1bnByb2plY3Q6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0cmV0dXJuIHRoaXMucHJvamVjdGlvbi51bnByb2plY3QocG9pbnQpO1xyXG5cdH0sXHJcblxyXG5cdC8vIGRlZmluZXMgaG93IHRoZSB3b3JsZCBzY2FsZXMgd2l0aCB6b29tXHJcblx0c2NhbGU6IGZ1bmN0aW9uICh6b29tKSB7XHJcblx0XHRyZXR1cm4gMjU2ICogTWF0aC5wb3coMiwgem9vbSk7XHJcblx0fSxcclxuXHJcblx0Ly8gcmV0dXJucyB0aGUgYm91bmRzIG9mIHRoZSB3b3JsZCBpbiBwcm9qZWN0ZWQgY29vcmRzIGlmIGFwcGxpY2FibGVcclxuXHRnZXRQcm9qZWN0ZWRCb3VuZHM6IGZ1bmN0aW9uICh6b29tKSB7XHJcblx0XHRpZiAodGhpcy5pbmZpbml0ZSkgeyByZXR1cm4gbnVsbDsgfVxyXG5cclxuXHRcdHZhciBiID0gdGhpcy5wcm9qZWN0aW9uLmJvdW5kcyxcclxuXHRcdCAgICBzID0gdGhpcy5zY2FsZSh6b29tKSxcclxuXHRcdCAgICBtaW4gPSB0aGlzLnRyYW5zZm9ybWF0aW9uLnRyYW5zZm9ybShiLm1pbiwgcyksXHJcblx0XHQgICAgbWF4ID0gdGhpcy50cmFuc2Zvcm1hdGlvbi50cmFuc2Zvcm0oYi5tYXgsIHMpO1xyXG5cclxuXHRcdHJldHVybiBMLmJvdW5kcyhtaW4sIG1heCk7XHJcblx0fSxcclxuXHJcblx0Ly8gd2hldGhlciBhIGNvb3JkaW5hdGUgYXhpcyB3cmFwcyBpbiBhIGdpdmVuIHJhbmdlIChlLmcuIGxvbmdpdHVkZSBmcm9tIC0xODAgdG8gMTgwKTsgZGVwZW5kcyBvbiBDUlNcclxuXHQvLyB3cmFwTG5nOiBbbWluLCBtYXhdLFxyXG5cdC8vIHdyYXBMYXQ6IFttaW4sIG1heF0sXHJcblxyXG5cdC8vIGlmIHRydWUsIHRoZSBjb29yZGluYXRlIHNwYWNlIHdpbGwgYmUgdW5ib3VuZGVkIChpbmZpbml0ZSBpbiBhbGwgZGlyZWN0aW9ucylcclxuXHQvLyBpbmZpbml0ZTogZmFsc2UsXHJcblxyXG5cdC8vIHdyYXBzIGdlbyBjb29yZHMgaW4gY2VydGFpbiByYW5nZXMgaWYgYXBwbGljYWJsZVxyXG5cdHdyYXBMYXRMbmc6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHZhciBsbmcgPSB0aGlzLndyYXBMbmcgPyBMLlV0aWwud3JhcE51bShsYXRsbmcubG5nLCB0aGlzLndyYXBMbmcsIHRydWUpIDogbGF0bG5nLmxuZyxcclxuXHRcdCAgICBsYXQgPSB0aGlzLndyYXBMYXQgPyBMLlV0aWwud3JhcE51bShsYXRsbmcubGF0LCB0aGlzLndyYXBMYXQsIHRydWUpIDogbGF0bG5nLmxhdDtcclxuXHJcblx0XHRyZXR1cm4gTC5sYXRMbmcobGF0LCBsbmcpO1xyXG5cdH1cclxufTtcclxuXG4vKlxuICogQSBzaW1wbGUgQ1JTIHRoYXQgY2FuIGJlIHVzZWQgZm9yIGZsYXQgbm9uLUVhcnRoIG1hcHMgbGlrZSBwYW5vcmFtYXMgb3IgZ2FtZSBtYXBzLlxuICovXG5cbkwuQ1JTLlNpbXBsZSA9IEwuZXh0ZW5kKHt9LCBMLkNSUywge1xuXHRwcm9qZWN0aW9uOiBMLlByb2plY3Rpb24uTG9uTGF0LFxuXHR0cmFuc2Zvcm1hdGlvbjogbmV3IEwuVHJhbnNmb3JtYXRpb24oMSwgMCwgLTEsIDApLFxuXG5cdHNjYWxlOiBmdW5jdGlvbiAoem9vbSkge1xuXHRcdHJldHVybiBNYXRoLnBvdygyLCB6b29tKTtcblx0fSxcblxuXHRkaXN0YW5jZTogZnVuY3Rpb24gKGxhdGxuZzEsIGxhdGxuZzIpIHtcblx0XHR2YXIgZHggPSBsYXRsbmcyLmxuZyAtIGxhdGxuZzEubG5nLFxuXHRcdCAgICBkeSA9IGxhdGxuZzIubGF0IC0gbGF0bG5nMS5sYXQ7XG5cblx0XHRyZXR1cm4gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcblx0fSxcblxuXHRpbmZpbml0ZTogdHJ1ZVxufSk7XG5cbi8qXG4gKiBMLkNSUy5FYXJ0aCBpcyB0aGUgYmFzZSBjbGFzcyBmb3IgYWxsIENSUyByZXByZXNlbnRpbmcgRWFydGguXG4gKi9cblxuTC5DUlMuRWFydGggPSBMLmV4dGVuZCh7fSwgTC5DUlMsIHtcblx0d3JhcExuZzogWy0xODAsIDE4MF0sXG5cblx0UjogNjM3ODEzNyxcblxuXHQvLyBkaXN0YW5lIGJldHdlZW4gdHdvIGdlb2dyYXBoaWNhbCBwb2ludHMgdXNpbmcgc3BoZXJpY2FsIGxhdyBvZiBjb3NpbmVzIGFwcHJveGltYXRpb25cblx0ZGlzdGFuY2U6IGZ1bmN0aW9uIChsYXRsbmcxLCBsYXRsbmcyKSB7XG5cdFx0dmFyIHJhZCA9IE1hdGguUEkgLyAxODAsXG5cdFx0ICAgIGxhdDEgPSBsYXRsbmcxLmxhdCAqIHJhZCxcblx0XHQgICAgbGF0MiA9IGxhdGxuZzIubGF0ICogcmFkO1xuXG5cdFx0cmV0dXJuIHRoaXMuUiAqIE1hdGguYWNvcyhNYXRoLnNpbihsYXQxKSAqIE1hdGguc2luKGxhdDIpICtcblx0XHRcdFx0TWF0aC5jb3MobGF0MSkgKiBNYXRoLmNvcyhsYXQyKSAqIE1hdGguY29zKChsYXRsbmcyLmxuZyAtIGxhdGxuZzEubG5nKSAqIHJhZCkpO1xuXHR9XG59KTtcblxuLypcclxuICogTC5DUlMuRVBTRzM4NTcgKFNwaGVyaWNhbCBNZXJjYXRvcikgaXMgdGhlIG1vc3QgY29tbW9uIENSUyBmb3Igd2ViIG1hcHBpbmcgYW5kIGlzIHVzZWQgYnkgTGVhZmxldCBieSBkZWZhdWx0LlxyXG4gKi9cclxuXHJcbkwuQ1JTLkVQU0czODU3ID0gTC5leHRlbmQoe30sIEwuQ1JTLkVhcnRoLCB7XHJcblx0Y29kZTogJ0VQU0c6Mzg1NycsXHJcblx0cHJvamVjdGlvbjogTC5Qcm9qZWN0aW9uLlNwaGVyaWNhbE1lcmNhdG9yLFxyXG5cclxuXHR0cmFuc2Zvcm1hdGlvbjogKGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBzY2FsZSA9IDAuNSAvIChNYXRoLlBJICogTC5Qcm9qZWN0aW9uLlNwaGVyaWNhbE1lcmNhdG9yLlIpO1xyXG5cdFx0cmV0dXJuIG5ldyBMLlRyYW5zZm9ybWF0aW9uKHNjYWxlLCAwLjUsIC1zY2FsZSwgMC41KTtcclxuXHR9KCkpXHJcbn0pO1xyXG5cclxuTC5DUlMuRVBTRzkwMDkxMyA9IEwuZXh0ZW5kKHt9LCBMLkNSUy5FUFNHMzg1Nywge1xyXG5cdGNvZGU6ICdFUFNHOjkwMDkxMydcclxufSk7XHJcblxuLypcclxuICogTC5DUlMuRVBTRzQzMjYgaXMgYSBDUlMgcG9wdWxhciBhbW9uZyBhZHZhbmNlZCBHSVMgc3BlY2lhbGlzdHMuXHJcbiAqL1xyXG5cclxuTC5DUlMuRVBTRzQzMjYgPSBMLmV4dGVuZCh7fSwgTC5DUlMuRWFydGgsIHtcclxuXHRjb2RlOiAnRVBTRzo0MzI2JyxcclxuXHRwcm9qZWN0aW9uOiBMLlByb2plY3Rpb24uTG9uTGF0LFxyXG5cdHRyYW5zZm9ybWF0aW9uOiBuZXcgTC5UcmFuc2Zvcm1hdGlvbigxIC8gMTgwLCAxLCAtMSAvIDE4MCwgMC41KVxyXG59KTtcclxuXG4vKlxyXG4gKiBMLk1hcCBpcyB0aGUgY2VudHJhbCBjbGFzcyBvZiB0aGUgQVBJIC0gaXQgaXMgdXNlZCB0byBjcmVhdGUgYSBtYXAuXHJcbiAqL1xyXG5cclxuTC5NYXAgPSBMLkV2ZW50ZWQuZXh0ZW5kKHtcclxuXHJcblx0b3B0aW9uczoge1xyXG5cdFx0Y3JzOiBMLkNSUy5FUFNHMzg1NyxcclxuXHJcblx0XHQvKlxyXG5cdFx0Y2VudGVyOiBMYXRMbmcsXHJcblx0XHR6b29tOiBOdW1iZXIsXHJcblx0XHRsYXllcnM6IEFycmF5LFxyXG5cdFx0Ki9cclxuXHJcblx0XHRmYWRlQW5pbWF0aW9uOiB0cnVlLFxyXG5cdFx0dHJhY2tSZXNpemU6IHRydWUsXHJcblx0XHRtYXJrZXJab29tQW5pbWF0aW9uOiB0cnVlXHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGlkLCBvcHRpb25zKSB7IC8vIChIVE1MRWxlbWVudCBvciBTdHJpbmcsIE9iamVjdClcclxuXHRcdG9wdGlvbnMgPSBMLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG5cdFx0dGhpcy5faW5pdENvbnRhaW5lcihpZCk7XHJcblx0XHR0aGlzLl9pbml0TGF5b3V0KCk7XHJcblxyXG5cdFx0Ly8gaGFjayBmb3IgaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC9pc3N1ZXMvMTk4MFxyXG5cdFx0dGhpcy5fb25SZXNpemUgPSBMLmJpbmQodGhpcy5fb25SZXNpemUsIHRoaXMpO1xyXG5cclxuXHRcdHRoaXMuX2luaXRFdmVudHMoKTtcclxuXHJcblx0XHRpZiAob3B0aW9ucy5tYXhCb3VuZHMpIHtcclxuXHRcdFx0dGhpcy5zZXRNYXhCb3VuZHMob3B0aW9ucy5tYXhCb3VuZHMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChvcHRpb25zLmNlbnRlciAmJiBvcHRpb25zLnpvb20gIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHR0aGlzLnNldFZpZXcoTC5sYXRMbmcob3B0aW9ucy5jZW50ZXIpLCBvcHRpb25zLnpvb20sIHtyZXNldDogdHJ1ZX0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2hhbmRsZXJzID0gW107XHJcblx0XHR0aGlzLl9sYXllcnMgPSB7fTtcclxuXHRcdHRoaXMuX3pvb21Cb3VuZExheWVycyA9IHt9O1xyXG5cclxuXHRcdHRoaXMuY2FsbEluaXRIb29rcygpO1xyXG5cclxuXHRcdHRoaXMuX2FkZExheWVycyh0aGlzLm9wdGlvbnMubGF5ZXJzKTtcclxuXHR9LFxyXG5cclxuXHJcblx0Ly8gcHVibGljIG1ldGhvZHMgdGhhdCBtb2RpZnkgbWFwIHN0YXRlXHJcblxyXG5cdC8vIHJlcGxhY2VkIGJ5IGFuaW1hdGlvbi1wb3dlcmVkIGltcGxlbWVudGF0aW9uIGluIE1hcC5QYW5BbmltYXRpb24uanNcclxuXHRzZXRWaWV3OiBmdW5jdGlvbiAoY2VudGVyLCB6b29tKSB7XHJcblx0XHR6b29tID0gem9vbSA9PT0gdW5kZWZpbmVkID8gdGhpcy5nZXRab29tKCkgOiB6b29tO1xyXG5cdFx0dGhpcy5fcmVzZXRWaWV3KEwubGF0TG5nKGNlbnRlciksIHRoaXMuX2xpbWl0Wm9vbSh6b29tKSk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRzZXRab29tOiBmdW5jdGlvbiAoem9vbSwgb3B0aW9ucykge1xyXG5cdFx0aWYgKCF0aGlzLl9sb2FkZWQpIHtcclxuXHRcdFx0dGhpcy5fem9vbSA9IHRoaXMuX2xpbWl0Wm9vbSh6b29tKTtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcy5zZXRWaWV3KHRoaXMuZ2V0Q2VudGVyKCksIHpvb20sIHt6b29tOiBvcHRpb25zfSk7XHJcblx0fSxcclxuXHJcblx0em9vbUluOiBmdW5jdGlvbiAoZGVsdGEsIG9wdGlvbnMpIHtcclxuXHRcdHJldHVybiB0aGlzLnNldFpvb20odGhpcy5fem9vbSArIChkZWx0YSB8fCAxKSwgb3B0aW9ucyk7XHJcblx0fSxcclxuXHJcblx0em9vbU91dDogZnVuY3Rpb24gKGRlbHRhLCBvcHRpb25zKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5zZXRab29tKHRoaXMuX3pvb20gLSAoZGVsdGEgfHwgMSksIG9wdGlvbnMpO1xyXG5cdH0sXHJcblxyXG5cdHNldFpvb21Bcm91bmQ6IGZ1bmN0aW9uIChsYXRsbmcsIHpvb20sIG9wdGlvbnMpIHtcclxuXHRcdHZhciBzY2FsZSA9IHRoaXMuZ2V0Wm9vbVNjYWxlKHpvb20pLFxyXG5cdFx0ICAgIHZpZXdIYWxmID0gdGhpcy5nZXRTaXplKCkuZGl2aWRlQnkoMiksXHJcblx0XHQgICAgY29udGFpbmVyUG9pbnQgPSBsYXRsbmcgaW5zdGFuY2VvZiBMLlBvaW50ID8gbGF0bG5nIDogdGhpcy5sYXRMbmdUb0NvbnRhaW5lclBvaW50KGxhdGxuZyksXHJcblxyXG5cdFx0ICAgIGNlbnRlck9mZnNldCA9IGNvbnRhaW5lclBvaW50LnN1YnRyYWN0KHZpZXdIYWxmKS5tdWx0aXBseUJ5KDEgLSAxIC8gc2NhbGUpLFxyXG5cdFx0ICAgIG5ld0NlbnRlciA9IHRoaXMuY29udGFpbmVyUG9pbnRUb0xhdExuZyh2aWV3SGFsZi5hZGQoY2VudGVyT2Zmc2V0KSk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuc2V0VmlldyhuZXdDZW50ZXIsIHpvb20sIHt6b29tOiBvcHRpb25zfSk7XHJcblx0fSxcclxuXHJcblx0Zml0Qm91bmRzOiBmdW5jdGlvbiAoYm91bmRzLCBvcHRpb25zKSB7XHJcblxyXG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblx0XHRib3VuZHMgPSBib3VuZHMuZ2V0Qm91bmRzID8gYm91bmRzLmdldEJvdW5kcygpIDogTC5sYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHR2YXIgcGFkZGluZ1RMID0gTC5wb2ludChvcHRpb25zLnBhZGRpbmdUb3BMZWZ0IHx8IG9wdGlvbnMucGFkZGluZyB8fCBbMCwgMF0pLFxyXG5cdFx0ICAgIHBhZGRpbmdCUiA9IEwucG9pbnQob3B0aW9ucy5wYWRkaW5nQm90dG9tUmlnaHQgfHwgb3B0aW9ucy5wYWRkaW5nIHx8IFswLCAwXSksXHJcblxyXG5cdFx0ICAgIHpvb20gPSB0aGlzLmdldEJvdW5kc1pvb20oYm91bmRzLCBmYWxzZSwgcGFkZGluZ1RMLmFkZChwYWRkaW5nQlIpKTtcclxuXHJcblx0XHR6b29tID0gb3B0aW9ucy5tYXhab29tID8gTWF0aC5taW4ob3B0aW9ucy5tYXhab29tLCB6b29tKSA6IHpvb207XHJcblxyXG5cdFx0dmFyIHBhZGRpbmdPZmZzZXQgPSBwYWRkaW5nQlIuc3VidHJhY3QocGFkZGluZ1RMKS5kaXZpZGVCeSgyKSxcclxuXHJcblx0XHQgICAgc3dQb2ludCA9IHRoaXMucHJvamVjdChib3VuZHMuZ2V0U291dGhXZXN0KCksIHpvb20pLFxyXG5cdFx0ICAgIG5lUG9pbnQgPSB0aGlzLnByb2plY3QoYm91bmRzLmdldE5vcnRoRWFzdCgpLCB6b29tKSxcclxuXHRcdCAgICBjZW50ZXIgPSB0aGlzLnVucHJvamVjdChzd1BvaW50LmFkZChuZVBvaW50KS5kaXZpZGVCeSgyKS5hZGQocGFkZGluZ09mZnNldCksIHpvb20pO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnNldFZpZXcoY2VudGVyLCB6b29tLCBvcHRpb25zKTtcclxuXHR9LFxyXG5cclxuXHRmaXRXb3JsZDogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRcdHJldHVybiB0aGlzLmZpdEJvdW5kcyhbWy05MCwgLTE4MF0sIFs5MCwgMTgwXV0sIG9wdGlvbnMpO1xyXG5cdH0sXHJcblxyXG5cdHBhblRvOiBmdW5jdGlvbiAoY2VudGVyLCBvcHRpb25zKSB7IC8vIChMYXRMbmcpXHJcblx0XHRyZXR1cm4gdGhpcy5zZXRWaWV3KGNlbnRlciwgdGhpcy5fem9vbSwge3Bhbjogb3B0aW9uc30pO1xyXG5cdH0sXHJcblxyXG5cdHBhbkJ5OiBmdW5jdGlvbiAob2Zmc2V0KSB7IC8vIChQb2ludClcclxuXHRcdC8vIHJlcGxhY2VkIHdpdGggYW5pbWF0ZWQgcGFuQnkgaW4gTWFwLlBhbkFuaW1hdGlvbi5qc1xyXG5cdFx0dGhpcy5maXJlKCdtb3Zlc3RhcnQnKTtcclxuXHJcblx0XHR0aGlzLl9yYXdQYW5CeShMLnBvaW50KG9mZnNldCkpO1xyXG5cclxuXHRcdHRoaXMuZmlyZSgnbW92ZScpO1xyXG5cdFx0cmV0dXJuIHRoaXMuZmlyZSgnbW92ZWVuZCcpO1xyXG5cdH0sXHJcblxyXG5cdHNldE1heEJvdW5kczogZnVuY3Rpb24gKGJvdW5kcykge1xyXG5cdFx0Ym91bmRzID0gTC5sYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHR0aGlzLm9wdGlvbnMubWF4Qm91bmRzID0gYm91bmRzO1xyXG5cclxuXHRcdGlmICghYm91bmRzKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLm9mZignbW92ZWVuZCcsIHRoaXMuX3Bhbkluc2lkZU1heEJvdW5kcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMuX2xvYWRlZCkge1xyXG5cdFx0XHR0aGlzLl9wYW5JbnNpZGVNYXhCb3VuZHMoKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy5vbignbW92ZWVuZCcsIHRoaXMuX3Bhbkluc2lkZU1heEJvdW5kcyk7XHJcblx0fSxcclxuXHJcblx0cGFuSW5zaWRlQm91bmRzOiBmdW5jdGlvbiAoYm91bmRzLCBvcHRpb25zKSB7XHJcblx0XHR2YXIgY2VudGVyID0gdGhpcy5nZXRDZW50ZXIoKSxcclxuXHRcdFx0bmV3Q2VudGVyID0gdGhpcy5fbGltaXRDZW50ZXIoY2VudGVyLCB0aGlzLl96b29tLCBib3VuZHMpO1xyXG5cclxuXHRcdGlmIChjZW50ZXIuZXF1YWxzKG5ld0NlbnRlcikpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy5wYW5UbyhuZXdDZW50ZXIsIG9wdGlvbnMpO1xyXG5cdH0sXHJcblxyXG5cdGludmFsaWRhdGVTaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdFx0aWYgKCF0aGlzLl9sb2FkZWQpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0XHRvcHRpb25zID0gTC5leHRlbmQoe1xyXG5cdFx0XHRhbmltYXRlOiBmYWxzZSxcclxuXHRcdFx0cGFuOiB0cnVlXHJcblx0XHR9LCBvcHRpb25zID09PSB0cnVlID8ge2FuaW1hdGU6IHRydWV9IDogb3B0aW9ucyk7XHJcblxyXG5cdFx0dmFyIG9sZFNpemUgPSB0aGlzLmdldFNpemUoKTtcclxuXHRcdHRoaXMuX3NpemVDaGFuZ2VkID0gdHJ1ZTtcclxuXHRcdHRoaXMuX2luaXRpYWxDZW50ZXIgPSBudWxsO1xyXG5cclxuXHRcdHZhciBuZXdTaXplID0gdGhpcy5nZXRTaXplKCksXHJcblx0XHQgICAgb2xkQ2VudGVyID0gb2xkU2l6ZS5kaXZpZGVCeSgyKS5yb3VuZCgpLFxyXG5cdFx0ICAgIG5ld0NlbnRlciA9IG5ld1NpemUuZGl2aWRlQnkoMikucm91bmQoKSxcclxuXHRcdCAgICBvZmZzZXQgPSBvbGRDZW50ZXIuc3VidHJhY3QobmV3Q2VudGVyKTtcclxuXHJcblx0XHRpZiAoIW9mZnNldC54ICYmICFvZmZzZXQueSkgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdGlmIChvcHRpb25zLmFuaW1hdGUgJiYgb3B0aW9ucy5wYW4pIHtcclxuXHRcdFx0dGhpcy5wYW5CeShvZmZzZXQpO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGlmIChvcHRpb25zLnBhbikge1xyXG5cdFx0XHRcdHRoaXMuX3Jhd1BhbkJ5KG9mZnNldCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuZmlyZSgnbW92ZScpO1xyXG5cclxuXHRcdFx0aWYgKG9wdGlvbnMuZGVib3VuY2VNb3ZlZW5kKSB7XHJcblx0XHRcdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX3NpemVUaW1lcik7XHJcblx0XHRcdFx0dGhpcy5fc2l6ZVRpbWVyID0gc2V0VGltZW91dChMLmJpbmQodGhpcy5maXJlLCB0aGlzLCAnbW92ZWVuZCcpLCAyMDApO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHRoaXMuZmlyZSgnbW92ZWVuZCcpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuZmlyZSgncmVzaXplJywge1xyXG5cdFx0XHRvbGRTaXplOiBvbGRTaXplLFxyXG5cdFx0XHRuZXdTaXplOiBuZXdTaXplXHJcblx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHQvLyBUT0RPIGhhbmRsZXIuYWRkVG9cclxuXHRhZGRIYW5kbGVyOiBmdW5jdGlvbiAobmFtZSwgSGFuZGxlckNsYXNzKSB7XHJcblx0XHRpZiAoIUhhbmRsZXJDbGFzcykgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdHZhciBoYW5kbGVyID0gdGhpc1tuYW1lXSA9IG5ldyBIYW5kbGVyQ2xhc3ModGhpcyk7XHJcblxyXG5cdFx0dGhpcy5faGFuZGxlcnMucHVzaChoYW5kbGVyKTtcclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zW25hbWVdKSB7XHJcblx0XHRcdGhhbmRsZXIuZW5hYmxlKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0cmVtb3ZlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dGhpcy5faW5pdEV2ZW50cygnb2ZmJyk7XHJcblxyXG5cdFx0dHJ5IHtcclxuXHRcdFx0Ly8gdGhyb3dzIGVycm9yIGluIElFNi04XHJcblx0XHRcdGRlbGV0ZSB0aGlzLl9jb250YWluZXIuX2xlYWZsZXQ7XHJcblx0XHR9IGNhdGNoIChlKSB7XHJcblx0XHRcdHRoaXMuX2NvbnRhaW5lci5fbGVhZmxldCA9IHVuZGVmaW5lZDtcclxuXHRcdH1cclxuXHJcblx0XHRMLkRvbVV0aWwucmVtb3ZlKHRoaXMuX21hcFBhbmUpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9jbGVhckNvbnRyb2xQb3MpIHtcclxuXHRcdFx0dGhpcy5fY2xlYXJDb250cm9sUG9zKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fY2xlYXJIYW5kbGVycygpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9sb2FkZWQpIHtcclxuXHRcdFx0dGhpcy5maXJlKCd1bmxvYWQnKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRjcmVhdGVQYW5lOiBmdW5jdGlvbiAobmFtZSwgY29udGFpbmVyKSB7XHJcblx0XHR2YXIgY2xhc3NOYW1lID0gJ2xlYWZsZXQtcGFuZScgKyAobmFtZSA/ICcgbGVhZmxldC0nICsgbmFtZS5yZXBsYWNlKCdQYW5lJywgJycpICsgJy1wYW5lJyA6ICcnKSxcclxuXHRcdCAgICBwYW5lID0gTC5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgY2xhc3NOYW1lLCBjb250YWluZXIgfHwgdGhpcy5fbWFwUGFuZSk7XHJcblxyXG5cdFx0aWYgKG5hbWUpIHtcclxuXHRcdFx0dGhpcy5fcGFuZXNbbmFtZV0gPSBwYW5lO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHBhbmU7XHJcblx0fSxcclxuXHJcblxyXG5cdC8vIHB1YmxpYyBtZXRob2RzIGZvciBnZXR0aW5nIG1hcCBzdGF0ZVxyXG5cclxuXHRnZXRDZW50ZXI6IGZ1bmN0aW9uICgpIHsgLy8gKEJvb2xlYW4pIC0+IExhdExuZ1xyXG5cdFx0dGhpcy5fY2hlY2tJZkxvYWRlZCgpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9pbml0aWFsQ2VudGVyICYmICF0aGlzLl9tb3ZlZCgpKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLl9pbml0aWFsQ2VudGVyO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXMubGF5ZXJQb2ludFRvTGF0TG5nKHRoaXMuX2dldENlbnRlckxheWVyUG9pbnQoKSk7XHJcblx0fSxcclxuXHJcblx0Z2V0Wm9vbTogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3pvb207XHJcblx0fSxcclxuXHJcblx0Z2V0Qm91bmRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgYm91bmRzID0gdGhpcy5nZXRQaXhlbEJvdW5kcygpLFxyXG5cdFx0ICAgIHN3ID0gdGhpcy51bnByb2plY3QoYm91bmRzLmdldEJvdHRvbUxlZnQoKSksXHJcblx0XHQgICAgbmUgPSB0aGlzLnVucHJvamVjdChib3VuZHMuZ2V0VG9wUmlnaHQoKSk7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBMLkxhdExuZ0JvdW5kcyhzdywgbmUpO1xyXG5cdH0sXHJcblxyXG5cdGdldE1pblpvb206IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMubWluWm9vbSA9PT0gdW5kZWZpbmVkID8gdGhpcy5fbGF5ZXJzTWluWm9vbSB8fCAwIDogdGhpcy5vcHRpb25zLm1pblpvb207XHJcblx0fSxcclxuXHJcblx0Z2V0TWF4Wm9vbTogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5tYXhab29tID09PSB1bmRlZmluZWQgP1xyXG5cdFx0XHQodGhpcy5fbGF5ZXJzTWF4Wm9vbSA9PT0gdW5kZWZpbmVkID8gSW5maW5pdHkgOiB0aGlzLl9sYXllcnNNYXhab29tKSA6XHJcblx0XHRcdHRoaXMub3B0aW9ucy5tYXhab29tO1xyXG5cdH0sXHJcblxyXG5cdGdldEJvdW5kc1pvb206IGZ1bmN0aW9uIChib3VuZHMsIGluc2lkZSwgcGFkZGluZykgeyAvLyAoTGF0TG5nQm91bmRzWywgQm9vbGVhbiwgUG9pbnRdKSAtPiBOdW1iZXJcclxuXHRcdGJvdW5kcyA9IEwubGF0TG5nQm91bmRzKGJvdW5kcyk7XHJcblxyXG5cdFx0dmFyIHpvb20gPSB0aGlzLmdldE1pblpvb20oKSAtIChpbnNpZGUgPyAxIDogMCksXHJcblx0XHQgICAgbWF4Wm9vbSA9IHRoaXMuZ2V0TWF4Wm9vbSgpLFxyXG5cdFx0ICAgIHNpemUgPSB0aGlzLmdldFNpemUoKSxcclxuXHJcblx0XHQgICAgbncgPSBib3VuZHMuZ2V0Tm9ydGhXZXN0KCksXHJcblx0XHQgICAgc2UgPSBib3VuZHMuZ2V0U291dGhFYXN0KCksXHJcblxyXG5cdFx0ICAgIHpvb21Ob3RGb3VuZCA9IHRydWUsXHJcblx0XHQgICAgYm91bmRzU2l6ZTtcclxuXHJcblx0XHRwYWRkaW5nID0gTC5wb2ludChwYWRkaW5nIHx8IFswLCAwXSk7XHJcblxyXG5cdFx0ZG8ge1xyXG5cdFx0XHR6b29tKys7XHJcblx0XHRcdGJvdW5kc1NpemUgPSB0aGlzLnByb2plY3Qoc2UsIHpvb20pLnN1YnRyYWN0KHRoaXMucHJvamVjdChudywgem9vbSkpLmFkZChwYWRkaW5nKTtcclxuXHRcdFx0em9vbU5vdEZvdW5kID0gIWluc2lkZSA/IHNpemUuY29udGFpbnMoYm91bmRzU2l6ZSkgOiBib3VuZHNTaXplLnggPCBzaXplLnggfHwgYm91bmRzU2l6ZS55IDwgc2l6ZS55O1xyXG5cclxuXHRcdH0gd2hpbGUgKHpvb21Ob3RGb3VuZCAmJiB6b29tIDw9IG1heFpvb20pO1xyXG5cclxuXHRcdGlmICh6b29tTm90Rm91bmQgJiYgaW5zaWRlKSB7XHJcblx0XHRcdHJldHVybiBudWxsO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBpbnNpZGUgPyB6b29tIDogem9vbSAtIDE7XHJcblx0fSxcclxuXHJcblx0Z2V0U2l6ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9zaXplIHx8IHRoaXMuX3NpemVDaGFuZ2VkKSB7XHJcblx0XHRcdHRoaXMuX3NpemUgPSBuZXcgTC5Qb2ludChcclxuXHRcdFx0XHR0aGlzLl9jb250YWluZXIuY2xpZW50V2lkdGgsXHJcblx0XHRcdFx0dGhpcy5fY29udGFpbmVyLmNsaWVudEhlaWdodCk7XHJcblxyXG5cdFx0XHR0aGlzLl9zaXplQ2hhbmdlZCA9IGZhbHNlO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXMuX3NpemUuY2xvbmUoKTtcclxuXHR9LFxyXG5cclxuXHRnZXRQaXhlbEJvdW5kczogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHRvcExlZnRQb2ludCA9IHRoaXMuX2dldFRvcExlZnRQb2ludCgpO1xyXG5cdFx0cmV0dXJuIG5ldyBMLkJvdW5kcyh0b3BMZWZ0UG9pbnQsIHRvcExlZnRQb2ludC5hZGQodGhpcy5nZXRTaXplKCkpKTtcclxuXHR9LFxyXG5cclxuXHRnZXRQaXhlbE9yaWdpbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5fY2hlY2tJZkxvYWRlZCgpO1xyXG5cdFx0cmV0dXJuIHRoaXMuX2luaXRpYWxUb3BMZWZ0UG9pbnQ7XHJcblx0fSxcclxuXHJcblx0Z2V0UGl4ZWxXb3JsZEJvdW5kczogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5jcnMuZ2V0UHJvamVjdGVkQm91bmRzKHRoaXMuZ2V0Wm9vbSgpKTtcclxuXHR9LFxyXG5cclxuXHRnZXRQYW5lOiBmdW5jdGlvbiAocGFuZSkge1xyXG5cdFx0cmV0dXJuIHR5cGVvZiBwYW5lID09PSAnc3RyaW5nJyA/IHRoaXMuX3BhbmVzW3BhbmVdIDogcGFuZTtcclxuXHR9LFxyXG5cclxuXHRnZXRQYW5lczogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3BhbmVzO1xyXG5cdH0sXHJcblxyXG5cdGdldENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcclxuXHR9LFxyXG5cclxuXHJcblx0Ly8gVE9ETyByZXBsYWNlIHdpdGggdW5pdmVyc2FsIGltcGxlbWVudGF0aW9uIGFmdGVyIHJlZmFjdG9yaW5nIHByb2plY3Rpb25zXHJcblxyXG5cdGdldFpvb21TY2FsZTogZnVuY3Rpb24gKHRvWm9vbSkge1xyXG5cdFx0dmFyIGNycyA9IHRoaXMub3B0aW9ucy5jcnM7XHJcblx0XHRyZXR1cm4gY3JzLnNjYWxlKHRvWm9vbSkgLyBjcnMuc2NhbGUodGhpcy5fem9vbSk7XHJcblx0fSxcclxuXHJcblx0Z2V0U2NhbGVab29tOiBmdW5jdGlvbiAoc2NhbGUpIHtcclxuXHRcdHJldHVybiB0aGlzLl96b29tICsgKE1hdGgubG9nKHNjYWxlKSAvIE1hdGguTE4yKTtcclxuXHR9LFxyXG5cclxuXHJcblx0Ly8gY29udmVyc2lvbiBtZXRob2RzXHJcblxyXG5cdHByb2plY3Q6IGZ1bmN0aW9uIChsYXRsbmcsIHpvb20pIHsgLy8gKExhdExuZ1ssIE51bWJlcl0pIC0+IFBvaW50XHJcblx0XHR6b29tID0gem9vbSA9PT0gdW5kZWZpbmVkID8gdGhpcy5fem9vbSA6IHpvb207XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmNycy5sYXRMbmdUb1BvaW50KEwubGF0TG5nKGxhdGxuZyksIHpvb20pO1xyXG5cdH0sXHJcblxyXG5cdHVucHJvamVjdDogZnVuY3Rpb24gKHBvaW50LCB6b29tKSB7IC8vIChQb2ludFssIE51bWJlcl0pIC0+IExhdExuZ1xyXG5cdFx0em9vbSA9IHpvb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuX3pvb20gOiB6b29tO1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5jcnMucG9pbnRUb0xhdExuZyhMLnBvaW50KHBvaW50KSwgem9vbSk7XHJcblx0fSxcclxuXHJcblx0bGF5ZXJQb2ludFRvTGF0TG5nOiBmdW5jdGlvbiAocG9pbnQpIHsgLy8gKFBvaW50KVxyXG5cdFx0dmFyIHByb2plY3RlZFBvaW50ID0gTC5wb2ludChwb2ludCkuYWRkKHRoaXMuZ2V0UGl4ZWxPcmlnaW4oKSk7XHJcblx0XHRyZXR1cm4gdGhpcy51bnByb2plY3QocHJvamVjdGVkUG9pbnQpO1xyXG5cdH0sXHJcblxyXG5cdGxhdExuZ1RvTGF5ZXJQb2ludDogZnVuY3Rpb24gKGxhdGxuZykgeyAvLyAoTGF0TG5nKVxyXG5cdFx0dmFyIHByb2plY3RlZFBvaW50ID0gdGhpcy5wcm9qZWN0KEwubGF0TG5nKGxhdGxuZykpLl9yb3VuZCgpO1xyXG5cdFx0cmV0dXJuIHByb2plY3RlZFBvaW50Ll9zdWJ0cmFjdCh0aGlzLmdldFBpeGVsT3JpZ2luKCkpO1xyXG5cdH0sXHJcblxyXG5cdHdyYXBMYXRMbmc6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuY3JzLndyYXBMYXRMbmcoTC5sYXRMbmcobGF0bG5nKSk7XHJcblx0fSxcclxuXHJcblx0ZGlzdGFuY2U6IGZ1bmN0aW9uIChsYXRsbmcxLCBsYXRsbmcyKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmNycy5kaXN0YW5jZShMLmxhdExuZyhsYXRsbmcxKSwgTC5sYXRMbmcobGF0bG5nMikpO1xyXG5cdH0sXHJcblxyXG5cdGNvbnRhaW5lclBvaW50VG9MYXllclBvaW50OiBmdW5jdGlvbiAocG9pbnQpIHsgLy8gKFBvaW50KVxyXG5cdFx0cmV0dXJuIEwucG9pbnQocG9pbnQpLnN1YnRyYWN0KHRoaXMuX2dldE1hcFBhbmVQb3MoKSk7XHJcblx0fSxcclxuXHJcblx0bGF5ZXJQb2ludFRvQ29udGFpbmVyUG9pbnQ6IGZ1bmN0aW9uIChwb2ludCkgeyAvLyAoUG9pbnQpXHJcblx0XHRyZXR1cm4gTC5wb2ludChwb2ludCkuYWRkKHRoaXMuX2dldE1hcFBhbmVQb3MoKSk7XHJcblx0fSxcclxuXHJcblx0Y29udGFpbmVyUG9pbnRUb0xhdExuZzogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHR2YXIgbGF5ZXJQb2ludCA9IHRoaXMuY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQoTC5wb2ludChwb2ludCkpO1xyXG5cdFx0cmV0dXJuIHRoaXMubGF5ZXJQb2ludFRvTGF0TG5nKGxheWVyUG9pbnQpO1xyXG5cdH0sXHJcblxyXG5cdGxhdExuZ1RvQ29udGFpbmVyUG9pbnQ6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHJldHVybiB0aGlzLmxheWVyUG9pbnRUb0NvbnRhaW5lclBvaW50KHRoaXMubGF0TG5nVG9MYXllclBvaW50KEwubGF0TG5nKGxhdGxuZykpKTtcclxuXHR9LFxyXG5cclxuXHRtb3VzZUV2ZW50VG9Db250YWluZXJQb2ludDogZnVuY3Rpb24gKGUpIHsgLy8gKE1vdXNlRXZlbnQpXHJcblx0XHRyZXR1cm4gTC5Eb21FdmVudC5nZXRNb3VzZVBvc2l0aW9uKGUsIHRoaXMuX2NvbnRhaW5lcik7XHJcblx0fSxcclxuXHJcblx0bW91c2VFdmVudFRvTGF5ZXJQb2ludDogZnVuY3Rpb24gKGUpIHsgLy8gKE1vdXNlRXZlbnQpXHJcblx0XHRyZXR1cm4gdGhpcy5jb250YWluZXJQb2ludFRvTGF5ZXJQb2ludCh0aGlzLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUpKTtcclxuXHR9LFxyXG5cclxuXHRtb3VzZUV2ZW50VG9MYXRMbmc6IGZ1bmN0aW9uIChlKSB7IC8vIChNb3VzZUV2ZW50KVxyXG5cdFx0cmV0dXJuIHRoaXMubGF5ZXJQb2ludFRvTGF0TG5nKHRoaXMubW91c2VFdmVudFRvTGF5ZXJQb2ludChlKSk7XHJcblx0fSxcclxuXHJcblxyXG5cdC8vIG1hcCBpbml0aWFsaXphdGlvbiBtZXRob2RzXHJcblxyXG5cdF9pbml0Q29udGFpbmVyOiBmdW5jdGlvbiAoaWQpIHtcclxuXHRcdHZhciBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIgPSBMLkRvbVV0aWwuZ2V0KGlkKTtcclxuXHJcblx0XHRpZiAoIWNvbnRhaW5lcikge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ01hcCBjb250YWluZXIgbm90IGZvdW5kLicpO1xyXG5cdFx0fSBlbHNlIGlmIChjb250YWluZXIuX2xlYWZsZXQpIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdNYXAgY29udGFpbmVyIGlzIGFscmVhZHkgaW5pdGlhbGl6ZWQuJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0Y29udGFpbmVyLl9sZWFmbGV0ID0gdHJ1ZTtcclxuXHR9LFxyXG5cclxuXHRfaW5pdExheW91dDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lcjtcclxuXHJcblx0XHR0aGlzLl9mYWRlQW5pbWF0ZWQgPSB0aGlzLm9wdGlvbnMuZmFkZUFuaW1hdGlvbiAmJiBMLkJyb3dzZXIuYW55M2Q7XHJcblxyXG5cdFx0TC5Eb21VdGlsLmFkZENsYXNzKGNvbnRhaW5lciwgJ2xlYWZsZXQtY29udGFpbmVyJyArXHJcblx0XHRcdChMLkJyb3dzZXIudG91Y2ggPyAnIGxlYWZsZXQtdG91Y2gnIDogJycpICtcclxuXHRcdFx0KEwuQnJvd3Nlci5yZXRpbmEgPyAnIGxlYWZsZXQtcmV0aW5hJyA6ICcnKSArXHJcblx0XHRcdChMLkJyb3dzZXIuaWVsdDkgPyAnIGxlYWZsZXQtb2xkaWUnIDogJycpICtcclxuXHRcdFx0KEwuQnJvd3Nlci5zYWZhcmkgPyAnIGxlYWZsZXQtc2FmYXJpJyA6ICcnKSArXHJcblx0XHRcdCh0aGlzLl9mYWRlQW5pbWF0ZWQgPyAnIGxlYWZsZXQtZmFkZS1hbmltJyA6ICcnKSk7XHJcblxyXG5cdFx0dmFyIHBvc2l0aW9uID0gTC5Eb21VdGlsLmdldFN0eWxlKGNvbnRhaW5lciwgJ3Bvc2l0aW9uJyk7XHJcblxyXG5cdFx0aWYgKHBvc2l0aW9uICE9PSAnYWJzb2x1dGUnICYmIHBvc2l0aW9uICE9PSAncmVsYXRpdmUnICYmIHBvc2l0aW9uICE9PSAnZml4ZWQnKSB7XHJcblx0XHRcdGNvbnRhaW5lci5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5faW5pdFBhbmVzKCk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2luaXRDb250cm9sUG9zKSB7XHJcblx0XHRcdHRoaXMuX2luaXRDb250cm9sUG9zKCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2luaXRQYW5lczogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHBhbmVzID0gdGhpcy5fcGFuZXMgPSB7fTtcclxuXHJcblx0XHR0aGlzLl9tYXBQYW5lID0gdGhpcy5jcmVhdGVQYW5lKCdtYXBQYW5lJywgdGhpcy5fY29udGFpbmVyKTtcclxuXHJcblx0XHR0aGlzLmNyZWF0ZVBhbmUoJ3RpbGVQYW5lJyk7XHJcblx0XHR0aGlzLmNyZWF0ZVBhbmUoJ3NoYWRvd1BhbmUnKTtcclxuXHRcdHRoaXMuY3JlYXRlUGFuZSgnb3ZlcmxheVBhbmUnKTtcclxuXHRcdHRoaXMuY3JlYXRlUGFuZSgnbWFya2VyUGFuZScpO1xyXG5cdFx0dGhpcy5jcmVhdGVQYW5lKCdwb3B1cFBhbmUnKTtcclxuXHJcblx0XHRpZiAoIXRoaXMub3B0aW9ucy5tYXJrZXJab29tQW5pbWF0aW9uKSB7XHJcblx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyhwYW5lcy5tYXJrZXJQYW5lLCAnbGVhZmxldC16b29tLWhpZGUnKTtcclxuXHRcdFx0TC5Eb21VdGlsLmFkZENsYXNzKHBhbmVzLnNoYWRvd1BhbmUsICdsZWFmbGV0LXpvb20taGlkZScpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cclxuXHQvLyBwcml2YXRlIG1ldGhvZHMgdGhhdCBtb2RpZnkgbWFwIHN0YXRlXHJcblxyXG5cdF9yZXNldFZpZXc6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20sIHByZXNlcnZlTWFwT2Zmc2V0LCBhZnRlclpvb21BbmltKSB7XHJcblxyXG5cdFx0dmFyIHpvb21DaGFuZ2VkID0gKHRoaXMuX3pvb20gIT09IHpvb20pO1xyXG5cclxuXHRcdGlmICghYWZ0ZXJab29tQW5pbSkge1xyXG5cdFx0XHR0aGlzLmZpcmUoJ21vdmVzdGFydCcpO1xyXG5cclxuXHRcdFx0aWYgKHpvb21DaGFuZ2VkKSB7XHJcblx0XHRcdFx0dGhpcy5maXJlKCd6b29tc3RhcnQnKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX3pvb20gPSB6b29tO1xyXG5cdFx0dGhpcy5faW5pdGlhbENlbnRlciA9IGNlbnRlcjtcclxuXHJcblx0XHR0aGlzLl9pbml0aWFsVG9wTGVmdFBvaW50ID0gdGhpcy5fZ2V0TmV3VG9wTGVmdFBvaW50KGNlbnRlcik7XHJcblxyXG5cdFx0aWYgKCFwcmVzZXJ2ZU1hcE9mZnNldCkge1xyXG5cdFx0XHRMLkRvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fbWFwUGFuZSwgbmV3IEwuUG9pbnQoMCwgMCkpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dGhpcy5faW5pdGlhbFRvcExlZnRQb2ludC5fYWRkKHRoaXMuX2dldE1hcFBhbmVQb3MoKSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGxvYWRpbmcgPSAhdGhpcy5fbG9hZGVkO1xyXG5cdFx0dGhpcy5fbG9hZGVkID0gdHJ1ZTtcclxuXHJcblx0XHR0aGlzLmZpcmUoJ3ZpZXdyZXNldCcsIHtoYXJkOiAhcHJlc2VydmVNYXBPZmZzZXR9KTtcclxuXHJcblx0XHRpZiAobG9hZGluZykge1xyXG5cdFx0XHR0aGlzLmZpcmUoJ2xvYWQnKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLmZpcmUoJ21vdmUnKTtcclxuXHJcblx0XHRpZiAoem9vbUNoYW5nZWQgfHwgYWZ0ZXJab29tQW5pbSkge1xyXG5cdFx0XHR0aGlzLmZpcmUoJ3pvb21lbmQnKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLmZpcmUoJ21vdmVlbmQnLCB7aGFyZDogIXByZXNlcnZlTWFwT2Zmc2V0fSk7XHJcblx0fSxcclxuXHJcblx0X3Jhd1BhbkJ5OiBmdW5jdGlvbiAob2Zmc2V0KSB7XHJcblx0XHRMLkRvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fbWFwUGFuZSwgdGhpcy5fZ2V0TWFwUGFuZVBvcygpLnN1YnRyYWN0KG9mZnNldCkpO1xyXG5cdH0sXHJcblxyXG5cdF9nZXRab29tU3BhbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuZ2V0TWF4Wm9vbSgpIC0gdGhpcy5nZXRNaW5ab29tKCk7XHJcblx0fSxcclxuXHJcblx0X3Bhbkluc2lkZU1heEJvdW5kczogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5wYW5JbnNpZGVCb3VuZHModGhpcy5vcHRpb25zLm1heEJvdW5kcyk7XHJcblx0fSxcclxuXHJcblx0X2NoZWNrSWZMb2FkZWQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fbG9hZGVkKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcignU2V0IG1hcCBjZW50ZXIgYW5kIHpvb20gZmlyc3QuJyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gbWFwIGV2ZW50c1xyXG5cclxuXHRfaW5pdEV2ZW50czogZnVuY3Rpb24gKG9uT2ZmKSB7XHJcblx0XHRpZiAoIUwuRG9tRXZlbnQpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0b25PZmYgPSBvbk9mZiB8fCAnb24nO1xyXG5cclxuXHRcdEwuRG9tRXZlbnRbb25PZmZdKHRoaXMuX2NvbnRhaW5lcixcclxuXHRcdFx0J2NsaWNrIGRibGNsaWNrIG1vdXNlZG93biBtb3VzZXVwIG1vdXNlZW50ZXIgbW91c2VsZWF2ZSBtb3VzZW1vdmUgY29udGV4dG1lbnUnLFxyXG5cdFx0XHR0aGlzLl9oYW5kbGVNb3VzZUV2ZW50LCB0aGlzKTtcclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLnRyYWNrUmVzaXplKSB7XHJcblx0XHRcdEwuRG9tRXZlbnRbb25PZmZdKHdpbmRvdywgJ3Jlc2l6ZScsIHRoaXMuX29uUmVzaXplLCB0aGlzKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfb25SZXNpemU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdEwuVXRpbC5jYW5jZWxBbmltRnJhbWUodGhpcy5fcmVzaXplUmVxdWVzdCk7XHJcblx0XHR0aGlzLl9yZXNpemVSZXF1ZXN0ID0gTC5VdGlsLnJlcXVlc3RBbmltRnJhbWUoXHJcblx0XHQgICAgICAgIGZ1bmN0aW9uICgpIHsgdGhpcy5pbnZhbGlkYXRlU2l6ZSh7ZGVib3VuY2VNb3ZlZW5kOiB0cnVlfSk7IH0sIHRoaXMsIGZhbHNlLCB0aGlzLl9jb250YWluZXIpO1xyXG5cdH0sXHJcblxyXG5cdF9oYW5kbGVNb3VzZUV2ZW50OiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0aWYgKCF0aGlzLl9sb2FkZWQpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0dGhpcy5fZmlyZU1vdXNlRXZlbnQodGhpcywgZSxcclxuXHRcdFx0XHRlLnR5cGUgPT09ICdtb3VzZWVudGVyJyA/ICdtb3VzZW92ZXInIDpcclxuXHRcdFx0XHRlLnR5cGUgPT09ICdtb3VzZWxlYXZlJyA/ICdtb3VzZW91dCcgOiBlLnR5cGUpO1xyXG5cdH0sXHJcblxyXG5cdF9maXJlTW91c2VFdmVudDogZnVuY3Rpb24gKG9iaiwgZSwgdHlwZSwgcHJvcGFnYXRlLCBsYXRsbmcpIHtcclxuXHRcdHR5cGUgPSB0eXBlIHx8IGUudHlwZTtcclxuXHJcblx0XHRpZiAoTC5Eb21FdmVudC5fc2tpcHBlZChlKSkgeyByZXR1cm47IH1cclxuXHJcblx0XHRpZiAodHlwZSA9PT0gJ2NsaWNrJykge1xyXG5cdFx0XHRpZiAoIWUuX3NpbXVsYXRlZCAmJiAoKHRoaXMuZHJhZ2dpbmcgJiYgdGhpcy5kcmFnZ2luZy5tb3ZlZCgpKSB8fFxyXG5cdFx0XHQgICAgICAgICAgICAgICAgICAgICAgKHRoaXMuYm94Wm9vbSAmJiB0aGlzLmJveFpvb20ubW92ZWQoKSkpKSB7IHJldHVybjsgfVxyXG5cdFx0XHRvYmouZmlyZSgncHJlY2xpY2snKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIW9iai5saXN0ZW5zKHR5cGUsIHByb3BhZ2F0ZSkpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0aWYgKHR5cGUgPT09ICdjb250ZXh0bWVudScpIHtcclxuXHRcdFx0TC5Eb21FdmVudC5wcmV2ZW50RGVmYXVsdChlKTtcclxuXHRcdH1cclxuXHRcdGlmICh0eXBlID09PSAnY2xpY2snIHx8IHR5cGUgPT09ICdkYmxjbGljaycgfHwgdHlwZSA9PT0gJ2NvbnRleHRtZW51Jykge1xyXG5cdFx0XHRMLkRvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbihlKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgZGF0YSA9IHtcclxuXHRcdFx0b3JpZ2luYWxFdmVudDogZSxcclxuXHRcdFx0Y29udGFpbmVyUG9pbnQ6IHRoaXMubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZSlcclxuXHRcdH07XHJcblxyXG5cdFx0ZGF0YS5sYXllclBvaW50ID0gdGhpcy5jb250YWluZXJQb2ludFRvTGF5ZXJQb2ludChkYXRhLmNvbnRhaW5lclBvaW50KTtcclxuXHRcdGRhdGEubGF0bG5nID0gbGF0bG5nIHx8IHRoaXMubGF5ZXJQb2ludFRvTGF0TG5nKGRhdGEubGF5ZXJQb2ludCk7XHJcblxyXG5cdFx0b2JqLmZpcmUodHlwZSwgZGF0YSwgcHJvcGFnYXRlKTtcclxuXHR9LFxyXG5cclxuXHRfY2xlYXJIYW5kbGVyczogZnVuY3Rpb24gKCkge1xyXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX2hhbmRsZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdHRoaXMuX2hhbmRsZXJzW2ldLmRpc2FibGUoKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHR3aGVuUmVhZHk6IGZ1bmN0aW9uIChjYWxsYmFjaywgY29udGV4dCkge1xyXG5cdFx0aWYgKHRoaXMuX2xvYWRlZCkge1xyXG5cdFx0XHRjYWxsYmFjay5jYWxsKGNvbnRleHQgfHwgdGhpcywge3RhcmdldDogdGhpc30pO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dGhpcy5vbignbG9hZCcsIGNhbGxiYWNrLCBjb250ZXh0KTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cclxuXHQvLyBwcml2YXRlIG1ldGhvZHMgZm9yIGdldHRpbmcgbWFwIHN0YXRlXHJcblxyXG5cdF9nZXRNYXBQYW5lUG9zOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gTC5Eb21VdGlsLmdldFBvc2l0aW9uKHRoaXMuX21hcFBhbmUpO1xyXG5cdH0sXHJcblxyXG5cdF9tb3ZlZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHBvcyA9IHRoaXMuX2dldE1hcFBhbmVQb3MoKTtcclxuXHRcdHJldHVybiBwb3MgJiYgIXBvcy5lcXVhbHMoWzAsIDBdKTtcclxuXHR9LFxyXG5cclxuXHRfZ2V0VG9wTGVmdFBvaW50OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5nZXRQaXhlbE9yaWdpbigpLnN1YnRyYWN0KHRoaXMuX2dldE1hcFBhbmVQb3MoKSk7XHJcblx0fSxcclxuXHJcblx0X2dldE5ld1RvcExlZnRQb2ludDogZnVuY3Rpb24gKGNlbnRlciwgem9vbSkge1xyXG5cdFx0dmFyIHZpZXdIYWxmID0gdGhpcy5nZXRTaXplKCkuX2RpdmlkZUJ5KDIpO1xyXG5cdFx0Ly8gVE9ETyByb3VuZCBvbiBkaXNwbGF5LCBub3QgY2FsY3VsYXRpb24gdG8gaW5jcmVhc2UgcHJlY2lzaW9uP1xyXG5cdFx0cmV0dXJuIHRoaXMucHJvamVjdChjZW50ZXIsIHpvb20pLl9zdWJ0cmFjdCh2aWV3SGFsZikuX3JvdW5kKCk7XHJcblx0fSxcclxuXHJcblx0X2xhdExuZ1RvTmV3TGF5ZXJQb2ludDogZnVuY3Rpb24gKGxhdGxuZywgbmV3Wm9vbSwgbmV3Q2VudGVyKSB7XHJcblx0XHR2YXIgdG9wTGVmdCA9IHRoaXMuX2dldE5ld1RvcExlZnRQb2ludChuZXdDZW50ZXIsIG5ld1pvb20pLmFkZCh0aGlzLl9nZXRNYXBQYW5lUG9zKCkpO1xyXG5cdFx0cmV0dXJuIHRoaXMucHJvamVjdChsYXRsbmcsIG5ld1pvb20pLl9zdWJ0cmFjdCh0b3BMZWZ0KTtcclxuXHR9LFxyXG5cclxuXHQvLyBsYXllciBwb2ludCBvZiB0aGUgY3VycmVudCBjZW50ZXJcclxuXHRfZ2V0Q2VudGVyTGF5ZXJQb2ludDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQodGhpcy5nZXRTaXplKCkuX2RpdmlkZUJ5KDIpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBvZmZzZXQgb2YgdGhlIHNwZWNpZmllZCBwbGFjZSB0byB0aGUgY3VycmVudCBjZW50ZXIgaW4gcGl4ZWxzXHJcblx0X2dldENlbnRlck9mZnNldDogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0cmV0dXJuIHRoaXMubGF0TG5nVG9MYXllclBvaW50KGxhdGxuZykuc3VidHJhY3QodGhpcy5fZ2V0Q2VudGVyTGF5ZXJQb2ludCgpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBhZGp1c3QgY2VudGVyIGZvciB2aWV3IHRvIGdldCBpbnNpZGUgYm91bmRzXHJcblx0X2xpbWl0Q2VudGVyOiBmdW5jdGlvbiAoY2VudGVyLCB6b29tLCBib3VuZHMpIHtcclxuXHJcblx0XHRpZiAoIWJvdW5kcykgeyByZXR1cm4gY2VudGVyOyB9XHJcblxyXG5cdFx0dmFyIGNlbnRlclBvaW50ID0gdGhpcy5wcm9qZWN0KGNlbnRlciwgem9vbSksXHJcblx0XHQgICAgdmlld0hhbGYgPSB0aGlzLmdldFNpemUoKS5kaXZpZGVCeSgyKSxcclxuXHRcdCAgICB2aWV3Qm91bmRzID0gbmV3IEwuQm91bmRzKGNlbnRlclBvaW50LnN1YnRyYWN0KHZpZXdIYWxmKSwgY2VudGVyUG9pbnQuYWRkKHZpZXdIYWxmKSksXHJcblx0XHQgICAgb2Zmc2V0ID0gdGhpcy5fZ2V0Qm91bmRzT2Zmc2V0KHZpZXdCb3VuZHMsIGJvdW5kcywgem9vbSk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMudW5wcm9qZWN0KGNlbnRlclBvaW50LmFkZChvZmZzZXQpLCB6b29tKTtcclxuXHR9LFxyXG5cclxuXHQvLyBhZGp1c3Qgb2Zmc2V0IGZvciB2aWV3IHRvIGdldCBpbnNpZGUgYm91bmRzXHJcblx0X2xpbWl0T2Zmc2V0OiBmdW5jdGlvbiAob2Zmc2V0LCBib3VuZHMpIHtcclxuXHRcdGlmICghYm91bmRzKSB7IHJldHVybiBvZmZzZXQ7IH1cclxuXHJcblx0XHR2YXIgdmlld0JvdW5kcyA9IHRoaXMuZ2V0UGl4ZWxCb3VuZHMoKSxcclxuXHRcdCAgICBuZXdCb3VuZHMgPSBuZXcgTC5Cb3VuZHModmlld0JvdW5kcy5taW4uYWRkKG9mZnNldCksIHZpZXdCb3VuZHMubWF4LmFkZChvZmZzZXQpKTtcclxuXHJcblx0XHRyZXR1cm4gb2Zmc2V0LmFkZCh0aGlzLl9nZXRCb3VuZHNPZmZzZXQobmV3Qm91bmRzLCBib3VuZHMpKTtcclxuXHR9LFxyXG5cclxuXHQvLyByZXR1cm5zIG9mZnNldCBuZWVkZWQgZm9yIHB4Qm91bmRzIHRvIGdldCBpbnNpZGUgbWF4Qm91bmRzIGF0IGEgc3BlY2lmaWVkIHpvb21cclxuXHRfZ2V0Qm91bmRzT2Zmc2V0OiBmdW5jdGlvbiAocHhCb3VuZHMsIG1heEJvdW5kcywgem9vbSkge1xyXG5cdFx0dmFyIG53T2Zmc2V0ID0gdGhpcy5wcm9qZWN0KG1heEJvdW5kcy5nZXROb3J0aFdlc3QoKSwgem9vbSkuc3VidHJhY3QocHhCb3VuZHMubWluKSxcclxuXHRcdCAgICBzZU9mZnNldCA9IHRoaXMucHJvamVjdChtYXhCb3VuZHMuZ2V0U291dGhFYXN0KCksIHpvb20pLnN1YnRyYWN0KHB4Qm91bmRzLm1heCksXHJcblxyXG5cdFx0ICAgIGR4ID0gdGhpcy5fcmVib3VuZChud09mZnNldC54LCAtc2VPZmZzZXQueCksXHJcblx0XHQgICAgZHkgPSB0aGlzLl9yZWJvdW5kKG53T2Zmc2V0LnksIC1zZU9mZnNldC55KTtcclxuXHJcblx0XHRyZXR1cm4gbmV3IEwuUG9pbnQoZHgsIGR5KTtcclxuXHR9LFxyXG5cclxuXHRfcmVib3VuZDogZnVuY3Rpb24gKGxlZnQsIHJpZ2h0KSB7XHJcblx0XHRyZXR1cm4gbGVmdCArIHJpZ2h0ID4gMCA/XHJcblx0XHRcdE1hdGgucm91bmQobGVmdCAtIHJpZ2h0KSAvIDIgOlxyXG5cdFx0XHRNYXRoLm1heCgwLCBNYXRoLmNlaWwobGVmdCkpIC0gTWF0aC5tYXgoMCwgTWF0aC5mbG9vcihyaWdodCkpO1xyXG5cdH0sXHJcblxyXG5cdF9saW1pdFpvb206IGZ1bmN0aW9uICh6b29tKSB7XHJcblx0XHR2YXIgbWluID0gdGhpcy5nZXRNaW5ab29tKCksXHJcblx0XHQgICAgbWF4ID0gdGhpcy5nZXRNYXhab29tKCk7XHJcblxyXG5cdFx0cmV0dXJuIE1hdGgubWF4KG1pbiwgTWF0aC5taW4obWF4LCB6b29tKSk7XHJcblx0fVxyXG59KTtcclxuXHJcbkwubWFwID0gZnVuY3Rpb24gKGlkLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBMLk1hcChpZCwgb3B0aW9ucyk7XHJcbn07XHJcblxuXG5MLkxheWVyID0gTC5FdmVudGVkLmV4dGVuZCh7XG5cblx0b3B0aW9uczoge1xuXHRcdHBhbmU6ICdvdmVybGF5UGFuZSdcblx0fSxcblxuXHRhZGRUbzogZnVuY3Rpb24gKG1hcCkge1xuXHRcdG1hcC5hZGRMYXllcih0aGlzKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRyZW1vdmU6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5yZW1vdmVGcm9tKHRoaXMuX21hcCB8fCB0aGlzLl9tYXBUb0FkZCk7XG5cdH0sXG5cblx0cmVtb3ZlRnJvbTogZnVuY3Rpb24gKG9iaikge1xuXHRcdGlmIChvYmopIHtcblx0XHRcdG9iai5yZW1vdmVMYXllcih0aGlzKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Z2V0UGFuZTogZnVuY3Rpb24gKG5hbWUpIHtcblx0XHRyZXR1cm4gdGhpcy5fbWFwLmdldFBhbmUobmFtZSA/ICh0aGlzLm9wdGlvbnNbbmFtZV0gfHwgbmFtZSkgOiB0aGlzLm9wdGlvbnMucGFuZSk7XG5cdH0sXG5cblx0X2xheWVyQWRkOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBtYXAgPSBlLnRhcmdldDtcblxuXHRcdC8vIGNoZWNrIGluIGNhc2UgbGF5ZXIgZ2V0cyBhZGRlZCBhbmQgdGhlbiByZW1vdmVkIGJlZm9yZSB0aGUgbWFwIGlzIHJlYWR5XG5cdFx0aWYgKCFtYXAuaGFzTGF5ZXIodGhpcykpIHsgcmV0dXJuOyB9XG5cblx0XHR0aGlzLl9tYXAgPSBtYXA7XG5cdFx0dGhpcy5fem9vbUFuaW1hdGVkID0gbWFwLl96b29tQW5pbWF0ZWQ7XG5cblx0XHR0aGlzLm9uQWRkKG1hcCk7XG5cblx0XHRpZiAodGhpcy5nZXRBdHRyaWJ1dGlvbiAmJiB0aGlzLl9tYXAuYXR0cmlidXRpb25Db250cm9sKSB7XG5cdFx0XHR0aGlzLl9tYXAuYXR0cmlidXRpb25Db250cm9sLmFkZEF0dHJpYnV0aW9uKHRoaXMuZ2V0QXR0cmlidXRpb24oKSk7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuZ2V0RXZlbnRzKSB7XG5cdFx0XHRtYXAub24odGhpcy5nZXRFdmVudHMoKSwgdGhpcyk7XG5cdFx0fVxuXG5cdFx0dGhpcy5maXJlKCdhZGQnKTtcblx0XHRtYXAuZmlyZSgnbGF5ZXJhZGQnLCB7bGF5ZXI6IHRoaXN9KTtcblx0fVxufSk7XG5cblxuTC5NYXAuaW5jbHVkZSh7XG5cdGFkZExheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgaWQgPSBMLnN0YW1wKGxheWVyKTtcblx0XHRpZiAodGhpcy5fbGF5ZXJzW2lkXSkgeyByZXR1cm4gbGF5ZXI7IH1cblx0XHR0aGlzLl9sYXllcnNbaWRdID0gbGF5ZXI7XG5cblx0XHRsYXllci5fbWFwVG9BZGQgPSB0aGlzO1xuXG5cdFx0aWYgKGxheWVyLmJlZm9yZUFkZCkge1xuXHRcdFx0bGF5ZXIuYmVmb3JlQWRkKHRoaXMpO1xuXHRcdH1cblxuXHRcdHRoaXMud2hlblJlYWR5KGxheWVyLl9sYXllckFkZCwgbGF5ZXIpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0cmVtb3ZlTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBpZCA9IEwuc3RhbXAobGF5ZXIpO1xuXG5cdFx0aWYgKCF0aGlzLl9sYXllcnNbaWRdKSB7IHJldHVybiB0aGlzOyB9XG5cblx0XHRpZiAodGhpcy5fbG9hZGVkKSB7XG5cdFx0XHRsYXllci5vblJlbW92ZSh0aGlzKTtcblx0XHR9XG5cblx0XHRpZiAobGF5ZXIuZ2V0QXR0cmlidXRpb24gJiYgdGhpcy5hdHRyaWJ1dGlvbkNvbnRyb2wpIHtcblx0XHRcdHRoaXMuYXR0cmlidXRpb25Db250cm9sLnJlbW92ZUF0dHJpYnV0aW9uKGxheWVyLmdldEF0dHJpYnV0aW9uKCkpO1xuXHRcdH1cblxuXHRcdGlmIChsYXllci5nZXRFdmVudHMpIHtcblx0XHRcdHRoaXMub2ZmKGxheWVyLmdldEV2ZW50cygpLCBsYXllcik7XG5cdFx0fVxuXG5cdFx0ZGVsZXRlIHRoaXMuX2xheWVyc1tpZF07XG5cblx0XHRpZiAodGhpcy5fbG9hZGVkKSB7XG5cdFx0XHR0aGlzLmZpcmUoJ2xheWVycmVtb3ZlJywge2xheWVyOiBsYXllcn0pO1xuXHRcdFx0bGF5ZXIuZmlyZSgncmVtb3ZlJyk7XG5cdFx0fVxuXG5cdFx0bGF5ZXIuX21hcCA9IGxheWVyLl9tYXBUb0FkZCA9IG51bGw7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRoYXNMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0cmV0dXJuICEhbGF5ZXIgJiYgKEwuc3RhbXAobGF5ZXIpIGluIHRoaXMuX2xheWVycyk7XG5cdH0sXG5cblx0ZWFjaExheWVyOiBmdW5jdGlvbiAobWV0aG9kLCBjb250ZXh0KSB7XG5cdFx0Zm9yICh2YXIgaSBpbiB0aGlzLl9sYXllcnMpIHtcblx0XHRcdG1ldGhvZC5jYWxsKGNvbnRleHQsIHRoaXMuX2xheWVyc1tpXSk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdF9hZGRMYXllcnM6IGZ1bmN0aW9uIChsYXllcnMpIHtcblx0XHRsYXllcnMgPSBsYXllcnMgPyAoTC5VdGlsLmlzQXJyYXkobGF5ZXJzKSA/IGxheWVycyA6IFtsYXllcnNdKSA6IFtdO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGxheWVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0dGhpcy5hZGRMYXllcihsYXllcnNbaV0pO1xuXHRcdH1cblx0fSxcblxuXHRfYWRkWm9vbUxpbWl0OiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHRpZiAoaXNOYU4obGF5ZXIub3B0aW9ucy5tYXhab29tKSB8fCAhaXNOYU4obGF5ZXIub3B0aW9ucy5taW5ab29tKSkge1xuXHRcdFx0dGhpcy5fem9vbUJvdW5kTGF5ZXJzW0wuc3RhbXAobGF5ZXIpXSA9IGxheWVyO1xuXHRcdFx0dGhpcy5fdXBkYXRlWm9vbUxldmVscygpO1xuXHRcdH1cblx0fSxcblxuXHRfcmVtb3ZlWm9vbUxpbWl0OiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgaWQgPSBMLnN0YW1wKGxheWVyKTtcblxuXHRcdGlmICh0aGlzLl96b29tQm91bmRMYXllcnNbaWRdKSB7XG5cdFx0XHRkZWxldGUgdGhpcy5fem9vbUJvdW5kTGF5ZXJzW2lkXTtcblx0XHRcdHRoaXMuX3VwZGF0ZVpvb21MZXZlbHMoKTtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZVpvb21MZXZlbHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgbWluWm9vbSA9IEluZmluaXR5LFxuXHRcdFx0bWF4Wm9vbSA9IC1JbmZpbml0eSxcblx0XHRcdG9sZFpvb21TcGFuID0gdGhpcy5fZ2V0Wm9vbVNwYW4oKTtcblxuXHRcdGZvciAodmFyIGkgaW4gdGhpcy5fem9vbUJvdW5kTGF5ZXJzKSB7XG5cdFx0XHR2YXIgb3B0aW9ucyA9IHRoaXMuX3pvb21Cb3VuZExheWVyc1tpXS5vcHRpb25zO1xuXG5cdFx0XHRtaW5ab29tID0gb3B0aW9ucy5taW5ab29tID09PSB1bmRlZmluZWQgPyBtaW5ab29tIDogTWF0aC5taW4obWluWm9vbSwgb3B0aW9ucy5taW5ab29tKTtcblx0XHRcdG1heFpvb20gPSBvcHRpb25zLm1heFpvb20gPT09IHVuZGVmaW5lZCA/IG1heFpvb20gOiBNYXRoLm1heChtYXhab29tLCBvcHRpb25zLm1heFpvb20pO1xuXHRcdH1cblxuXHRcdHRoaXMuX2xheWVyc01heFpvb20gPSBtYXhab29tID09PSAtSW5maW5pdHkgPyB1bmRlZmluZWQgOiBtYXhab29tO1xuXHRcdHRoaXMuX2xheWVyc01pblpvb20gPSBtaW5ab29tID09PSBJbmZpbml0eSA/IHVuZGVmaW5lZCA6IG1pblpvb207XG5cblx0XHRpZiAob2xkWm9vbVNwYW4gIT09IHRoaXMuX2dldFpvb21TcGFuKCkpIHtcblx0XHRcdHRoaXMuZmlyZSgnem9vbWxldmVsc2NoYW5nZScpO1xuXHRcdH1cblx0fVxufSk7XG5cbi8qXHJcbiAqIE1lcmNhdG9yIHByb2plY3Rpb24gdGhhdCB0YWtlcyBpbnRvIGFjY291bnQgdGhhdCB0aGUgRWFydGggaXMgbm90IGEgcGVyZmVjdCBzcGhlcmUuXHJcbiAqIExlc3MgcG9wdWxhciB0aGFuIHNwaGVyaWNhbCBtZXJjYXRvcjsgdXNlZCBieSBwcm9qZWN0aW9ucyBsaWtlIEVQU0c6MzM5NS5cclxuICovXHJcblxyXG5MLlByb2plY3Rpb24uTWVyY2F0b3IgPSB7XHJcblx0UjogNjM3ODEzNyxcclxuXHRSX01JTk9SOiA2MzU2NzUyLjMxNDI0NTE3OSxcclxuXHJcblx0Ym91bmRzOiBMLmJvdW5kcyhbLTIwMDM3NTA4LjM0Mjc5LCAtMTU0OTY1NzAuNzM5NzJdLCBbMjAwMzc1MDguMzQyNzksIDE4NzY0NjU2LjIzMTM4XSksXHJcblxyXG5cdHByb2plY3Q6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHZhciBkID0gTWF0aC5QSSAvIDE4MCxcclxuXHRcdCAgICByID0gdGhpcy5SLFxyXG5cdFx0ICAgIHkgPSBsYXRsbmcubGF0ICogZCxcclxuXHRcdCAgICB0bXAgPSB0aGlzLlJfTUlOT1IgLyByLFxyXG5cdFx0ICAgIGUgPSBNYXRoLnNxcnQoMSAtIHRtcCAqIHRtcCksXHJcblx0XHQgICAgY29uID0gZSAqIE1hdGguc2luKHkpO1xyXG5cclxuXHRcdHZhciB0cyA9IE1hdGgudGFuKE1hdGguUEkgLyA0IC0geSAvIDIpIC8gTWF0aC5wb3coKDEgLSBjb24pIC8gKDEgKyBjb24pLCBlIC8gMik7XHJcblx0XHR5ID0gLXIgKiBNYXRoLmxvZyhNYXRoLm1heCh0cywgMUUtMTApKTtcclxuXHJcblx0XHRyZXR1cm4gbmV3IEwuUG9pbnQobGF0bG5nLmxuZyAqIGQgKiByLCB5KTtcclxuXHR9LFxyXG5cclxuXHR1bnByb2plY3Q6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0dmFyIGQgPSAxODAgLyBNYXRoLlBJLFxyXG5cdFx0ICAgIHIgPSB0aGlzLlIsXHJcblx0XHQgICAgdG1wID0gdGhpcy5SX01JTk9SIC8gcixcclxuXHRcdCAgICBlID0gTWF0aC5zcXJ0KDEgLSB0bXAgKiB0bXApLFxyXG5cdFx0ICAgIHRzID0gTWF0aC5leHAoLXBvaW50LnkgLyByKSxcclxuXHRcdCAgICBwaGkgPSBNYXRoLlBJIC8gMiAtIDIgKiBNYXRoLmF0YW4odHMpO1xyXG5cclxuXHRcdGZvciAodmFyIGkgPSAwLCBkcGhpID0gMC4xLCBjb247IGkgPCAxNSAmJiBNYXRoLmFicyhkcGhpKSA+IDFlLTc7IGkrKykge1xyXG5cdFx0XHRjb24gPSBlICogTWF0aC5zaW4ocGhpKTtcclxuXHRcdFx0Y29uID0gTWF0aC5wb3coKDEgLSBjb24pIC8gKDEgKyBjb24pLCBlIC8gMik7XHJcblx0XHRcdGRwaGkgPSBNYXRoLlBJIC8gMiAtIDIgKiBNYXRoLmF0YW4odHMgKiBjb24pIC0gcGhpO1xyXG5cdFx0XHRwaGkgKz0gZHBoaTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbmV3IEwuTGF0TG5nKHBoaSAqIGQsIHBvaW50LnggKiBkIC8gcik7XHJcblx0fVxyXG59O1xyXG5cbi8qXHJcbiAqIEwuQ1JTLkVQU0czODU3IChXb3JsZCBNZXJjYXRvcikgQ1JTIGltcGxlbWVudGF0aW9uLlxyXG4gKi9cclxuXHJcbkwuQ1JTLkVQU0czMzk1ID0gTC5leHRlbmQoe30sIEwuQ1JTLkVhcnRoLCB7XHJcblx0Y29kZTogJ0VQU0c6MzM5NScsXHJcblx0cHJvamVjdGlvbjogTC5Qcm9qZWN0aW9uLk1lcmNhdG9yLFxyXG5cclxuXHR0cmFuc2Zvcm1hdGlvbjogKGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBzY2FsZSA9IDAuNSAvIChNYXRoLlBJICogTC5Qcm9qZWN0aW9uLk1lcmNhdG9yLlIpO1xyXG5cdFx0cmV0dXJuIG5ldyBMLlRyYW5zZm9ybWF0aW9uKHNjYWxlLCAwLjUsIC1zY2FsZSwgMC41KTtcclxuXHR9KCkpXHJcbn0pO1xyXG5cbi8qXG4gKiBMLkdyaWRMYXllciBpcyB1c2VkIGFzIGJhc2UgY2xhc3MgZm9yIGdyaWQtbGlrZSBsYXllcnMgbGlrZSBUaWxlTGF5ZXIuXG4gKi9cblxuTC5HcmlkTGF5ZXIgPSBMLkxheWVyLmV4dGVuZCh7XG5cblx0b3B0aW9uczoge1xuXHRcdHBhbmU6ICd0aWxlUGFuZScsXG5cblx0XHR0aWxlU2l6ZTogMjU2LFxuXHRcdG9wYWNpdHk6IDEsXG5cblx0XHR1bmxvYWRJbnZpc2libGVUaWxlczogTC5Ccm93c2VyLm1vYmlsZSxcblx0XHR1cGRhdGVXaGVuSWRsZTogTC5Ccm93c2VyLm1vYmlsZSxcblx0XHR1cGRhdGVJbnRlcnZhbDogMTUwXG5cblx0XHQvKlxuXHRcdG1pblpvb206IDxOdW1iZXI+LFxuXHRcdG1heFpvb206IDxOdW1iZXI+LFxuXHRcdGF0dHJpYnV0aW9uOiA8U3RyaW5nPixcblx0XHR6SW5kZXg6IDxOdW1iZXI+LFxuXHRcdGJvdW5kczogPExhdExuZ0JvdW5kcz5cblx0XHQqL1xuXHR9LFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cdFx0b3B0aW9ucyA9IEwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcblx0fSxcblxuXHRvbkFkZDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX2luaXRDb250YWluZXIoKTtcblxuXHRcdGlmICghdGhpcy5vcHRpb25zLnVwZGF0ZVdoZW5JZGxlKSB7XG5cdFx0XHQvLyB1cGRhdGUgdGlsZXMgb24gbW92ZSwgYnV0IG5vdCBtb3JlIG9mdGVuIHRoYW4gb25jZSBwZXIgZ2l2ZW4gaW50ZXJ2YWxcblx0XHRcdHRoaXMuX3VwZGF0ZSA9IEwuVXRpbC50aHJvdHRsZSh0aGlzLl91cGRhdGUsIHRoaXMub3B0aW9ucy51cGRhdGVJbnRlcnZhbCwgdGhpcyk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fcmVzZXQoKTtcblx0XHR0aGlzLl91cGRhdGUoKTtcblx0fSxcblxuXHRiZWZvcmVBZGQ6IGZ1bmN0aW9uIChtYXApIHtcblx0XHRtYXAuX2FkZFpvb21MaW1pdCh0aGlzKTtcblx0fSxcblxuXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xuXHRcdHRoaXMuX2NsZWFyQmdCdWZmZXIoKTtcblx0XHRMLkRvbVV0aWwucmVtb3ZlKHRoaXMuX2NvbnRhaW5lcik7XG5cblx0XHRtYXAuX3JlbW92ZVpvb21MaW1pdCh0aGlzKTtcblxuXHRcdHRoaXMuX2NvbnRhaW5lciA9IG51bGw7XG5cdH0sXG5cblx0YnJpbmdUb0Zyb250OiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX21hcCkge1xuXHRcdFx0TC5Eb21VdGlsLnRvRnJvbnQodGhpcy5fY29udGFpbmVyKTtcblx0XHRcdHRoaXMuX3NldEF1dG9aSW5kZXgoTWF0aC5tYXgpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRicmluZ1RvQmFjazogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9tYXApIHtcblx0XHRcdEwuRG9tVXRpbC50b0JhY2sodGhpcy5fY29udGFpbmVyKTtcblx0XHRcdHRoaXMuX3NldEF1dG9aSW5kZXgoTWF0aC5taW4pO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRnZXRBdHRyaWJ1dGlvbjogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuYXR0cmlidXRpb247XG5cdH0sXG5cblx0Z2V0Q29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcblx0fSxcblxuXHRzZXRPcGFjaXR5OiBmdW5jdGlvbiAob3BhY2l0eSkge1xuXHRcdHRoaXMub3B0aW9ucy5vcGFjaXR5ID0gb3BhY2l0eTtcblxuXHRcdGlmICh0aGlzLl9tYXApIHtcblx0XHRcdHRoaXMuX3VwZGF0ZU9wYWNpdHkoKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0c2V0WkluZGV4OiBmdW5jdGlvbiAoekluZGV4KSB7XG5cdFx0dGhpcy5vcHRpb25zLnpJbmRleCA9IHpJbmRleDtcblx0XHR0aGlzLl91cGRhdGVaSW5kZXgoKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHJlZHJhdzogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9tYXApIHtcblx0XHRcdHRoaXMuX3Jlc2V0KHtoYXJkOiB0cnVlfSk7XG5cdFx0XHR0aGlzLl91cGRhdGUoKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Z2V0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGV2ZW50cyA9IHtcblx0XHRcdHZpZXdyZXNldDogdGhpcy5fcmVzZXQsXG5cdFx0XHRtb3ZlZW5kOiB0aGlzLl91cGRhdGVcblx0XHR9O1xuXG5cdFx0aWYgKCF0aGlzLm9wdGlvbnMudXBkYXRlV2hlbklkbGUpIHtcblx0XHRcdGV2ZW50cy5tb3ZlID0gdGhpcy5fdXBkYXRlO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcblx0XHRcdGV2ZW50cy56b29tc3RhcnQgPSB0aGlzLl9zdGFydFpvb21BbmltO1xuXHRcdFx0ZXZlbnRzLnpvb21hbmltID0gdGhpcy5fYW5pbWF0ZVpvb207XG5cdFx0XHRldmVudHMuem9vbWVuZCA9IHRoaXMuX2VuZFpvb21BbmltO1xuXHRcdH1cblxuXHRcdHJldHVybiBldmVudHM7XG5cdH0sXG5cblx0X3VwZGF0ZVpJbmRleDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9jb250YWluZXIgJiYgdGhpcy5vcHRpb25zLnpJbmRleCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR0aGlzLl9jb250YWluZXIuc3R5bGUuekluZGV4ID0gdGhpcy5vcHRpb25zLnpJbmRleDtcblx0XHR9XG5cdH0sXG5cblx0X3NldEF1dG9aSW5kZXg6IGZ1bmN0aW9uIChjb21wYXJlKSB7XG5cdFx0Ly8gZ28gdGhyb3VnaCBhbGwgb3RoZXIgbGF5ZXJzIG9mIHRoZSBzYW1lIHBhbmUsIHNldCB6SW5kZXggdG8gbWF4ICsgMSAoZnJvbnQpIG9yIG1pbiAtIDEgKGJhY2spXG5cblx0XHR2YXIgbGF5ZXJzID0gdGhpcy5nZXRQYW5lKCkuY2hpbGRyZW4sXG5cdFx0ICAgIGVkZ2VaSW5kZXggPSAtY29tcGFyZSgtSW5maW5pdHksIEluZmluaXR5KTsgLy8gLUluZmluaXR5IGZvciBtYXgsIEluZmluaXR5IGZvciBtaW5cblxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBsYXllcnMubGVuZ3RoLCB6SW5kZXg7IGkgPCBsZW47IGkrKykge1xuXG5cdFx0XHR6SW5kZXggPSBsYXllcnNbaV0uc3R5bGUuekluZGV4O1xuXG5cdFx0XHRpZiAobGF5ZXJzW2ldICE9PSB0aGlzLl9jb250YWluZXIgJiYgekluZGV4KSB7XG5cdFx0XHRcdGVkZ2VaSW5kZXggPSBjb21wYXJlKGVkZ2VaSW5kZXgsICt6SW5kZXgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChpc0Zpbml0ZShlZGdlWkluZGV4KSkge1xuXHRcdFx0dGhpcy5vcHRpb25zLnpJbmRleCA9IGVkZ2VaSW5kZXggKyBjb21wYXJlKC0xLCAxKTtcblx0XHRcdHRoaXMuX3VwZGF0ZVpJbmRleCgpO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlT3BhY2l0eTogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBvcGFjaXR5ID0gdGhpcy5vcHRpb25zLm9wYWNpdHk7XG5cblx0XHRpZiAoTC5Ccm93c2VyLmllbHQ5KSB7XG5cdFx0XHQvLyBJRSBkb2Vzbid0IGluaGVyaXQgZmlsdGVyIG9wYWNpdHkgcHJvcGVybHksIHNvIHdlJ3JlIGZvcmNlZCB0byBzZXQgaXQgb24gdGlsZXNcblx0XHRcdGZvciAodmFyIGkgaW4gdGhpcy5fdGlsZXMpIHtcblx0XHRcdFx0TC5Eb21VdGlsLnNldE9wYWNpdHkodGhpcy5fdGlsZXNbaV0sIG9wYWNpdHkpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRMLkRvbVV0aWwuc2V0T3BhY2l0eSh0aGlzLl9jb250YWluZXIsIG9wYWNpdHkpO1xuXHRcdH1cblx0fSxcblxuXHRfaW5pdENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9jb250YWluZXIpIHsgcmV0dXJuOyB9XG5cblx0XHR0aGlzLl9jb250YWluZXIgPSBMLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCAnbGVhZmxldC1sYXllcicpO1xuXHRcdHRoaXMuX3VwZGF0ZVpJbmRleCgpO1xuXG5cdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xuXHRcdFx0dmFyIGNsYXNzTmFtZSA9ICdsZWFmbGV0LXRpbGUtY29udGFpbmVyIGxlYWZsZXQtem9vbS1hbmltYXRlZCc7XG5cblx0XHRcdHRoaXMuX2JnQnVmZmVyID0gTC5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgY2xhc3NOYW1lLCB0aGlzLl9jb250YWluZXIpO1xuXHRcdFx0dGhpcy5fdGlsZUNvbnRhaW5lciA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSwgdGhpcy5fY29udGFpbmVyKTtcblxuXHRcdFx0TC5Eb21VdGlsLnNldFRyYW5zZm9ybSh0aGlzLl90aWxlQ29udGFpbmVyKTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl90aWxlQ29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLm9wdGlvbnMub3BhY2l0eSA8IDEpIHtcblx0XHRcdHRoaXMuX3VwZGF0ZU9wYWNpdHkoKTtcblx0XHR9XG5cblx0XHR0aGlzLmdldFBhbmUoKS5hcHBlbmRDaGlsZCh0aGlzLl9jb250YWluZXIpO1xuXHR9LFxuXG5cdF9yZXNldDogZnVuY3Rpb24gKGUpIHtcblx0XHRmb3IgKHZhciBrZXkgaW4gdGhpcy5fdGlsZXMpIHtcblx0XHRcdHRoaXMuZmlyZSgndGlsZXVubG9hZCcsIHtcblx0XHRcdFx0dGlsZTogdGhpcy5fdGlsZXNba2V5XVxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fdGlsZXMgPSB7fTtcblx0XHR0aGlzLl90aWxlc1RvTG9hZCA9IDA7XG5cdFx0dGhpcy5fdGlsZXNUb3RhbCA9IDA7XG5cblx0XHR0aGlzLl90aWxlQ29udGFpbmVyLmlubmVySFRNTCA9ICcnO1xuXG5cdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCAmJiBlICYmIGUuaGFyZCkge1xuXHRcdFx0dGhpcy5fY2xlYXJCZ0J1ZmZlcigpO1xuXHRcdH1cblxuXHRcdHRoaXMuX3RpbGVOdW1Cb3VuZHMgPSB0aGlzLl9nZXRUaWxlTnVtQm91bmRzKCk7XG5cdFx0dGhpcy5fcmVzZXRXcmFwKCk7XG5cdH0sXG5cblx0X3Jlc2V0V3JhcDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIGNycyA9IG1hcC5vcHRpb25zLmNycztcblxuXHRcdGlmIChjcnMuaW5maW5pdGUpIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIgdGlsZVNpemUgPSB0aGlzLl9nZXRUaWxlU2l6ZSgpO1xuXG5cdFx0aWYgKGNycy53cmFwTG5nKSB7XG5cdFx0XHR0aGlzLl93cmFwTG5nID0gW1xuXHRcdFx0XHRNYXRoLmZsb29yKG1hcC5wcm9qZWN0KFswLCBjcnMud3JhcExuZ1swXV0pLnggLyB0aWxlU2l6ZSksXG5cdFx0XHRcdE1hdGguY2VpbChtYXAucHJvamVjdChbMCwgY3JzLndyYXBMbmdbMV1dKS54IC8gdGlsZVNpemUpXG5cdFx0XHRdO1xuXHRcdH1cblxuXHRcdGlmIChjcnMud3JhcExhdCkge1xuXHRcdFx0dGhpcy5fd3JhcExhdCA9IFtcblx0XHRcdFx0TWF0aC5mbG9vcihtYXAucHJvamVjdChbY3JzLndyYXBMYXRbMF0sIDBdKS55IC8gdGlsZVNpemUpLFxuXHRcdFx0XHRNYXRoLmNlaWwobWFwLnByb2plY3QoW2Nycy53cmFwTGF0WzFdLCAwXSkueSAvIHRpbGVTaXplKVxuXHRcdFx0XTtcblx0XHR9XG5cdH0sXG5cblx0X2dldFRpbGVTaXplOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy50aWxlU2l6ZTtcblx0fSxcblxuXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRpZiAoIXRoaXMuX21hcCkgeyByZXR1cm47IH1cblxuXHRcdHZhciBib3VuZHMgPSB0aGlzLl9tYXAuZ2V0UGl4ZWxCb3VuZHMoKSxcblx0XHQgICAgem9vbSA9IHRoaXMuX21hcC5nZXRab29tKCksXG5cdFx0ICAgIHRpbGVTaXplID0gdGhpcy5fZ2V0VGlsZVNpemUoKTtcblxuXHRcdGlmICh6b29tID4gdGhpcy5vcHRpb25zLm1heFpvb20gfHxcblx0XHQgICAgem9vbSA8IHRoaXMub3B0aW9ucy5taW5ab29tKSB7IHJldHVybjsgfVxuXG5cdFx0Ly8gdGlsZSBjb29yZGluYXRlcyByYW5nZSBmb3IgdGhlIGN1cnJlbnQgdmlld1xuXHRcdHZhciB0aWxlQm91bmRzID0gTC5ib3VuZHMoXG5cdFx0XHRib3VuZHMubWluLmRpdmlkZUJ5KHRpbGVTaXplKS5mbG9vcigpLFxuXHRcdFx0Ym91bmRzLm1heC5kaXZpZGVCeSh0aWxlU2l6ZSkuZmxvb3IoKSk7XG5cblx0XHR0aGlzLl9hZGRUaWxlcyh0aWxlQm91bmRzKTtcblxuXHRcdGlmICh0aGlzLm9wdGlvbnMudW5sb2FkSW52aXNpYmxlVGlsZXMpIHtcblx0XHRcdHRoaXMuX3JlbW92ZU90aGVyVGlsZXModGlsZUJvdW5kcyk7XG5cdFx0fVxuXHR9LFxuXG5cdF9hZGRUaWxlczogZnVuY3Rpb24gKGJvdW5kcykge1xuXHRcdHZhciBxdWV1ZSA9IFtdLFxuXHRcdCAgICBjZW50ZXIgPSBib3VuZHMuZ2V0Q2VudGVyKCksXG5cdFx0ICAgIHpvb20gPSB0aGlzLl9tYXAuZ2V0Wm9vbSgpO1xuXG5cdFx0dmFyIGosIGksIGNvb3JkcztcblxuXHRcdC8vIGNyZWF0ZSBhIHF1ZXVlIG9mIGNvb3JkaW5hdGVzIHRvIGxvYWQgdGlsZXMgZnJvbVxuXHRcdGZvciAoaiA9IGJvdW5kcy5taW4ueTsgaiA8PSBib3VuZHMubWF4Lnk7IGorKykge1xuXHRcdFx0Zm9yIChpID0gYm91bmRzLm1pbi54OyBpIDw9IGJvdW5kcy5tYXgueDsgaSsrKSB7XG5cblx0XHRcdFx0Y29vcmRzID0gbmV3IEwuUG9pbnQoaSwgaik7XG5cdFx0XHRcdGNvb3Jkcy56ID0gem9vbTtcblxuXHRcdFx0XHQvLyBhZGQgdGlsZSB0byBxdWV1ZSBpZiBpdCdzIG5vdCBpbiBjYWNoZSBvciBvdXQgb2YgYm91bmRzXG5cdFx0XHRcdGlmICghKHRoaXMuX3RpbGVDb29yZHNUb0tleShjb29yZHMpIGluIHRoaXMuX3RpbGVzKSAmJiB0aGlzLl9pc1ZhbGlkVGlsZShjb29yZHMpKSB7XG5cdFx0XHRcdFx0cXVldWUucHVzaChjb29yZHMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dmFyIHRpbGVzVG9Mb2FkID0gcXVldWUubGVuZ3RoO1xuXG5cdFx0aWYgKHRpbGVzVG9Mb2FkID09PSAwKSB7IHJldHVybjsgfVxuXG5cdFx0Ly8gaWYgaXRzIHRoZSBmaXJzdCBiYXRjaCBvZiB0aWxlcyB0byBsb2FkXG5cdFx0aWYgKCF0aGlzLl90aWxlc1RvTG9hZCkge1xuXHRcdFx0dGhpcy5maXJlKCdsb2FkaW5nJyk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fdGlsZXNUb0xvYWQgKz0gdGlsZXNUb0xvYWQ7XG5cdFx0dGhpcy5fdGlsZXNUb3RhbCArPSB0aWxlc1RvTG9hZDtcblxuXHRcdC8vIHNvcnQgdGlsZSBxdWV1ZSB0byBsb2FkIHRpbGVzIGluIG9yZGVyIG9mIHRoZWlyIGRpc3RhbmNlIHRvIGNlbnRlclxuXHRcdHF1ZXVlLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcblx0XHRcdHJldHVybiBhLmRpc3RhbmNlVG8oY2VudGVyKSAtIGIuZGlzdGFuY2VUbyhjZW50ZXIpO1xuXHRcdH0pO1xuXG5cdFx0Ly8gY3JlYXRlIERPTSBmcmFnbWVudCB0byBhcHBlbmQgdGlsZXMgaW4gb25lIGJhdGNoXG5cdFx0dmFyIGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXG5cdFx0Zm9yIChpID0gMDsgaSA8IHRpbGVzVG9Mb2FkOyBpKyspIHtcblx0XHRcdHRoaXMuX2FkZFRpbGUocXVldWVbaV0sIGZyYWdtZW50KTtcblx0XHR9XG5cblx0XHR0aGlzLl90aWxlQ29udGFpbmVyLmFwcGVuZENoaWxkKGZyYWdtZW50KTtcblx0fSxcblxuXHRfaXNWYWxpZFRpbGU6IGZ1bmN0aW9uIChjb29yZHMpIHtcblx0XHR2YXIgY3JzID0gdGhpcy5fbWFwLm9wdGlvbnMuY3JzO1xuXG5cdFx0aWYgKCFjcnMuaW5maW5pdGUpIHtcblx0XHRcdC8vIGRvbid0IGxvYWQgdGlsZSBpZiBpdCdzIG91dCBvZiBib3VuZHMgYW5kIG5vdCB3cmFwcGVkXG5cdFx0XHR2YXIgYm91bmRzID0gdGhpcy5fdGlsZU51bUJvdW5kcztcblx0XHRcdGlmICgoIWNycy53cmFwTG5nICYmIChjb29yZHMueCA8IGJvdW5kcy5taW4ueCB8fCBjb29yZHMueCA+IGJvdW5kcy5tYXgueCkpIHx8XG5cdFx0XHQgICAgKCFjcnMud3JhcExhdCAmJiAoY29vcmRzLnkgPCBib3VuZHMubWluLnkgfHwgY29vcmRzLnkgPiBib3VuZHMubWF4LnkpKSkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHR9XG5cblx0XHRpZiAoIXRoaXMub3B0aW9ucy5ib3VuZHMpIHsgcmV0dXJuIHRydWU7IH1cblxuXHRcdC8vIGRvbid0IGxvYWQgdGlsZSBpZiBpdCBkb2Vzbid0IGludGVyc2VjdCB0aGUgYm91bmRzIGluIG9wdGlvbnNcblx0XHR2YXIgdGlsZUJvdW5kcyA9IHRoaXMuX3RpbGVDb29yZHNUb0JvdW5kcyhjb29yZHMpO1xuXHRcdHJldHVybiBMLmxhdExuZ0JvdW5kcyh0aGlzLm9wdGlvbnMuYm91bmRzKS5pbnRlcnNlY3RzKHRpbGVCb3VuZHMpO1xuXHR9LFxuXG5cdC8vIGNvbnZlcnRzIHRpbGUgY29vcmRpbmF0ZXMgdG8gaXRzIGdlb2dyYXBoaWNhbCBib3VuZHNcblx0X3RpbGVDb29yZHNUb0JvdW5kczogZnVuY3Rpb24gKGNvb3Jkcykge1xuXG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgdGlsZVNpemUgPSB0aGlzLm9wdGlvbnMudGlsZVNpemUsXG5cblx0XHQgICAgbndQb2ludCA9IGNvb3Jkcy5tdWx0aXBseUJ5KHRpbGVTaXplKSxcblx0XHQgICAgc2VQb2ludCA9IG53UG9pbnQuYWRkKFt0aWxlU2l6ZSwgdGlsZVNpemVdKSxcblxuXHRcdCAgICBudyA9IG1hcC53cmFwTGF0TG5nKG1hcC51bnByb2plY3QobndQb2ludCwgY29vcmRzLnopKSxcblx0XHQgICAgc2UgPSBtYXAud3JhcExhdExuZyhtYXAudW5wcm9qZWN0KHNlUG9pbnQsIGNvb3Jkcy56KSk7XG5cblx0XHRyZXR1cm4gbmV3IEwuTGF0TG5nQm91bmRzKG53LCBzZSk7XG5cdH0sXG5cblx0Ly8gY29udmVydHMgdGlsZSBjb29yZGluYXRlcyB0byBrZXkgZm9yIHRoZSB0aWxlIGNhY2hlXG5cdF90aWxlQ29vcmRzVG9LZXk6IGZ1bmN0aW9uIChjb29yZHMpIHtcblx0XHRyZXR1cm4gY29vcmRzLnggKyAnOicgKyBjb29yZHMueTtcblx0fSxcblxuXHQvLyBjb252ZXJ0cyB0aWxlIGNhY2hlIGtleSB0byBjb29yZGlhbnRlc1xuXHRfa2V5VG9UaWxlQ29vcmRzOiBmdW5jdGlvbiAoa2V5KSB7XG5cdFx0dmFyIGtBcnIgPSBrZXkuc3BsaXQoJzonKSxcblx0XHQgICAgeCA9IHBhcnNlSW50KGtBcnJbMF0sIDEwKSxcblx0XHQgICAgeSA9IHBhcnNlSW50KGtBcnJbMV0sIDEwKTtcblxuXHRcdHJldHVybiBuZXcgTC5Qb2ludCh4LCB5KTtcblx0fSxcblxuXHQvLyByZW1vdmUgYW55IHByZXNlbnQgdGlsZXMgdGhhdCBhcmUgb2ZmIHRoZSBzcGVjaWZpZWQgYm91bmRzXG5cdF9yZW1vdmVPdGhlclRpbGVzOiBmdW5jdGlvbiAoYm91bmRzKSB7XG5cdFx0Zm9yICh2YXIga2V5IGluIHRoaXMuX3RpbGVzKSB7XG5cdFx0XHRpZiAoIWJvdW5kcy5jb250YWlucyh0aGlzLl9rZXlUb1RpbGVDb29yZHMoa2V5KSkpIHtcblx0XHRcdFx0dGhpcy5fcmVtb3ZlVGlsZShrZXkpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRfcmVtb3ZlVGlsZTogZnVuY3Rpb24gKGtleSkge1xuXHRcdHZhciB0aWxlID0gdGhpcy5fdGlsZXNba2V5XTtcblxuXHRcdEwuRG9tVXRpbC5yZW1vdmUodGlsZSk7XG5cblx0XHRkZWxldGUgdGhpcy5fdGlsZXNba2V5XTtcblxuXHRcdHRoaXMuZmlyZSgndGlsZXVubG9hZCcsIHt0aWxlOiB0aWxlfSk7XG5cdH0sXG5cblx0X2luaXRUaWxlOiBmdW5jdGlvbiAodGlsZSkge1xuXHRcdHZhciBzaXplID0gdGhpcy5fZ2V0VGlsZVNpemUoKTtcblxuXHRcdEwuRG9tVXRpbC5hZGRDbGFzcyh0aWxlLCAnbGVhZmxldC10aWxlJyk7XG5cblx0XHR0aWxlLnN0eWxlLndpZHRoID0gc2l6ZSArICdweCc7XG5cdFx0dGlsZS5zdHlsZS5oZWlnaHQgPSBzaXplICsgJ3B4JztcblxuXHRcdHRpbGUub25zZWxlY3RzdGFydCA9IEwuVXRpbC5mYWxzZUZuO1xuXHRcdHRpbGUub25tb3VzZW1vdmUgPSBMLlV0aWwuZmFsc2VGbjtcblxuXHRcdC8vIHVwZGF0ZSBvcGFjaXR5IG9uIHRpbGVzIGluIElFNy04IGJlY2F1c2Ugb2YgZmlsdGVyIGluaGVyaXRhbmNlIHByb2JsZW1zXG5cdFx0aWYgKEwuQnJvd3Nlci5pZWx0OSAmJiB0aGlzLm9wdGlvbnMub3BhY2l0eSA8IDEpIHtcblx0XHRcdEwuRG9tVXRpbC5zZXRPcGFjaXR5KHRpbGUsIHRoaXMub3B0aW9ucy5vcGFjaXR5KTtcblx0XHR9XG5cblx0XHQvLyB3aXRob3V0IHRoaXMgaGFjaywgdGlsZXMgZGlzYXBwZWFyIGFmdGVyIHpvb20gb24gQ2hyb21lIGZvciBBbmRyb2lkXG5cdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC9pc3N1ZXMvMjA3OFxuXHRcdGlmIChMLkJyb3dzZXIuYW5kcm9pZCAmJiAhTC5Ccm93c2VyLmFuZHJvaWQyMykge1xuXHRcdFx0dGlsZS5zdHlsZS5XZWJraXRCYWNrZmFjZVZpc2liaWxpdHkgPSAnaGlkZGVuJztcblx0XHR9XG5cdH0sXG5cblx0X2FkZFRpbGU6IGZ1bmN0aW9uIChjb29yZHMsIGNvbnRhaW5lcikge1xuXHRcdHZhciB0aWxlUG9zID0gdGhpcy5fZ2V0VGlsZVBvcyhjb29yZHMpO1xuXG5cdFx0Ly8gd3JhcCB0aWxlIGNvb3JkcyBpZiBuZWNlc3NhcnkgKGRlcGVuZGluZyBvbiBDUlMpXG5cdFx0dGhpcy5fd3JhcENvb3Jkcyhjb29yZHMpO1xuXG5cdFx0dmFyIHRpbGUgPSB0aGlzLmNyZWF0ZVRpbGUoY29vcmRzLCBMLmJpbmQodGhpcy5fdGlsZVJlYWR5LCB0aGlzKSk7XG5cblx0XHR0aGlzLl9pbml0VGlsZSh0aWxlKTtcblxuXHRcdC8vIGlmIGNyZWF0ZVRpbGUgaXMgZGVmaW5lZCB3aXRoIGEgc2Vjb25kIGFyZ3VtZW50IChcImRvbmVcIiBjYWxsYmFjayksXG5cdFx0Ly8gd2Uga25vdyB0aGF0IHRpbGUgaXMgYXN5bmMgYW5kIHdpbGwgYmUgcmVhZHkgbGF0ZXI7IG90aGVyd2lzZVxuXHRcdGlmICh0aGlzLmNyZWF0ZVRpbGUubGVuZ3RoIDwgMikge1xuXHRcdFx0Ly8gbWFyayB0aWxlIGFzIHJlYWR5LCBidXQgZGVsYXkgb25lIGZyYW1lIGZvciBvcGFjaXR5IGFuaW1hdGlvbiB0byBoYXBwZW5cblx0XHRcdHNldFRpbWVvdXQoTC5iaW5kKHRoaXMuX3RpbGVSZWFkeSwgdGhpcywgbnVsbCwgdGlsZSksIDApO1xuXHRcdH1cblxuXHRcdC8vIHdlIHByZWZlciB0b3AvbGVmdCBvdmVyIHRyYW5zbGF0ZTNkIHNvIHRoYXQgd2UgZG9uJ3QgY3JlYXRlIGEgSFctYWNjZWxlcmF0ZWQgbGF5ZXIgZnJvbSBlYWNoIHRpbGVcblx0XHQvLyB3aGljaCBpcyBzbG93LCBhbmQgaXQgYWxzbyBmaXhlcyBnYXBzIGJldHdlZW4gdGlsZXMgaW4gU2FmYXJpXG5cdFx0TC5Eb21VdGlsLnNldFBvc2l0aW9uKHRpbGUsIHRpbGVQb3MsIHRydWUpO1xuXG5cdFx0Ly8gc2F2ZSB0aWxlIGluIGNhY2hlXG5cdFx0dGhpcy5fdGlsZXNbdGhpcy5fdGlsZUNvb3Jkc1RvS2V5KGNvb3JkcyldID0gdGlsZTtcblxuXHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aWxlKTtcblx0XHR0aGlzLmZpcmUoJ3RpbGVsb2Fkc3RhcnQnLCB7dGlsZTogdGlsZX0pO1xuXHR9LFxuXG5cdF90aWxlUmVhZHk6IGZ1bmN0aW9uIChlcnIsIHRpbGUpIHtcblx0XHRpZiAoZXJyKSB7XG5cdFx0XHR0aGlzLmZpcmUoJ3RpbGVlcnJvcicsIHtcblx0XHRcdFx0ZXJyb3I6IGVycixcblx0XHRcdFx0dGlsZTogdGlsZVxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0TC5Eb21VdGlsLmFkZENsYXNzKHRpbGUsICdsZWFmbGV0LXRpbGUtbG9hZGVkJyk7XG5cblx0XHR0aGlzLmZpcmUoJ3RpbGVsb2FkJywge3RpbGU6IHRpbGV9KTtcblxuXHRcdHRoaXMuX3RpbGVzVG9Mb2FkLS07XG5cblx0XHRpZiAodGhpcy5fdGlsZXNUb0xvYWQgPT09IDApIHtcblx0XHRcdHRoaXMuX3Zpc2libGVUaWxlc1JlYWR5KCk7XG5cdFx0fVxuXHR9LFxuXG5cdF92aXNpYmxlVGlsZXNSZWFkeTogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuZmlyZSgnbG9hZCcpO1xuXG5cdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xuXHRcdFx0Ly8gY2xlYXIgc2NhbGVkIHRpbGVzIGFmdGVyIGFsbCBuZXcgdGlsZXMgYXJlIGxvYWRlZCAoZm9yIHBlcmZvcm1hbmNlKVxuXHRcdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX2NsZWFyQmdCdWZmZXJUaW1lcik7XG5cdFx0XHR0aGlzLl9jbGVhckJnQnVmZmVyVGltZXIgPSBzZXRUaW1lb3V0KEwuYmluZCh0aGlzLl9jbGVhckJnQnVmZmVyLCB0aGlzKSwgMzAwKTtcblx0XHR9XG5cdH0sXG5cblx0X2dldFRpbGVQb3M6IGZ1bmN0aW9uIChjb29yZHMpIHtcblx0XHRyZXR1cm4gY29vcmRzXG5cdFx0XHRcdC5tdWx0aXBseUJ5KHRoaXMuX2dldFRpbGVTaXplKCkpXG5cdFx0XHRcdC5zdWJ0cmFjdCh0aGlzLl9tYXAuZ2V0UGl4ZWxPcmlnaW4oKSk7XG5cdH0sXG5cblx0X3dyYXBDb29yZHM6IGZ1bmN0aW9uIChjb29yZHMpIHtcblx0XHRjb29yZHMueCA9IHRoaXMuX3dyYXBMbmcgPyBMLlV0aWwud3JhcE51bShjb29yZHMueCwgdGhpcy5fd3JhcExuZykgOiBjb29yZHMueDtcblx0XHRjb29yZHMueSA9IHRoaXMuX3dyYXBMYXQgPyBMLlV0aWwud3JhcE51bShjb29yZHMueSwgdGhpcy5fd3JhcExhdCkgOiBjb29yZHMueTtcblx0fSxcblxuXHQvLyBnZXQgdGhlIGdsb2JhbCB0aWxlIGNvb3JkaW5hdGVzIHJhbmdlIGZvciB0aGUgY3VycmVudCB6b29tXG5cdF9nZXRUaWxlTnVtQm91bmRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGJvdW5kcyA9IHRoaXMuX21hcC5nZXRQaXhlbFdvcmxkQm91bmRzKCksXG5cdFx0XHRzaXplID0gdGhpcy5fZ2V0VGlsZVNpemUoKTtcblxuXHRcdHJldHVybiBib3VuZHMgPyBMLmJvdW5kcyhcblx0XHRcdFx0Ym91bmRzLm1pbi5kaXZpZGVCeShzaXplKS5mbG9vcigpLFxuXHRcdFx0XHRib3VuZHMubWF4LmRpdmlkZUJ5KHNpemUpLmNlaWwoKS5zdWJ0cmFjdChbMSwgMV0pKSA6IG51bGw7XG5cdH0sXG5cblx0X3N0YXJ0Wm9vbUFuaW06IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9wcmVwYXJlQmdCdWZmZXIoKTtcblx0XHR0aGlzLl9wcmV2VHJhbnNsYXRlID0gdGhpcy5fdHJhbnNsYXRlIHx8IG5ldyBMLlBvaW50KDAsIDApO1xuXHRcdHRoaXMuX3ByZXZTY2FsZSA9IHRoaXMuX3NjYWxlO1xuXHR9LFxuXG5cdF9hbmltYXRlWm9vbTogZnVuY3Rpb24gKGUpIHtcblx0XHQvLyBhdm9pZCBzdGFja2luZyB0cmFuc2Zvcm1zIGJ5IGNhbGN1bGF0aW5nIGN1bXVsYXRpbmcgdHJhbnNsYXRlL3NjYWxlIHNlcXVlbmNlXG5cdFx0dGhpcy5fdHJhbnNsYXRlID0gdGhpcy5fcHJldlRyYW5zbGF0ZS5tdWx0aXBseUJ5KGUuc2NhbGUpLmFkZChlLm9yaWdpbi5tdWx0aXBseUJ5KDEgLSBlLnNjYWxlKSk7XG5cdFx0dGhpcy5fc2NhbGUgPSB0aGlzLl9wcmV2U2NhbGUgKiBlLnNjYWxlO1xuXG5cdFx0TC5Eb21VdGlsLnNldFRyYW5zZm9ybSh0aGlzLl9iZ0J1ZmZlciwgdGhpcy5fdHJhbnNsYXRlLCB0aGlzLl9zY2FsZSk7XG5cdH0sXG5cblx0X2VuZFpvb21BbmltOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGZyb250ID0gdGhpcy5fdGlsZUNvbnRhaW5lcjtcblx0XHRmcm9udC5zdHlsZS52aXNpYmlsaXR5ID0gJyc7XG5cdFx0TC5Eb21VdGlsLnRvRnJvbnQoZnJvbnQpOyAvLyBicmluZyB0byBmcm9udFxuXHR9LFxuXG5cdF9jbGVhckJnQnVmZmVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcblx0XHRcdGJnID0gdGhpcy5fYmdCdWZmZXI7XG5cblx0XHRpZiAobWFwICYmICFtYXAuX2FuaW1hdGluZ1pvb20gJiYgIW1hcC50b3VjaFpvb20uX3pvb21pbmcgJiYgYmcpIHtcblx0XHRcdGJnLmlubmVySFRNTCA9ICcnO1xuXHRcdFx0TC5Eb21VdGlsLnNldFRyYW5zZm9ybShiZyk7XG5cdFx0fVxuXHR9LFxuXG5cdF9wcmVwYXJlQmdCdWZmZXI6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBmcm9udCA9IHRoaXMuX3RpbGVDb250YWluZXIsXG5cdFx0ICAgIGJnID0gdGhpcy5fYmdCdWZmZXI7XG5cblx0XHRpZiAodGhpcy5fYWJvcnRMb2FkaW5nKSB7XG5cdFx0XHR0aGlzLl9hYm9ydExvYWRpbmcoKTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5fdGlsZXNUb0xvYWQgLyB0aGlzLl90aWxlc1RvdGFsID4gMC41KSB7XG5cdFx0XHQvLyBpZiBmb3JlZ3JvdW5kIGxheWVyIGRvZXNuJ3QgaGF2ZSBtYW55IHRpbGVzIGxvYWRlZCxcblx0XHRcdC8vIGtlZXAgdGhlIGV4aXN0aW5nIGJnIGxheWVyIGFuZCBqdXN0IHpvb20gaXQgc29tZSBtb3JlXG5cdFx0XHRmcm9udC5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gcHJlcGFyZSB0aGUgYnVmZmVyIHRvIGJlY29tZSB0aGUgZnJvbnQgdGlsZSBwYW5lXG5cdFx0Ymcuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuXHRcdEwuRG9tVXRpbC5zZXRUcmFuc2Zvcm0oYmcpO1xuXG5cdFx0Ly8gc3dpdGNoIG91dCB0aGUgY3VycmVudCBsYXllciB0byBiZSB0aGUgbmV3IGJnIGxheWVyIChhbmQgdmljZS12ZXJzYSlcblx0XHR0aGlzLl90aWxlQ29udGFpbmVyID0gYmc7XG5cdFx0dGhpcy5fYmdCdWZmZXIgPSBmcm9udDtcblxuXHRcdC8vIHJlc2V0IGJnIGxheWVyIHRyYW5zZm9ybSBpbmZvXG5cdFx0dGhpcy5fdHJhbnNsYXRlID0gbmV3IEwuUG9pbnQoMCwgMCk7XG5cdFx0dGhpcy5fc2NhbGUgPSAxO1xuXG5cdFx0Ly8gcHJldmVudCBiZyBidWZmZXIgZnJvbSBjbGVhcmluZyByaWdodCBhZnRlciB6b29tXG5cdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX2NsZWFyQmdCdWZmZXJUaW1lcik7XG5cdH1cbn0pO1xuXG5MLmdyaWRMYXllciA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cdHJldHVybiBuZXcgTC5HcmlkTGF5ZXIob3B0aW9ucyk7XG59O1xuXG4vKlxyXG4gKiBMLlRpbGVMYXllciBpcyB1c2VkIGZvciBzdGFuZGFyZCB4eXotbnVtYmVyZWQgdGlsZSBsYXllcnMuXHJcbiAqL1xyXG5cclxuTC5UaWxlTGF5ZXIgPSBMLkdyaWRMYXllci5leHRlbmQoe1xyXG5cclxuXHRvcHRpb25zOiB7XHJcblx0XHRtaW5ab29tOiAwLFxyXG5cdFx0bWF4Wm9vbTogMTgsXHJcblxyXG5cdFx0c3ViZG9tYWluczogJ2FiYycsXHJcblx0XHQvLyBlcnJvclRpbGVVcmw6ICcnLFxyXG5cdFx0em9vbU9mZnNldDogMFxyXG5cclxuXHRcdC8qXHJcblx0XHRtYXhOYXRpdmVab29tOiA8TnVtYmVyPixcclxuXHRcdHRtczogPEJvb2xlYW4+LFxyXG5cdFx0em9vbVJldmVyc2U6IDxOdW1iZXI+LFxyXG5cdFx0ZGV0ZWN0UmV0aW5hOiA8TnVtYmVyPixcclxuXHRcdCovXHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKHVybCwgb3B0aW9ucykge1xyXG5cclxuXHRcdHRoaXMuX3VybCA9IHVybDtcclxuXHJcblx0XHRvcHRpb25zID0gTC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuXHRcdC8vIGRldGVjdGluZyByZXRpbmEgZGlzcGxheXMsIGFkanVzdGluZyB0aWxlU2l6ZSBhbmQgem9vbSBsZXZlbHNcclxuXHRcdGlmIChvcHRpb25zLmRldGVjdFJldGluYSAmJiBMLkJyb3dzZXIucmV0aW5hICYmIG9wdGlvbnMubWF4Wm9vbSA+IDApIHtcclxuXHJcblx0XHRcdG9wdGlvbnMudGlsZVNpemUgPSBNYXRoLmZsb29yKG9wdGlvbnMudGlsZVNpemUgLyAyKTtcclxuXHRcdFx0b3B0aW9ucy56b29tT2Zmc2V0Kys7XHJcblxyXG5cdFx0XHRvcHRpb25zLm1pblpvb20gPSBNYXRoLm1heCgwLCBvcHRpb25zLm1pblpvb20pO1xyXG5cdFx0XHRvcHRpb25zLm1heFpvb20tLTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodHlwZW9mIG9wdGlvbnMuc3ViZG9tYWlucyA9PT0gJ3N0cmluZycpIHtcclxuXHRcdFx0b3B0aW9ucy5zdWJkb21haW5zID0gb3B0aW9ucy5zdWJkb21haW5zLnNwbGl0KCcnKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRzZXRVcmw6IGZ1bmN0aW9uICh1cmwsIG5vUmVkcmF3KSB7XHJcblx0XHR0aGlzLl91cmwgPSB1cmw7XHJcblxyXG5cdFx0aWYgKCFub1JlZHJhdykge1xyXG5cdFx0XHR0aGlzLnJlZHJhdygpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Y3JlYXRlVGlsZTogZnVuY3Rpb24gKGNvb3JkcywgZG9uZSkge1xyXG5cdFx0dmFyIHRpbGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcclxuXHJcblx0XHR0aWxlLm9ubG9hZCA9IEwuYmluZCh0aGlzLl90aWxlT25Mb2FkLCB0aGlzLCBkb25lLCB0aWxlKTtcclxuXHRcdHRpbGUub25lcnJvciA9IEwuYmluZCh0aGlzLl90aWxlT25FcnJvciwgdGhpcywgZG9uZSwgdGlsZSk7XHJcblxyXG5cdFx0LypcclxuXHRcdCBBbHQgdGFnIGlzIHNldCB0byBlbXB0eSBzdHJpbmcgdG8ga2VlcCBzY3JlZW4gcmVhZGVycyBmcm9tIHJlYWRpbmcgVVJMIGFuZCBmb3IgY29tcGxpYW5jZSByZWFzb25zXHJcblx0XHQgaHR0cDovL3d3dy53My5vcmcvVFIvV0NBRzIwLVRFQ0hTL0g2N1xyXG5cdFx0Ki9cclxuXHRcdHRpbGUuYWx0ID0gJyc7XHJcblxyXG5cdFx0dGlsZS5zcmMgPSB0aGlzLmdldFRpbGVVcmwoY29vcmRzKTtcclxuXHJcblx0XHRyZXR1cm4gdGlsZTtcclxuXHR9LFxyXG5cclxuXHRnZXRUaWxlVXJsOiBmdW5jdGlvbiAoY29vcmRzKSB7XHJcblx0XHRyZXR1cm4gTC5VdGlsLnRlbXBsYXRlKHRoaXMuX3VybCwgTC5leHRlbmQoe1xyXG5cdFx0XHRyOiB0aGlzLm9wdGlvbnMuZGV0ZWN0UmV0aW5hICYmIEwuQnJvd3Nlci5yZXRpbmEgJiYgdGhpcy5vcHRpb25zLm1heFpvb20gPiAwID8gJ0AyeCcgOiAnJyxcclxuXHRcdFx0czogdGhpcy5fZ2V0U3ViZG9tYWluKGNvb3JkcyksXHJcblx0XHRcdHg6IGNvb3Jkcy54LFxyXG5cdFx0XHR5OiB0aGlzLm9wdGlvbnMudG1zID8gdGhpcy5fdGlsZU51bUJvdW5kcy5tYXgueSAtIGNvb3Jkcy55IDogY29vcmRzLnksXHJcblx0XHRcdHo6IHRoaXMuX2dldFpvb21Gb3JVcmwoKVxyXG5cdFx0fSwgdGhpcy5vcHRpb25zKSk7XHJcblx0fSxcclxuXHJcblx0X3RpbGVPbkxvYWQ6IGZ1bmN0aW9uIChkb25lLCB0aWxlKSB7XHJcblx0XHRkb25lKG51bGwsIHRpbGUpO1xyXG5cdH0sXHJcblxyXG5cdF90aWxlT25FcnJvcjogZnVuY3Rpb24gKGRvbmUsIHRpbGUsIGUpIHtcclxuXHRcdHZhciBlcnJvclVybCA9IHRoaXMub3B0aW9ucy5lcnJvclRpbGVVcmw7XHJcblx0XHRpZiAoZXJyb3JVcmwpIHtcclxuXHRcdFx0dGlsZS5zcmMgPSBlcnJvclVybDtcclxuXHRcdH1cclxuXHRcdGRvbmUoZSwgdGlsZSk7XHJcblx0fSxcclxuXHJcblx0X2dldFRpbGVTaXplOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxyXG5cdFx0ICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXHJcblx0XHQgICAgem9vbSA9IG1hcC5nZXRab29tKCkgKyBvcHRpb25zLnpvb21PZmZzZXQsXHJcblx0XHQgICAgem9vbU4gPSBvcHRpb25zLm1heE5hdGl2ZVpvb207XHJcblxyXG5cdFx0Ly8gaW5jcmVhc2UgdGlsZSBzaXplIHdoZW4gb3ZlcnNjYWxpbmdcclxuXHRcdHJldHVybiB6b29tTiAmJiB6b29tID4gem9vbU4gP1xyXG5cdFx0XHRcdE1hdGgucm91bmQobWFwLmdldFpvb21TY2FsZSh6b29tKSAvIG1hcC5nZXRab29tU2NhbGUoem9vbU4pICogb3B0aW9ucy50aWxlU2l6ZSkgOlxyXG5cdFx0XHRcdG9wdGlvbnMudGlsZVNpemU7XHJcblx0fSxcclxuXHJcblx0X3JlbW92ZVRpbGU6IGZ1bmN0aW9uIChrZXkpIHtcclxuXHRcdHZhciB0aWxlID0gdGhpcy5fdGlsZXNba2V5XTtcclxuXHJcblx0XHRMLkdyaWRMYXllci5wcm90b3R5cGUuX3JlbW92ZVRpbGUuY2FsbCh0aGlzLCBrZXkpO1xyXG5cclxuXHRcdC8vIGZvciBodHRwczovL2dpdGh1Yi5jb20vTGVhZmxldC9MZWFmbGV0L2lzc3Vlcy8xMzdcclxuXHRcdGlmICghTC5Ccm93c2VyLmFuZHJvaWQpIHtcclxuXHRcdFx0dGlsZS5vbmxvYWQgPSBudWxsO1xyXG5cdFx0XHR0aWxlLnNyYyA9IEwuVXRpbC5lbXB0eUltYWdlVXJsO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9nZXRab29tRm9yVXJsOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXHJcblx0XHQgICAgem9vbSA9IHRoaXMuX21hcC5nZXRab29tKCk7XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMuem9vbVJldmVyc2UpIHtcclxuXHRcdFx0em9vbSA9IG9wdGlvbnMubWF4Wm9vbSAtIHpvb207XHJcblx0XHR9XHJcblxyXG5cdFx0em9vbSArPSBvcHRpb25zLnpvb21PZmZzZXQ7XHJcblxyXG5cdFx0cmV0dXJuIG9wdGlvbnMubWF4TmF0aXZlWm9vbSA/IE1hdGgubWluKHpvb20sIG9wdGlvbnMubWF4TmF0aXZlWm9vbSkgOiB6b29tO1xyXG5cdH0sXHJcblxyXG5cdF9nZXRTdWJkb21haW46IGZ1bmN0aW9uICh0aWxlUG9pbnQpIHtcclxuXHRcdHZhciBpbmRleCA9IE1hdGguYWJzKHRpbGVQb2ludC54ICsgdGlsZVBvaW50LnkpICUgdGhpcy5vcHRpb25zLnN1YmRvbWFpbnMubGVuZ3RoO1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5zdWJkb21haW5zW2luZGV4XTtcclxuXHR9LFxyXG5cclxuXHQvLyBzdG9wcyBsb2FkaW5nIGFsbCB0aWxlcyBpbiB0aGUgYmFja2dyb3VuZCBsYXllclxyXG5cdF9hYm9ydExvYWRpbmc6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBpLCB0aWxlO1xyXG5cdFx0Zm9yIChpIGluIHRoaXMuX3RpbGVzKSB7XHJcblx0XHRcdHRpbGUgPSB0aGlzLl90aWxlc1tpXTtcclxuXHJcblx0XHRcdGlmICghdGlsZS5jb21wbGV0ZSkge1xyXG5cdFx0XHRcdHRpbGUub25sb2FkID0gTC5VdGlsLmZhbHNlRm47XHJcblx0XHRcdFx0dGlsZS5vbmVycm9yID0gTC5VdGlsLmZhbHNlRm47XHJcblx0XHRcdFx0dGlsZS5zcmMgPSBMLlV0aWwuZW1wdHlJbWFnZVVybDtcclxuXHJcblx0XHRcdFx0TC5Eb21VdGlsLnJlbW92ZSh0aWxlKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxufSk7XHJcblxyXG5MLnRpbGVMYXllciA9IGZ1bmN0aW9uICh1cmwsIG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IEwuVGlsZUxheWVyKHVybCwgb3B0aW9ucyk7XHJcbn07XHJcblxuLypcclxuICogTC5UaWxlTGF5ZXIuV01TIGlzIHVzZWQgZm9yIFdNUyB0aWxlIGxheWVycy5cclxuICovXHJcblxyXG5MLlRpbGVMYXllci5XTVMgPSBMLlRpbGVMYXllci5leHRlbmQoe1xyXG5cclxuXHRkZWZhdWx0V21zUGFyYW1zOiB7XHJcblx0XHRzZXJ2aWNlOiAnV01TJyxcclxuXHRcdHJlcXVlc3Q6ICdHZXRNYXAnLFxyXG5cdFx0dmVyc2lvbjogJzEuMS4xJyxcclxuXHRcdGxheWVyczogJycsXHJcblx0XHRzdHlsZXM6ICcnLFxyXG5cdFx0Zm9ybWF0OiAnaW1hZ2UvanBlZycsXHJcblx0XHR0cmFuc3BhcmVudDogZmFsc2VcclxuXHR9LFxyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAodXJsLCBvcHRpb25zKSB7XHJcblxyXG5cdFx0dGhpcy5fdXJsID0gdXJsO1xyXG5cclxuXHRcdHZhciB3bXNQYXJhbXMgPSBMLmV4dGVuZCh7fSwgdGhpcy5kZWZhdWx0V21zUGFyYW1zKTtcclxuXHJcblx0XHQvLyBhbGwga2V5cyB0aGF0IGFyZSBub3QgVGlsZUxheWVyIG9wdGlvbnMgZ28gdG8gV01TIHBhcmFtc1xyXG5cdFx0Zm9yICh2YXIgaSBpbiBvcHRpb25zKSB7XHJcblx0XHRcdGlmICghdGhpcy5vcHRpb25zLmhhc093blByb3BlcnR5KGkpICYmIGkgIT09ICdjcnMnKSB7XHJcblx0XHRcdFx0d21zUGFyYW1zW2ldID0gb3B0aW9uc1tpXTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdG9wdGlvbnMgPSBMLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG5cdFx0d21zUGFyYW1zLndpZHRoID0gd21zUGFyYW1zLmhlaWdodCA9XHJcblx0XHRcdFx0b3B0aW9ucy50aWxlU2l6ZSAqIChvcHRpb25zLmRldGVjdFJldGluYSAmJiBMLkJyb3dzZXIucmV0aW5hID8gMiA6IDEpO1xyXG5cclxuXHRcdHRoaXMud21zUGFyYW1zID0gd21zUGFyYW1zO1xyXG5cdH0sXHJcblxyXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcblxyXG5cdFx0dGhpcy5fY3JzID0gdGhpcy5vcHRpb25zLmNycyB8fCBtYXAub3B0aW9ucy5jcnM7XHJcblxyXG5cdFx0dGhpcy5fd21zVmVyc2lvbiA9IHBhcnNlRmxvYXQodGhpcy53bXNQYXJhbXMudmVyc2lvbik7XHJcblxyXG5cdFx0dmFyIHByb2plY3Rpb25LZXkgPSB0aGlzLl93bXNWZXJzaW9uID49IDEuMyA/ICdjcnMnIDogJ3Nycyc7XHJcblx0XHR0aGlzLndtc1BhcmFtc1twcm9qZWN0aW9uS2V5XSA9IHRoaXMuX2Nycy5jb2RlO1xyXG5cclxuXHRcdEwuVGlsZUxheWVyLnByb3RvdHlwZS5vbkFkZC5jYWxsKHRoaXMsIG1hcCk7XHJcblx0fSxcclxuXHJcblx0Z2V0VGlsZVVybDogZnVuY3Rpb24gKGNvb3Jkcykge1xyXG5cclxuXHRcdHZhciB0aWxlQm91bmRzID0gdGhpcy5fdGlsZUNvb3Jkc1RvQm91bmRzKGNvb3JkcyksXHJcblx0XHQgICAgbncgPSB0aGlzLl9jcnMucHJvamVjdCh0aWxlQm91bmRzLmdldE5vcnRoV2VzdCgpKSxcclxuXHRcdCAgICBzZSA9IHRoaXMuX2Nycy5wcm9qZWN0KHRpbGVCb3VuZHMuZ2V0U291dGhFYXN0KCkpLFxyXG5cclxuXHRcdCAgICBiYm94ID0gKHRoaXMuX3dtc1ZlcnNpb24gPj0gMS4zICYmIHRoaXMuX2NycyA9PT0gTC5DUlMuRVBTRzQzMjYgP1xyXG5cdFx0XHQgICAgW3NlLnksIG53LngsIG53LnksIHNlLnhdIDpcclxuXHRcdFx0ICAgIFtudy54LCBzZS55LCBzZS54LCBudy55XSkuam9pbignLCcpLFxyXG5cclxuXHRcdCAgICB1cmwgPSBMLlV0aWwudGVtcGxhdGUodGhpcy5fdXJsLCB7czogdGhpcy5fZ2V0U3ViZG9tYWluKGNvb3Jkcyl9KTtcclxuXHJcblx0XHRyZXR1cm4gdXJsICsgTC5VdGlsLmdldFBhcmFtU3RyaW5nKHRoaXMud21zUGFyYW1zLCB1cmwsIHRydWUpICsgJyZCQk9YPScgKyBiYm94O1xyXG5cdH0sXHJcblxyXG5cdHNldFBhcmFtczogZnVuY3Rpb24gKHBhcmFtcywgbm9SZWRyYXcpIHtcclxuXHJcblx0XHRMLmV4dGVuZCh0aGlzLndtc1BhcmFtcywgcGFyYW1zKTtcclxuXHJcblx0XHRpZiAoIW5vUmVkcmF3KSB7XHJcblx0XHRcdHRoaXMucmVkcmF3KCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG59KTtcclxuXHJcbkwudGlsZUxheWVyLndtcyA9IGZ1bmN0aW9uICh1cmwsIG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IEwuVGlsZUxheWVyLldNUyh1cmwsIG9wdGlvbnMpO1xyXG59O1xyXG5cbi8qXHJcbiAqIEwuSW1hZ2VPdmVybGF5IGlzIHVzZWQgdG8gb3ZlcmxheSBpbWFnZXMgb3ZlciB0aGUgbWFwICh0byBzcGVjaWZpYyBnZW9ncmFwaGljYWwgYm91bmRzKS5cclxuICovXHJcblxyXG5MLkltYWdlT3ZlcmxheSA9IEwuTGF5ZXIuZXh0ZW5kKHtcclxuXHJcblx0b3B0aW9uczoge1xyXG5cdFx0b3BhY2l0eTogMVxyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uICh1cmwsIGJvdW5kcywgb3B0aW9ucykgeyAvLyAoU3RyaW5nLCBMYXRMbmdCb3VuZHMsIE9iamVjdClcclxuXHRcdHRoaXMuX3VybCA9IHVybDtcclxuXHRcdHRoaXMuX2JvdW5kcyA9IEwubGF0TG5nQm91bmRzKGJvdW5kcyk7XHJcblxyXG5cdFx0TC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cdH0sXHJcblxyXG5cdG9uQWRkOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX2ltYWdlKSB7XHJcblx0XHRcdHRoaXMuX2luaXRJbWFnZSgpO1xyXG5cclxuXHRcdFx0aWYgKHRoaXMub3B0aW9ucy5vcGFjaXR5IDwgMSkge1xyXG5cdFx0XHRcdHRoaXMuX3VwZGF0ZU9wYWNpdHkoKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuZ2V0UGFuZSgpLmFwcGVuZENoaWxkKHRoaXMuX2ltYWdlKTtcclxuXHJcblx0XHR0aGlzLl9yZXNldCgpO1xyXG5cdH0sXHJcblxyXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRMLkRvbVV0aWwucmVtb3ZlKHRoaXMuX2ltYWdlKTtcclxuXHR9LFxyXG5cclxuXHRzZXRPcGFjaXR5OiBmdW5jdGlvbiAob3BhY2l0eSkge1xyXG5cdFx0dGhpcy5vcHRpb25zLm9wYWNpdHkgPSBvcGFjaXR5O1xyXG5cclxuXHRcdGlmICh0aGlzLl9pbWFnZSkge1xyXG5cdFx0XHR0aGlzLl91cGRhdGVPcGFjaXR5KCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRicmluZ1RvRnJvbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0TC5Eb21VdGlsLnRvRnJvbnQodGhpcy5faW1hZ2UpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0YnJpbmdUb0JhY2s6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0TC5Eb21VdGlsLnRvQmFjayh0aGlzLl9pbWFnZSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRzZXRVcmw6IGZ1bmN0aW9uICh1cmwpIHtcclxuXHRcdHRoaXMuX3VybCA9IHVybDtcclxuXHJcblx0XHRpZiAodGhpcy5faW1hZ2UpIHtcclxuXHRcdFx0dGhpcy5faW1hZ2Uuc3JjID0gdXJsO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Z2V0QXR0cmlidXRpb246IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuYXR0cmlidXRpb247XHJcblx0fSxcclxuXHJcblx0Z2V0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgZXZlbnRzID0ge1xyXG5cdFx0XHR2aWV3cmVzZXQ6IHRoaXMuX3Jlc2V0XHJcblx0XHR9O1xyXG5cclxuXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcclxuXHRcdFx0ZXZlbnRzLnpvb21hbmltID0gdGhpcy5fYW5pbWF0ZVpvb207XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGV2ZW50cztcclxuXHR9LFxyXG5cclxuXHRfaW5pdEltYWdlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgaW1nID0gdGhpcy5faW1hZ2UgPSBMLkRvbVV0aWwuY3JlYXRlKCdpbWcnLFxyXG5cdFx0XHRcdCdsZWFmbGV0LWltYWdlLWxheWVyICcgKyAodGhpcy5fem9vbUFuaW1hdGVkID8gJ2xlYWZsZXQtem9vbS1hbmltYXRlZCcgOiAnJykpO1xyXG5cclxuXHRcdGltZy5vbnNlbGVjdHN0YXJ0ID0gTC5VdGlsLmZhbHNlRm47XHJcblx0XHRpbWcub25tb3VzZW1vdmUgPSBMLlV0aWwuZmFsc2VGbjtcclxuXHJcblx0XHRpbWcub25sb2FkID0gTC5iaW5kKHRoaXMuZmlyZSwgdGhpcywgJ2xvYWQnKTtcclxuXHRcdGltZy5zcmMgPSB0aGlzLl91cmw7XHJcblx0fSxcclxuXHJcblx0X2FuaW1hdGVab29tOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0dmFyIHRvcExlZnQgPSB0aGlzLl9tYXAuX2xhdExuZ1RvTmV3TGF5ZXJQb2ludCh0aGlzLl9ib3VuZHMuZ2V0Tm9ydGhXZXN0KCksIGUuem9vbSwgZS5jZW50ZXIpLFxyXG5cdFx0ICAgIHNpemUgPSB0aGlzLl9tYXAuX2xhdExuZ1RvTmV3TGF5ZXJQb2ludCh0aGlzLl9ib3VuZHMuZ2V0U291dGhFYXN0KCksIGUuem9vbSwgZS5jZW50ZXIpLnN1YnRyYWN0KHRvcExlZnQpLFxyXG5cdFx0ICAgIG9mZnNldCA9IHRvcExlZnQuYWRkKHNpemUuX211bHRpcGx5QnkoKDEgLSAxIC8gZS5zY2FsZSkgLyAyKSk7XHJcblxyXG5cdFx0TC5Eb21VdGlsLnNldFRyYW5zZm9ybSh0aGlzLl9pbWFnZSwgb2Zmc2V0LCBlLnNjYWxlKTtcclxuXHR9LFxyXG5cclxuXHRfcmVzZXQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBpbWFnZSA9IHRoaXMuX2ltYWdlLFxyXG5cdFx0ICAgIGJvdW5kcyA9IG5ldyBMLkJvdW5kcyhcclxuXHRcdCAgICAgICAgdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9ib3VuZHMuZ2V0Tm9ydGhXZXN0KCkpLFxyXG5cdFx0ICAgICAgICB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2JvdW5kcy5nZXRTb3V0aEVhc3QoKSkpLFxyXG5cdFx0ICAgIHNpemUgPSBib3VuZHMuZ2V0U2l6ZSgpO1xyXG5cclxuXHRcdEwuRG9tVXRpbC5zZXRQb3NpdGlvbihpbWFnZSwgYm91bmRzLm1pbik7XHJcblxyXG5cdFx0aW1hZ2Uuc3R5bGUud2lkdGggID0gc2l6ZS54ICsgJ3B4JztcclxuXHRcdGltYWdlLnN0eWxlLmhlaWdodCA9IHNpemUueSArICdweCc7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZU9wYWNpdHk6IGZ1bmN0aW9uICgpIHtcclxuXHRcdEwuRG9tVXRpbC5zZXRPcGFjaXR5KHRoaXMuX2ltYWdlLCB0aGlzLm9wdGlvbnMub3BhY2l0eSk7XHJcblx0fVxyXG59KTtcclxuXHJcbkwuaW1hZ2VPdmVybGF5ID0gZnVuY3Rpb24gKHVybCwgYm91bmRzLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBMLkltYWdlT3ZlcmxheSh1cmwsIGJvdW5kcywgb3B0aW9ucyk7XHJcbn07XHJcblxuLypcclxuICogTC5JY29uIGlzIGFuIGltYWdlLWJhc2VkIGljb24gY2xhc3MgdGhhdCB5b3UgY2FuIHVzZSB3aXRoIEwuTWFya2VyIGZvciBjdXN0b20gbWFya2Vycy5cclxuICovXHJcblxyXG5MLkljb24gPSBMLkNsYXNzLmV4dGVuZCh7XHJcblx0LypcclxuXHRvcHRpb25zOiB7XHJcblx0XHRpY29uVXJsOiAoU3RyaW5nKSAocmVxdWlyZWQpXHJcblx0XHRpY29uUmV0aW5hVXJsOiAoU3RyaW5nKSAob3B0aW9uYWwsIHVzZWQgZm9yIHJldGluYSBkZXZpY2VzIGlmIGRldGVjdGVkKVxyXG5cdFx0aWNvblNpemU6IChQb2ludCkgKGNhbiBiZSBzZXQgdGhyb3VnaCBDU1MpXHJcblx0XHRpY29uQW5jaG9yOiAoUG9pbnQpIChjZW50ZXJlZCBieSBkZWZhdWx0LCBjYW4gYmUgc2V0IGluIENTUyB3aXRoIG5lZ2F0aXZlIG1hcmdpbnMpXHJcblx0XHRwb3B1cEFuY2hvcjogKFBvaW50KSAoaWYgbm90IHNwZWNpZmllZCwgcG9wdXAgb3BlbnMgaW4gdGhlIGFuY2hvciBwb2ludClcclxuXHRcdHNoYWRvd1VybDogKFN0cmluZykgKG5vIHNoYWRvdyBieSBkZWZhdWx0KVxyXG5cdFx0c2hhZG93UmV0aW5hVXJsOiAoU3RyaW5nKSAob3B0aW9uYWwsIHVzZWQgZm9yIHJldGluYSBkZXZpY2VzIGlmIGRldGVjdGVkKVxyXG5cdFx0c2hhZG93U2l6ZTogKFBvaW50KVxyXG5cdFx0c2hhZG93QW5jaG9yOiAoUG9pbnQpXHJcblx0XHRjbGFzc05hbWU6IChTdHJpbmcpXHJcblx0fSxcclxuXHQqL1xyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdFx0TC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cdH0sXHJcblxyXG5cdGNyZWF0ZUljb246IGZ1bmN0aW9uIChvbGRJY29uKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fY3JlYXRlSWNvbignaWNvbicsIG9sZEljb24pO1xyXG5cdH0sXHJcblxyXG5cdGNyZWF0ZVNoYWRvdzogZnVuY3Rpb24gKG9sZEljb24pIHtcclxuXHRcdHJldHVybiB0aGlzLl9jcmVhdGVJY29uKCdzaGFkb3cnLCBvbGRJY29uKTtcclxuXHR9LFxyXG5cclxuXHRfY3JlYXRlSWNvbjogZnVuY3Rpb24gKG5hbWUsIG9sZEljb24pIHtcclxuXHRcdHZhciBzcmMgPSB0aGlzLl9nZXRJY29uVXJsKG5hbWUpO1xyXG5cclxuXHRcdGlmICghc3JjKSB7XHJcblx0XHRcdGlmIChuYW1lID09PSAnaWNvbicpIHtcclxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ2ljb25Vcmwgbm90IHNldCBpbiBJY29uIG9wdGlvbnMgKHNlZSB0aGUgZG9jcykuJyk7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIG51bGw7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGltZyA9IHRoaXMuX2NyZWF0ZUltZyhzcmMsIG9sZEljb24gJiYgb2xkSWNvbi50YWdOYW1lID09PSAnSU1HJyA/IG9sZEljb24gOiBudWxsKTtcclxuXHRcdHRoaXMuX3NldEljb25TdHlsZXMoaW1nLCBuYW1lKTtcclxuXHJcblx0XHRyZXR1cm4gaW1nO1xyXG5cdH0sXHJcblxyXG5cdF9zZXRJY29uU3R5bGVzOiBmdW5jdGlvbiAoaW1nLCBuYW1lKSB7XHJcblx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcclxuXHRcdCAgICBzaXplID0gTC5wb2ludChvcHRpb25zW25hbWUgKyAnU2l6ZSddKSxcclxuXHRcdCAgICBhbmNob3IgPSBMLnBvaW50KG5hbWUgPT09ICdzaGFkb3cnICYmIG9wdGlvbnMuc2hhZG93QW5jaG9yIHx8IG9wdGlvbnMuaWNvbkFuY2hvciB8fFxyXG5cdFx0ICAgICAgICAgICAgc2l6ZSAmJiBzaXplLmRpdmlkZUJ5KDIsIHRydWUpKTtcclxuXHJcblx0XHRpbWcuY2xhc3NOYW1lID0gJ2xlYWZsZXQtbWFya2VyLScgKyBuYW1lICsgJyAnICsgKG9wdGlvbnMuY2xhc3NOYW1lIHx8ICcnKTtcclxuXHJcblx0XHRpZiAoYW5jaG9yKSB7XHJcblx0XHRcdGltZy5zdHlsZS5tYXJnaW5MZWZ0ID0gKC1hbmNob3IueCkgKyAncHgnO1xyXG5cdFx0XHRpbWcuc3R5bGUubWFyZ2luVG9wICA9ICgtYW5jaG9yLnkpICsgJ3B4JztcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoc2l6ZSkge1xyXG5cdFx0XHRpbWcuc3R5bGUud2lkdGggID0gc2l6ZS54ICsgJ3B4JztcclxuXHRcdFx0aW1nLnN0eWxlLmhlaWdodCA9IHNpemUueSArICdweCc7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2NyZWF0ZUltZzogZnVuY3Rpb24gKHNyYywgZWwpIHtcclxuXHRcdGVsID0gZWwgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XHJcblx0XHRlbC5zcmMgPSBzcmM7XHJcblx0XHRyZXR1cm4gZWw7XHJcblx0fSxcclxuXHJcblx0X2dldEljb25Vcmw6IGZ1bmN0aW9uIChuYW1lKSB7XHJcblx0XHRyZXR1cm4gTC5Ccm93c2VyLnJldGluYSAmJiB0aGlzLm9wdGlvbnNbbmFtZSArICdSZXRpbmFVcmwnXSB8fCB0aGlzLm9wdGlvbnNbbmFtZSArICdVcmwnXTtcclxuXHR9XHJcbn0pO1xyXG5cclxuTC5pY29uID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IEwuSWNvbihvcHRpb25zKTtcclxufTtcclxuXG4vKlxuICogTC5JY29uLkRlZmF1bHQgaXMgdGhlIGJsdWUgbWFya2VyIGljb24gdXNlZCBieSBkZWZhdWx0IGluIExlYWZsZXQuXG4gKi9cblxuTC5JY29uLkRlZmF1bHQgPSBMLkljb24uZXh0ZW5kKHtcblxuXHRvcHRpb25zOiB7XG5cdFx0aWNvblNpemU6ICAgIFsyNSwgNDFdLFxuXHRcdGljb25BbmNob3I6ICBbMTIsIDQxXSxcblx0XHRwb3B1cEFuY2hvcjogWzEsIC0zNF0sXG5cdFx0c2hhZG93U2l6ZTogIFs0MSwgNDFdXG5cdH0sXG5cblx0X2dldEljb25Vcmw6IGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0dmFyIGtleSA9IG5hbWUgKyAnVXJsJztcblxuXHRcdGlmICh0aGlzLm9wdGlvbnNba2V5XSkge1xuXHRcdFx0cmV0dXJuIHRoaXMub3B0aW9uc1trZXldO1xuXHRcdH1cblxuXHRcdHZhciBwYXRoID0gTC5JY29uLkRlZmF1bHQuaW1hZ2VQYXRoO1xuXG5cdFx0aWYgKCFwYXRoKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkblxcJ3QgYXV0b2RldGVjdCBMLkljb24uRGVmYXVsdC5pbWFnZVBhdGgsIHNldCBpdCBtYW51YWxseS4nKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcGF0aCArICcvbWFya2VyLScgKyBuYW1lICsgKEwuQnJvd3Nlci5yZXRpbmEgJiYgbmFtZSA9PT0gJ2ljb24nID8gJy0yeCcgOiAnJykgKyAnLnBuZyc7XG5cdH1cbn0pO1xuXG5MLkljb24uRGVmYXVsdC5pbWFnZVBhdGggPSAoZnVuY3Rpb24gKCkge1xuXHR2YXIgc2NyaXB0cyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzY3JpcHQnKSxcblx0ICAgIGxlYWZsZXRSZSA9IC9bXFwvXl1sZWFmbGV0W1xcLVxcLl9dPyhbXFx3XFwtXFwuX10qKVxcLmpzXFw/Py87XG5cblx0dmFyIGksIGxlbiwgc3JjLCBwYXRoO1xuXG5cdGZvciAoaSA9IDAsIGxlbiA9IHNjcmlwdHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRzcmMgPSBzY3JpcHRzW2ldLnNyYztcblxuXHRcdGlmIChzcmMubWF0Y2gobGVhZmxldFJlKSkge1xuXHRcdFx0cGF0aCA9IHNyYy5zcGxpdChsZWFmbGV0UmUpWzBdO1xuXHRcdFx0cmV0dXJuIChwYXRoID8gcGF0aCArICcvJyA6ICcnKSArICdpbWFnZXMnO1xuXHRcdH1cblx0fVxufSgpKTtcblxuLypcclxuICogTC5NYXJrZXIgaXMgdXNlZCB0byBkaXNwbGF5IGNsaWNrYWJsZS9kcmFnZ2FibGUgaWNvbnMgb24gdGhlIG1hcC5cclxuICovXHJcblxyXG5MLk1hcmtlciA9IEwuTGF5ZXIuZXh0ZW5kKHtcclxuXHJcblx0b3B0aW9uczoge1xyXG5cdFx0cGFuZTogJ21hcmtlclBhbmUnLFxyXG5cclxuXHRcdGljb246IG5ldyBMLkljb24uRGVmYXVsdCgpLFxyXG5cdFx0Ly8gdGl0bGU6ICcnLFxyXG5cdFx0Ly8gYWx0OiAnJyxcclxuXHRcdGNsaWNrYWJsZTogdHJ1ZSxcclxuXHRcdC8vIGRyYWdnYWJsZTogZmFsc2UsXHJcblx0XHRrZXlib2FyZDogdHJ1ZSxcclxuXHRcdHpJbmRleE9mZnNldDogMCxcclxuXHRcdG9wYWNpdHk6IDEsXHJcblx0XHQvLyByaXNlT25Ib3ZlcjogZmFsc2UsXHJcblx0XHRyaXNlT2Zmc2V0OiAyNTBcclxuXHR9LFxyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobGF0bG5nLCBvcHRpb25zKSB7XHJcblx0XHRMLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblx0XHR0aGlzLl9sYXRsbmcgPSBMLmxhdExuZyhsYXRsbmcpO1xyXG5cdH0sXHJcblxyXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHR0aGlzLl96b29tQW5pbWF0ZWQgPSB0aGlzLl96b29tQW5pbWF0ZWQgJiYgbWFwLm9wdGlvbnMubWFya2VyWm9vbUFuaW1hdGlvbjtcclxuXHJcblx0XHR0aGlzLl9pbml0SWNvbigpO1xyXG5cdFx0dGhpcy51cGRhdGUoKTtcclxuXHR9LFxyXG5cclxuXHRvblJlbW92ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuZHJhZ2dpbmcpIHtcclxuXHRcdFx0dGhpcy5kcmFnZ2luZy5kaXNhYmxlKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fcmVtb3ZlSWNvbigpO1xyXG5cdFx0dGhpcy5fcmVtb3ZlU2hhZG93KCk7XHJcblx0fSxcclxuXHJcblx0Z2V0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgZXZlbnRzID0ge3ZpZXdyZXNldDogdGhpcy51cGRhdGV9O1xyXG5cclxuXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcclxuXHRcdFx0ZXZlbnRzLnpvb21hbmltID0gdGhpcy5fYW5pbWF0ZVpvb207XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGV2ZW50cztcclxuXHR9LFxyXG5cclxuXHRnZXRMYXRMbmc6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9sYXRsbmc7XHJcblx0fSxcclxuXHJcblx0c2V0TGF0TG5nOiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHR2YXIgb2xkTGF0TG5nID0gdGhpcy5fbGF0bG5nO1xyXG5cdFx0dGhpcy5fbGF0bG5nID0gTC5sYXRMbmcobGF0bG5nKTtcclxuXHRcdHRoaXMudXBkYXRlKCk7XHJcblx0XHRyZXR1cm4gdGhpcy5maXJlKCdtb3ZlJywgeyBvbGRMYXRMbmc6IG9sZExhdExuZywgbGF0bG5nOiB0aGlzLl9sYXRsbmcgfSk7XHJcblx0fSxcclxuXHJcblx0c2V0WkluZGV4T2Zmc2V0OiBmdW5jdGlvbiAob2Zmc2V0KSB7XHJcblx0XHR0aGlzLm9wdGlvbnMuekluZGV4T2Zmc2V0ID0gb2Zmc2V0O1xyXG5cdFx0cmV0dXJuIHRoaXMudXBkYXRlKCk7XHJcblx0fSxcclxuXHJcblx0c2V0SWNvbjogZnVuY3Rpb24gKGljb24pIHtcclxuXHJcblx0XHR0aGlzLm9wdGlvbnMuaWNvbiA9IGljb247XHJcblxyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHR0aGlzLl9pbml0SWNvbigpO1xyXG5cdFx0XHR0aGlzLnVwZGF0ZSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLl9wb3B1cCkge1xyXG5cdFx0XHR0aGlzLmJpbmRQb3B1cCh0aGlzLl9wb3B1cCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0dXBkYXRlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2ljb24pIHtcclxuXHRcdFx0dmFyIHBvcyA9IHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fbGF0bG5nKS5yb3VuZCgpO1xyXG5cdFx0XHR0aGlzLl9zZXRQb3MocG9zKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfaW5pdEljb246IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxyXG5cdFx0ICAgIGNsYXNzVG9BZGQgPSAnbGVhZmxldC16b29tLScgKyAodGhpcy5fem9vbUFuaW1hdGVkID8gJ2FuaW1hdGVkJyA6ICdoaWRlJyk7XHJcblxyXG5cdFx0dmFyIGljb24gPSBvcHRpb25zLmljb24uY3JlYXRlSWNvbih0aGlzLl9pY29uKSxcclxuXHRcdFx0YWRkSWNvbiA9IGZhbHNlO1xyXG5cclxuXHRcdC8vIGlmIHdlJ3JlIG5vdCByZXVzaW5nIHRoZSBpY29uLCByZW1vdmUgdGhlIG9sZCBvbmUgYW5kIGluaXQgbmV3IG9uZVxyXG5cdFx0aWYgKGljb24gIT09IHRoaXMuX2ljb24pIHtcclxuXHRcdFx0aWYgKHRoaXMuX2ljb24pIHtcclxuXHRcdFx0XHR0aGlzLl9yZW1vdmVJY29uKCk7XHJcblx0XHRcdH1cclxuXHRcdFx0YWRkSWNvbiA9IHRydWU7XHJcblxyXG5cdFx0XHRpZiAob3B0aW9ucy50aXRsZSkge1xyXG5cdFx0XHRcdGljb24udGl0bGUgPSBvcHRpb25zLnRpdGxlO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmIChvcHRpb25zLmFsdCkge1xyXG5cdFx0XHRcdGljb24uYWx0ID0gb3B0aW9ucy5hbHQ7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRMLkRvbVV0aWwuYWRkQ2xhc3MoaWNvbiwgY2xhc3NUb0FkZCk7XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMua2V5Ym9hcmQpIHtcclxuXHRcdFx0aWNvbi50YWJJbmRleCA9ICcwJztcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9pY29uID0gaWNvbjtcclxuXHRcdHRoaXMuX2luaXRJbnRlcmFjdGlvbigpO1xyXG5cclxuXHRcdGlmIChvcHRpb25zLnJpc2VPbkhvdmVyKSB7XHJcblx0XHRcdEwuRG9tRXZlbnQub24oaWNvbiwge1xyXG5cdFx0XHRcdG1vdXNlb3ZlcjogdGhpcy5fYnJpbmdUb0Zyb250LFxyXG5cdFx0XHRcdG1vdXNlb3V0OiB0aGlzLl9yZXNldFpJbmRleFxyXG5cdFx0XHR9LCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgbmV3U2hhZG93ID0gb3B0aW9ucy5pY29uLmNyZWF0ZVNoYWRvdyh0aGlzLl9zaGFkb3cpLFxyXG5cdFx0XHRhZGRTaGFkb3cgPSBmYWxzZTtcclxuXHJcblx0XHRpZiAobmV3U2hhZG93ICE9PSB0aGlzLl9zaGFkb3cpIHtcclxuXHRcdFx0dGhpcy5fcmVtb3ZlU2hhZG93KCk7XHJcblx0XHRcdGFkZFNoYWRvdyA9IHRydWU7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKG5ld1NoYWRvdykge1xyXG5cdFx0XHRMLkRvbVV0aWwuYWRkQ2xhc3MobmV3U2hhZG93LCBjbGFzc1RvQWRkKTtcclxuXHRcdH1cclxuXHRcdHRoaXMuX3NoYWRvdyA9IG5ld1NoYWRvdztcclxuXHJcblxyXG5cdFx0aWYgKG9wdGlvbnMub3BhY2l0eSA8IDEpIHtcclxuXHRcdFx0dGhpcy5fdXBkYXRlT3BhY2l0eSgpO1xyXG5cdFx0fVxyXG5cclxuXHJcblx0XHRpZiAoYWRkSWNvbikge1xyXG5cdFx0XHR0aGlzLmdldFBhbmUoKS5hcHBlbmRDaGlsZCh0aGlzLl9pY29uKTtcclxuXHRcdH1cclxuXHRcdGlmIChuZXdTaGFkb3cgJiYgYWRkU2hhZG93KSB7XHJcblx0XHRcdHRoaXMuZ2V0UGFuZSgnc2hhZG93UGFuZScpLmFwcGVuZENoaWxkKHRoaXMuX3NoYWRvdyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X3JlbW92ZUljb246IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLm9wdGlvbnMucmlzZU9uSG92ZXIpIHtcclxuXHRcdFx0TC5Eb21FdmVudC5vZmYodGhpcy5faWNvbiwge1xyXG5cdFx0XHRcdG1vdXNlb3ZlcjogdGhpcy5fYnJpbmdUb0Zyb250LFxyXG5cdFx0XHQgICAgbW91c2VvdXQ6IHRoaXMuX3Jlc2V0WkluZGV4XHJcblx0XHRcdH0sIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdEwuRG9tVXRpbC5yZW1vdmUodGhpcy5faWNvbik7XHJcblxyXG5cdFx0dGhpcy5faWNvbiA9IG51bGw7XHJcblx0fSxcclxuXHJcblx0X3JlbW92ZVNoYWRvdzogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX3NoYWRvdykge1xyXG5cdFx0XHRMLkRvbVV0aWwucmVtb3ZlKHRoaXMuX3NoYWRvdyk7XHJcblx0XHR9XHJcblx0XHR0aGlzLl9zaGFkb3cgPSBudWxsO1xyXG5cdH0sXHJcblxyXG5cdF9zZXRQb3M6IGZ1bmN0aW9uIChwb3MpIHtcclxuXHRcdEwuRG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9pY29uLCBwb3MpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9zaGFkb3cpIHtcclxuXHRcdFx0TC5Eb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX3NoYWRvdywgcG9zKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl96SW5kZXggPSBwb3MueSArIHRoaXMub3B0aW9ucy56SW5kZXhPZmZzZXQ7XHJcblxyXG5cdFx0dGhpcy5fcmVzZXRaSW5kZXgoKTtcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlWkluZGV4OiBmdW5jdGlvbiAob2Zmc2V0KSB7XHJcblx0XHR0aGlzLl9pY29uLnN0eWxlLnpJbmRleCA9IHRoaXMuX3pJbmRleCArIG9mZnNldDtcclxuXHR9LFxyXG5cclxuXHRfYW5pbWF0ZVpvb206IGZ1bmN0aW9uIChvcHQpIHtcclxuXHRcdHZhciBwb3MgPSB0aGlzLl9tYXAuX2xhdExuZ1RvTmV3TGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcsIG9wdC56b29tLCBvcHQuY2VudGVyKS5yb3VuZCgpO1xyXG5cclxuXHRcdHRoaXMuX3NldFBvcyhwb3MpO1xyXG5cdH0sXHJcblxyXG5cdF9pbml0SW50ZXJhY3Rpb246IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRpZiAoIXRoaXMub3B0aW9ucy5jbGlja2FibGUpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0TC5Eb21VdGlsLmFkZENsYXNzKHRoaXMuX2ljb24sICdsZWFmbGV0LWNsaWNrYWJsZScpO1xyXG5cclxuXHRcdEwuRG9tRXZlbnQub24odGhpcy5faWNvbiwgJ2NsaWNrIGRibGNsaWNrIG1vdXNlZG93biBtb3VzZXVwIG1vdXNlb3ZlciBtb3VzZW91dCBjb250ZXh0bWVudSBrZXlwcmVzcycsXHJcblx0XHRcdFx0dGhpcy5fZmlyZU1vdXNlRXZlbnQsIHRoaXMpO1xyXG5cclxuXHRcdGlmIChMLkhhbmRsZXIuTWFya2VyRHJhZykge1xyXG5cdFx0XHR0aGlzLmRyYWdnaW5nID0gbmV3IEwuSGFuZGxlci5NYXJrZXJEcmFnKHRoaXMpO1xyXG5cclxuXHRcdFx0aWYgKHRoaXMub3B0aW9ucy5kcmFnZ2FibGUpIHtcclxuXHRcdFx0XHR0aGlzLmRyYWdnaW5nLmVuYWJsZSgpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2ZpcmVNb3VzZUV2ZW50OiBmdW5jdGlvbiAoZSwgdHlwZSkge1xyXG5cdFx0Ly8gdG8gcHJldmVudCBvdXRsaW5lIHdoZW4gY2xpY2tpbmcgb24ga2V5Ym9hcmQtZm9jdXNhYmxlIG1hcmtlclxyXG5cdFx0aWYgKGUudHlwZSA9PT0gJ21vdXNlZG93bicpIHtcclxuXHRcdFx0TC5Eb21FdmVudC5wcmV2ZW50RGVmYXVsdChlKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoZS50eXBlID09PSAnY2xpY2snICYmIHRoaXMuZHJhZ2dpbmcgJiYgdGhpcy5kcmFnZ2luZy5tb3ZlZCgpKSB7XHJcblx0XHRcdEwuRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uKGUpO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGUudHlwZSA9PT0gJ2tleXByZXNzJyAmJiBlLmtleUNvZGUgPT09IDEzKSB7XHJcblx0XHRcdHR5cGUgPSAnY2xpY2snO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0dGhpcy5fbWFwLl9maXJlTW91c2VFdmVudCh0aGlzLCBlLCB0eXBlLCB0cnVlLCB0aGlzLl9sYXRsbmcpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdHNldE9wYWNpdHk6IGZ1bmN0aW9uIChvcGFjaXR5KSB7XHJcblx0XHR0aGlzLm9wdGlvbnMub3BhY2l0eSA9IG9wYWNpdHk7XHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdHRoaXMuX3VwZGF0ZU9wYWNpdHkoKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlT3BhY2l0eTogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIG9wYWNpdHkgPSB0aGlzLm9wdGlvbnMub3BhY2l0eTtcclxuXHJcblx0XHRMLkRvbVV0aWwuc2V0T3BhY2l0eSh0aGlzLl9pY29uLCBvcGFjaXR5KTtcclxuXHJcblx0XHRpZiAodGhpcy5fc2hhZG93KSB7XHJcblx0XHRcdEwuRG9tVXRpbC5zZXRPcGFjaXR5KHRoaXMuX3NoYWRvdywgb3BhY2l0eSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2JyaW5nVG9Gcm9udDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5fdXBkYXRlWkluZGV4KHRoaXMub3B0aW9ucy5yaXNlT2Zmc2V0KTtcclxuXHR9LFxyXG5cclxuXHRfcmVzZXRaSW5kZXg6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX3VwZGF0ZVpJbmRleCgwKTtcclxuXHR9XHJcbn0pO1xyXG5cclxuTC5tYXJrZXIgPSBmdW5jdGlvbiAobGF0bG5nLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBMLk1hcmtlcihsYXRsbmcsIG9wdGlvbnMpO1xyXG59O1xyXG5cbi8qXG4gKiBMLkRpdkljb24gaXMgYSBsaWdodHdlaWdodCBIVE1MLWJhc2VkIGljb24gY2xhc3MgKGFzIG9wcG9zZWQgdG8gdGhlIGltYWdlLWJhc2VkIEwuSWNvbilcbiAqIHRvIHVzZSB3aXRoIEwuTWFya2VyLlxuICovXG5cbkwuRGl2SWNvbiA9IEwuSWNvbi5leHRlbmQoe1xuXHRvcHRpb25zOiB7XG5cdFx0aWNvblNpemU6IFsxMiwgMTJdLCAvLyBhbHNvIGNhbiBiZSBzZXQgdGhyb3VnaCBDU1Ncblx0XHQvKlxuXHRcdGljb25BbmNob3I6IChQb2ludClcblx0XHRwb3B1cEFuY2hvcjogKFBvaW50KVxuXHRcdGh0bWw6IChTdHJpbmcpXG5cdFx0YmdQb3M6IChQb2ludClcblx0XHQqL1xuXHRcdGNsYXNzTmFtZTogJ2xlYWZsZXQtZGl2LWljb24nLFxuXHRcdGh0bWw6IGZhbHNlXG5cdH0sXG5cblx0Y3JlYXRlSWNvbjogZnVuY3Rpb24gKG9sZEljb24pIHtcblx0XHR2YXIgZGl2ID0gKG9sZEljb24gJiYgb2xkSWNvbi50YWdOYW1lID09PSAnRElWJykgPyBvbGRJY29uIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksXG5cdFx0ICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cblx0XHRkaXYuaW5uZXJIVE1MID0gb3B0aW9ucy5odG1sICE9PSBmYWxzZSA/IG9wdGlvbnMuaHRtbCA6ICcnO1xuXG5cdFx0aWYgKG9wdGlvbnMuYmdQb3MpIHtcblx0XHRcdGRpdi5zdHlsZS5iYWNrZ3JvdW5kUG9zaXRpb24gPSAoLW9wdGlvbnMuYmdQb3MueCkgKyAncHggJyArICgtb3B0aW9ucy5iZ1Bvcy55KSArICdweCc7XG5cdFx0fVxuXHRcdHRoaXMuX3NldEljb25TdHlsZXMoZGl2LCAnaWNvbicpO1xuXG5cdFx0cmV0dXJuIGRpdjtcblx0fSxcblxuXHRjcmVhdGVTaGFkb3c6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxufSk7XG5cbkwuZGl2SWNvbiA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cdHJldHVybiBuZXcgTC5EaXZJY29uKG9wdGlvbnMpO1xufTtcblxuLypcclxuICogTC5Qb3B1cCBpcyB1c2VkIGZvciBkaXNwbGF5aW5nIHBvcHVwcyBvbiB0aGUgbWFwLlxyXG4gKi9cclxuXHJcbkwuTWFwLm1lcmdlT3B0aW9ucyh7XHJcblx0Y2xvc2VQb3B1cE9uQ2xpY2s6IHRydWVcclxufSk7XHJcblxyXG5MLlBvcHVwID0gTC5MYXllci5leHRlbmQoe1xyXG5cclxuXHRvcHRpb25zOiB7XHJcblx0XHRwYW5lOiAncG9wdXBQYW5lJyxcclxuXHJcblx0XHRtaW5XaWR0aDogNTAsXHJcblx0XHRtYXhXaWR0aDogMzAwLFxyXG5cdFx0Ly8gbWF4SGVpZ2h0OiA8TnVtYmVyPixcclxuXHRcdG9mZnNldDogWzAsIDddLFxyXG5cclxuXHRcdGF1dG9QYW46IHRydWUsXHJcblx0XHRhdXRvUGFuUGFkZGluZzogWzUsIDVdLFxyXG5cdFx0Ly8gYXV0b1BhblBhZGRpbmdUb3BMZWZ0OiA8UG9pbnQ+LFxyXG5cdFx0Ly8gYXV0b1BhblBhZGRpbmdCb3R0b21SaWdodDogPFBvaW50PixcclxuXHJcblx0XHRjbG9zZUJ1dHRvbjogdHJ1ZSxcclxuXHRcdC8vIGtlZXBJblZpZXc6IGZhbHNlLFxyXG5cdFx0Ly8gY2xhc3NOYW1lOiAnJyxcclxuXHRcdHpvb21BbmltYXRpb246IHRydWVcclxuXHR9LFxyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucywgc291cmNlKSB7XHJcblx0XHRMLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG5cdFx0dGhpcy5fc291cmNlID0gc291cmNlO1xyXG5cdH0sXHJcblxyXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHR0aGlzLl96b29tQW5pbWF0ZWQgPSB0aGlzLl96b29tQW5pbWF0ZWQgJiYgdGhpcy5vcHRpb25zLnpvb21BbmltYXRpb247XHJcblxyXG5cdFx0aWYgKCF0aGlzLl9jb250YWluZXIpIHtcclxuXHRcdFx0dGhpcy5faW5pdExheW91dCgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChtYXAuX2ZhZGVBbmltYXRlZCkge1xyXG5cdFx0XHRMLkRvbVV0aWwuc2V0T3BhY2l0eSh0aGlzLl9jb250YWluZXIsIDApO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNsZWFyVGltZW91dCh0aGlzLl9yZW1vdmVUaW1lb3V0KTtcclxuXHRcdHRoaXMuZ2V0UGFuZSgpLmFwcGVuZENoaWxkKHRoaXMuX2NvbnRhaW5lcik7XHJcblx0XHR0aGlzLnVwZGF0ZSgpO1xyXG5cclxuXHRcdGlmIChtYXAuX2ZhZGVBbmltYXRlZCkge1xyXG5cdFx0XHRMLkRvbVV0aWwuc2V0T3BhY2l0eSh0aGlzLl9jb250YWluZXIsIDEpO1xyXG5cdFx0fVxyXG5cclxuXHRcdG1hcC5maXJlKCdwb3B1cG9wZW4nLCB7cG9wdXA6IHRoaXN9KTtcclxuXHJcblx0XHRpZiAodGhpcy5fc291cmNlKSB7XHJcblx0XHRcdHRoaXMuX3NvdXJjZS5maXJlKCdwb3B1cG9wZW4nLCB7cG9wdXA6IHRoaXN9LCB0cnVlKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRvcGVuT246IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdG1hcC5vcGVuUG9wdXAodGhpcyk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0aWYgKG1hcC5fZmFkZUFuaW1hdGVkKSB7XHJcblx0XHRcdEwuRG9tVXRpbC5zZXRPcGFjaXR5KHRoaXMuX2NvbnRhaW5lciwgMCk7XHJcblx0XHRcdHRoaXMuX3JlbW92ZVRpbWVvdXQgPSBzZXRUaW1lb3V0KEwuYmluZChMLkRvbVV0aWwucmVtb3ZlLCBMLkRvbVV0aWwsIHRoaXMuX2NvbnRhaW5lciksIDIwMCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRMLkRvbVV0aWwucmVtb3ZlKHRoaXMuX2NvbnRhaW5lcik7XHJcblx0XHR9XHJcblxyXG5cdFx0bWFwLmZpcmUoJ3BvcHVwY2xvc2UnLCB7cG9wdXA6IHRoaXN9KTtcclxuXHJcblx0XHRpZiAodGhpcy5fc291cmNlKSB7XHJcblx0XHRcdHRoaXMuX3NvdXJjZS5maXJlKCdwb3B1cGNsb3NlJywge3BvcHVwOiB0aGlzfSwgdHJ1ZSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Z2V0TGF0TG5nOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fbGF0bG5nO1xyXG5cdH0sXHJcblxyXG5cdHNldExhdExuZzogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0dGhpcy5fbGF0bG5nID0gTC5sYXRMbmcobGF0bG5nKTtcclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0dGhpcy5fdXBkYXRlUG9zaXRpb24oKTtcclxuXHRcdFx0dGhpcy5fYWRqdXN0UGFuKCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRnZXRDb250ZW50OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fY29udGVudDtcclxuXHR9LFxyXG5cclxuXHRzZXRDb250ZW50OiBmdW5jdGlvbiAoY29udGVudCkge1xyXG5cdFx0dGhpcy5fY29udGVudCA9IGNvbnRlbnQ7XHJcblx0XHR0aGlzLnVwZGF0ZSgpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0dXBkYXRlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX21hcCkgeyByZXR1cm47IH1cclxuXHJcblx0XHR0aGlzLl9jb250YWluZXIuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xyXG5cclxuXHRcdHRoaXMuX3VwZGF0ZUNvbnRlbnQoKTtcclxuXHRcdHRoaXMuX3VwZGF0ZUxheW91dCgpO1xyXG5cdFx0dGhpcy5fdXBkYXRlUG9zaXRpb24oKTtcclxuXHJcblx0XHR0aGlzLl9jb250YWluZXIuc3R5bGUudmlzaWJpbGl0eSA9ICcnO1xyXG5cclxuXHRcdHRoaXMuX2FkanVzdFBhbigpO1xyXG5cdH0sXHJcblxyXG5cdGdldEV2ZW50czogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGV2ZW50cyA9IHt2aWV3cmVzZXQ6IHRoaXMuX3VwZGF0ZVBvc2l0aW9ufSxcclxuXHRcdCAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xyXG5cclxuXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcclxuXHRcdFx0ZXZlbnRzLnpvb21hbmltID0gdGhpcy5fYW5pbWF0ZVpvb207XHJcblx0XHR9XHJcblx0XHRpZiAoJ2Nsb3NlT25DbGljaycgaW4gb3B0aW9ucyA/IG9wdGlvbnMuY2xvc2VPbkNsaWNrIDogdGhpcy5fbWFwLm9wdGlvbnMuY2xvc2VQb3B1cE9uQ2xpY2spIHtcclxuXHRcdFx0ZXZlbnRzLnByZWNsaWNrID0gdGhpcy5fY2xvc2U7XHJcblx0XHR9XHJcblx0XHRpZiAob3B0aW9ucy5rZWVwSW5WaWV3KSB7XHJcblx0XHRcdGV2ZW50cy5tb3ZlZW5kID0gdGhpcy5fYWRqdXN0UGFuO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGV2ZW50cztcclxuXHR9LFxyXG5cdFxyXG5cdGlzT3BlbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuICEhdGhpcy5fbWFwICYmIHRoaXMuX21hcC5oYXNMYXllcih0aGlzKTtcclxuXHR9LFxyXG5cclxuXHRfY2xvc2U6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0dGhpcy5fbWFwLmNsb3NlUG9wdXAodGhpcyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2luaXRMYXlvdXQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBwcmVmaXggPSAnbGVhZmxldC1wb3B1cCcsXHJcblx0XHQgICAgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyID0gTC5Eb21VdGlsLmNyZWF0ZSgnZGl2JyxcclxuXHRcdFx0cHJlZml4ICsgJyAnICsgKHRoaXMub3B0aW9ucy5jbGFzc05hbWUgfHwgJycpICtcclxuXHRcdFx0JyBsZWFmbGV0LXpvb20tJyArICh0aGlzLl96b29tQW5pbWF0ZWQgPyAnYW5pbWF0ZWQnIDogJ2hpZGUnKSk7XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5jbG9zZUJ1dHRvbikge1xyXG5cdFx0XHR2YXIgY2xvc2VCdXR0b24gPSB0aGlzLl9jbG9zZUJ1dHRvbiA9IEwuRG9tVXRpbC5jcmVhdGUoJ2EnLCBwcmVmaXggKyAnLWNsb3NlLWJ1dHRvbicsIGNvbnRhaW5lcik7XHJcblx0XHRcdGNsb3NlQnV0dG9uLmhyZWYgPSAnI2Nsb3NlJztcclxuXHRcdFx0Y2xvc2VCdXR0b24uaW5uZXJIVE1MID0gJyYjMjE1Oyc7XHJcblxyXG5cdFx0XHRMLkRvbUV2ZW50Lm9uKGNsb3NlQnV0dG9uLCAnY2xpY2snLCB0aGlzLl9vbkNsb3NlQnV0dG9uQ2xpY2ssIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciB3cmFwcGVyID0gdGhpcy5fd3JhcHBlciA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsIHByZWZpeCArICctY29udGVudC13cmFwcGVyJywgY29udGFpbmVyKTtcclxuXHRcdHRoaXMuX2NvbnRlbnROb2RlID0gTC5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgcHJlZml4ICsgJy1jb250ZW50Jywgd3JhcHBlcik7XHJcblxyXG5cdFx0TC5Eb21FdmVudFxyXG5cdFx0XHQuZGlzYWJsZUNsaWNrUHJvcGFnYXRpb24od3JhcHBlcilcclxuXHRcdFx0LmRpc2FibGVTY3JvbGxQcm9wYWdhdGlvbih0aGlzLl9jb250ZW50Tm9kZSlcclxuXHRcdFx0Lm9uKHdyYXBwZXIsICdjb250ZXh0bWVudScsIEwuRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uKTtcclxuXHJcblx0XHR0aGlzLl90aXBDb250YWluZXIgPSBMLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCBwcmVmaXggKyAnLXRpcC1jb250YWluZXInLCBjb250YWluZXIpO1xyXG5cdFx0dGhpcy5fdGlwID0gTC5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgcHJlZml4ICsgJy10aXAnLCB0aGlzLl90aXBDb250YWluZXIpO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVDb250ZW50OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX2NvbnRlbnQpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0dmFyIG5vZGUgPSB0aGlzLl9jb250ZW50Tm9kZTtcclxuXHJcblx0XHRpZiAodHlwZW9mIHRoaXMuX2NvbnRlbnQgPT09ICdzdHJpbmcnKSB7XHJcblx0XHRcdG5vZGUuaW5uZXJIVE1MID0gdGhpcy5fY29udGVudDtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHdoaWxlIChub2RlLmhhc0NoaWxkTm9kZXMoKSkge1xyXG5cdFx0XHRcdG5vZGUucmVtb3ZlQ2hpbGQobm9kZS5maXJzdENoaWxkKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRub2RlLmFwcGVuZENoaWxkKHRoaXMuX2NvbnRlbnQpO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5maXJlKCdjb250ZW50dXBkYXRlJyk7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZUxheW91dDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRlbnROb2RlLFxyXG5cdFx0ICAgIHN0eWxlID0gY29udGFpbmVyLnN0eWxlO1xyXG5cclxuXHRcdHN0eWxlLndpZHRoID0gJyc7XHJcblx0XHRzdHlsZS53aGl0ZVNwYWNlID0gJ25vd3JhcCc7XHJcblxyXG5cdFx0dmFyIHdpZHRoID0gY29udGFpbmVyLm9mZnNldFdpZHRoO1xyXG5cdFx0d2lkdGggPSBNYXRoLm1pbih3aWR0aCwgdGhpcy5vcHRpb25zLm1heFdpZHRoKTtcclxuXHRcdHdpZHRoID0gTWF0aC5tYXgod2lkdGgsIHRoaXMub3B0aW9ucy5taW5XaWR0aCk7XHJcblxyXG5cdFx0c3R5bGUud2lkdGggPSAod2lkdGggKyAxKSArICdweCc7XHJcblx0XHRzdHlsZS53aGl0ZVNwYWNlID0gJyc7XHJcblxyXG5cdFx0c3R5bGUuaGVpZ2h0ID0gJyc7XHJcblxyXG5cdFx0dmFyIGhlaWdodCA9IGNvbnRhaW5lci5vZmZzZXRIZWlnaHQsXHJcblx0XHQgICAgbWF4SGVpZ2h0ID0gdGhpcy5vcHRpb25zLm1heEhlaWdodCxcclxuXHRcdCAgICBzY3JvbGxlZENsYXNzID0gJ2xlYWZsZXQtcG9wdXAtc2Nyb2xsZWQnO1xyXG5cclxuXHRcdGlmIChtYXhIZWlnaHQgJiYgaGVpZ2h0ID4gbWF4SGVpZ2h0KSB7XHJcblx0XHRcdHN0eWxlLmhlaWdodCA9IG1heEhlaWdodCArICdweCc7XHJcblx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyhjb250YWluZXIsIHNjcm9sbGVkQ2xhc3MpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0TC5Eb21VdGlsLnJlbW92ZUNsYXNzKGNvbnRhaW5lciwgc2Nyb2xsZWRDbGFzcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fY29udGFpbmVyV2lkdGggPSB0aGlzLl9jb250YWluZXIub2Zmc2V0V2lkdGg7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZVBvc2l0aW9uOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX21hcCkgeyByZXR1cm47IH1cclxuXHJcblx0XHR2YXIgcG9zID0gdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcpLFxyXG5cdFx0ICAgIG9mZnNldCA9IEwucG9pbnQodGhpcy5vcHRpb25zLm9mZnNldCk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xyXG5cdFx0XHRMLkRvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fY29udGFpbmVyLCBwb3MpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0b2Zmc2V0ID0gb2Zmc2V0LmFkZChwb3MpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBib3R0b20gPSB0aGlzLl9jb250YWluZXJCb3R0b20gPSAtb2Zmc2V0LnksXHJcblx0XHQgICAgbGVmdCA9IHRoaXMuX2NvbnRhaW5lckxlZnQgPSAtTWF0aC5yb3VuZCh0aGlzLl9jb250YWluZXJXaWR0aCAvIDIpICsgb2Zmc2V0Lng7XHJcblxyXG5cdFx0Ly8gYm90dG9tIHBvc2l0aW9uIHRoZSBwb3B1cCBpbiBjYXNlIHRoZSBoZWlnaHQgb2YgdGhlIHBvcHVwIGNoYW5nZXMgKGltYWdlcyBsb2FkaW5nIGV0YylcclxuXHRcdHRoaXMuX2NvbnRhaW5lci5zdHlsZS5ib3R0b20gPSBib3R0b20gKyAncHgnO1xyXG5cdFx0dGhpcy5fY29udGFpbmVyLnN0eWxlLmxlZnQgPSBsZWZ0ICsgJ3B4JztcclxuXHR9LFxyXG5cclxuXHRfYW5pbWF0ZVpvb206IGZ1bmN0aW9uIChlKSB7XHJcblx0XHR2YXIgcG9zID0gdGhpcy5fbWFwLl9sYXRMbmdUb05ld0xheWVyUG9pbnQodGhpcy5fbGF0bG5nLCBlLnpvb20sIGUuY2VudGVyKTtcclxuXHRcdEwuRG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9jb250YWluZXIsIHBvcyk7XHJcblx0fSxcclxuXHJcblx0X2FkanVzdFBhbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLm9wdGlvbnMuYXV0b1BhbikgeyByZXR1cm47IH1cclxuXHJcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxyXG5cdFx0ICAgIGNvbnRhaW5lckhlaWdodCA9IHRoaXMuX2NvbnRhaW5lci5vZmZzZXRIZWlnaHQsXHJcblx0XHQgICAgY29udGFpbmVyV2lkdGggPSB0aGlzLl9jb250YWluZXJXaWR0aCxcclxuXHRcdCAgICBsYXllclBvcyA9IG5ldyBMLlBvaW50KHRoaXMuX2NvbnRhaW5lckxlZnQsIC1jb250YWluZXJIZWlnaHQgLSB0aGlzLl9jb250YWluZXJCb3R0b20pO1xyXG5cclxuXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcclxuXHRcdFx0bGF5ZXJQb3MuX2FkZChMLkRvbVV0aWwuZ2V0UG9zaXRpb24odGhpcy5fY29udGFpbmVyKSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGNvbnRhaW5lclBvcyA9IG1hcC5sYXllclBvaW50VG9Db250YWluZXJQb2ludChsYXllclBvcyksXHJcblx0XHQgICAgcGFkZGluZyA9IEwucG9pbnQodGhpcy5vcHRpb25zLmF1dG9QYW5QYWRkaW5nKSxcclxuXHRcdCAgICBwYWRkaW5nVEwgPSBMLnBvaW50KHRoaXMub3B0aW9ucy5hdXRvUGFuUGFkZGluZ1RvcExlZnQgfHwgcGFkZGluZyksXHJcblx0XHQgICAgcGFkZGluZ0JSID0gTC5wb2ludCh0aGlzLm9wdGlvbnMuYXV0b1BhblBhZGRpbmdCb3R0b21SaWdodCB8fCBwYWRkaW5nKSxcclxuXHRcdCAgICBzaXplID0gbWFwLmdldFNpemUoKSxcclxuXHRcdCAgICBkeCA9IDAsXHJcblx0XHQgICAgZHkgPSAwO1xyXG5cclxuXHRcdGlmIChjb250YWluZXJQb3MueCArIGNvbnRhaW5lcldpZHRoICsgcGFkZGluZ0JSLnggPiBzaXplLngpIHsgLy8gcmlnaHRcclxuXHRcdFx0ZHggPSBjb250YWluZXJQb3MueCArIGNvbnRhaW5lcldpZHRoIC0gc2l6ZS54ICsgcGFkZGluZ0JSLng7XHJcblx0XHR9XHJcblx0XHRpZiAoY29udGFpbmVyUG9zLnggLSBkeCAtIHBhZGRpbmdUTC54IDwgMCkgeyAvLyBsZWZ0XHJcblx0XHRcdGR4ID0gY29udGFpbmVyUG9zLnggLSBwYWRkaW5nVEwueDtcclxuXHRcdH1cclxuXHRcdGlmIChjb250YWluZXJQb3MueSArIGNvbnRhaW5lckhlaWdodCArIHBhZGRpbmdCUi55ID4gc2l6ZS55KSB7IC8vIGJvdHRvbVxyXG5cdFx0XHRkeSA9IGNvbnRhaW5lclBvcy55ICsgY29udGFpbmVySGVpZ2h0IC0gc2l6ZS55ICsgcGFkZGluZ0JSLnk7XHJcblx0XHR9XHJcblx0XHRpZiAoY29udGFpbmVyUG9zLnkgLSBkeSAtIHBhZGRpbmdUTC55IDwgMCkgeyAvLyB0b3BcclxuXHRcdFx0ZHkgPSBjb250YWluZXJQb3MueSAtIHBhZGRpbmdUTC55O1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChkeCB8fCBkeSkge1xyXG5cdFx0XHRtYXBcclxuXHRcdFx0ICAgIC5maXJlKCdhdXRvcGFuc3RhcnQnKVxyXG5cdFx0XHQgICAgLnBhbkJ5KFtkeCwgZHldKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfb25DbG9zZUJ1dHRvbkNsaWNrOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0dGhpcy5fY2xvc2UoKTtcclxuXHRcdEwuRG9tRXZlbnQuc3RvcChlKTtcclxuXHR9XHJcbn0pO1xyXG5cclxuTC5wb3B1cCA9IGZ1bmN0aW9uIChvcHRpb25zLCBzb3VyY2UpIHtcclxuXHRyZXR1cm4gbmV3IEwuUG9wdXAob3B0aW9ucywgc291cmNlKTtcclxufTtcclxuXHJcblxyXG5MLk1hcC5pbmNsdWRlKHtcclxuXHRvcGVuUG9wdXA6IGZ1bmN0aW9uIChwb3B1cCwgbGF0bG5nLCBvcHRpb25zKSB7IC8vIChQb3B1cCkgb3IgKFN0cmluZyB8fCBIVE1MRWxlbWVudCwgTGF0TG5nWywgT2JqZWN0XSlcclxuXHRcdGlmICghKHBvcHVwIGluc3RhbmNlb2YgTC5Qb3B1cCkpIHtcclxuXHRcdFx0dmFyIGNvbnRlbnQgPSBwb3B1cDtcclxuXHJcblx0XHRcdHBvcHVwID0gbmV3IEwuUG9wdXAob3B0aW9ucykuc2V0Q29udGVudChjb250ZW50KTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAobGF0bG5nKSB7XHJcblx0XHRcdHBvcHVwLnNldExhdExuZyhsYXRsbmcpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLmhhc0xheWVyKHBvcHVwKSkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLmNsb3NlUG9wdXAoKTtcclxuXHRcdHRoaXMuX3BvcHVwID0gcG9wdXA7XHJcblx0XHRyZXR1cm4gdGhpcy5hZGRMYXllcihwb3B1cCk7XHJcblx0fSxcclxuXHJcblx0Y2xvc2VQb3B1cDogZnVuY3Rpb24gKHBvcHVwKSB7XHJcblx0XHRpZiAoIXBvcHVwIHx8IHBvcHVwID09PSB0aGlzLl9wb3B1cCkge1xyXG5cdFx0XHRwb3B1cCA9IHRoaXMuX3BvcHVwO1xyXG5cdFx0XHR0aGlzLl9wb3B1cCA9IG51bGw7XHJcblx0XHR9XHJcblx0XHRpZiAocG9wdXApIHtcclxuXHRcdFx0dGhpcy5yZW1vdmVMYXllcihwb3B1cCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcbn0pO1xyXG5cbi8qXG4gKiBBZGRzIHBvcHVwLXJlbGF0ZWQgbWV0aG9kcyB0byBhbGwgbGF5ZXJzLlxuICovXG5cbkwuTGF5ZXIuaW5jbHVkZSh7XG5cblx0YmluZFBvcHVwOiBmdW5jdGlvbiAoY29udGVudCwgb3B0aW9ucykge1xuXG5cdFx0aWYgKGNvbnRlbnQgaW5zdGFuY2VvZiBMLlBvcHVwKSB7XG5cdFx0XHR0aGlzLl9wb3B1cCA9IGNvbnRlbnQ7XG5cdFx0XHRjb250ZW50Ll9zb3VyY2UgPSB0aGlzO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAoIXRoaXMuX3BvcHVwIHx8IG9wdGlvbnMpIHtcblx0XHRcdFx0dGhpcy5fcG9wdXAgPSBuZXcgTC5Qb3B1cChvcHRpb25zLCB0aGlzKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX3BvcHVwLnNldENvbnRlbnQoY29udGVudCk7XG5cdFx0fVxuXG5cdFx0aWYgKCF0aGlzLl9wb3B1cEhhbmRsZXJzQWRkZWQpIHtcblx0XHRcdHRoaXMub24oe1xuXHRcdFx0XHRjbGljazogdGhpcy5fb3BlblBvcHVwLFxuXHRcdFx0XHRyZW1vdmU6IHRoaXMuY2xvc2VQb3B1cCxcblx0XHRcdFx0bW92ZTogdGhpcy5fbW92ZVBvcHVwXG5cdFx0XHR9KTtcblx0XHRcdHRoaXMuX3BvcHVwSGFuZGxlcnNBZGRlZCA9IHRydWU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0dW5iaW5kUG9wdXA6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fcG9wdXApIHtcblx0XHRcdHRoaXMub24oe1xuXHRcdFx0ICAgIGNsaWNrOiB0aGlzLl9vcGVuUG9wdXAsXG5cdFx0XHQgICAgcmVtb3ZlOiB0aGlzLmNsb3NlUG9wdXAsXG5cdFx0XHQgICAgbW92ZTogdGhpcy5fbW92ZVBvcHVwXG5cdFx0XHR9KTtcblx0XHRcdHRoaXMuX3BvcHVwSGFuZGxlcnNBZGRlZCA9IGZhbHNlO1xuXHRcdFx0dGhpcy5fcG9wdXAgPSBudWxsO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRvcGVuUG9wdXA6IGZ1bmN0aW9uIChsYXRsbmcpIHtcblx0XHRpZiAodGhpcy5fcG9wdXAgJiYgdGhpcy5fbWFwKSB7XG5cdFx0XHR0aGlzLl9tYXAub3BlblBvcHVwKHRoaXMuX3BvcHVwLCBsYXRsbmcgfHwgdGhpcy5fbGF0bG5nIHx8IHRoaXMuZ2V0Q2VudGVyKCkpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRjbG9zZVBvcHVwOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX3BvcHVwKSB7XG5cdFx0XHR0aGlzLl9wb3B1cC5fY2xvc2UoKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0dG9nZ2xlUG9wdXA6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fcG9wdXApIHtcblx0XHRcdGlmICh0aGlzLl9wb3B1cC5fbWFwKSB7XG5cdFx0XHRcdHRoaXMuY2xvc2VQb3B1cCgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5vcGVuUG9wdXAoKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0c2V0UG9wdXBDb250ZW50OiBmdW5jdGlvbiAoY29udGVudCkge1xuXHRcdGlmICh0aGlzLl9wb3B1cCkge1xuXHRcdFx0dGhpcy5fcG9wdXAuc2V0Q29udGVudChjb250ZW50KTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Z2V0UG9wdXA6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fcG9wdXA7XG5cdH0sXG5cblx0X29wZW5Qb3B1cDogZnVuY3Rpb24gKGUpIHtcblx0XHR0aGlzLl9tYXAub3BlblBvcHVwKHRoaXMuX3BvcHVwLCBlLmxhdGxuZyk7XG5cdH0sXG5cblx0X21vdmVQb3B1cDogZnVuY3Rpb24gKGUpIHtcblx0XHR0aGlzLl9wb3B1cC5zZXRMYXRMbmcoZS5sYXRsbmcpO1xuXHR9XG59KTtcblxuLypcclxuICogUG9wdXAgZXh0ZW5zaW9uIHRvIEwuTWFya2VyLCBhZGRpbmcgcG9wdXAtcmVsYXRlZCBtZXRob2RzLlxyXG4gKi9cclxuXHJcbkwuTWFya2VyLmluY2x1ZGUoe1xyXG5cdGJpbmRQb3B1cDogZnVuY3Rpb24gKGNvbnRlbnQsIG9wdGlvbnMpIHtcclxuXHRcdHZhciBhbmNob3IgPSBMLnBvaW50KHRoaXMub3B0aW9ucy5pY29uLm9wdGlvbnMucG9wdXBBbmNob3IgfHwgWzAsIDBdKVxyXG5cdFx0XHQuYWRkKEwuUG9wdXAucHJvdG90eXBlLm9wdGlvbnMub2Zmc2V0KTtcclxuXHJcblx0XHRvcHRpb25zID0gTC5leHRlbmQoe29mZnNldDogYW5jaG9yfSwgb3B0aW9ucyk7XHJcblxyXG5cdFx0cmV0dXJuIEwuTGF5ZXIucHJvdG90eXBlLmJpbmRQb3B1cC5jYWxsKHRoaXMsIGNvbnRlbnQsIG9wdGlvbnMpO1xyXG5cdH0sXHJcblxyXG5cdF9vcGVuUG9wdXA6IEwuTGF5ZXIucHJvdG90eXBlLnRvZ2dsZVBvcHVwXHJcbn0pO1xyXG5cbi8qXHJcbiAqIEwuTGF5ZXJHcm91cCBpcyBhIGNsYXNzIHRvIGNvbWJpbmUgc2V2ZXJhbCBsYXllcnMgaW50byBvbmUgc28gdGhhdFxyXG4gKiB5b3UgY2FuIG1hbmlwdWxhdGUgdGhlIGdyb3VwIChlLmcuIGFkZC9yZW1vdmUgaXQpIGFzIG9uZSBsYXllci5cclxuICovXHJcblxyXG5MLkxheWVyR3JvdXAgPSBMLkxheWVyLmV4dGVuZCh7XHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChsYXllcnMpIHtcclxuXHRcdHRoaXMuX2xheWVycyA9IHt9O1xyXG5cclxuXHRcdHZhciBpLCBsZW47XHJcblxyXG5cdFx0aWYgKGxheWVycykge1xyXG5cdFx0XHRmb3IgKGkgPSAwLCBsZW4gPSBsYXllcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0XHR0aGlzLmFkZExheWVyKGxheWVyc1tpXSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRhZGRMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHR2YXIgaWQgPSB0aGlzLmdldExheWVySWQobGF5ZXIpO1xyXG5cclxuXHRcdHRoaXMuX2xheWVyc1tpZF0gPSBsYXllcjtcclxuXHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdHRoaXMuX21hcC5hZGRMYXllcihsYXllcik7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0cmVtb3ZlTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0dmFyIGlkID0gbGF5ZXIgaW4gdGhpcy5fbGF5ZXJzID8gbGF5ZXIgOiB0aGlzLmdldExheWVySWQobGF5ZXIpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9tYXAgJiYgdGhpcy5fbGF5ZXJzW2lkXSkge1xyXG5cdFx0XHR0aGlzLl9tYXAucmVtb3ZlTGF5ZXIodGhpcy5fbGF5ZXJzW2lkXSk7XHJcblx0XHR9XHJcblxyXG5cdFx0ZGVsZXRlIHRoaXMuX2xheWVyc1tpZF07XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0aGFzTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0cmV0dXJuICEhbGF5ZXIgJiYgKGxheWVyIGluIHRoaXMuX2xheWVycyB8fCB0aGlzLmdldExheWVySWQobGF5ZXIpIGluIHRoaXMuX2xheWVycyk7XHJcblx0fSxcclxuXHJcblx0Y2xlYXJMYXllcnM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGZvciAodmFyIGkgaW4gdGhpcy5fbGF5ZXJzKSB7XHJcblx0XHRcdHRoaXMucmVtb3ZlTGF5ZXIodGhpcy5fbGF5ZXJzW2ldKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdGludm9rZTogZnVuY3Rpb24gKG1ldGhvZE5hbWUpIHtcclxuXHRcdHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSxcclxuXHRcdCAgICBpLCBsYXllcjtcclxuXHJcblx0XHRmb3IgKGkgaW4gdGhpcy5fbGF5ZXJzKSB7XHJcblx0XHRcdGxheWVyID0gdGhpcy5fbGF5ZXJzW2ldO1xyXG5cclxuXHRcdFx0aWYgKGxheWVyW21ldGhvZE5hbWVdKSB7XHJcblx0XHRcdFx0bGF5ZXJbbWV0aG9kTmFtZV0uYXBwbHkobGF5ZXIsIGFyZ3MpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdGZvciAodmFyIGkgaW4gdGhpcy5fbGF5ZXJzKSB7XHJcblx0XHRcdG1hcC5hZGRMYXllcih0aGlzLl9sYXllcnNbaV0pO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHRmb3IgKHZhciBpIGluIHRoaXMuX2xheWVycykge1xyXG5cdFx0XHRtYXAucmVtb3ZlTGF5ZXIodGhpcy5fbGF5ZXJzW2ldKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRlYWNoTGF5ZXI6IGZ1bmN0aW9uIChtZXRob2QsIGNvbnRleHQpIHtcclxuXHRcdGZvciAodmFyIGkgaW4gdGhpcy5fbGF5ZXJzKSB7XHJcblx0XHRcdG1ldGhvZC5jYWxsKGNvbnRleHQsIHRoaXMuX2xheWVyc1tpXSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRnZXRMYXllcjogZnVuY3Rpb24gKGlkKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fbGF5ZXJzW2lkXTtcclxuXHR9LFxyXG5cclxuXHRnZXRMYXllcnM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBsYXllcnMgPSBbXTtcclxuXHJcblx0XHRmb3IgKHZhciBpIGluIHRoaXMuX2xheWVycykge1xyXG5cdFx0XHRsYXllcnMucHVzaCh0aGlzLl9sYXllcnNbaV0pO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGxheWVycztcclxuXHR9LFxyXG5cclxuXHRzZXRaSW5kZXg6IGZ1bmN0aW9uICh6SW5kZXgpIHtcclxuXHRcdHJldHVybiB0aGlzLmludm9rZSgnc2V0WkluZGV4JywgekluZGV4KTtcclxuXHR9LFxyXG5cclxuXHRnZXRMYXllcklkOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdHJldHVybiBMLnN0YW1wKGxheWVyKTtcclxuXHR9XHJcbn0pO1xyXG5cclxuTC5sYXllckdyb3VwID0gZnVuY3Rpb24gKGxheWVycykge1xyXG5cdHJldHVybiBuZXcgTC5MYXllckdyb3VwKGxheWVycyk7XHJcbn07XHJcblxuLypcclxuICogTC5GZWF0dXJlR3JvdXAgZXh0ZW5kcyBMLkxheWVyR3JvdXAgYnkgaW50cm9kdWNpbmcgbW91c2UgZXZlbnRzIGFuZCBhZGRpdGlvbmFsIG1ldGhvZHNcclxuICogc2hhcmVkIGJldHdlZW4gYSBncm91cCBvZiBpbnRlcmFjdGl2ZSBsYXllcnMgKGxpa2UgdmVjdG9ycyBvciBtYXJrZXJzKS5cclxuICovXHJcblxyXG5MLkZlYXR1cmVHcm91cCA9IEwuTGF5ZXJHcm91cC5leHRlbmQoe1xyXG5cclxuXHRhZGRMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHRpZiAodGhpcy5oYXNMYXllcihsYXllcikpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblxyXG5cdFx0bGF5ZXIuYWRkRXZlbnRQYXJlbnQodGhpcyk7XHJcblxyXG5cdFx0TC5MYXllckdyb3VwLnByb3RvdHlwZS5hZGRMYXllci5jYWxsKHRoaXMsIGxheWVyKTtcclxuXHJcblx0XHRpZiAodGhpcy5fcG9wdXBDb250ZW50ICYmIGxheWVyLmJpbmRQb3B1cCkge1xyXG5cdFx0XHRsYXllci5iaW5kUG9wdXAodGhpcy5fcG9wdXBDb250ZW50LCB0aGlzLl9wb3B1cE9wdGlvbnMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzLmZpcmUoJ2xheWVyYWRkJywge2xheWVyOiBsYXllcn0pO1xyXG5cdH0sXHJcblxyXG5cdHJlbW92ZUxheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdGlmICghdGhpcy5oYXNMYXllcihsYXllcikpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblx0XHRpZiAobGF5ZXIgaW4gdGhpcy5fbGF5ZXJzKSB7XHJcblx0XHRcdGxheWVyID0gdGhpcy5fbGF5ZXJzW2xheWVyXTtcclxuXHRcdH1cclxuXHJcblx0XHRsYXllci5yZW1vdmVFdmVudFBhcmVudCh0aGlzKTtcclxuXHJcblx0XHRMLkxheWVyR3JvdXAucHJvdG90eXBlLnJlbW92ZUxheWVyLmNhbGwodGhpcywgbGF5ZXIpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9wb3B1cENvbnRlbnQpIHtcclxuXHRcdFx0dGhpcy5pbnZva2UoJ3VuYmluZFBvcHVwJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuZmlyZSgnbGF5ZXJyZW1vdmUnLCB7bGF5ZXI6IGxheWVyfSk7XHJcblx0fSxcclxuXHJcblx0YmluZFBvcHVwOiBmdW5jdGlvbiAoY29udGVudCwgb3B0aW9ucykge1xyXG5cdFx0dGhpcy5fcG9wdXBDb250ZW50ID0gY29udGVudDtcclxuXHRcdHRoaXMuX3BvcHVwT3B0aW9ucyA9IG9wdGlvbnM7XHJcblx0XHRyZXR1cm4gdGhpcy5pbnZva2UoJ2JpbmRQb3B1cCcsIGNvbnRlbnQsIG9wdGlvbnMpO1xyXG5cdH0sXHJcblxyXG5cdG9wZW5Qb3B1cDogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0Ly8gb3BlbiBwb3B1cCBvbiB0aGUgZmlyc3QgbGF5ZXJcclxuXHRcdGZvciAodmFyIGlkIGluIHRoaXMuX2xheWVycykge1xyXG5cdFx0XHR0aGlzLl9sYXllcnNbaWRdLm9wZW5Qb3B1cChsYXRsbmcpO1xyXG5cdFx0XHRicmVhaztcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdHNldFN0eWxlOiBmdW5jdGlvbiAoc3R5bGUpIHtcclxuXHRcdHJldHVybiB0aGlzLmludm9rZSgnc2V0U3R5bGUnLCBzdHlsZSk7XHJcblx0fSxcclxuXHJcblx0YnJpbmdUb0Zyb250OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5pbnZva2UoJ2JyaW5nVG9Gcm9udCcpO1xyXG5cdH0sXHJcblxyXG5cdGJyaW5nVG9CYWNrOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5pbnZva2UoJ2JyaW5nVG9CYWNrJyk7XHJcblx0fSxcclxuXHJcblx0Z2V0Qm91bmRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgYm91bmRzID0gbmV3IEwuTGF0TG5nQm91bmRzKCk7XHJcblxyXG5cdFx0dGhpcy5lYWNoTGF5ZXIoZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHRcdGJvdW5kcy5leHRlbmQobGF5ZXIuZ2V0Qm91bmRzID8gbGF5ZXIuZ2V0Qm91bmRzKCkgOiBsYXllci5nZXRMYXRMbmcoKSk7XHJcblx0XHR9KTtcclxuXHJcblx0XHRyZXR1cm4gYm91bmRzO1xyXG5cdH1cclxufSk7XHJcblxyXG5MLmZlYXR1cmVHcm91cCA9IGZ1bmN0aW9uIChsYXllcnMpIHtcclxuXHRyZXR1cm4gbmV3IEwuRmVhdHVyZUdyb3VwKGxheWVycyk7XHJcbn07XHJcblxuLypcbiAqIEwuUmVuZGVyZXIgaXMgYSBiYXNlIGNsYXNzIGZvciByZW5kZXJlciBpbXBsZW1lbnRhdGlvbnMgKFNWRywgQ2FudmFzKTtcbiAqIGhhbmRsZXMgcmVuZGVyZXIgY29udGFpbmVyLCBib3VuZHMgYW5kIHpvb20gYW5pbWF0aW9uLlxuICovXG5cbkwuUmVuZGVyZXIgPSBMLkxheWVyLmV4dGVuZCh7XG5cblx0b3B0aW9uczoge1xuXHRcdC8vIGhvdyBtdWNoIHRvIGV4dGVuZCB0aGUgY2xpcCBhcmVhIGFyb3VuZCB0aGUgbWFwIHZpZXcgKHJlbGF0aXZlIHRvIGl0cyBzaXplKVxuXHRcdC8vIGUuZy4gMC4xIHdvdWxkIGJlIDEwJSBvZiBtYXAgdmlldyBpbiBlYWNoIGRpcmVjdGlvbjsgZGVmYXVsdHMgdG8gY2xpcCB3aXRoIHRoZSBtYXAgdmlld1xuXHRcdHBhZGRpbmc6IDBcblx0fSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xuXHRcdEwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcblx0XHRMLnN0YW1wKHRoaXMpO1xuXHR9LFxuXG5cdG9uQWRkOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9jb250YWluZXIpIHtcblx0XHRcdHRoaXMuX2luaXRDb250YWluZXIoKTsgLy8gZGVmaW5lZCBieSByZW5kZXJlciBpbXBsZW1lbnRhdGlvbnNcblxuXHRcdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xuXHRcdFx0XHRMLkRvbVV0aWwuYWRkQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC16b29tLWFuaW1hdGVkJyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5nZXRQYW5lKCkuYXBwZW5kQ2hpbGQodGhpcy5fY29udGFpbmVyKTtcblx0XHR0aGlzLl91cGRhdGUoKTtcblx0fSxcblxuXHRvblJlbW92ZTogZnVuY3Rpb24gKCkge1xuXHRcdEwuRG9tVXRpbC5yZW1vdmUodGhpcy5fY29udGFpbmVyKTtcblx0fSxcblxuXHRnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgZXZlbnRzID0ge1xuXHRcdFx0bW92ZWVuZDogdGhpcy5fdXBkYXRlXG5cdFx0fTtcblx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XG5cdFx0XHRldmVudHMuem9vbWFuaW0gPSB0aGlzLl9hbmltYXRlWm9vbTtcblx0XHR9XG5cdFx0cmV0dXJuIGV2ZW50cztcblx0fSxcblxuXHRfYW5pbWF0ZVpvb206IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIG9yaWdpbiA9IGUub3JpZ2luLnN1YnRyYWN0KHRoaXMuX21hcC5fZ2V0Q2VudGVyTGF5ZXJQb2ludCgpKSxcblx0XHQgICAgb2Zmc2V0ID0gdGhpcy5fYm91bmRzLm1pbi5hZGQob3JpZ2luLm11bHRpcGx5QnkoMSAtIGUuc2NhbGUpKTtcblxuXHRcdEwuRG9tVXRpbC5zZXRUcmFuc2Zvcm0odGhpcy5fY29udGFpbmVyLCBvZmZzZXQsIGUuc2NhbGUpO1xuXHR9LFxuXG5cdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyB1cGRhdGUgcGl4ZWwgYm91bmRzIG9mIHJlbmRlcmVyIGNvbnRhaW5lciAoZm9yIHBvc2l0aW9uaW5nL3NpemluZy9jbGlwcGluZyBsYXRlcilcblx0XHR2YXIgcCA9IHRoaXMub3B0aW9ucy5wYWRkaW5nLFxuXHRcdCAgICBzaXplID0gdGhpcy5fbWFwLmdldFNpemUoKSxcblx0XHQgICAgbWluID0gdGhpcy5fbWFwLmNvbnRhaW5lclBvaW50VG9MYXllclBvaW50KHNpemUubXVsdGlwbHlCeSgtcCkpLnJvdW5kKCk7XG5cblx0XHR0aGlzLl9ib3VuZHMgPSBuZXcgTC5Cb3VuZHMobWluLCBtaW4uYWRkKHNpemUubXVsdGlwbHlCeSgxICsgcCAqIDIpKS5yb3VuZCgpKTtcblx0fVxufSk7XG5cblxuTC5NYXAuaW5jbHVkZSh7XG5cdC8vIHVzZWQgYnkgZWFjaCB2ZWN0b3IgbGF5ZXIgdG8gZGVjaWRlIHdoaWNoIHJlbmRlcmVyIHRvIHVzZVxuXHRnZXRSZW5kZXJlcjogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIHJlbmRlcmVyID0gbGF5ZXIub3B0aW9ucy5yZW5kZXJlciB8fCB0aGlzLm9wdGlvbnMucmVuZGVyZXIgfHwgdGhpcy5fcmVuZGVyZXI7XG5cblx0XHRpZiAoIXJlbmRlcmVyKSB7XG5cdFx0XHRyZW5kZXJlciA9IHRoaXMuX3JlbmRlcmVyID0gKEwuU1ZHICYmIEwuc3ZnKCkpIHx8IChMLkNhbnZhcyAmJiBMLmNhbnZhcygpKTtcblx0XHR9XG5cblx0XHRpZiAoIXRoaXMuaGFzTGF5ZXIocmVuZGVyZXIpKSB7XG5cdFx0XHR0aGlzLmFkZExheWVyKHJlbmRlcmVyKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlbmRlcmVyO1xuXHR9XG59KTtcblxuLypcbiAqIEwuUGF0aCBpcyB0aGUgYmFzZSBjbGFzcyBmb3IgYWxsIExlYWZsZXQgdmVjdG9yIGxheWVycyBsaWtlIHBvbHlnb25zIGFuZCBjaXJjbGVzLlxuICovXG5cbkwuUGF0aCA9IEwuTGF5ZXIuZXh0ZW5kKHtcblxuXHRvcHRpb25zOiB7XG5cdFx0c3Ryb2tlOiB0cnVlLFxuXHRcdGNvbG9yOiAnIzMzODhmZicsXG5cdFx0d2VpZ2h0OiAzLFxuXHRcdG9wYWNpdHk6IDEsXG5cdFx0bGluZUNhcDogJ3JvdW5kJyxcblx0XHRsaW5lSm9pbjogJ3JvdW5kJyxcblx0XHQvLyBkYXNoQXJyYXk6IG51bGxcblx0XHQvLyBkYXNoT2Zmc2V0OiBudWxsXG5cblx0XHQvLyBmaWxsOiBmYWxzZVxuXHRcdC8vIGZpbGxDb2xvcjogc2FtZSBhcyBjb2xvciBieSBkZWZhdWx0XG5cdFx0ZmlsbE9wYWNpdHk6IDAuMixcblxuXHRcdC8vIGNsYXNzTmFtZTogJydcblx0XHRjbGlja2FibGU6IHRydWVcblx0fSxcblxuXHRvbkFkZDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3JlbmRlcmVyID0gdGhpcy5fbWFwLmdldFJlbmRlcmVyKHRoaXMpO1xuXHRcdHRoaXMuX3JlbmRlcmVyLl9pbml0UGF0aCh0aGlzKTtcblxuXHRcdC8vIGRlZmluZWQgaW4gY2hpbGRyZW4gY2xhc3Nlc1xuXHRcdHRoaXMuX3Byb2plY3QoKTtcblx0XHR0aGlzLl91cGRhdGUoKTtcblxuXHRcdHRoaXMuX3JlbmRlcmVyLl9hZGRQYXRoKHRoaXMpO1xuXHR9LFxuXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fcmVuZGVyZXIuX3JlbW92ZVBhdGgodGhpcyk7XG5cdH0sXG5cblx0Z2V0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHZpZXdyZXNldDogdGhpcy5fcHJvamVjdCxcblx0XHRcdG1vdmVlbmQ6IHRoaXMuX3VwZGF0ZVxuXHRcdH07XG5cdH0sXG5cblx0cmVkcmF3OiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX21hcCkge1xuXHRcdFx0dGhpcy5fcmVuZGVyZXIuX3VwZGF0ZVBhdGgodGhpcyk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHNldFN0eWxlOiBmdW5jdGlvbiAoc3R5bGUpIHtcblx0XHRMLnNldE9wdGlvbnModGhpcywgc3R5bGUpO1xuXHRcdGlmICh0aGlzLl9yZW5kZXJlcikge1xuXHRcdFx0dGhpcy5fcmVuZGVyZXIuX3VwZGF0ZVN0eWxlKHRoaXMpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRicmluZ1RvRnJvbnQ6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9yZW5kZXJlci5fYnJpbmdUb0Zyb250KHRoaXMpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGJyaW5nVG9CYWNrOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fcmVuZGVyZXIuX2JyaW5nVG9CYWNrKHRoaXMpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdF9maXJlTW91c2VFdmVudDogZnVuY3Rpb24gKGUsIHR5cGUpIHtcblx0XHR0aGlzLl9tYXAuX2ZpcmVNb3VzZUV2ZW50KHRoaXMsIGUsIHR5cGUsIHRydWUpO1xuXHR9LFxuXG5cdF9jbGlja1RvbGVyYW5jZTogZnVuY3Rpb24gKCkge1xuXHRcdC8vIHVzZWQgd2hlbiBkb2luZyBoaXQgZGV0ZWN0aW9uIGZvciBDYW52YXMgbGF5ZXJzXG5cdFx0cmV0dXJuICh0aGlzLm9wdGlvbnMuc3Ryb2tlID8gdGhpcy5vcHRpb25zLndlaWdodCAvIDIgOiAwKSArIChMLkJyb3dzZXIudG91Y2ggPyAxMCA6IDApO1xuXHR9XG59KTtcblxuLypcclxuICogTC5MaW5lVXRpbCBjb250YWlucyBkaWZmZXJlbnQgdXRpbGl0eSBmdW5jdGlvbnMgZm9yIGxpbmUgc2VnbWVudHNcclxuICogYW5kIHBvbHlsaW5lcyAoY2xpcHBpbmcsIHNpbXBsaWZpY2F0aW9uLCBkaXN0YW5jZXMsIGV0Yy4pXHJcbiAqL1xyXG5cclxuLypqc2hpbnQgYml0d2lzZTpmYWxzZSAqLyAvLyBhbGxvdyBiaXR3aXNlIG9wZXJhdGlvbnMgZm9yIHRoaXMgZmlsZVxyXG5cclxuTC5MaW5lVXRpbCA9IHtcclxuXHJcblx0Ly8gU2ltcGxpZnkgcG9seWxpbmUgd2l0aCB2ZXJ0ZXggcmVkdWN0aW9uIGFuZCBEb3VnbGFzLVBldWNrZXIgc2ltcGxpZmljYXRpb24uXHJcblx0Ly8gSW1wcm92ZXMgcmVuZGVyaW5nIHBlcmZvcm1hbmNlIGRyYW1hdGljYWxseSBieSBsZXNzZW5pbmcgdGhlIG51bWJlciBvZiBwb2ludHMgdG8gZHJhdy5cclxuXHJcblx0c2ltcGxpZnk6IGZ1bmN0aW9uICgvKlBvaW50W10qLyBwb2ludHMsIC8qTnVtYmVyKi8gdG9sZXJhbmNlKSB7XHJcblx0XHRpZiAoIXRvbGVyYW5jZSB8fCAhcG9pbnRzLmxlbmd0aCkge1xyXG5cdFx0XHRyZXR1cm4gcG9pbnRzLnNsaWNlKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHNxVG9sZXJhbmNlID0gdG9sZXJhbmNlICogdG9sZXJhbmNlO1xyXG5cclxuXHRcdC8vIHN0YWdlIDE6IHZlcnRleCByZWR1Y3Rpb25cclxuXHRcdHBvaW50cyA9IHRoaXMuX3JlZHVjZVBvaW50cyhwb2ludHMsIHNxVG9sZXJhbmNlKTtcclxuXHJcblx0XHQvLyBzdGFnZSAyOiBEb3VnbGFzLVBldWNrZXIgc2ltcGxpZmljYXRpb25cclxuXHRcdHBvaW50cyA9IHRoaXMuX3NpbXBsaWZ5RFAocG9pbnRzLCBzcVRvbGVyYW5jZSk7XHJcblxyXG5cdFx0cmV0dXJuIHBvaW50cztcclxuXHR9LFxyXG5cclxuXHQvLyBkaXN0YW5jZSBmcm9tIGEgcG9pbnQgdG8gYSBzZWdtZW50IGJldHdlZW4gdHdvIHBvaW50c1xyXG5cdHBvaW50VG9TZWdtZW50RGlzdGFuY2U6ICBmdW5jdGlvbiAoLypQb2ludCovIHAsIC8qUG9pbnQqLyBwMSwgLypQb2ludCovIHAyKSB7XHJcblx0XHRyZXR1cm4gTWF0aC5zcXJ0KHRoaXMuX3NxQ2xvc2VzdFBvaW50T25TZWdtZW50KHAsIHAxLCBwMiwgdHJ1ZSkpO1xyXG5cdH0sXHJcblxyXG5cdGNsb3Nlc3RQb2ludE9uU2VnbWVudDogZnVuY3Rpb24gKC8qUG9pbnQqLyBwLCAvKlBvaW50Ki8gcDEsIC8qUG9pbnQqLyBwMikge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3NxQ2xvc2VzdFBvaW50T25TZWdtZW50KHAsIHAxLCBwMik7XHJcblx0fSxcclxuXHJcblx0Ly8gRG91Z2xhcy1QZXVja2VyIHNpbXBsaWZpY2F0aW9uLCBzZWUgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Eb3VnbGFzLVBldWNrZXJfYWxnb3JpdGhtXHJcblx0X3NpbXBsaWZ5RFA6IGZ1bmN0aW9uIChwb2ludHMsIHNxVG9sZXJhbmNlKSB7XHJcblxyXG5cdFx0dmFyIGxlbiA9IHBvaW50cy5sZW5ndGgsXHJcblx0XHQgICAgQXJyYXlDb25zdHJ1Y3RvciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSB1bmRlZmluZWQgKyAnJyA/IFVpbnQ4QXJyYXkgOiBBcnJheSxcclxuXHRcdCAgICBtYXJrZXJzID0gbmV3IEFycmF5Q29uc3RydWN0b3IobGVuKTtcclxuXHJcblx0XHRtYXJrZXJzWzBdID0gbWFya2Vyc1tsZW4gLSAxXSA9IDE7XHJcblxyXG5cdFx0dGhpcy5fc2ltcGxpZnlEUFN0ZXAocG9pbnRzLCBtYXJrZXJzLCBzcVRvbGVyYW5jZSwgMCwgbGVuIC0gMSk7XHJcblxyXG5cdFx0dmFyIGksXHJcblx0XHQgICAgbmV3UG9pbnRzID0gW107XHJcblxyXG5cdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdGlmIChtYXJrZXJzW2ldKSB7XHJcblx0XHRcdFx0bmV3UG9pbnRzLnB1c2gocG9pbnRzW2ldKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBuZXdQb2ludHM7XHJcblx0fSxcclxuXHJcblx0X3NpbXBsaWZ5RFBTdGVwOiBmdW5jdGlvbiAocG9pbnRzLCBtYXJrZXJzLCBzcVRvbGVyYW5jZSwgZmlyc3QsIGxhc3QpIHtcclxuXHJcblx0XHR2YXIgbWF4U3FEaXN0ID0gMCxcclxuXHRcdCAgICBpbmRleCwgaSwgc3FEaXN0O1xyXG5cclxuXHRcdGZvciAoaSA9IGZpcnN0ICsgMTsgaSA8PSBsYXN0IC0gMTsgaSsrKSB7XHJcblx0XHRcdHNxRGlzdCA9IHRoaXMuX3NxQ2xvc2VzdFBvaW50T25TZWdtZW50KHBvaW50c1tpXSwgcG9pbnRzW2ZpcnN0XSwgcG9pbnRzW2xhc3RdLCB0cnVlKTtcclxuXHJcblx0XHRcdGlmIChzcURpc3QgPiBtYXhTcURpc3QpIHtcclxuXHRcdFx0XHRpbmRleCA9IGk7XHJcblx0XHRcdFx0bWF4U3FEaXN0ID0gc3FEaXN0O1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKG1heFNxRGlzdCA+IHNxVG9sZXJhbmNlKSB7XHJcblx0XHRcdG1hcmtlcnNbaW5kZXhdID0gMTtcclxuXHJcblx0XHRcdHRoaXMuX3NpbXBsaWZ5RFBTdGVwKHBvaW50cywgbWFya2Vycywgc3FUb2xlcmFuY2UsIGZpcnN0LCBpbmRleCk7XHJcblx0XHRcdHRoaXMuX3NpbXBsaWZ5RFBTdGVwKHBvaW50cywgbWFya2Vycywgc3FUb2xlcmFuY2UsIGluZGV4LCBsYXN0KTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyByZWR1Y2UgcG9pbnRzIHRoYXQgYXJlIHRvbyBjbG9zZSB0byBlYWNoIG90aGVyIHRvIGEgc2luZ2xlIHBvaW50XHJcblx0X3JlZHVjZVBvaW50czogZnVuY3Rpb24gKHBvaW50cywgc3FUb2xlcmFuY2UpIHtcclxuXHRcdHZhciByZWR1Y2VkUG9pbnRzID0gW3BvaW50c1swXV07XHJcblxyXG5cdFx0Zm9yICh2YXIgaSA9IDEsIHByZXYgPSAwLCBsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0aWYgKHRoaXMuX3NxRGlzdChwb2ludHNbaV0sIHBvaW50c1twcmV2XSkgPiBzcVRvbGVyYW5jZSkge1xyXG5cdFx0XHRcdHJlZHVjZWRQb2ludHMucHVzaChwb2ludHNbaV0pO1xyXG5cdFx0XHRcdHByZXYgPSBpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRpZiAocHJldiA8IGxlbiAtIDEpIHtcclxuXHRcdFx0cmVkdWNlZFBvaW50cy5wdXNoKHBvaW50c1tsZW4gLSAxXSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gcmVkdWNlZFBvaW50cztcclxuXHR9LFxyXG5cclxuXHQvLyBDb2hlbi1TdXRoZXJsYW5kIGxpbmUgY2xpcHBpbmcgYWxnb3JpdGhtLlxyXG5cdC8vIFVzZWQgdG8gYXZvaWQgcmVuZGVyaW5nIHBhcnRzIG9mIGEgcG9seWxpbmUgdGhhdCBhcmUgbm90IGN1cnJlbnRseSB2aXNpYmxlLlxyXG5cclxuXHRjbGlwU2VnbWVudDogZnVuY3Rpb24gKGEsIGIsIGJvdW5kcywgdXNlTGFzdENvZGUpIHtcclxuXHRcdHZhciBjb2RlQSA9IHVzZUxhc3RDb2RlID8gdGhpcy5fbGFzdENvZGUgOiB0aGlzLl9nZXRCaXRDb2RlKGEsIGJvdW5kcyksXHJcblx0XHQgICAgY29kZUIgPSB0aGlzLl9nZXRCaXRDb2RlKGIsIGJvdW5kcyksXHJcblxyXG5cdFx0ICAgIGNvZGVPdXQsIHAsIG5ld0NvZGU7XHJcblxyXG5cdFx0Ly8gc2F2ZSAybmQgY29kZSB0byBhdm9pZCBjYWxjdWxhdGluZyBpdCBvbiB0aGUgbmV4dCBzZWdtZW50XHJcblx0XHR0aGlzLl9sYXN0Q29kZSA9IGNvZGVCO1xyXG5cclxuXHRcdHdoaWxlICh0cnVlKSB7XHJcblx0XHRcdC8vIGlmIGEsYiBpcyBpbnNpZGUgdGhlIGNsaXAgd2luZG93ICh0cml2aWFsIGFjY2VwdClcclxuXHRcdFx0aWYgKCEoY29kZUEgfCBjb2RlQikpIHtcclxuXHRcdFx0XHRyZXR1cm4gW2EsIGJdO1xyXG5cdFx0XHQvLyBpZiBhLGIgaXMgb3V0c2lkZSB0aGUgY2xpcCB3aW5kb3cgKHRyaXZpYWwgcmVqZWN0KVxyXG5cdFx0XHR9IGVsc2UgaWYgKGNvZGVBICYgY29kZUIpIHtcclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdC8vIG90aGVyIGNhc2VzXHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0Y29kZU91dCA9IGNvZGVBIHx8IGNvZGVCO1xyXG5cdFx0XHRcdHAgPSB0aGlzLl9nZXRFZGdlSW50ZXJzZWN0aW9uKGEsIGIsIGNvZGVPdXQsIGJvdW5kcyk7XHJcblx0XHRcdFx0bmV3Q29kZSA9IHRoaXMuX2dldEJpdENvZGUocCwgYm91bmRzKTtcclxuXHJcblx0XHRcdFx0aWYgKGNvZGVPdXQgPT09IGNvZGVBKSB7XHJcblx0XHRcdFx0XHRhID0gcDtcclxuXHRcdFx0XHRcdGNvZGVBID0gbmV3Q29kZTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0YiA9IHA7XHJcblx0XHRcdFx0XHRjb2RlQiA9IG5ld0NvZGU7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2dldEVkZ2VJbnRlcnNlY3Rpb246IGZ1bmN0aW9uIChhLCBiLCBjb2RlLCBib3VuZHMpIHtcclxuXHRcdHZhciBkeCA9IGIueCAtIGEueCxcclxuXHRcdCAgICBkeSA9IGIueSAtIGEueSxcclxuXHRcdCAgICBtaW4gPSBib3VuZHMubWluLFxyXG5cdFx0ICAgIG1heCA9IGJvdW5kcy5tYXgsXHJcblx0XHQgICAgeCwgeTtcclxuXHJcblx0XHRpZiAoY29kZSAmIDgpIHsgLy8gdG9wXHJcblx0XHRcdHggPSBhLnggKyBkeCAqIChtYXgueSAtIGEueSkgLyBkeTtcclxuXHRcdFx0eSA9IG1heC55O1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoY29kZSAmIDQpIHsgLy8gYm90dG9tXHJcblx0XHRcdHggPSBhLnggKyBkeCAqIChtaW4ueSAtIGEueSkgLyBkeTtcclxuXHRcdFx0eSA9IG1pbi55O1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoY29kZSAmIDIpIHsgLy8gcmlnaHRcclxuXHRcdFx0eCA9IG1heC54O1xyXG5cdFx0XHR5ID0gYS55ICsgZHkgKiAobWF4LnggLSBhLngpIC8gZHg7XHJcblxyXG5cdFx0fSBlbHNlIGlmIChjb2RlICYgMSkgeyAvLyBsZWZ0XHJcblx0XHRcdHggPSBtaW4ueDtcclxuXHRcdFx0eSA9IGEueSArIGR5ICogKG1pbi54IC0gYS54KSAvIGR4O1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBuZXcgTC5Qb2ludCh4LCB5LCB0cnVlKTtcclxuXHR9LFxyXG5cclxuXHRfZ2V0Qml0Q29kZTogZnVuY3Rpb24gKC8qUG9pbnQqLyBwLCBib3VuZHMpIHtcclxuXHRcdHZhciBjb2RlID0gMDtcclxuXHJcblx0XHRpZiAocC54IDwgYm91bmRzLm1pbi54KSB7IC8vIGxlZnRcclxuXHRcdFx0Y29kZSB8PSAxO1xyXG5cdFx0fSBlbHNlIGlmIChwLnggPiBib3VuZHMubWF4LngpIHsgLy8gcmlnaHRcclxuXHRcdFx0Y29kZSB8PSAyO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChwLnkgPCBib3VuZHMubWluLnkpIHsgLy8gYm90dG9tXHJcblx0XHRcdGNvZGUgfD0gNDtcclxuXHRcdH0gZWxzZSBpZiAocC55ID4gYm91bmRzLm1heC55KSB7IC8vIHRvcFxyXG5cdFx0XHRjb2RlIHw9IDg7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGNvZGU7XHJcblx0fSxcclxuXHJcblx0Ly8gc3F1YXJlIGRpc3RhbmNlICh0byBhdm9pZCB1bm5lY2Vzc2FyeSBNYXRoLnNxcnQgY2FsbHMpXHJcblx0X3NxRGlzdDogZnVuY3Rpb24gKHAxLCBwMikge1xyXG5cdFx0dmFyIGR4ID0gcDIueCAtIHAxLngsXHJcblx0XHQgICAgZHkgPSBwMi55IC0gcDEueTtcclxuXHRcdHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcclxuXHR9LFxyXG5cclxuXHQvLyByZXR1cm4gY2xvc2VzdCBwb2ludCBvbiBzZWdtZW50IG9yIGRpc3RhbmNlIHRvIHRoYXQgcG9pbnRcclxuXHRfc3FDbG9zZXN0UG9pbnRPblNlZ21lbnQ6IGZ1bmN0aW9uIChwLCBwMSwgcDIsIHNxRGlzdCkge1xyXG5cdFx0dmFyIHggPSBwMS54LFxyXG5cdFx0ICAgIHkgPSBwMS55LFxyXG5cdFx0ICAgIGR4ID0gcDIueCAtIHgsXHJcblx0XHQgICAgZHkgPSBwMi55IC0geSxcclxuXHRcdCAgICBkb3QgPSBkeCAqIGR4ICsgZHkgKiBkeSxcclxuXHRcdCAgICB0O1xyXG5cclxuXHRcdGlmIChkb3QgPiAwKSB7XHJcblx0XHRcdHQgPSAoKHAueCAtIHgpICogZHggKyAocC55IC0geSkgKiBkeSkgLyBkb3Q7XHJcblxyXG5cdFx0XHRpZiAodCA+IDEpIHtcclxuXHRcdFx0XHR4ID0gcDIueDtcclxuXHRcdFx0XHR5ID0gcDIueTtcclxuXHRcdFx0fSBlbHNlIGlmICh0ID4gMCkge1xyXG5cdFx0XHRcdHggKz0gZHggKiB0O1xyXG5cdFx0XHRcdHkgKz0gZHkgKiB0O1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0ZHggPSBwLnggLSB4O1xyXG5cdFx0ZHkgPSBwLnkgLSB5O1xyXG5cclxuXHRcdHJldHVybiBzcURpc3QgPyBkeCAqIGR4ICsgZHkgKiBkeSA6IG5ldyBMLlBvaW50KHgsIHkpO1xyXG5cdH1cclxufTtcclxuXG4vKlxuICogTC5Qb2x5bGluZSBpbXBsZW1lbnRzIHBvbHlsaW5lIHZlY3RvciBsYXllciAoYSBzZXQgb2YgcG9pbnRzIGNvbm5lY3RlZCB3aXRoIGxpbmVzKVxuICovXG5cbkwuUG9seWxpbmUgPSBMLlBhdGguZXh0ZW5kKHtcblxuXHRvcHRpb25zOiB7XG5cdFx0Ly8gaG93IG11Y2ggdG8gc2ltcGxpZnkgdGhlIHBvbHlsaW5lIG9uIGVhY2ggem9vbSBsZXZlbFxuXHRcdC8vIG1vcmUgPSBiZXR0ZXIgcGVyZm9ybWFuY2UgYW5kIHNtb290aGVyIGxvb2ssIGxlc3MgPSBtb3JlIGFjY3VyYXRlXG5cdFx0c21vb3RoRmFjdG9yOiAxLjBcblx0XHQvLyBub0NsaXA6IGZhbHNlXG5cdH0sXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGxhdGxuZ3MsIG9wdGlvbnMpIHtcblx0XHRMLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG5cdFx0dGhpcy5fc2V0TGF0TG5ncyhsYXRsbmdzKTtcblx0fSxcblxuXHRnZXRMYXRMbmdzOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gVE9ETyByaW5nc1xuXHRcdHJldHVybiB0aGlzLl9sYXRsbmdzO1xuXHR9LFxuXG5cdHNldExhdExuZ3M6IGZ1bmN0aW9uIChsYXRsbmdzKSB7XG5cdFx0dGhpcy5fc2V0TGF0TG5ncyhsYXRsbmdzKTtcblx0XHRyZXR1cm4gdGhpcy5yZWRyYXcoKTtcblx0fSxcblxuXHRhZGRMYXRMbmc6IGZ1bmN0aW9uIChsYXRsbmcpIHtcblx0XHQvLyBUT0RPIHJpbmdzXG5cdFx0bGF0bG5nID0gTC5sYXRMbmcobGF0bG5nKTtcblx0XHR0aGlzLl9sYXRsbmdzLnB1c2gobGF0bG5nKTtcblx0XHR0aGlzLl9ib3VuZHMuZXh0ZW5kKGxhdGxuZyk7XG5cdFx0cmV0dXJuIHRoaXMucmVkcmF3KCk7XG5cdH0sXG5cblx0c3BsaWNlTGF0TG5nczogZnVuY3Rpb24gKCkge1xuXHRcdC8vIFRPRE8gcmluZ3Ncblx0XHR2YXIgcmVtb3ZlZCA9IFtdLnNwbGljZS5hcHBseSh0aGlzLl9sYXRsbmdzLCBhcmd1bWVudHMpO1xuXHRcdHRoaXMuX3NldExhdExuZ3ModGhpcy5fbGF0bG5ncyk7XG5cdFx0dGhpcy5yZWRyYXcoKTtcblx0XHRyZXR1cm4gcmVtb3ZlZDtcblx0fSxcblxuXHRjbG9zZXN0TGF5ZXJQb2ludDogZnVuY3Rpb24gKHApIHtcblx0XHR2YXIgbWluRGlzdGFuY2UgPSBJbmZpbml0eSxcblx0XHQgICAgbWluUG9pbnQgPSBudWxsLFxuXHRcdCAgICBjbG9zZXN0ID0gTC5MaW5lVXRpbC5fc3FDbG9zZXN0UG9pbnRPblNlZ21lbnQsXG5cdFx0ICAgIHAxLCBwMjtcblxuXHRcdGZvciAodmFyIGogPSAwLCBqTGVuID0gdGhpcy5fcGFydHMubGVuZ3RoOyBqIDwgakxlbjsgaisrKSB7XG5cdFx0XHR2YXIgcG9pbnRzID0gdGhpcy5fcGFydHNbal07XG5cblx0XHRcdGZvciAodmFyIGkgPSAxLCBsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0cDEgPSBwb2ludHNbaSAtIDFdO1xuXHRcdFx0XHRwMiA9IHBvaW50c1tpXTtcblxuXHRcdFx0XHR2YXIgc3FEaXN0ID0gY2xvc2VzdChwLCBwMSwgcDIsIHRydWUpO1xuXG5cdFx0XHRcdGlmIChzcURpc3QgPCBtaW5EaXN0YW5jZSkge1xuXHRcdFx0XHRcdG1pbkRpc3RhbmNlID0gc3FEaXN0O1xuXHRcdFx0XHRcdG1pblBvaW50ID0gY2xvc2VzdChwLCBwMSwgcDIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChtaW5Qb2ludCkge1xuXHRcdFx0bWluUG9pbnQuZGlzdGFuY2UgPSBNYXRoLnNxcnQobWluRGlzdGFuY2UpO1xuXHRcdH1cblx0XHRyZXR1cm4gbWluUG9pbnQ7XG5cdH0sXG5cblx0Z2V0Q2VudGVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGksIGhhbGZEaXN0LCBzZWdEaXN0LCBkaXN0LCBwMSwgcDIsIHJhdGlvLFxuXHRcdCAgICBwb2ludHMgPSB0aGlzLl9yaW5nc1swXSxcblx0XHQgICAgbGVuID0gcG9pbnRzLmxlbmd0aDtcblxuXHRcdC8vIHBvbHlsaW5lIGNlbnRyb2lkIGFsZ29yaXRobTsgb25seSB1c2VzIHRoZSBmaXJzdCByaW5nIGlmIHRoZXJlIGFyZSBtdWx0aXBsZVxuXG5cdFx0Zm9yIChpID0gMCwgaGFsZkRpc3QgPSAwOyBpIDwgbGVuIC0gMTsgaSsrKSB7XG5cdFx0XHRoYWxmRGlzdCArPSBwb2ludHNbaV0uZGlzdGFuY2VUbyhwb2ludHNbaSArIDFdKSAvIDI7XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMCwgZGlzdCA9IDA7IGkgPCBsZW4gLSAxOyBpKyspIHtcblx0XHRcdHAxID0gcG9pbnRzW2ldO1xuXHRcdFx0cDIgPSBwb2ludHNbaSArIDFdO1xuXHRcdFx0c2VnRGlzdCA9IHAxLmRpc3RhbmNlVG8ocDIpO1xuXHRcdFx0ZGlzdCArPSBzZWdEaXN0O1xuXG5cdFx0XHRpZiAoZGlzdCA+IGhhbGZEaXN0KSB7XG5cdFx0XHRcdHJhdGlvID0gKGRpc3QgLSBoYWxmRGlzdCkgLyBzZWdEaXN0O1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fbWFwLmxheWVyUG9pbnRUb0xhdExuZyhbXG5cdFx0XHRcdFx0cDIueCAtIHJhdGlvICogKHAyLnggLSBwMS54KSxcblx0XHRcdFx0XHRwMi55IC0gcmF0aW8gKiAocDIueSAtIHAxLnkpXG5cdFx0XHRcdF0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRnZXRCb3VuZHM6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fYm91bmRzO1xuXHR9LFxuXG5cdF9zZXRMYXRMbmdzOiBmdW5jdGlvbiAobGF0bG5ncykge1xuXHRcdHRoaXMuX2JvdW5kcyA9IG5ldyBMLkxhdExuZ0JvdW5kcygpO1xuXHRcdHRoaXMuX2xhdGxuZ3MgPSB0aGlzLl9jb252ZXJ0TGF0TG5ncyhsYXRsbmdzKTtcblx0fSxcblxuXHQvLyByZWN1cnNpdmVseSBjb252ZXJ0IGxhdGxuZ3MgaW5wdXQgaW50byBhY3R1YWwgTGF0TG5nIGluc3RhbmNlczsgY2FsY3VsYXRlIGJvdW5kcyBhbG9uZyB0aGUgd2F5XG5cdF9jb252ZXJ0TGF0TG5nczogZnVuY3Rpb24gKGxhdGxuZ3MpIHtcblx0XHR2YXIgcmVzdWx0ID0gW10sXG5cdFx0ICAgIGZsYXQgPSB0aGlzLl9mbGF0KGxhdGxuZ3MpO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGxhdGxuZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGlmIChmbGF0KSB7XG5cdFx0XHRcdHJlc3VsdFtpXSA9IEwubGF0TG5nKGxhdGxuZ3NbaV0pO1xuXHRcdFx0XHR0aGlzLl9ib3VuZHMuZXh0ZW5kKHJlc3VsdFtpXSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXN1bHRbaV0gPSB0aGlzLl9jb252ZXJ0TGF0TG5ncyhsYXRsbmdzW2ldKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9LFxuXG5cdF9mbGF0OiBmdW5jdGlvbiAobGF0bG5ncykge1xuXHRcdC8vIHRydWUgaWYgaXQncyBhIGZsYXQgYXJyYXkgb2YgbGF0bG5nczsgZmFsc2UgaWYgbmVzdGVkXG5cdFx0cmV0dXJuICFMLlV0aWwuaXNBcnJheShsYXRsbmdzWzBdKSB8fCB0eXBlb2YgbGF0bG5nc1swXVswXSAhPT0gJ29iamVjdCc7XG5cdH0sXG5cblx0X3Byb2plY3Q6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9yaW5ncyA9IFtdO1xuXHRcdHRoaXMuX3Byb2plY3RMYXRsbmdzKHRoaXMuX2xhdGxuZ3MsIHRoaXMuX3JpbmdzKTtcblxuXHRcdC8vIHByb2plY3QgYm91bmRzIGFzIHdlbGwgdG8gdXNlIGxhdGVyIGZvciBDYW52YXMgaGl0IGRldGVjdGlvbi9ldGMuXG5cdFx0dmFyIHcgPSB0aGlzLl9jbGlja1RvbGVyYW5jZSgpLFxuXHRcdFx0cCA9IG5ldyBMLlBvaW50KHcsIC13KTtcblxuXHRcdGlmICh0aGlzLl9sYXRsbmdzLmxlbmd0aCkge1xuXHRcdFx0dGhpcy5fcHhCb3VuZHMgPSBuZXcgTC5Cb3VuZHMoXG5cdFx0XHRcdHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fYm91bmRzLmdldFNvdXRoV2VzdCgpKS5fc3VidHJhY3QocCksXG5cdFx0XHRcdHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fYm91bmRzLmdldE5vcnRoRWFzdCgpKS5fYWRkKHApKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gcmVjdXJzaXZlbHkgdHVybnMgbGF0bG5ncyBpbnRvIGEgc2V0IG9mIHJpbmdzIHdpdGggcHJvamVjdGVkIGNvb3JkaW5hdGVzXG5cdF9wcm9qZWN0TGF0bG5nczogZnVuY3Rpb24gKGxhdGxuZ3MsIHJlc3VsdCkge1xuXG5cdFx0dmFyIGZsYXQgPSBsYXRsbmdzWzBdIGluc3RhbmNlb2YgTC5MYXRMbmcsXG5cdFx0ICAgIGxlbiA9IGxhdGxuZ3MubGVuZ3RoLFxuXHRcdCAgICBpLCByaW5nO1xuXG5cdFx0aWYgKGZsYXQpIHtcblx0XHRcdHJpbmcgPSBbXTtcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRyaW5nW2ldID0gdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludChsYXRsbmdzW2ldKTtcblx0XHRcdH1cblx0XHRcdHJlc3VsdC5wdXNoKHJpbmcpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0dGhpcy5fcHJvamVjdExhdGxuZ3MobGF0bG5nc1tpXSwgcmVzdWx0KTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0Ly8gY2xpcCBwb2x5bGluZSBieSByZW5kZXJlciBib3VuZHMgc28gdGhhdCB3ZSBoYXZlIGxlc3MgdG8gcmVuZGVyIGZvciBwZXJmb3JtYW5jZVxuXHRfY2xpcFBvaW50czogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLm9wdGlvbnMubm9DbGlwKSB7XG5cdFx0XHR0aGlzLl9wYXJ0cyA9IHRoaXMuX3JpbmdzO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHRoaXMuX3BhcnRzID0gW107XG5cblx0XHR2YXIgcGFydHMgPSB0aGlzLl9wYXJ0cyxcblx0XHQgICAgYm91bmRzID0gdGhpcy5fcmVuZGVyZXIuX2JvdW5kcyxcblx0XHQgICAgaSwgaiwgaywgbGVuLCBsZW4yLCBzZWdtZW50LCBwb2ludHM7XG5cblx0XHRmb3IgKGkgPSAwLCBrID0gMCwgbGVuID0gdGhpcy5fcmluZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdHBvaW50cyA9IHRoaXMuX3JpbmdzW2ldO1xuXG5cdFx0XHRmb3IgKGogPSAwLCBsZW4yID0gcG9pbnRzLmxlbmd0aDsgaiA8IGxlbjIgLSAxOyBqKyspIHtcblx0XHRcdFx0c2VnbWVudCA9IEwuTGluZVV0aWwuY2xpcFNlZ21lbnQocG9pbnRzW2pdLCBwb2ludHNbaiArIDFdLCBib3VuZHMsIGopO1xuXG5cdFx0XHRcdGlmICghc2VnbWVudCkgeyBjb250aW51ZTsgfVxuXG5cdFx0XHRcdHBhcnRzW2tdID0gcGFydHNba10gfHwgW107XG5cdFx0XHRcdHBhcnRzW2tdLnB1c2goc2VnbWVudFswXSk7XG5cblx0XHRcdFx0Ly8gaWYgc2VnbWVudCBnb2VzIG91dCBvZiBzY3JlZW4sIG9yIGl0J3MgdGhlIGxhc3Qgb25lLCBpdCdzIHRoZSBlbmQgb2YgdGhlIGxpbmUgcGFydFxuXHRcdFx0XHRpZiAoKHNlZ21lbnRbMV0gIT09IHBvaW50c1tqICsgMV0pIHx8IChqID09PSBsZW4yIC0gMikpIHtcblx0XHRcdFx0XHRwYXJ0c1trXS5wdXNoKHNlZ21lbnRbMV0pO1xuXHRcdFx0XHRcdGsrKztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvLyBzaW1wbGlmeSBlYWNoIGNsaXBwZWQgcGFydCBvZiB0aGUgcG9seWxpbmUgZm9yIHBlcmZvcm1hbmNlXG5cdF9zaW1wbGlmeVBvaW50czogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBwYXJ0cyA9IHRoaXMuX3BhcnRzLFxuXHRcdFx0dG9sZXJhbmNlID0gdGhpcy5vcHRpb25zLnNtb290aEZhY3RvcjtcblxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBwYXJ0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0cGFydHNbaV0gPSBMLkxpbmVVdGlsLnNpbXBsaWZ5KHBhcnRzW2ldLCB0b2xlcmFuY2UpO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9tYXApIHsgcmV0dXJuOyB9XG5cblx0XHR0aGlzLl9jbGlwUG9pbnRzKCk7XG5cdFx0dGhpcy5fc2ltcGxpZnlQb2ludHMoKTtcblx0XHR0aGlzLl91cGRhdGVQYXRoKCk7XG5cdH0sXG5cblx0X3VwZGF0ZVBhdGg6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9yZW5kZXJlci5fdXBkYXRlUG9seSh0aGlzKTtcblx0fVxufSk7XG5cbkwucG9seWxpbmUgPSBmdW5jdGlvbiAobGF0bG5ncywgb3B0aW9ucykge1xuXHRyZXR1cm4gbmV3IEwuUG9seWxpbmUobGF0bG5ncywgb3B0aW9ucyk7XG59O1xuXG4vKlxyXG4gKiBMLlBvbHlVdGlsIGNvbnRhaW5zIHV0aWxpdHkgZnVuY3Rpb25zIGZvciBwb2x5Z29ucyAoY2xpcHBpbmcsIGV0Yy4pLlxyXG4gKi9cclxuXHJcbi8qanNoaW50IGJpdHdpc2U6ZmFsc2UgKi8gLy8gYWxsb3cgYml0d2lzZSBvcGVyYXRpb25zIGhlcmVcclxuXHJcbkwuUG9seVV0aWwgPSB7fTtcclxuXHJcbi8qXHJcbiAqIFN1dGhlcmxhbmQtSG9kZ2VtYW4gcG9seWdvbiBjbGlwcGluZyBhbGdvcml0aG0uXHJcbiAqIFVzZWQgdG8gYXZvaWQgcmVuZGVyaW5nIHBhcnRzIG9mIGEgcG9seWdvbiB0aGF0IGFyZSBub3QgY3VycmVudGx5IHZpc2libGUuXHJcbiAqL1xyXG5MLlBvbHlVdGlsLmNsaXBQb2x5Z29uID0gZnVuY3Rpb24gKHBvaW50cywgYm91bmRzKSB7XHJcblx0dmFyIGNsaXBwZWRQb2ludHMsXHJcblx0ICAgIGVkZ2VzID0gWzEsIDQsIDIsIDhdLFxyXG5cdCAgICBpLCBqLCBrLFxyXG5cdCAgICBhLCBiLFxyXG5cdCAgICBsZW4sIGVkZ2UsIHAsXHJcblx0ICAgIGx1ID0gTC5MaW5lVXRpbDtcclxuXHJcblx0Zm9yIChpID0gMCwgbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRwb2ludHNbaV0uX2NvZGUgPSBsdS5fZ2V0Qml0Q29kZShwb2ludHNbaV0sIGJvdW5kcyk7XHJcblx0fVxyXG5cclxuXHQvLyBmb3IgZWFjaCBlZGdlIChsZWZ0LCBib3R0b20sIHJpZ2h0LCB0b3ApXHJcblx0Zm9yIChrID0gMDsgayA8IDQ7IGsrKykge1xyXG5cdFx0ZWRnZSA9IGVkZ2VzW2tdO1xyXG5cdFx0Y2xpcHBlZFBvaW50cyA9IFtdO1xyXG5cclxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IHBvaW50cy5sZW5ndGgsIGogPSBsZW4gLSAxOyBpIDwgbGVuOyBqID0gaSsrKSB7XHJcblx0XHRcdGEgPSBwb2ludHNbaV07XHJcblx0XHRcdGIgPSBwb2ludHNbal07XHJcblxyXG5cdFx0XHQvLyBpZiBhIGlzIGluc2lkZSB0aGUgY2xpcCB3aW5kb3dcclxuXHRcdFx0aWYgKCEoYS5fY29kZSAmIGVkZ2UpKSB7XHJcblx0XHRcdFx0Ly8gaWYgYiBpcyBvdXRzaWRlIHRoZSBjbGlwIHdpbmRvdyAoYS0+YiBnb2VzIG91dCBvZiBzY3JlZW4pXHJcblx0XHRcdFx0aWYgKGIuX2NvZGUgJiBlZGdlKSB7XHJcblx0XHRcdFx0XHRwID0gbHUuX2dldEVkZ2VJbnRlcnNlY3Rpb24oYiwgYSwgZWRnZSwgYm91bmRzKTtcclxuXHRcdFx0XHRcdHAuX2NvZGUgPSBsdS5fZ2V0Qml0Q29kZShwLCBib3VuZHMpO1xyXG5cdFx0XHRcdFx0Y2xpcHBlZFBvaW50cy5wdXNoKHApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRjbGlwcGVkUG9pbnRzLnB1c2goYSk7XHJcblxyXG5cdFx0XHQvLyBlbHNlIGlmIGIgaXMgaW5zaWRlIHRoZSBjbGlwIHdpbmRvdyAoYS0+YiBlbnRlcnMgdGhlIHNjcmVlbilcclxuXHRcdFx0fSBlbHNlIGlmICghKGIuX2NvZGUgJiBlZGdlKSkge1xyXG5cdFx0XHRcdHAgPSBsdS5fZ2V0RWRnZUludGVyc2VjdGlvbihiLCBhLCBlZGdlLCBib3VuZHMpO1xyXG5cdFx0XHRcdHAuX2NvZGUgPSBsdS5fZ2V0Qml0Q29kZShwLCBib3VuZHMpO1xyXG5cdFx0XHRcdGNsaXBwZWRQb2ludHMucHVzaChwKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cG9pbnRzID0gY2xpcHBlZFBvaW50cztcclxuXHR9XHJcblxyXG5cdHJldHVybiBwb2ludHM7XHJcbn07XHJcblxuLypcbiAqIEwuUG9seWdvbiBpbXBsZW1lbnRzIHBvbHlnb24gdmVjdG9yIGxheWVyIChjbG9zZWQgcG9seWxpbmUgd2l0aCBhIGZpbGwgaW5zaWRlKS5cbiAqL1xuXG5MLlBvbHlnb24gPSBMLlBvbHlsaW5lLmV4dGVuZCh7XG5cblx0b3B0aW9uczoge1xuXHRcdGZpbGw6IHRydWVcblx0fSxcblxuXHRnZXRDZW50ZXI6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgaSwgaiwgbGVuLCBwMSwgcDIsIGYsIGFyZWEsIHgsIHksXG5cdFx0ICAgIHBvaW50cyA9IHRoaXMuX3JpbmdzWzBdO1xuXG5cdFx0Ly8gcG9seWdvbiBjZW50cm9pZCBhbGdvcml0aG07IG9ubHkgdXNlcyB0aGUgZmlyc3QgcmluZyBpZiB0aGVyZSBhcmUgbXVsdGlwbGVcblxuXHRcdGFyZWEgPSB4ID0geSA9IDA7XG5cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBwb2ludHMubGVuZ3RoLCBqID0gbGVuIC0gMTsgaSA8IGxlbjsgaiA9IGkrKykge1xuXHRcdFx0cDEgPSBwb2ludHNbaV07XG5cdFx0XHRwMiA9IHBvaW50c1tqXTtcblxuXHRcdFx0ZiA9IHAxLnkgKiBwMi54IC0gcDIueSAqIHAxLng7XG5cdFx0XHR4ICs9IChwMS54ICsgcDIueCkgKiBmO1xuXHRcdFx0eSArPSAocDEueSArIHAyLnkpICogZjtcblx0XHRcdGFyZWEgKz0gZiAqIDM7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuX21hcC5sYXllclBvaW50VG9MYXRMbmcoW3ggLyBhcmVhLCB5IC8gYXJlYV0pO1xuXHR9LFxuXG5cdF9jb252ZXJ0TGF0TG5nczogZnVuY3Rpb24gKGxhdGxuZ3MpIHtcblx0XHR2YXIgcmVzdWx0ID0gTC5Qb2x5bGluZS5wcm90b3R5cGUuX2NvbnZlcnRMYXRMbmdzLmNhbGwodGhpcywgbGF0bG5ncyksXG5cdFx0ICAgIGxlbiA9IHJlc3VsdC5sZW5ndGg7XG5cblx0XHQvLyByZW1vdmUgbGFzdCBwb2ludCBpZiBpdCBlcXVhbHMgZmlyc3Qgb25lXG5cdFx0aWYgKGxlbiA+PSAyICYmIHJlc3VsdFswXSBpbnN0YW5jZW9mIEwuTGF0TG5nICYmIHJlc3VsdFswXS5lcXVhbHMocmVzdWx0W2xlbiAtIDFdKSkge1xuXHRcdFx0cmVzdWx0LnBvcCgpO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9LFxuXG5cdF9jbGlwUG9pbnRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMub3B0aW9ucy5ub0NsaXApIHtcblx0XHRcdHRoaXMuX3BhcnRzID0gdGhpcy5fcmluZ3M7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gcG9seWdvbnMgbmVlZCBhIGRpZmZlcmVudCBjbGlwcGluZyBhbGdvcml0aG0gc28gd2UgcmVkZWZpbmUgdGhhdFxuXG5cdFx0dmFyIGJvdW5kcyA9IHRoaXMuX3JlbmRlcmVyLl9ib3VuZHMsXG5cdFx0ICAgIHcgPSB0aGlzLm9wdGlvbnMud2VpZ2h0LFxuXHRcdCAgICBwID0gbmV3IEwuUG9pbnQodywgdyk7XG5cblx0XHQvLyBpbmNyZWFzZSBjbGlwIHBhZGRpbmcgYnkgc3Ryb2tlIHdpZHRoIHRvIGF2b2lkIHN0cm9rZSBvbiBjbGlwIGVkZ2VzXG5cdFx0Ym91bmRzID0gbmV3IEwuQm91bmRzKGJvdW5kcy5taW4uc3VidHJhY3QocCksIGJvdW5kcy5tYXguYWRkKHApKTtcblxuXHRcdHRoaXMuX3BhcnRzID0gW107XG5cblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5fcmluZ3MubGVuZ3RoLCBjbGlwcGVkOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGNsaXBwZWQgPSBMLlBvbHlVdGlsLmNsaXBQb2x5Z29uKHRoaXMuX3JpbmdzW2ldLCBib3VuZHMpO1xuXHRcdFx0aWYgKGNsaXBwZWQubGVuZ3RoKSB7XG5cdFx0XHRcdHRoaXMuX3BhcnRzLnB1c2goY2xpcHBlZCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGVQYXRoOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fcmVuZGVyZXIuX3VwZGF0ZVBvbHkodGhpcywgdHJ1ZSk7XG5cdH1cbn0pO1xuXG5MLnBvbHlnb24gPSBmdW5jdGlvbiAobGF0bG5ncywgb3B0aW9ucykge1xuXHRyZXR1cm4gbmV3IEwuUG9seWdvbihsYXRsbmdzLCBvcHRpb25zKTtcbn07XG5cbi8qXG4gKiBMLlJlY3RhbmdsZSBleHRlbmRzIFBvbHlnb24gYW5kIGNyZWF0ZXMgYSByZWN0YW5nbGUgd2hlbiBwYXNzZWQgYSBMYXRMbmdCb3VuZHMgb2JqZWN0LlxuICovXG5cbkwuUmVjdGFuZ2xlID0gTC5Qb2x5Z29uLmV4dGVuZCh7XG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChsYXRMbmdCb3VuZHMsIG9wdGlvbnMpIHtcblx0XHRMLlBvbHlnb24ucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzLCB0aGlzLl9ib3VuZHNUb0xhdExuZ3MobGF0TG5nQm91bmRzKSwgb3B0aW9ucyk7XG5cdH0sXG5cblx0c2V0Qm91bmRzOiBmdW5jdGlvbiAobGF0TG5nQm91bmRzKSB7XG5cdFx0dGhpcy5zZXRMYXRMbmdzKHRoaXMuX2JvdW5kc1RvTGF0TG5ncyhsYXRMbmdCb3VuZHMpKTtcblx0fSxcblxuXHRfYm91bmRzVG9MYXRMbmdzOiBmdW5jdGlvbiAobGF0TG5nQm91bmRzKSB7XG5cdFx0bGF0TG5nQm91bmRzID0gTC5sYXRMbmdCb3VuZHMobGF0TG5nQm91bmRzKTtcblx0XHRyZXR1cm4gW1xuXHRcdFx0bGF0TG5nQm91bmRzLmdldFNvdXRoV2VzdCgpLFxuXHRcdFx0bGF0TG5nQm91bmRzLmdldE5vcnRoV2VzdCgpLFxuXHRcdFx0bGF0TG5nQm91bmRzLmdldE5vcnRoRWFzdCgpLFxuXHRcdFx0bGF0TG5nQm91bmRzLmdldFNvdXRoRWFzdCgpXG5cdFx0XTtcblx0fVxufSk7XG5cbkwucmVjdGFuZ2xlID0gZnVuY3Rpb24gKGxhdExuZ0JvdW5kcywgb3B0aW9ucykge1xuXHRyZXR1cm4gbmV3IEwuUmVjdGFuZ2xlKGxhdExuZ0JvdW5kcywgb3B0aW9ucyk7XG59O1xuXG4vKlxuICogTC5DaXJjbGVNYXJrZXIgaXMgYSBjaXJjbGUgb3ZlcmxheSB3aXRoIGEgcGVybWFuZW50IHBpeGVsIHJhZGl1cy5cbiAqL1xuXG5MLkNpcmNsZU1hcmtlciA9IEwuUGF0aC5leHRlbmQoe1xuXG5cdG9wdGlvbnM6IHtcblx0XHRmaWxsOiB0cnVlLFxuXHRcdHJhZGl1czogMTBcblx0fSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobGF0bG5nLCBvcHRpb25zKSB7XG5cdFx0TC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuXHRcdHRoaXMuX2xhdGxuZyA9IEwubGF0TG5nKGxhdGxuZyk7XG5cdFx0dGhpcy5fcmFkaXVzID0gdGhpcy5vcHRpb25zLnJhZGl1cztcblx0fSxcblxuXHRzZXRMYXRMbmc6IGZ1bmN0aW9uIChsYXRsbmcpIHtcblx0XHR0aGlzLl9sYXRsbmcgPSBMLmxhdExuZyhsYXRsbmcpO1xuXHRcdHRoaXMucmVkcmF3KCk7XG5cdFx0cmV0dXJuIHRoaXMuZmlyZSgnbW92ZScsIHtsYXRsbmc6IHRoaXMuX2xhdGxuZ30pO1xuXHR9LFxuXG5cdGdldExhdExuZzogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9sYXRsbmc7XG5cdH0sXG5cblx0c2V0UmFkaXVzOiBmdW5jdGlvbiAocmFkaXVzKSB7XG5cdFx0dGhpcy5vcHRpb25zLnJhZGl1cyA9IHRoaXMuX3JhZGl1cyA9IHJhZGl1cztcblx0XHRyZXR1cm4gdGhpcy5yZWRyYXcoKTtcblx0fSxcblxuXHRnZXRSYWRpdXM6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fcmFkaXVzO1xuXHR9LFxuXG5cdHNldFN0eWxlIDogZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0XHR2YXIgcmFkaXVzID0gb3B0aW9ucyAmJiBvcHRpb25zLnJhZGl1cyB8fCB0aGlzLl9yYWRpdXM7XG5cdFx0TC5QYXRoLnByb3RvdHlwZS5zZXRTdHlsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXHRcdHRoaXMuc2V0UmFkaXVzKHJhZGl1cyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0X3Byb2plY3Q6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9wb2ludCA9IHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fbGF0bG5nKTtcblx0XHR0aGlzLl91cGRhdGVCb3VuZHMoKTtcblx0fSxcblxuXHRfdXBkYXRlQm91bmRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHIgPSB0aGlzLl9yYWRpdXMsXG5cdFx0ICAgIHIyID0gdGhpcy5fcmFkaXVzWSB8fCByLFxuXHRcdCAgICB3ID0gdGhpcy5fY2xpY2tUb2xlcmFuY2UoKSxcblx0XHQgICAgcCA9IFtyICsgdywgcjIgKyB3XTtcblx0XHR0aGlzLl9weEJvdW5kcyA9IG5ldyBMLkJvdW5kcyh0aGlzLl9wb2ludC5zdWJ0cmFjdChwKSwgdGhpcy5fcG9pbnQuYWRkKHApKTtcblx0fSxcblxuXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX21hcCkge1xuXHRcdFx0dGhpcy5fdXBkYXRlUGF0aCgpO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlUGF0aDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3JlbmRlcmVyLl91cGRhdGVDaXJjbGUodGhpcyk7XG5cdH0sXG5cblx0X2VtcHR5OiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3JhZGl1cyAmJiAhdGhpcy5fcmVuZGVyZXIuX2JvdW5kcy5pbnRlcnNlY3RzKHRoaXMuX3B4Qm91bmRzKTtcblx0fVxufSk7XG5cbkwuY2lyY2xlTWFya2VyID0gZnVuY3Rpb24gKGxhdGxuZywgb3B0aW9ucykge1xuXHRyZXR1cm4gbmV3IEwuQ2lyY2xlTWFya2VyKGxhdGxuZywgb3B0aW9ucyk7XG59O1xuXG4vKlxuICogTC5DaXJjbGUgaXMgYSBjaXJjbGUgb3ZlcmxheSAod2l0aCBhIGNlcnRhaW4gcmFkaXVzIGluIG1ldGVycykuXG4gKiBJdCdzIGFuIGFwcHJveGltYXRpb24gYW5kIHN0YXJ0cyB0byBkaXZlcmdlIGZyb20gYSByZWFsIGNpcmNsZSBjbG9zZXIgdG8gcG9sZXMgKGR1ZSB0byBwcm9qZWN0aW9uIGRpc3RvcnRpb24pXG4gKi9cblxuTC5DaXJjbGUgPSBMLkNpcmNsZU1hcmtlci5leHRlbmQoe1xuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChsYXRsbmcsIHJhZGl1cywgb3B0aW9ucykge1xuXHRcdEwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcblx0XHR0aGlzLl9sYXRsbmcgPSBMLmxhdExuZyhsYXRsbmcpO1xuXHRcdHRoaXMuX21SYWRpdXMgPSByYWRpdXM7XG5cdH0sXG5cblx0c2V0UmFkaXVzOiBmdW5jdGlvbiAocmFkaXVzKSB7XG5cdFx0dGhpcy5fbVJhZGl1cyA9IHJhZGl1cztcblx0XHRyZXR1cm4gdGhpcy5yZWRyYXcoKTtcblx0fSxcblxuXHRnZXRSYWRpdXM6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fbVJhZGl1cztcblx0fSxcblxuXHRnZXRCb3VuZHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgaGFsZiA9IFt0aGlzLl9yYWRpdXMsIHRoaXMuX3JhZGl1c1ldO1xuXG5cdFx0cmV0dXJuIG5ldyBMLkxhdExuZ0JvdW5kcyhcblx0XHRcdHRoaXMuX21hcC5sYXllclBvaW50VG9MYXRMbmcodGhpcy5fcG9pbnQuc3VidHJhY3QoaGFsZikpLFxuXHRcdFx0dGhpcy5fbWFwLmxheWVyUG9pbnRUb0xhdExuZyh0aGlzLl9wb2ludC5hZGQoaGFsZikpKTtcblx0fSxcblxuXHRzZXRTdHlsZTogTC5QYXRoLnByb3RvdHlwZS5zZXRTdHlsZSxcblxuXHRfcHJvamVjdDogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIGxuZyA9IHRoaXMuX2xhdGxuZy5sbmcsXG5cdFx0ICAgIGxhdCA9IHRoaXMuX2xhdGxuZy5sYXQsXG5cdFx0ICAgIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgY3JzID0gbWFwLm9wdGlvbnMuY3JzO1xuXG5cdFx0aWYgKGNycy5kaXN0YW5jZSA9PT0gTC5DUlMuRWFydGguZGlzdGFuY2UpIHtcblx0XHRcdHZhciBkID0gTWF0aC5QSSAvIDE4MCxcblx0XHRcdCAgICBsYXRSID0gKHRoaXMuX21SYWRpdXMgLyBMLkNSUy5FYXJ0aC5SKSAvIGQsXG5cdFx0XHQgICAgdG9wID0gbWFwLnByb2plY3QoW2xhdCArIGxhdFIsIGxuZ10pLFxuXHRcdFx0ICAgIGJvdHRvbSA9IG1hcC5wcm9qZWN0KFtsYXQgLSBsYXRSLCBsbmddKSxcblx0XHRcdCAgICBwID0gdG9wLmFkZChib3R0b20pLmRpdmlkZUJ5KDIpLFxuXHRcdFx0ICAgIGxhdDIgPSBtYXAudW5wcm9qZWN0KHApLmxhdCxcblx0XHRcdCAgICBsbmdSID0gTWF0aC5hY29zKChNYXRoLmNvcyhsYXRSICogZCkgLSBNYXRoLnNpbihsYXQgKiBkKSAqIE1hdGguc2luKGxhdDIgKiBkKSkgL1xuXHRcdFx0ICAgICAgICAgICAgKE1hdGguY29zKGxhdCAqIGQpICogTWF0aC5jb3MobGF0MiAqIGQpKSkgLyBkO1xuXG5cdFx0XHR0aGlzLl9wb2ludCA9IHAuc3VidHJhY3QobWFwLmdldFBpeGVsT3JpZ2luKCkpO1xuXHRcdFx0dGhpcy5fcmFkaXVzID0gaXNOYU4obG5nUikgPyAwIDogTWF0aC5tYXgoTWF0aC5yb3VuZChwLnggLSBtYXAucHJvamVjdChbbGF0MiwgbG5nIC0gbG5nUl0pLngpLCAxKTtcblx0XHRcdHRoaXMuX3JhZGl1c1kgPSBNYXRoLm1heChNYXRoLnJvdW5kKHAueSAtIHRvcC55KSwgMSk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIGxhdGxuZzIgPSBjcnMudW5wcm9qZWN0KGNycy5wcm9qZWN0KHRoaXMuX2xhdGxuZykuc3VidHJhY3QoW3RoaXMuX21SYWRpdXMsIDBdKSk7XG5cblx0XHRcdHRoaXMuX3BvaW50ID0gbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcpO1xuXHRcdFx0dGhpcy5fcmFkaXVzID0gdGhpcy5fcG9pbnQueCAtIG1hcC5sYXRMbmdUb0xheWVyUG9pbnQobGF0bG5nMikueDtcblx0XHR9XG5cblx0XHR0aGlzLl91cGRhdGVCb3VuZHMoKTtcblx0fVxufSk7XG5cbkwuY2lyY2xlID0gZnVuY3Rpb24gKGxhdGxuZywgcmFkaXVzLCBvcHRpb25zKSB7XG5cdHJldHVybiBuZXcgTC5DaXJjbGUobGF0bG5nLCByYWRpdXMsIG9wdGlvbnMpO1xufTtcblxuLypcbiAqIEwuU1ZHIHJlbmRlcnMgdmVjdG9yIGxheWVycyB3aXRoIFNWRy4gQWxsIFNWRy1zcGVjaWZpYyBjb2RlIGdvZXMgaGVyZS5cbiAqL1xuXG5MLlNWRyA9IEwuUmVuZGVyZXIuZXh0ZW5kKHtcblxuXHRfaW5pdENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX2NvbnRhaW5lciA9IEwuU1ZHLmNyZWF0ZSgnc3ZnJyk7XG5cblx0XHR0aGlzLl9wYXRocyA9IHt9O1xuXHRcdHRoaXMuX2luaXRFdmVudHMoKTtcblxuXHRcdC8vIG1ha2VzIGl0IHBvc3NpYmxlIHRvIGNsaWNrIHRocm91Z2ggc3ZnIHJvb3Q7IHdlJ2xsIHJlc2V0IGl0IGJhY2sgaW4gaW5kaXZpZHVhbCBwYXRoc1xuXHRcdHRoaXMuX2NvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ3BvaW50ZXItZXZlbnRzJywgJ25vbmUnKTtcblx0fSxcblxuXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX21hcC5fYW5pbWF0aW5nWm9vbSAmJiB0aGlzLl9ib3VuZHMpIHsgcmV0dXJuOyB9XG5cblx0XHRMLlJlbmRlcmVyLnByb3RvdHlwZS5fdXBkYXRlLmNhbGwodGhpcyk7XG5cblx0XHR2YXIgYiA9IHRoaXMuX2JvdW5kcyxcblx0XHQgICAgc2l6ZSA9IGIuZ2V0U2l6ZSgpLFxuXHRcdCAgICBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIsXG5cdFx0ICAgIHBhbmUgPSB0aGlzLmdldFBhbmUoKTtcblxuXHRcdC8vIGhhY2sgdG8gbWFrZSBmbGlja2VyIG9uIGRyYWcgZW5kIG9uIG1vYmlsZSB3ZWJraXQgbGVzcyBpcnJpdGF0aW5nXG5cdFx0aWYgKEwuQnJvd3Nlci5tb2JpbGVXZWJraXQpIHtcblx0XHRcdHBhbmUucmVtb3ZlQ2hpbGQoY29udGFpbmVyKTtcblx0XHR9XG5cblx0XHRMLkRvbVV0aWwuc2V0UG9zaXRpb24oY29udGFpbmVyLCBiLm1pbik7XG5cblx0XHQvLyB1cGRhdGUgY29udGFpbmVyIHZpZXdCb3ggc28gdGhhdCB3ZSBkb24ndCBoYXZlIHRvIGNoYW5nZSBjb29yZGluYXRlcyBvZiBpbmRpdmlkdWFsIGxheWVyc1xuXHRcdGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgc2l6ZS54KTtcblx0XHRjb250YWluZXIuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCBzaXplLnkpO1xuXHRcdGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnLCBbYi5taW4ueCwgYi5taW4ueSwgc2l6ZS54LCBzaXplLnldLmpvaW4oJyAnKSk7XG5cblx0XHRpZiAoTC5Ccm93c2VyLm1vYmlsZVdlYmtpdCkge1xuXHRcdFx0cGFuZS5hcHBlbmRDaGlsZChjb250YWluZXIpO1xuXHRcdH1cblx0fSxcblxuXHQvLyBtZXRob2RzIGJlbG93IGFyZSBjYWxsZWQgYnkgdmVjdG9yIGxheWVycyBpbXBsZW1lbnRhdGlvbnNcblxuXHRfaW5pdFBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBwYXRoID0gbGF5ZXIuX3BhdGggPSBMLlNWRy5jcmVhdGUoJ3BhdGgnKTtcblxuXHRcdGlmIChsYXllci5vcHRpb25zLmNsYXNzTmFtZSkge1xuXHRcdFx0TC5Eb21VdGlsLmFkZENsYXNzKHBhdGgsIGxheWVyLm9wdGlvbnMuY2xhc3NOYW1lKTtcblx0XHR9XG5cblx0XHRpZiAobGF5ZXIub3B0aW9ucy5jbGlja2FibGUpIHtcblx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyhwYXRoLCAnbGVhZmxldC1jbGlja2FibGUnKTtcblx0XHR9XG5cblx0XHR0aGlzLl91cGRhdGVTdHlsZShsYXllcik7XG5cdH0sXG5cblx0X2FkZFBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBwYXRoID0gbGF5ZXIuX3BhdGg7XG5cdFx0dGhpcy5fY29udGFpbmVyLmFwcGVuZENoaWxkKHBhdGgpO1xuXHRcdHRoaXMuX3BhdGhzW0wuc3RhbXAocGF0aCldID0gbGF5ZXI7XG5cdH0sXG5cblx0X3JlbW92ZVBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBwYXRoID0gbGF5ZXIuX3BhdGg7XG5cdFx0TC5Eb21VdGlsLnJlbW92ZShwYXRoKTtcblx0XHRkZWxldGUgdGhpcy5fcGF0aHNbTC5zdGFtcChwYXRoKV07XG5cdH0sXG5cblx0X3VwZGF0ZVBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdGxheWVyLl9wcm9qZWN0KCk7XG5cdFx0bGF5ZXIuX3VwZGF0ZSgpO1xuXHR9LFxuXG5cdF91cGRhdGVTdHlsZTogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIHBhdGggPSBsYXllci5fcGF0aCxcblx0XHRcdG9wdGlvbnMgPSBsYXllci5vcHRpb25zO1xuXG5cdFx0aWYgKCFwYXRoKSB7IHJldHVybjsgfVxuXG5cdFx0aWYgKG9wdGlvbnMuc3Ryb2tlKSB7XG5cdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlJywgb3B0aW9ucy5jb2xvcik7XG5cdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLW9wYWNpdHknLCBvcHRpb25zLm9wYWNpdHkpO1xuXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS13aWR0aCcsIG9wdGlvbnMud2VpZ2h0KTtcblx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UtbGluZWNhcCcsIG9wdGlvbnMubGluZUNhcCk7XG5cdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWxpbmVqb2luJywgb3B0aW9ucy5saW5lSm9pbik7XG5cblx0XHRcdGlmIChvcHRpb25zLmRhc2hBcnJheSkge1xuXHRcdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWRhc2hhcnJheScsIG9wdGlvbnMuZGFzaEFycmF5KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHBhdGgucmVtb3ZlQXR0cmlidXRlKCdzdHJva2UtZGFzaGFycmF5Jyk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChvcHRpb25zLmRhc2hPZmZzZXQpIHtcblx0XHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1kYXNob2Zmc2V0Jywgb3B0aW9ucy5kYXNoT2Zmc2V0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHBhdGgucmVtb3ZlQXR0cmlidXRlKCdzdHJva2UtZGFzaG9mZnNldCcpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlJywgJ25vbmUnKTtcblx0XHR9XG5cblx0XHRpZiAob3B0aW9ucy5maWxsKSB7XG5cdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnZmlsbCcsIG9wdGlvbnMuZmlsbENvbG9yIHx8IG9wdGlvbnMuY29sb3IpO1xuXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ2ZpbGwtb3BhY2l0eScsIG9wdGlvbnMuZmlsbE9wYWNpdHkpO1xuXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ2ZpbGwtcnVsZScsICdldmVub2RkJyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdmaWxsJywgJ25vbmUnKTtcblx0XHR9XG5cblx0XHRwYXRoLnNldEF0dHJpYnV0ZSgncG9pbnRlci1ldmVudHMnLCBvcHRpb25zLnBvaW50ZXJFdmVudHMgfHwgKG9wdGlvbnMuY2xpY2thYmxlID8gJ3Zpc2libGVQYWludGVkJyA6ICdub25lJykpO1xuXHR9LFxuXG5cdF91cGRhdGVQb2x5OiBmdW5jdGlvbiAobGF5ZXIsIGNsb3NlZCkge1xuXHRcdHRoaXMuX3NldFBhdGgobGF5ZXIsIEwuU1ZHLnBvaW50c1RvUGF0aChsYXllci5fcGFydHMsIGNsb3NlZCkpO1xuXHR9LFxuXG5cdF91cGRhdGVDaXJjbGU6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBwID0gbGF5ZXIuX3BvaW50LFxuXHRcdCAgICByID0gbGF5ZXIuX3JhZGl1cyxcblx0XHQgICAgcjIgPSBsYXllci5fcmFkaXVzWSB8fCByLFxuXHRcdCAgICBhcmMgPSAnYScgKyByICsgJywnICsgcjIgKyAnIDAgMSwwICc7XG5cblx0XHQvLyBkcmF3aW5nIGEgY2lyY2xlIHdpdGggdHdvIGhhbGYtYXJjc1xuXHRcdHZhciBkID0gbGF5ZXIuX2VtcHR5KCkgPyAnTTAgMCcgOlxuXHRcdFx0XHQnTScgKyAocC54IC0gcikgKyAnLCcgKyBwLnkgK1xuXHRcdFx0XHRhcmMgKyAgKHIgKiAyKSArICcsMCAnICtcblx0XHRcdFx0YXJjICsgKC1yICogMikgKyAnLDAgJztcblxuXHRcdHRoaXMuX3NldFBhdGgobGF5ZXIsIGQpO1xuXHR9LFxuXG5cdF9zZXRQYXRoOiBmdW5jdGlvbiAobGF5ZXIsIHBhdGgpIHtcblx0XHRsYXllci5fcGF0aC5zZXRBdHRyaWJ1dGUoJ2QnLCBwYXRoKTtcblx0fSxcblxuXHQvLyBTVkcgZG9lcyBub3QgaGF2ZSB0aGUgY29uY2VwdCBvZiB6SW5kZXggc28gd2UgcmVzb3J0IHRvIGNoYW5naW5nIHRoZSBET00gb3JkZXIgb2YgZWxlbWVudHNcblx0X2JyaW5nVG9Gcm9udDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0TC5Eb21VdGlsLnRvRnJvbnQobGF5ZXIuX3BhdGgpO1xuXHR9LFxuXG5cdF9icmluZ1RvQmFjazogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0TC5Eb21VdGlsLnRvQmFjayhsYXllci5fcGF0aCk7XG5cdH0sXG5cblx0Ly8gVE9ETyByZW1vdmUgZHVwbGljYXRpb24gd2l0aCBMLk1hcFxuXHRfaW5pdEV2ZW50czogZnVuY3Rpb24gKCkge1xuXHRcdEwuRG9tRXZlbnQub24odGhpcy5fY29udGFpbmVyLCAnY2xpY2sgZGJsY2xpY2sgbW91c2Vkb3duIG1vdXNldXAgbW91c2VvdmVyIG1vdXNlb3V0IG1vdXNlbW92ZSBjb250ZXh0bWVudScsXG5cdFx0XHRcdHRoaXMuX2ZpcmVNb3VzZUV2ZW50LCB0aGlzKTtcblx0fSxcblxuXHRfZmlyZU1vdXNlRXZlbnQ6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dGhpcy5fcGF0aHNbTC5zdGFtcChlLnRhcmdldCB8fCBlLnNyY0VsZW1lbnQpXSAmJiB0aGlzLl9wYXRoc1tMLnN0YW1wKGUudGFyZ2V0IHx8IGUuc3JjRWxlbWVudCldLl9maXJlTW91c2VFdmVudChlKTtcblx0fVxufSk7XG5cblxuTC5leHRlbmQoTC5TVkcsIHtcblx0Y3JlYXRlOiBmdW5jdGlvbiAobmFtZSkge1xuXHRcdHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgbmFtZSk7XG5cdH0sXG5cblx0Ly8gZ2VuZXJhdGVzIFNWRyBwYXRoIHN0cmluZyBmb3IgbXVsdGlwbGUgcmluZ3MsIHdpdGggZWFjaCByaW5nIHR1cm5pbmcgaW50byBcIk0uLkwuLkwuLlwiIGluc3RydWN0aW9uc1xuXHRwb2ludHNUb1BhdGg6IGZ1bmN0aW9uIChyaW5ncywgY2xvc2VkKSB7XG5cdFx0dmFyIHN0ciA9ICcnLFxuXHRcdFx0aSwgaiwgbGVuLCBsZW4yLCBwb2ludHMsIHA7XG5cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSByaW5ncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0cG9pbnRzID0gcmluZ3NbaV07XG5cblx0XHRcdGZvciAoaiA9IDAsIGxlbjIgPSBwb2ludHMubGVuZ3RoOyBqIDwgbGVuMjsgaisrKSB7XG5cdFx0XHRcdHAgPSBwb2ludHNbal07XG5cdFx0XHRcdHN0ciArPSAoaiA/ICdMJyA6ICdNJykgKyBwLnggKyAnICcgKyBwLnk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGNsb3NlcyB0aGUgcmluZyBmb3IgcG9seWdvbnM7IFwieFwiIGlzIFZNTCBzeW50YXhcblx0XHRcdHN0ciArPSBjbG9zZWQgPyAoTC5Ccm93c2VyLnN2ZyA/ICd6JyA6ICd4JykgOiAnJztcblx0XHR9XG5cblx0XHQvLyBTVkcgY29tcGxhaW5zIGFib3V0IGVtcHR5IHBhdGggc3RyaW5nc1xuXHRcdHJldHVybiBzdHIgfHwgJ00wIDAnO1xuXHR9XG59KTtcblxuTC5Ccm93c2VyLnN2ZyA9ICEhKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyAmJiBMLlNWRy5jcmVhdGUoJ3N2ZycpLmNyZWF0ZVNWR1JlY3QpO1xuXG5MLnN2ZyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cdHJldHVybiBMLkJyb3dzZXIuc3ZnIHx8IEwuQnJvd3Nlci52bWwgPyBuZXcgTC5TVkcob3B0aW9ucykgOiBudWxsO1xufTtcblxuLypcbiAqIFZlY3RvciByZW5kZXJpbmcgZm9yIElFNy04IHRocm91Z2ggVk1MLlxuICogVGhhbmtzIHRvIERtaXRyeSBCYXJhbm92c2t5IGFuZCBoaXMgUmFwaGFlbCBsaWJyYXJ5IGZvciBpbnNwaXJhdGlvbiFcbiAqL1xuXG5MLkJyb3dzZXIudm1sID0gIUwuQnJvd3Nlci5zdmcgJiYgKGZ1bmN0aW9uICgpIHtcblx0dHJ5IHtcblx0XHR2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdFx0ZGl2LmlubmVySFRNTCA9ICc8djpzaGFwZSBhZGo9XCIxXCIvPic7XG5cblx0XHR2YXIgc2hhcGUgPSBkaXYuZmlyc3RDaGlsZDtcblx0XHRzaGFwZS5zdHlsZS5iZWhhdmlvciA9ICd1cmwoI2RlZmF1bHQjVk1MKSc7XG5cblx0XHRyZXR1cm4gc2hhcGUgJiYgKHR5cGVvZiBzaGFwZS5hZGogPT09ICdvYmplY3QnKTtcblxuXHR9IGNhdGNoIChlKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59KCkpO1xuXG4vLyByZWRlZmluZSBzb21lIFNWRyBtZXRob2RzIHRvIGhhbmRsZSBWTUwgc3ludGF4IHdoaWNoIGlzIHNpbWlsYXIgYnV0IHdpdGggc29tZSBkaWZmZXJlbmNlc1xuTC5TVkcuaW5jbHVkZSghTC5Ccm93c2VyLnZtbCA/IHt9IDoge1xuXG5cdF9pbml0Q29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fY29udGFpbmVyID0gTC5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgJ2xlYWZsZXQtdm1sLWNvbnRhaW5lcicpO1xuXG5cdFx0dGhpcy5fcGF0aHMgPSB7fTtcblx0XHR0aGlzLl9pbml0RXZlbnRzKCk7XG5cdH0sXG5cblx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9tYXAuX2FuaW1hdGluZ1pvb20pIHsgcmV0dXJuOyB9XG5cdFx0TC5SZW5kZXJlci5wcm90b3R5cGUuX3VwZGF0ZS5jYWxsKHRoaXMpO1xuXHR9LFxuXG5cdF9pbml0UGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIGNvbnRhaW5lciA9IGxheWVyLl9jb250YWluZXIgPSBMLlNWRy5jcmVhdGUoJ3NoYXBlJyk7XG5cblx0XHRMLkRvbVV0aWwuYWRkQ2xhc3MoY29udGFpbmVyLCAnbGVhZmxldC12bWwtc2hhcGUgJyArICh0aGlzLm9wdGlvbnMuY2xhc3NOYW1lIHx8ICcnKSk7XG5cblx0XHRjb250YWluZXIuY29vcmRzaXplID0gJzEgMSc7XG5cblx0XHRsYXllci5fcGF0aCA9IEwuU1ZHLmNyZWF0ZSgncGF0aCcpO1xuXHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChsYXllci5fcGF0aCk7XG5cblx0XHR0aGlzLl91cGRhdGVTdHlsZShsYXllcik7XG5cdH0sXG5cblx0X2FkZFBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBjb250YWluZXIgPSBsYXllci5fY29udGFpbmVyO1xuXHRcdHRoaXMuX2NvbnRhaW5lci5hcHBlbmRDaGlsZChjb250YWluZXIpO1xuXHRcdHRoaXMuX3BhdGhzW0wuc3RhbXAoY29udGFpbmVyKV0gPSBsYXllcjtcblx0fSxcblxuXHRfcmVtb3ZlUGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIGNvbnRhaW5lciA9IGxheWVyLl9jb250YWluZXI7XG5cdFx0TC5Eb21VdGlsLnJlbW92ZShjb250YWluZXIpO1xuXHRcdGRlbGV0ZSB0aGlzLl9wYXRoc1tMLnN0YW1wKGNvbnRhaW5lcildO1xuXHR9LFxuXG5cdF91cGRhdGVTdHlsZTogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIHN0cm9rZSA9IGxheWVyLl9zdHJva2UsXG5cdFx0ICAgIGZpbGwgPSBsYXllci5fZmlsbCxcblx0XHQgICAgb3B0aW9ucyA9IGxheWVyLm9wdGlvbnMsXG5cdFx0ICAgIGNvbnRhaW5lciA9IGxheWVyLl9jb250YWluZXI7XG5cblx0XHRjb250YWluZXIuc3Ryb2tlZCA9ICEhb3B0aW9ucy5zdHJva2U7XG5cdFx0Y29udGFpbmVyLmZpbGxlZCA9ICEhb3B0aW9ucy5maWxsO1xuXG5cdFx0aWYgKG9wdGlvbnMuc3Ryb2tlKSB7XG5cdFx0XHRpZiAoIXN0cm9rZSkge1xuXHRcdFx0XHRzdHJva2UgPSBsYXllci5fc3Ryb2tlID0gTC5TVkcuY3JlYXRlKCdzdHJva2UnKTtcblx0XHRcdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKHN0cm9rZSk7XG5cdFx0XHR9XG5cdFx0XHRzdHJva2Uud2VpZ2h0ID0gb3B0aW9ucy53ZWlnaHQgKyAncHgnO1xuXHRcdFx0c3Ryb2tlLmNvbG9yID0gb3B0aW9ucy5jb2xvcjtcblx0XHRcdHN0cm9rZS5vcGFjaXR5ID0gb3B0aW9ucy5vcGFjaXR5O1xuXG5cdFx0XHRpZiAob3B0aW9ucy5kYXNoQXJyYXkpIHtcblx0XHRcdFx0c3Ryb2tlLmRhc2hTdHlsZSA9IEwuVXRpbC5pc0FycmF5KG9wdGlvbnMuZGFzaEFycmF5KSA/XG5cdFx0XHRcdCAgICBvcHRpb25zLmRhc2hBcnJheS5qb2luKCcgJykgOlxuXHRcdFx0XHQgICAgb3B0aW9ucy5kYXNoQXJyYXkucmVwbGFjZSgvKCAqLCAqKS9nLCAnICcpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c3Ryb2tlLmRhc2hTdHlsZSA9ICcnO1xuXHRcdFx0fVxuXHRcdFx0c3Ryb2tlLmVuZGNhcCA9IG9wdGlvbnMubGluZUNhcC5yZXBsYWNlKCdidXR0JywgJ2ZsYXQnKTtcblx0XHRcdHN0cm9rZS5qb2luc3R5bGUgPSBvcHRpb25zLmxpbmVKb2luO1xuXG5cdFx0fSBlbHNlIGlmIChzdHJva2UpIHtcblx0XHRcdGNvbnRhaW5lci5yZW1vdmVDaGlsZChzdHJva2UpO1xuXHRcdFx0bGF5ZXIuX3N0cm9rZSA9IG51bGw7XG5cdFx0fVxuXG5cdFx0aWYgKG9wdGlvbnMuZmlsbCkge1xuXHRcdFx0aWYgKCFmaWxsKSB7XG5cdFx0XHRcdGZpbGwgPSBsYXllci5fZmlsbCA9IEwuU1ZHLmNyZWF0ZSgnZmlsbCcpO1xuXHRcdFx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQoZmlsbCk7XG5cdFx0XHR9XG5cdFx0XHRmaWxsLmNvbG9yID0gb3B0aW9ucy5maWxsQ29sb3IgfHwgb3B0aW9ucy5jb2xvcjtcblx0XHRcdGZpbGwub3BhY2l0eSA9IG9wdGlvbnMuZmlsbE9wYWNpdHk7XG5cblx0XHR9IGVsc2UgaWYgKGZpbGwpIHtcblx0XHRcdGNvbnRhaW5lci5yZW1vdmVDaGlsZChmaWxsKTtcblx0XHRcdGxheWVyLl9maWxsID0gbnVsbDtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZUNpcmNsZTogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIHAgPSBsYXllci5fcG9pbnQsXG5cdFx0ICAgIHIgPSBNYXRoLnJvdW5kKGxheWVyLl9yYWRpdXMpLFxuXHRcdCAgICByMiA9IE1hdGgucm91bmQobGF5ZXIuX3JhZGl1c1kgfHwgcik7XG5cblx0XHR0aGlzLl9zZXRQYXRoKGxheWVyLCBsYXllci5fZW1wdHkoKSA/ICdNMCAwJyA6XG5cdFx0XHRcdCdBTCAnICsgcC54ICsgJywnICsgcC55ICsgJyAnICsgciArICcsJyArIHIyICsgJyAwLCcgKyAoNjU1MzUgKiAzNjApKTtcblx0fSxcblxuXHRfc2V0UGF0aDogZnVuY3Rpb24gKGxheWVyLCBwYXRoKSB7XG5cdFx0bGF5ZXIuX3BhdGgudiA9IHBhdGg7XG5cdH0sXG5cblx0X2JyaW5nVG9Gcm9udDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0TC5Eb21VdGlsLnRvRnJvbnQobGF5ZXIuX3BhdGgucGFyZW50Tm9kZSk7XG5cdH0sXG5cblx0X2JyaW5nVG9CYWNrOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHRMLkRvbVV0aWwudG9CYWNrKGxheWVyLl9wYXRoLnBhcmVudE5vZGUpO1xuXHR9XG59KTtcblxuaWYgKEwuQnJvd3Nlci52bWwpIHtcblx0TC5TVkcuY3JlYXRlID0gKGZ1bmN0aW9uICgpIHtcblx0XHR0cnkge1xuXHRcdFx0ZG9jdW1lbnQubmFtZXNwYWNlcy5hZGQoJ2x2bWwnLCAndXJuOnNjaGVtYXMtbWljcm9zb2Z0LWNvbTp2bWwnKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiAobmFtZSkge1xuXHRcdFx0XHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnPGx2bWw6JyArIG5hbWUgKyAnIGNsYXNzPVwibHZtbFwiPicpO1xuXHRcdFx0fTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gKG5hbWUpIHtcblx0XHRcdFx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJzwnICsgbmFtZSArICcgeG1sbnM9XCJ1cm46c2NoZW1hcy1taWNyb3NvZnQuY29tOnZtbFwiIGNsYXNzPVwibHZtbFwiPicpO1xuXHRcdFx0fTtcblx0XHR9XG5cdH0pKCk7XG59XG5cbi8qXG4gKiBMLkNhbnZhcyBoYW5kbGVzIENhbnZhcyB2ZWN0b3IgbGF5ZXJzIHJlbmRlcmluZyBhbmQgbW91c2UgZXZlbnRzIGhhbmRsaW5nLiBBbGwgQ2FudmFzLXNwZWNpZmljIGNvZGUgZ29lcyBoZXJlLlxuICovXG5cbkwuQ2FudmFzID0gTC5SZW5kZXJlci5leHRlbmQoe1xuXG5cdG9uQWRkOiBmdW5jdGlvbiAoKSB7XG5cdFx0TC5SZW5kZXJlci5wcm90b3R5cGUub25BZGQuY2FsbCh0aGlzKTtcblxuXHRcdHRoaXMuX2xheWVycyA9IHRoaXMuX2xheWVycyB8fCB7fTtcblxuXHRcdC8vIHJlZHJhdyB2ZWN0b3JzIHNpbmNlIGNhbnZhcyBpcyBjbGVhcmVkIHVwb24gcmVtb3ZhbFxuXHRcdHRoaXMuX2RyYXcoKTtcblx0fSxcblxuXHRfaW5pdENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcblxuXHRcdEwuRG9tRXZlbnRcblx0XHRcdC5vbihjb250YWluZXIsICdtb3VzZW1vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZSwgdGhpcylcblx0XHRcdC5vbihjb250YWluZXIsICdjbGljayBkYmxjbGljayBtb3VzZWRvd24gbW91c2V1cCBjb250ZXh0bWVudScsIHRoaXMuX29uQ2xpY2ssIHRoaXMpO1xuXG5cdFx0dGhpcy5fY3R4ID0gY29udGFpbmVyLmdldENvbnRleHQoJzJkJyk7XG5cdH0sXG5cblx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9tYXAuX2FuaW1hdGluZ1pvb20gJiYgdGhpcy5fYm91bmRzKSB7IHJldHVybjsgfVxuXG5cdFx0TC5SZW5kZXJlci5wcm90b3R5cGUuX3VwZGF0ZS5jYWxsKHRoaXMpO1xuXG5cdFx0dmFyIGIgPSB0aGlzLl9ib3VuZHMsXG5cdFx0ICAgIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lcixcblx0XHQgICAgc2l6ZSA9IGIuZ2V0U2l6ZSgpLFxuXHRcdCAgICBtID0gTC5Ccm93c2VyLnJldGluYSA/IDIgOiAxO1xuXG5cdFx0TC5Eb21VdGlsLnNldFBvc2l0aW9uKGNvbnRhaW5lciwgYi5taW4pO1xuXG5cdFx0Ly8gc2V0IGNhbnZhcyBzaXplIChhbHNvIGNsZWFyaW5nIGl0KTsgdXNlIGRvdWJsZSBzaXplIG9uIHJldGluYVxuXHRcdGNvbnRhaW5lci53aWR0aCA9IG0gKiBzaXplLng7XG5cdFx0Y29udGFpbmVyLmhlaWdodCA9IG0gKiBzaXplLnk7XG5cdFx0Y29udGFpbmVyLnN0eWxlLndpZHRoID0gc2l6ZS54ICsgJ3B4Jztcblx0XHRjb250YWluZXIuc3R5bGUuaGVpZ2h0ID0gc2l6ZS55ICsgJ3B4JztcblxuXHRcdGlmIChMLkJyb3dzZXIucmV0aW5hKSB7XG5cdFx0XHR0aGlzLl9jdHguc2NhbGUoMiwgMik7XG5cdFx0fVxuXG5cdFx0Ly8gdHJhbnNsYXRlIHNvIHdlIHVzZSB0aGUgc2FtZSBwYXRoIGNvb3JkaW5hdGVzIGFmdGVyIGNhbnZhcyBlbGVtZW50IG1vdmVzXG5cdFx0dGhpcy5fY3R4LnRyYW5zbGF0ZSgtYi5taW4ueCwgLWIubWluLnkpO1xuXHR9LFxuXG5cdF9pbml0UGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dGhpcy5fbGF5ZXJzW0wuc3RhbXAobGF5ZXIpXSA9IGxheWVyO1xuXHR9LFxuXG5cdF9hZGRQYXRoOiBMLlV0aWwuZmFsc2VGbixcblxuXHRfcmVtb3ZlUGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0bGF5ZXIuX3JlbW92ZWQgPSB0cnVlO1xuXHRcdHRoaXMuX3JlcXVlc3RSZWRyYXcobGF5ZXIpO1xuXHR9LFxuXG5cdF91cGRhdGVQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR0aGlzLl9yZWRyYXdCb3VuZHMgPSBsYXllci5fcHhCb3VuZHM7XG5cdFx0dGhpcy5fZHJhdyh0cnVlKTtcblx0XHRsYXllci5fcHJvamVjdCgpO1xuXHRcdGxheWVyLl91cGRhdGUoKTtcblx0XHR0aGlzLl9kcmF3KCk7XG5cdFx0dGhpcy5fcmVkcmF3Qm91bmRzID0gbnVsbDtcblx0fSxcblxuXHRfdXBkYXRlU3R5bGU6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHRoaXMuX3JlcXVlc3RSZWRyYXcobGF5ZXIpO1xuXHR9LFxuXG5cdF9yZXF1ZXN0UmVkcmF3OiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHRpZiAoIXRoaXMuX21hcCkgeyByZXR1cm47IH1cblxuXHRcdHRoaXMuX3JlZHJhd0JvdW5kcyA9IHRoaXMuX3JlZHJhd0JvdW5kcyB8fCBuZXcgTC5Cb3VuZHMoKTtcblx0XHR0aGlzLl9yZWRyYXdCb3VuZHMuZXh0ZW5kKGxheWVyLl9weEJvdW5kcy5taW4pLmV4dGVuZChsYXllci5fcHhCb3VuZHMubWF4KTtcblxuXHRcdHRoaXMuX3JlZHJhd1JlcXVlc3QgPSB0aGlzLl9yZWRyYXdSZXF1ZXN0IHx8IEwuVXRpbC5yZXF1ZXN0QW5pbUZyYW1lKHRoaXMuX3JlZHJhdywgdGhpcyk7XG5cdH0sXG5cblx0X3JlZHJhdzogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3JlZHJhd1JlcXVlc3QgPSBudWxsO1xuXG5cdFx0dGhpcy5fZHJhdyh0cnVlKTsgLy8gY2xlYXIgbGF5ZXJzIGluIHJlZHJhdyBib3VuZHNcblx0XHR0aGlzLl9kcmF3KCk7IC8vIGRyYXcgbGF5ZXJzXG5cblx0XHR0aGlzLl9yZWRyYXdCb3VuZHMgPSBudWxsO1xuXHR9LFxuXG5cdF9kcmF3OiBmdW5jdGlvbiAoY2xlYXIpIHtcblx0XHR0aGlzLl9jbGVhciA9IGNsZWFyO1xuXHRcdHZhciBsYXllcjtcblxuXHRcdGZvciAodmFyIGlkIGluIHRoaXMuX2xheWVycykge1xuXHRcdFx0bGF5ZXIgPSB0aGlzLl9sYXllcnNbaWRdO1xuXHRcdFx0aWYgKCF0aGlzLl9yZWRyYXdCb3VuZHMgfHwgbGF5ZXIuX3B4Qm91bmRzLmludGVyc2VjdHModGhpcy5fcmVkcmF3Qm91bmRzKSkge1xuXHRcdFx0XHRsYXllci5fdXBkYXRlUGF0aCgpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGNsZWFyICYmIGxheWVyLl9yZW1vdmVkKSB7XG5cdFx0XHRcdGRlbGV0ZSBsYXllci5fcmVtb3ZlZDtcblx0XHRcdFx0ZGVsZXRlIHRoaXMuX2xheWVyc1tpZF07XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGVQb2x5OiBmdW5jdGlvbiAobGF5ZXIsIGNsb3NlZCkge1xuXG5cdFx0dmFyIGksIGosIGxlbjIsIHAsXG5cdFx0ICAgIHBhcnRzID0gbGF5ZXIuX3BhcnRzLFxuXHRcdCAgICBsZW4gPSBwYXJ0cy5sZW5ndGgsXG5cdFx0ICAgIGN0eCA9IHRoaXMuX2N0eDtcblxuXHQgICAgaWYgKCFsZW4pIHsgcmV0dXJuOyB9XG5cblx0XHRjdHguYmVnaW5QYXRoKCk7XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGZvciAoaiA9IDAsIGxlbjIgPSBwYXJ0c1tpXS5sZW5ndGg7IGogPCBsZW4yOyBqKyspIHtcblx0XHRcdFx0cCA9IHBhcnRzW2ldW2pdO1xuXHRcdFx0XHRjdHhbaiA/ICdsaW5lVG8nIDogJ21vdmVUbyddKHAueCwgcC55KTtcblx0XHRcdH1cblx0XHRcdGlmIChjbG9zZWQpIHtcblx0XHRcdFx0Y3R4LmNsb3NlUGF0aCgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMuX2ZpbGxTdHJva2UoY3R4LCBsYXllcik7XG5cblx0XHQvLyBUT0RPIG9wdGltaXphdGlvbjogMSBmaWxsL3N0cm9rZSBmb3IgYWxsIGZlYXR1cmVzIHdpdGggZXF1YWwgc3R5bGUgaW5zdGVhZCBvZiAxIGZvciBlYWNoIGZlYXR1cmVcblx0fSxcblxuXHRfdXBkYXRlQ2lyY2xlOiBmdW5jdGlvbiAobGF5ZXIpIHtcblxuXHRcdGlmIChsYXllci5fZW1wdHkoKSkgeyByZXR1cm47IH1cblxuXHRcdHZhciBwID0gbGF5ZXIuX3BvaW50LFxuXHRcdCAgICBjdHggPSB0aGlzLl9jdHgsXG5cdFx0ICAgIHIgPSBsYXllci5fcmFkaXVzLFxuXHRcdCAgICBzID0gKGxheWVyLl9yYWRpdXNZIHx8IHIpIC8gcjtcblxuXHRcdGlmIChzICE9PSAxKSB7XG5cdFx0XHRjdHguc2F2ZSgpO1xuXHRcdFx0Y3R4LnNjYWxlKDEsIHMpO1xuXHRcdH1cblxuXHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRjdHguYXJjKHAueCwgcC55IC8gcywgciwgMCwgTWF0aC5QSSAqIDIsIGZhbHNlKTtcblxuXHRcdGlmIChzICE9PSAxKSB7XG5cdFx0XHRjdHgucmVzdG9yZSgpO1xuXHRcdH1cblxuXHRcdHRoaXMuX2ZpbGxTdHJva2UoY3R4LCBsYXllcik7XG5cdH0sXG5cblx0X2ZpbGxTdHJva2U6IGZ1bmN0aW9uIChjdHgsIGxheWVyKSB7XG5cdFx0dmFyIGNsZWFyID0gdGhpcy5fY2xlYXIsXG5cdFx0ICAgIG9wdGlvbnMgPSBsYXllci5vcHRpb25zO1xuXG5cdFx0Y3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IGNsZWFyID8gJ2Rlc3RpbmF0aW9uLW91dCcgOiAnc291cmNlLW92ZXInO1xuXG5cdFx0aWYgKG9wdGlvbnMuZmlsbCkge1xuXHRcdFx0Y3R4Lmdsb2JhbEFscGhhID0gY2xlYXIgPyAxIDogb3B0aW9ucy5maWxsT3BhY2l0eTtcblx0XHRcdGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLmZpbGxDb2xvciB8fCBvcHRpb25zLmNvbG9yO1xuXHRcdFx0Y3R4LmZpbGwoJ2V2ZW5vZGQnKTtcblx0XHR9XG5cblx0XHRpZiAob3B0aW9ucy5zdHJva2UpIHtcblx0XHRcdGN0eC5nbG9iYWxBbHBoYSA9IGNsZWFyID8gMSA6IG9wdGlvbnMub3BhY2l0eTtcblxuXHRcdFx0Ly8gaWYgY2xlYXJpbmcgc2hhcGUsIGRvIGl0IHdpdGggdGhlIHByZXZpb3VzbHkgZHJhd24gbGluZSB3aWR0aFxuXHRcdFx0bGF5ZXIuX3ByZXZXZWlnaHQgPSBjdHgubGluZVdpZHRoID0gY2xlYXIgPyBsYXllci5fcHJldldlaWdodCArIDEgOiBvcHRpb25zLndlaWdodDtcblxuXHRcdFx0Y3R4LnN0cm9rZVN0eWxlID0gb3B0aW9ucy5jb2xvcjtcblx0XHRcdGN0eC5saW5lQ2FwID0gb3B0aW9ucy5saW5lQ2FwO1xuXHRcdFx0Y3R4LmxpbmVKb2luID0gb3B0aW9ucy5saW5lSm9pbjtcblx0XHRcdGN0eC5zdHJva2UoKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gQ2FudmFzIG9idmlvdXNseSBkb2Vzbid0IGhhdmUgbW91c2UgZXZlbnRzIGZvciBpbmRpdmlkdWFsIGRyYXduIG9iamVjdHMsXG5cdC8vIHNvIHdlIGVtdWxhdGUgdGhhdCBieSBjYWxjdWxhdGluZyB3aGF0J3MgdW5kZXIgdGhlIG1vdXNlIG9uIG1vdXNlbW92ZS9jbGljayBtYW51YWxseVxuXG5cdF9vbkNsaWNrOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBwb2ludCA9IHRoaXMuX21hcC5tb3VzZUV2ZW50VG9MYXllclBvaW50KGUpO1xuXG5cdFx0Zm9yICh2YXIgaWQgaW4gdGhpcy5fbGF5ZXJzKSB7XG5cdFx0XHRpZiAodGhpcy5fbGF5ZXJzW2lkXS5fY29udGFpbnNQb2ludChwb2ludCkpIHtcblx0XHRcdFx0dGhpcy5fbGF5ZXJzW2lkXS5fZmlyZU1vdXNlRXZlbnQoZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdF9vbk1vdXNlTW92ZTogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAoIXRoaXMuX21hcCB8fCB0aGlzLl9tYXAuX2FuaW1hdGluZ1pvb20pIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIgcG9pbnQgPSB0aGlzLl9tYXAubW91c2VFdmVudFRvTGF5ZXJQb2ludChlKTtcblxuXHRcdC8vIFRPRE8gZG9uJ3QgZG8gb24gZWFjaCBtb3ZlIGV2ZW50LCB0aHJvdHRsZSBzaW5jZSBpdCdzIGV4cGVuc2l2ZVxuXHRcdGZvciAodmFyIGlkIGluIHRoaXMuX2xheWVycykge1xuXHRcdFx0dGhpcy5faGFuZGxlSG92ZXIodGhpcy5fbGF5ZXJzW2lkXSwgZSwgcG9pbnQpO1xuXHRcdH1cblx0fSxcblxuXHRfaGFuZGxlSG92ZXI6IGZ1bmN0aW9uIChsYXllciwgZSwgcG9pbnQpIHtcblx0XHRpZiAoIWxheWVyLm9wdGlvbnMuY2xpY2thYmxlKSB7IHJldHVybjsgfVxuXG5cdFx0aWYgKGxheWVyLl9jb250YWluc1BvaW50KHBvaW50KSkge1xuXHRcdFx0Ly8gaWYgd2UganVzdCBnb3QgaW5zaWRlIHRoZSBsYXllciwgZmlyZSBtb3VzZW92ZXJcblx0XHRcdGlmICghbGF5ZXIuX21vdXNlSW5zaWRlKSB7XG5cdFx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWNsaWNrYWJsZScpOyAvLyBjaGFuZ2UgY3Vyc29yXG5cdFx0XHRcdGxheWVyLl9maXJlTW91c2VFdmVudChlLCAnbW91c2VvdmVyJyk7XG5cdFx0XHRcdGxheWVyLl9tb3VzZUluc2lkZSA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHQvLyBmaXJlIG1vdXNlbW92ZVxuXHRcdFx0bGF5ZXIuX2ZpcmVNb3VzZUV2ZW50KGUpO1xuXG5cdFx0fSBlbHNlIGlmIChsYXllci5fbW91c2VJbnNpZGUpIHtcblx0XHRcdC8vIGlmIHdlJ3JlIGxlYXZpbmcgdGhlIGxheWVyLCBmaXJlIG1vdXNlb3V0XG5cdFx0XHRMLkRvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC1jbGlja2FibGUnKTtcblx0XHRcdGxheWVyLl9maXJlTW91c2VFdmVudChlLCAnbW91c2VvdXQnKTtcblx0XHRcdGxheWVyLl9tb3VzZUluc2lkZSA9IGZhbHNlO1xuXHRcdH1cblx0fSxcblxuXHQvLyBUT0RPIF9icmluZ1RvRnJvbnQgJiBfYnJpbmdUb0JhY2ssIHByZXR0eSB0cmlja3lcblxuXHRfYnJpbmdUb0Zyb250OiBMLlV0aWwuZmFsc2VGbixcblx0X2JyaW5nVG9CYWNrOiBMLlV0aWwuZmFsc2VGblxufSk7XG5cbkwuQnJvd3Nlci5jYW52YXMgPSAoZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gISFkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKS5nZXRDb250ZXh0O1xufSgpKTtcblxuTC5jYW52YXMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuXHRyZXR1cm4gTC5Ccm93c2VyLmNhbnZhcyA/IG5ldyBMLkNhbnZhcyhvcHRpb25zKSA6IG51bGw7XG59O1xuXG5MLlBvbHlsaW5lLnByb3RvdHlwZS5fY29udGFpbnNQb2ludCA9IGZ1bmN0aW9uIChwLCBjbG9zZWQpIHtcblx0dmFyIGksIGosIGssIGxlbiwgbGVuMiwgcGFydCxcblx0ICAgIHcgPSB0aGlzLl9jbGlja1RvbGVyYW5jZSgpO1xuXG5cdGlmICghdGhpcy5fcHhCb3VuZHMuY29udGFpbnMocCkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0Ly8gaGl0IGRldGVjdGlvbiBmb3IgcG9seWxpbmVzXG5cdGZvciAoaSA9IDAsIGxlbiA9IHRoaXMuX3BhcnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0cGFydCA9IHRoaXMuX3BhcnRzW2ldO1xuXG5cdFx0Zm9yIChqID0gMCwgbGVuMiA9IHBhcnQubGVuZ3RoLCBrID0gbGVuMiAtIDE7IGogPCBsZW4yOyBrID0gaisrKSB7XG5cdFx0XHRpZiAoIWNsb3NlZCAmJiAoaiA9PT0gMCkpIHsgY29udGludWU7IH1cblxuXHRcdFx0aWYgKEwuTGluZVV0aWwucG9pbnRUb1NlZ21lbnREaXN0YW5jZShwLCBwYXJ0W2tdLCBwYXJ0W2pdKSA8PSB3KSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRyZXR1cm4gZmFsc2U7XG59O1xuXG5MLlBvbHlnb24ucHJvdG90eXBlLl9jb250YWluc1BvaW50ID0gZnVuY3Rpb24gKHApIHtcblx0dmFyIGluc2lkZSA9IGZhbHNlLFxuXHQgICAgcGFydCwgcDEsIHAyLCBpLCBqLCBrLCBsZW4sIGxlbjI7XG5cblx0aWYgKCF0aGlzLl9weEJvdW5kcy5jb250YWlucyhwKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHQvLyByYXkgY2FzdGluZyBhbGdvcml0aG0gZm9yIGRldGVjdGluZyBpZiBwb2ludCBpcyBpbiBwb2x5Z29uXG5cdGZvciAoaSA9IDAsIGxlbiA9IHRoaXMuX3BhcnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0cGFydCA9IHRoaXMuX3BhcnRzW2ldO1xuXG5cdFx0Zm9yIChqID0gMCwgbGVuMiA9IHBhcnQubGVuZ3RoLCBrID0gbGVuMiAtIDE7IGogPCBsZW4yOyBrID0gaisrKSB7XG5cdFx0XHRwMSA9IHBhcnRbal07XG5cdFx0XHRwMiA9IHBhcnRba107XG5cblx0XHRcdGlmICgoKHAxLnkgPiBwLnkpICE9PSAocDIueSA+IHAueSkpICYmIChwLnggPCAocDIueCAtIHAxLngpICogKHAueSAtIHAxLnkpIC8gKHAyLnkgLSBwMS55KSArIHAxLngpKSB7XG5cdFx0XHRcdGluc2lkZSA9ICFpbnNpZGU7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gYWxzbyBjaGVjayBpZiBpdCdzIG9uIHBvbHlnb24gc3Ryb2tlXG5cdHJldHVybiBpbnNpZGUgfHwgTC5Qb2x5bGluZS5wcm90b3R5cGUuX2NvbnRhaW5zUG9pbnQuY2FsbCh0aGlzLCBwLCB0cnVlKTtcbn07XG5cbkwuQ2lyY2xlTWFya2VyLnByb3RvdHlwZS5fY29udGFpbnNQb2ludCA9IGZ1bmN0aW9uIChwKSB7XG5cdHJldHVybiBwLmRpc3RhbmNlVG8odGhpcy5fcG9pbnQpIDw9IHRoaXMuX3JhZGl1cyArIHRoaXMuX2NsaWNrVG9sZXJhbmNlKCk7XG59O1xuXG4vKlxyXG4gKiBMLkdlb0pTT04gdHVybnMgYW55IEdlb0pTT04gZGF0YSBpbnRvIGEgTGVhZmxldCBsYXllci5cclxuICovXHJcblxyXG5MLkdlb0pTT04gPSBMLkZlYXR1cmVHcm91cC5leHRlbmQoe1xyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAoZ2VvanNvbiwgb3B0aW9ucykge1xyXG5cdFx0TC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuXHRcdHRoaXMuX2xheWVycyA9IHt9O1xyXG5cclxuXHRcdGlmIChnZW9qc29uKSB7XHJcblx0XHRcdHRoaXMuYWRkRGF0YShnZW9qc29uKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRhZGREYXRhOiBmdW5jdGlvbiAoZ2VvanNvbikge1xyXG5cdFx0dmFyIGZlYXR1cmVzID0gTC5VdGlsLmlzQXJyYXkoZ2VvanNvbikgPyBnZW9qc29uIDogZ2VvanNvbi5mZWF0dXJlcyxcclxuXHRcdCAgICBpLCBsZW4sIGZlYXR1cmU7XHJcblxyXG5cdFx0aWYgKGZlYXR1cmVzKSB7XHJcblx0XHRcdGZvciAoaSA9IDAsIGxlbiA9IGZlYXR1cmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0Ly8gT25seSBhZGQgdGhpcyBpZiBnZW9tZXRyeSBvciBnZW9tZXRyaWVzIGFyZSBzZXQgYW5kIG5vdCBudWxsXHJcblx0XHRcdFx0ZmVhdHVyZSA9IGZlYXR1cmVzW2ldO1xyXG5cdFx0XHRcdGlmIChmZWF0dXJlLmdlb21ldHJpZXMgfHwgZmVhdHVyZS5nZW9tZXRyeSB8fCBmZWF0dXJlLmZlYXR1cmVzIHx8IGZlYXR1cmUuY29vcmRpbmF0ZXMpIHtcclxuXHRcdFx0XHRcdHRoaXMuYWRkRGF0YShmZWF0dXJlKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMuZmlsdGVyICYmICFvcHRpb25zLmZpbHRlcihnZW9qc29uKSkgeyByZXR1cm47IH1cclxuXHJcblx0XHR2YXIgbGF5ZXIgPSBMLkdlb0pTT04uZ2VvbWV0cnlUb0xheWVyKGdlb2pzb24sIG9wdGlvbnMpO1xyXG5cdFx0bGF5ZXIuZmVhdHVyZSA9IEwuR2VvSlNPTi5hc0ZlYXR1cmUoZ2VvanNvbik7XHJcblxyXG5cdFx0bGF5ZXIuZGVmYXVsdE9wdGlvbnMgPSBsYXllci5vcHRpb25zO1xyXG5cdFx0dGhpcy5yZXNldFN0eWxlKGxheWVyKTtcclxuXHJcblx0XHRpZiAob3B0aW9ucy5vbkVhY2hGZWF0dXJlKSB7XHJcblx0XHRcdG9wdGlvbnMub25FYWNoRmVhdHVyZShnZW9qc29uLCBsYXllcik7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuYWRkTGF5ZXIobGF5ZXIpO1xyXG5cdH0sXHJcblxyXG5cdHJlc2V0U3R5bGU6IGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0Ly8gcmVzZXQgYW55IGN1c3RvbSBzdHlsZXNcclxuXHRcdGxheWVyLm9wdGlvbnMgPSBsYXllci5kZWZhdWx0T3B0aW9ucztcclxuXHRcdHRoaXMuX3NldExheWVyU3R5bGUobGF5ZXIsIHRoaXMub3B0aW9ucy5zdHlsZSk7XHJcblx0fSxcclxuXHJcblx0c2V0U3R5bGU6IGZ1bmN0aW9uIChzdHlsZSkge1xyXG5cdFx0dGhpcy5lYWNoTGF5ZXIoZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHRcdHRoaXMuX3NldExheWVyU3R5bGUobGF5ZXIsIHN0eWxlKTtcclxuXHRcdH0sIHRoaXMpO1xyXG5cdH0sXHJcblxyXG5cdF9zZXRMYXllclN0eWxlOiBmdW5jdGlvbiAobGF5ZXIsIHN0eWxlKSB7XHJcblx0XHRpZiAodHlwZW9mIHN0eWxlID09PSAnZnVuY3Rpb24nKSB7XHJcblx0XHRcdHN0eWxlID0gc3R5bGUobGF5ZXIuZmVhdHVyZSk7XHJcblx0XHR9XHJcblx0XHRpZiAobGF5ZXIuc2V0U3R5bGUpIHtcclxuXHRcdFx0bGF5ZXIuc2V0U3R5bGUoc3R5bGUpO1xyXG5cdFx0fVxyXG5cdH1cclxufSk7XHJcblxyXG5MLmV4dGVuZChMLkdlb0pTT04sIHtcclxuXHRnZW9tZXRyeVRvTGF5ZXI6IGZ1bmN0aW9uIChnZW9qc29uLCBvcHRpb25zKSB7XHJcblxyXG5cdFx0dmFyIGdlb21ldHJ5ID0gZ2VvanNvbi50eXBlID09PSAnRmVhdHVyZScgPyBnZW9qc29uLmdlb21ldHJ5IDogZ2VvanNvbixcclxuXHRcdCAgICBjb29yZHMgPSBnZW9tZXRyeS5jb29yZGluYXRlcyxcclxuXHRcdCAgICBsYXllcnMgPSBbXSxcclxuXHRcdCAgICBwb2ludFRvTGF5ZXIgPSBvcHRpb25zICYmIG9wdGlvbnMucG9pbnRUb0xheWVyLFxyXG5cdFx0ICAgIGNvb3Jkc1RvTGF0TG5nID0gb3B0aW9ucyAmJiBvcHRpb25zLmNvb3Jkc1RvTGF0TG5nIHx8IHRoaXMuY29vcmRzVG9MYXRMbmcsXHJcblx0XHQgICAgbGF0bG5nLCBsYXRsbmdzLCBpLCBsZW47XHJcblxyXG5cdFx0c3dpdGNoIChnZW9tZXRyeS50eXBlKSB7XHJcblx0XHRjYXNlICdQb2ludCc6XHJcblx0XHRcdGxhdGxuZyA9IGNvb3Jkc1RvTGF0TG5nKGNvb3Jkcyk7XHJcblx0XHRcdHJldHVybiBwb2ludFRvTGF5ZXIgPyBwb2ludFRvTGF5ZXIoZ2VvanNvbiwgbGF0bG5nKSA6IG5ldyBMLk1hcmtlcihsYXRsbmcpO1xyXG5cclxuXHRcdGNhc2UgJ011bHRpUG9pbnQnOlxyXG5cdFx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjb29yZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0XHRsYXRsbmcgPSBjb29yZHNUb0xhdExuZyhjb29yZHNbaV0pO1xyXG5cdFx0XHRcdGxheWVycy5wdXNoKHBvaW50VG9MYXllciA/IHBvaW50VG9MYXllcihnZW9qc29uLCBsYXRsbmcpIDogbmV3IEwuTWFya2VyKGxhdGxuZykpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiBuZXcgTC5GZWF0dXJlR3JvdXAobGF5ZXJzKTtcclxuXHJcblx0XHRjYXNlICdMaW5lU3RyaW5nJzpcclxuXHRcdGNhc2UgJ011bHRpTGluZVN0cmluZyc6XHJcblx0XHRcdGxhdGxuZ3MgPSB0aGlzLmNvb3Jkc1RvTGF0TG5ncyhjb29yZHMsIGdlb21ldHJ5LnR5cGUgPT09ICdMaW5lU3RyaW5nJyA/IDAgOiAxLCBjb29yZHNUb0xhdExuZyk7XHJcblx0XHRcdHJldHVybiBuZXcgTC5Qb2x5bGluZShsYXRsbmdzLCBvcHRpb25zKTtcclxuXHJcblx0XHRjYXNlICdQb2x5Z29uJzpcclxuXHRcdGNhc2UgJ011bHRpUG9seWdvbic6XHJcblx0XHRcdGxhdGxuZ3MgPSB0aGlzLmNvb3Jkc1RvTGF0TG5ncyhjb29yZHMsIGdlb21ldHJ5LnR5cGUgPT09ICdQb2x5Z29uJyA/IDEgOiAyLCBjb29yZHNUb0xhdExuZyk7XHJcblx0XHRcdHJldHVybiBuZXcgTC5Qb2x5Z29uKGxhdGxuZ3MsIG9wdGlvbnMpO1xyXG5cclxuXHRcdGNhc2UgJ0dlb21ldHJ5Q29sbGVjdGlvbic6XHJcblx0XHRcdGZvciAoaSA9IDAsIGxlbiA9IGdlb21ldHJ5Lmdlb21ldHJpZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHJcblx0XHRcdFx0bGF5ZXJzLnB1c2godGhpcy5nZW9tZXRyeVRvTGF5ZXIoe1xyXG5cdFx0XHRcdFx0Z2VvbWV0cnk6IGdlb21ldHJ5Lmdlb21ldHJpZXNbaV0sXHJcblx0XHRcdFx0XHR0eXBlOiAnRmVhdHVyZScsXHJcblx0XHRcdFx0XHRwcm9wZXJ0aWVzOiBnZW9qc29uLnByb3BlcnRpZXNcclxuXHRcdFx0XHR9LCBvcHRpb25zKSk7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIG5ldyBMLkZlYXR1cmVHcm91cChsYXllcnMpO1xyXG5cclxuXHRcdGRlZmF1bHQ6XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcignSW52YWxpZCBHZW9KU09OIG9iamVjdC4nKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRjb29yZHNUb0xhdExuZzogZnVuY3Rpb24gKGNvb3Jkcykge1xyXG5cdFx0cmV0dXJuIG5ldyBMLkxhdExuZyhjb29yZHNbMV0sIGNvb3Jkc1swXSwgY29vcmRzWzJdKTtcclxuXHR9LFxyXG5cclxuXHRjb29yZHNUb0xhdExuZ3M6IGZ1bmN0aW9uIChjb29yZHMsIGxldmVsc0RlZXAsIGNvb3Jkc1RvTGF0TG5nKSB7XHJcblx0XHR2YXIgbGF0bG5ncyA9IFtdO1xyXG5cclxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBjb29yZHMubGVuZ3RoLCBsYXRsbmc7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRsYXRsbmcgPSBsZXZlbHNEZWVwID9cclxuXHRcdFx0ICAgICAgICB0aGlzLmNvb3Jkc1RvTGF0TG5ncyhjb29yZHNbaV0sIGxldmVsc0RlZXAgLSAxLCBjb29yZHNUb0xhdExuZykgOlxyXG5cdFx0XHQgICAgICAgIChjb29yZHNUb0xhdExuZyB8fCB0aGlzLmNvb3Jkc1RvTGF0TG5nKShjb29yZHNbaV0pO1xyXG5cclxuXHRcdFx0bGF0bG5ncy5wdXNoKGxhdGxuZyk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGxhdGxuZ3M7XHJcblx0fSxcclxuXHJcblx0bGF0TG5nVG9Db29yZHM6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHJldHVybiBsYXRsbmcuYWx0ICE9PSB1bmRlZmluZWQgP1xyXG5cdFx0XHRcdFtsYXRsbmcubG5nLCBsYXRsbmcubGF0LCBsYXRsbmcuYWx0XSA6XHJcblx0XHRcdFx0W2xhdGxuZy5sbmcsIGxhdGxuZy5sYXRdO1xyXG5cdH0sXHJcblxyXG5cdGxhdExuZ3NUb0Nvb3JkczogZnVuY3Rpb24gKGxhdGxuZ3MsIGxldmVsc0RlZXAsIGNsb3NlZCkge1xyXG5cdFx0dmFyIGNvb3JkcyA9IFtdO1xyXG5cclxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBsYXRsbmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdGNvb3Jkcy5wdXNoKGxldmVsc0RlZXAgP1xyXG5cdFx0XHRcdEwuR2VvSlNPTi5sYXRMbmdzVG9Db29yZHMobGF0bG5nc1tpXSwgbGV2ZWxzRGVlcCAtIDEsIGNsb3NlZCk6XHJcblx0XHRcdFx0TC5HZW9KU09OLmxhdExuZ1RvQ29vcmRzKGxhdGxuZ3NbaV0pKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIWxldmVsc0RlZXAgJiYgY2xvc2VkKSB7XHJcblx0XHRcdGNvb3Jkcy5wdXNoKGNvb3Jkc1swXSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGNvb3JkcztcclxuXHR9LFxyXG5cclxuXHRnZXRGZWF0dXJlOiBmdW5jdGlvbiAobGF5ZXIsIG5ld0dlb21ldHJ5KSB7XHJcblx0XHRyZXR1cm4gbGF5ZXIuZmVhdHVyZSA/XHJcblx0XHRcdFx0TC5leHRlbmQoe30sIGxheWVyLmZlYXR1cmUsIHtnZW9tZXRyeTogbmV3R2VvbWV0cnl9KSA6XHJcblx0XHRcdFx0TC5HZW9KU09OLmFzRmVhdHVyZShuZXdHZW9tZXRyeSk7XHJcblx0fSxcclxuXHJcblx0YXNGZWF0dXJlOiBmdW5jdGlvbiAoZ2VvSlNPTikge1xyXG5cdFx0aWYgKGdlb0pTT04udHlwZSA9PT0gJ0ZlYXR1cmUnKSB7XHJcblx0XHRcdHJldHVybiBnZW9KU09OO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB7XHJcblx0XHRcdHR5cGU6ICdGZWF0dXJlJyxcclxuXHRcdFx0cHJvcGVydGllczoge30sXHJcblx0XHRcdGdlb21ldHJ5OiBnZW9KU09OXHJcblx0XHR9O1xyXG5cdH1cclxufSk7XHJcblxyXG52YXIgUG9pbnRUb0dlb0pTT04gPSB7XHJcblx0dG9HZW9KU09OOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gTC5HZW9KU09OLmdldEZlYXR1cmUodGhpcywge1xyXG5cdFx0XHR0eXBlOiAnUG9pbnQnLFxyXG5cdFx0XHRjb29yZGluYXRlczogTC5HZW9KU09OLmxhdExuZ1RvQ29vcmRzKHRoaXMuZ2V0TGF0TG5nKCkpXHJcblx0XHR9KTtcclxuXHR9XHJcbn07XHJcblxyXG5MLk1hcmtlci5pbmNsdWRlKFBvaW50VG9HZW9KU09OKTtcclxuTC5DaXJjbGUuaW5jbHVkZShQb2ludFRvR2VvSlNPTik7XHJcbkwuQ2lyY2xlTWFya2VyLmluY2x1ZGUoUG9pbnRUb0dlb0pTT04pO1xyXG5cclxuTC5Qb2x5bGluZS5wcm90b3R5cGUudG9HZW9KU09OID0gZnVuY3Rpb24gKCkge1xyXG5cdHZhciBtdWx0aSA9ICF0aGlzLl9mbGF0KHRoaXMuX2xhdGxuZ3MpO1xyXG5cclxuXHR2YXIgY29vcmRzID0gTC5HZW9KU09OLmxhdExuZ3NUb0Nvb3Jkcyh0aGlzLl9sYXRsbmdzLCBtdWx0aSA/IDEgOiAwKTtcclxuXHJcblx0cmV0dXJuIEwuR2VvSlNPTi5nZXRGZWF0dXJlKHRoaXMsIHtcclxuXHRcdHR5cGU6IChtdWx0aSA/ICdNdWx0aScgOiAnJykgKyAnTGluZVN0cmluZycsXHJcblx0XHRjb29yZGluYXRlczogY29vcmRzXHJcblx0fSk7XHJcbn07XHJcblxyXG5MLlBvbHlnb24ucHJvdG90eXBlLnRvR2VvSlNPTiA9IGZ1bmN0aW9uICgpIHtcclxuXHR2YXIgaG9sZXMgPSAhdGhpcy5fZmxhdCh0aGlzLl9sYXRsbmdzKSxcclxuXHQgICAgbXVsdGkgPSBob2xlcyAmJiAhdGhpcy5fZmxhdCh0aGlzLl9sYXRsbmdzWzBdKTtcclxuXHJcblx0dmFyIGNvb3JkcyA9IEwuR2VvSlNPTi5sYXRMbmdzVG9Db29yZHModGhpcy5fbGF0bG5ncywgbXVsdGkgPyAyIDogaG9sZXMgPyAxIDogMCwgdHJ1ZSk7XHJcblxyXG5cdGlmIChob2xlcyAmJiB0aGlzLl9sYXRsbmdzLmxlbmd0aCA9PT0gMSkge1xyXG5cdFx0bXVsdGkgPSB0cnVlO1xyXG5cdFx0Y29vcmRzID0gW2Nvb3Jkc107XHJcblx0fVxyXG5cdGlmICghaG9sZXMpIHtcclxuXHRcdGNvb3JkcyA9IFtjb29yZHNdO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIEwuR2VvSlNPTi5nZXRGZWF0dXJlKHRoaXMsIHtcclxuXHRcdHR5cGU6IChtdWx0aSA/ICdNdWx0aScgOiAnJykgKyAnUG9seWdvbicsXHJcblx0XHRjb29yZGluYXRlczogY29vcmRzXHJcblx0fSk7XHJcbn07XHJcblxyXG5cclxuTC5MYXllckdyb3VwLmluY2x1ZGUoe1xyXG5cdHRvTXVsdGlQb2ludDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGNvb3JkcyA9IFtdO1xyXG5cclxuXHRcdHRoaXMuZWFjaExheWVyKGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0XHRjb29yZHMucHVzaChsYXllci50b0dlb0pTT04oKS5nZW9tZXRyeS5jb29yZGluYXRlcyk7XHJcblx0XHR9KTtcclxuXHJcblx0XHRyZXR1cm4gTC5HZW9KU09OLmdldEZlYXR1cmUodGhpcywge1xyXG5cdFx0XHR0eXBlOiAnTXVsdGlQb2ludCcsXHJcblx0XHRcdGNvb3JkaW5hdGVzOiBjb29yZHNcclxuXHRcdH0pO1xyXG5cdH0sXHJcblxyXG5cdHRvR2VvSlNPTjogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciB0eXBlID0gdGhpcy5mZWF0dXJlICYmIHRoaXMuZmVhdHVyZS5nZW9tZXRyeSAmJiB0aGlzLmZlYXR1cmUuZ2VvbWV0cnkudHlwZTtcclxuXHJcblx0XHRpZiAodHlwZSA9PT0gJ011bHRpUG9pbnQnKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLnRvTXVsdGlQb2ludCgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBpc0dlb21ldHJ5Q29sbGVjdGlvbiA9IHR5cGUgPT09ICdHZW9tZXRyeUNvbGxlY3Rpb24nLFxyXG5cdFx0XHRqc29ucyA9IFtdO1xyXG5cclxuXHRcdHRoaXMuZWFjaExheWVyKGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0XHRpZiAobGF5ZXIudG9HZW9KU09OKSB7XHJcblx0XHRcdFx0dmFyIGpzb24gPSBsYXllci50b0dlb0pTT04oKTtcclxuXHRcdFx0XHRqc29ucy5wdXNoKGlzR2VvbWV0cnlDb2xsZWN0aW9uID8ganNvbi5nZW9tZXRyeSA6IEwuR2VvSlNPTi5hc0ZlYXR1cmUoanNvbikpO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHJcblx0XHRpZiAoaXNHZW9tZXRyeUNvbGxlY3Rpb24pIHtcclxuXHRcdFx0cmV0dXJuIEwuR2VvSlNPTi5nZXRGZWF0dXJlKHRoaXMsIHtcclxuXHRcdFx0XHRnZW9tZXRyaWVzOiBqc29ucyxcclxuXHRcdFx0XHR0eXBlOiAnR2VvbWV0cnlDb2xsZWN0aW9uJ1xyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHR0eXBlOiAnRmVhdHVyZUNvbGxlY3Rpb24nLFxyXG5cdFx0XHRmZWF0dXJlczoganNvbnNcclxuXHRcdH07XHJcblx0fVxyXG59KTtcclxuXHJcbkwuZ2VvSnNvbiA9IGZ1bmN0aW9uIChnZW9qc29uLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBMLkdlb0pTT04oZ2VvanNvbiwgb3B0aW9ucyk7XHJcbn07XHJcblxuLypcclxuICogTC5Eb21FdmVudCBjb250YWlucyBmdW5jdGlvbnMgZm9yIHdvcmtpbmcgd2l0aCBET00gZXZlbnRzLlxyXG4gKiBJbnNwaXJlZCBieSBKb2huIFJlc2lnLCBEZWFuIEVkd2FyZHMgYW5kIFlVSSBhZGRFdmVudCBpbXBsZW1lbnRhdGlvbnMuXHJcbiAqL1xyXG5cclxudmFyIGV2ZW50c0tleSA9ICdfbGVhZmxldF9ldmVudHMnO1xyXG5cclxuTC5Eb21FdmVudCA9IHtcclxuXHJcblx0b246IGZ1bmN0aW9uIChvYmosIHR5cGVzLCBmbiwgY29udGV4dCkge1xyXG5cclxuXHRcdGlmICh0eXBlb2YgdHlwZXMgPT09ICdvYmplY3QnKSB7XHJcblx0XHRcdGZvciAodmFyIHR5cGUgaW4gdHlwZXMpIHtcclxuXHRcdFx0XHR0aGlzLl9vbihvYmosIHR5cGUsIHR5cGVzW3R5cGVdLCBmbik7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHR5cGVzID0gTC5VdGlsLnNwbGl0V29yZHModHlwZXMpO1xyXG5cclxuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHR5cGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0dGhpcy5fb24ob2JqLCB0eXBlc1tpXSwgZm4sIGNvbnRleHQpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0b2ZmOiBmdW5jdGlvbiAob2JqLCB0eXBlcywgZm4sIGNvbnRleHQpIHtcclxuXHJcblx0XHRpZiAodHlwZW9mIHR5cGVzID09PSAnb2JqZWN0Jykge1xyXG5cdFx0XHRmb3IgKHZhciB0eXBlIGluIHR5cGVzKSB7XHJcblx0XHRcdFx0dGhpcy5fb2ZmKG9iaiwgdHlwZSwgdHlwZXNbdHlwZV0sIGZuKTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dHlwZXMgPSBMLlV0aWwuc3BsaXRXb3Jkcyh0eXBlcyk7XHJcblxyXG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gdHlwZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0XHR0aGlzLl9vZmYob2JqLCB0eXBlc1tpXSwgZm4sIGNvbnRleHQpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X29uOiBmdW5jdGlvbiAob2JqLCB0eXBlLCBmbiwgY29udGV4dCkge1xyXG5cdFx0dmFyIGlkID0gdHlwZSArIEwuc3RhbXAoZm4pICsgKGNvbnRleHQgPyAnXycgKyBMLnN0YW1wKGNvbnRleHQpIDogJycpO1xyXG5cclxuXHRcdGlmIChvYmpbZXZlbnRzS2V5XSAmJiBvYmpbZXZlbnRzS2V5XVtpZF0pIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0XHR2YXIgaGFuZGxlciA9IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRcdHJldHVybiBmbi5jYWxsKGNvbnRleHQgfHwgb2JqLCBlIHx8IHdpbmRvdy5ldmVudCk7XHJcblx0XHR9O1xyXG5cclxuXHRcdHZhciBvcmlnaW5hbEhhbmRsZXIgPSBoYW5kbGVyO1xyXG5cclxuXHRcdGlmIChMLkJyb3dzZXIucG9pbnRlciAmJiB0eXBlLmluZGV4T2YoJ3RvdWNoJykgPT09IDApIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuYWRkUG9pbnRlckxpc3RlbmVyKG9iaiwgdHlwZSwgaGFuZGxlciwgaWQpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKEwuQnJvd3Nlci50b3VjaCAmJiAodHlwZSA9PT0gJ2RibGNsaWNrJykgJiYgdGhpcy5hZGREb3VibGVUYXBMaXN0ZW5lcikge1xyXG5cdFx0XHR0aGlzLmFkZERvdWJsZVRhcExpc3RlbmVyKG9iaiwgaGFuZGxlciwgaWQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICgnYWRkRXZlbnRMaXN0ZW5lcicgaW4gb2JqKSB7XHJcblxyXG5cdFx0XHRpZiAodHlwZSA9PT0gJ21vdXNld2hlZWwnKSB7XHJcblx0XHRcdFx0b2JqLmFkZEV2ZW50TGlzdGVuZXIoJ0RPTU1vdXNlU2Nyb2xsJywgaGFuZGxlciwgZmFsc2UpO1xyXG5cdFx0XHRcdG9iai5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIGZhbHNlKTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoKHR5cGUgPT09ICdtb3VzZWVudGVyJykgfHwgKHR5cGUgPT09ICdtb3VzZWxlYXZlJykpIHtcclxuXHRcdFx0XHRoYW5kbGVyID0gZnVuY3Rpb24gKGUpIHtcclxuXHRcdFx0XHRcdGUgPSBlIHx8IHdpbmRvdy5ldmVudDtcclxuXHRcdFx0XHRcdGlmICghTC5Eb21FdmVudC5fY2hlY2tNb3VzZShvYmosIGUpKSB7IHJldHVybjsgfVxyXG5cdFx0XHRcdFx0cmV0dXJuIG9yaWdpbmFsSGFuZGxlcihlKTtcclxuXHRcdFx0XHR9O1xyXG5cdFx0XHRcdG9iai5hZGRFdmVudExpc3RlbmVyKHR5cGUgPT09ICdtb3VzZWVudGVyJyA/ICdtb3VzZW92ZXInIDogJ21vdXNlb3V0JywgaGFuZGxlciwgZmFsc2UpO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRpZiAodHlwZSA9PT0gJ2NsaWNrJyAmJiBMLkJyb3dzZXIuYW5kcm9pZCkge1xyXG5cdFx0XHRcdFx0aGFuZGxlciA9IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRcdFx0XHRcdHJldHVybiBMLkRvbUV2ZW50Ll9maWx0ZXJDbGljayhlLCBvcmlnaW5hbEhhbmRsZXIpO1xyXG5cdFx0XHRcdFx0fTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0b2JqLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciwgZmFsc2UpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIGlmICgnYXR0YWNoRXZlbnQnIGluIG9iaikge1xyXG5cdFx0XHRvYmouYXR0YWNoRXZlbnQoJ29uJyArIHR5cGUsIGhhbmRsZXIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdG9ialtldmVudHNLZXldID0gb2JqW2V2ZW50c0tleV0gfHwge307XHJcblx0XHRvYmpbZXZlbnRzS2V5XVtpZF0gPSBoYW5kbGVyO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF9vZmY6IGZ1bmN0aW9uIChvYmosIHR5cGUsIGZuLCBjb250ZXh0KSB7XHJcblxyXG5cdFx0dmFyIGlkID0gdHlwZSArIEwuc3RhbXAoZm4pICsgKGNvbnRleHQgPyAnXycgKyBMLnN0YW1wKGNvbnRleHQpIDogJycpLFxyXG5cdFx0ICAgIGhhbmRsZXIgPSBvYmpbZXZlbnRzS2V5XSAmJiBvYmpbZXZlbnRzS2V5XVtpZF07XHJcblxyXG5cdFx0aWYgKCFoYW5kbGVyKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0aWYgKEwuQnJvd3Nlci5wb2ludGVyICYmIHR5cGUuaW5kZXhPZigndG91Y2gnKSA9PT0gMCkge1xyXG5cdFx0XHR0aGlzLnJlbW92ZVBvaW50ZXJMaXN0ZW5lcihvYmosIHR5cGUsIGlkKTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKEwuQnJvd3Nlci50b3VjaCAmJiAodHlwZSA9PT0gJ2RibGNsaWNrJykgJiYgdGhpcy5yZW1vdmVEb3VibGVUYXBMaXN0ZW5lcikge1xyXG5cdFx0XHR0aGlzLnJlbW92ZURvdWJsZVRhcExpc3RlbmVyKG9iaiwgaWQpO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoJ3JlbW92ZUV2ZW50TGlzdGVuZXInIGluIG9iaikge1xyXG5cclxuXHRcdFx0aWYgKHR5cGUgPT09ICdtb3VzZXdoZWVsJykge1xyXG5cdFx0XHRcdG9iai5yZW1vdmVFdmVudExpc3RlbmVyKCdET01Nb3VzZVNjcm9sbCcsIGhhbmRsZXIsIGZhbHNlKTtcclxuXHRcdFx0XHRvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCBmYWxzZSk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdG9iai5yZW1vdmVFdmVudExpc3RlbmVyKFxyXG5cdFx0XHRcdFx0dHlwZSA9PT0gJ21vdXNlZW50ZXInID8gJ21vdXNlb3ZlcicgOlxyXG5cdFx0XHRcdFx0dHlwZSA9PT0gJ21vdXNlbGVhdmUnID8gJ21vdXNlb3V0JyA6IHR5cGUsIGhhbmRsZXIsIGZhbHNlKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSBpZiAoJ2RldGFjaEV2ZW50JyBpbiBvYmopIHtcclxuXHRcdFx0b2JqLmRldGFjaEV2ZW50KCdvbicgKyB0eXBlLCBoYW5kbGVyKTtcclxuXHRcdH1cclxuXHJcblx0XHRvYmpbZXZlbnRzS2V5XVtpZF0gPSBudWxsO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24gKGUpIHtcclxuXHJcblx0XHRpZiAoZS5zdG9wUHJvcGFnYXRpb24pIHtcclxuXHRcdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGUuY2FuY2VsQnViYmxlID0gdHJ1ZTtcclxuXHRcdH1cclxuXHRcdEwuRG9tRXZlbnQuX3NraXBwZWQoZSk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0ZGlzYWJsZVNjcm9sbFByb3BhZ2F0aW9uOiBmdW5jdGlvbiAoZWwpIHtcclxuXHRcdHJldHVybiBMLkRvbUV2ZW50Lm9uKGVsLCAnbW91c2V3aGVlbCBNb3pNb3VzZVBpeGVsU2Nyb2xsJywgTC5Eb21FdmVudC5zdG9wUHJvcGFnYXRpb24pO1xyXG5cdH0sXHJcblxyXG5cdGRpc2FibGVDbGlja1Byb3BhZ2F0aW9uOiBmdW5jdGlvbiAoZWwpIHtcclxuXHRcdHZhciBzdG9wID0gTC5Eb21FdmVudC5zdG9wUHJvcGFnYXRpb247XHJcblxyXG5cdFx0TC5Eb21FdmVudC5vbihlbCwgTC5EcmFnZ2FibGUuU1RBUlQuam9pbignICcpLCBzdG9wKTtcclxuXHJcblx0XHRyZXR1cm4gTC5Eb21FdmVudC5vbihlbCwge1xyXG5cdFx0XHRjbGljazogTC5Eb21FdmVudC5fZmFrZVN0b3AsXHJcblx0XHRcdGRibGNsaWNrOiBzdG9wXHJcblx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHRwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24gKGUpIHtcclxuXHJcblx0XHRpZiAoZS5wcmV2ZW50RGVmYXVsdCkge1xyXG5cdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRlLnJldHVyblZhbHVlID0gZmFsc2U7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRzdG9wOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0cmV0dXJuIEwuRG9tRXZlbnRcclxuXHRcdFx0LnByZXZlbnREZWZhdWx0KGUpXHJcblx0XHRcdC5zdG9wUHJvcGFnYXRpb24oZSk7XHJcblx0fSxcclxuXHJcblx0Z2V0TW91c2VQb3NpdGlvbjogZnVuY3Rpb24gKGUsIGNvbnRhaW5lcikge1xyXG5cdFx0aWYgKCFjb250YWluZXIpIHtcclxuXHRcdFx0cmV0dXJuIG5ldyBMLlBvaW50KGUuY2xpZW50WCwgZS5jbGllbnRZKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgcmVjdCA9IGNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuXHJcblx0XHRyZXR1cm4gbmV3IEwuUG9pbnQoXHJcblx0XHRcdGUuY2xpZW50WCAtIHJlY3QubGVmdCAtIGNvbnRhaW5lci5jbGllbnRMZWZ0LFxyXG5cdFx0XHRlLmNsaWVudFkgLSByZWN0LnRvcCAtIGNvbnRhaW5lci5jbGllbnRUb3ApO1xyXG5cdH0sXHJcblxyXG5cdGdldFdoZWVsRGVsdGE6IGZ1bmN0aW9uIChlKSB7XHJcblxyXG5cdFx0dmFyIGRlbHRhID0gMDtcclxuXHJcblx0XHRpZiAoZS53aGVlbERlbHRhKSB7XHJcblx0XHRcdGRlbHRhID0gZS53aGVlbERlbHRhIC8gMTIwO1xyXG5cdFx0fVxyXG5cdFx0aWYgKGUuZGV0YWlsKSB7XHJcblx0XHRcdGRlbHRhID0gLWUuZGV0YWlsIC8gMztcclxuXHRcdH1cclxuXHRcdHJldHVybiBkZWx0YTtcclxuXHR9LFxyXG5cclxuXHRfc2tpcEV2ZW50czoge30sXHJcblxyXG5cdF9mYWtlU3RvcDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdC8vIGZha2VzIHN0b3BQcm9wYWdhdGlvbiBieSBzZXR0aW5nIGEgc3BlY2lhbCBldmVudCBmbGFnLCBjaGVja2VkL3Jlc2V0IHdpdGggTC5Eb21FdmVudC5fc2tpcHBlZChlKVxyXG5cdFx0TC5Eb21FdmVudC5fc2tpcEV2ZW50c1tlLnR5cGVdID0gdHJ1ZTtcclxuXHR9LFxyXG5cclxuXHRfc2tpcHBlZDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdHZhciBza2lwcGVkID0gdGhpcy5fc2tpcEV2ZW50c1tlLnR5cGVdO1xyXG5cdFx0Ly8gcmVzZXQgd2hlbiBjaGVja2luZywgYXMgaXQncyBvbmx5IHVzZWQgaW4gbWFwIGNvbnRhaW5lciBhbmQgcHJvcGFnYXRlcyBvdXRzaWRlIG9mIHRoZSBtYXBcclxuXHRcdHRoaXMuX3NraXBFdmVudHNbZS50eXBlXSA9IGZhbHNlO1xyXG5cdFx0cmV0dXJuIHNraXBwZWQ7XHJcblx0fSxcclxuXHJcblx0Ly8gY2hlY2sgaWYgZWxlbWVudCByZWFsbHkgbGVmdC9lbnRlcmVkIHRoZSBldmVudCB0YXJnZXQgKGZvciBtb3VzZWVudGVyL21vdXNlbGVhdmUpXHJcblx0X2NoZWNrTW91c2U6IGZ1bmN0aW9uIChlbCwgZSkge1xyXG5cclxuXHRcdHZhciByZWxhdGVkID0gZS5yZWxhdGVkVGFyZ2V0O1xyXG5cclxuXHRcdGlmICghcmVsYXRlZCkgeyByZXR1cm4gdHJ1ZTsgfVxyXG5cclxuXHRcdHRyeSB7XHJcblx0XHRcdHdoaWxlIChyZWxhdGVkICYmIChyZWxhdGVkICE9PSBlbCkpIHtcclxuXHRcdFx0XHRyZWxhdGVkID0gcmVsYXRlZC5wYXJlbnROb2RlO1xyXG5cdFx0XHR9XHJcblx0XHR9IGNhdGNoIChlcnIpIHtcclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIChyZWxhdGVkICE9PSBlbCk7XHJcblx0fSxcclxuXHJcblx0Ly8gdGhpcyBpcyBhIGhvcnJpYmxlIHdvcmthcm91bmQgZm9yIGEgYnVnIGluIEFuZHJvaWQgd2hlcmUgYSBzaW5nbGUgdG91Y2ggdHJpZ2dlcnMgdHdvIGNsaWNrIGV2ZW50c1xyXG5cdF9maWx0ZXJDbGljazogZnVuY3Rpb24gKGUsIGhhbmRsZXIpIHtcclxuXHRcdHZhciB0aW1lU3RhbXAgPSAoZS50aW1lU3RhbXAgfHwgZS5vcmlnaW5hbEV2ZW50LnRpbWVTdGFtcCksXHJcblx0XHRcdGVsYXBzZWQgPSBMLkRvbUV2ZW50Ll9sYXN0Q2xpY2sgJiYgKHRpbWVTdGFtcCAtIEwuRG9tRXZlbnQuX2xhc3RDbGljayk7XHJcblxyXG5cdFx0Ly8gYXJlIHRoZXkgY2xvc2VyIHRvZ2V0aGVyIHRoYW4gNTAwbXMgeWV0IG1vcmUgdGhhbiAxMDBtcz9cclxuXHRcdC8vIEFuZHJvaWQgdHlwaWNhbGx5IHRyaWdnZXJzIHRoZW0gfjMwMG1zIGFwYXJ0IHdoaWxlIG11bHRpcGxlIGxpc3RlbmVyc1xyXG5cdFx0Ly8gb24gdGhlIHNhbWUgZXZlbnQgc2hvdWxkIGJlIHRyaWdnZXJlZCBmYXIgZmFzdGVyO1xyXG5cdFx0Ly8gb3IgY2hlY2sgaWYgY2xpY2sgaXMgc2ltdWxhdGVkIG9uIHRoZSBlbGVtZW50LCBhbmQgaWYgaXQgaXMsIHJlamVjdCBhbnkgbm9uLXNpbXVsYXRlZCBldmVudHNcclxuXHJcblx0XHRpZiAoKGVsYXBzZWQgJiYgZWxhcHNlZCA+IDEwMCAmJiBlbGFwc2VkIDwgNTAwKSB8fCAoZS50YXJnZXQuX3NpbXVsYXRlZENsaWNrICYmICFlLl9zaW11bGF0ZWQpKSB7XHJcblx0XHRcdEwuRG9tRXZlbnQuc3RvcChlKTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cdFx0TC5Eb21FdmVudC5fbGFzdENsaWNrID0gdGltZVN0YW1wO1xyXG5cclxuXHRcdHJldHVybiBoYW5kbGVyKGUpO1xyXG5cdH1cclxufTtcclxuXHJcbkwuRG9tRXZlbnQuYWRkTGlzdGVuZXIgPSBMLkRvbUV2ZW50Lm9uO1xyXG5MLkRvbUV2ZW50LnJlbW92ZUxpc3RlbmVyID0gTC5Eb21FdmVudC5vZmY7XHJcblxuLypcclxuICogTC5EcmFnZ2FibGUgYWxsb3dzIHlvdSB0byBhZGQgZHJhZ2dpbmcgY2FwYWJpbGl0aWVzIHRvIGFueSBlbGVtZW50LiBTdXBwb3J0cyBtb2JpbGUgZGV2aWNlcyB0b28uXHJcbiAqL1xyXG5cclxuTC5EcmFnZ2FibGUgPSBMLkV2ZW50ZWQuZXh0ZW5kKHtcclxuXHJcblx0c3RhdGljczoge1xyXG5cdFx0U1RBUlQ6IEwuQnJvd3Nlci50b3VjaCA/IFsndG91Y2hzdGFydCcsICdtb3VzZWRvd24nXSA6IFsnbW91c2Vkb3duJ10sXHJcblx0XHRFTkQ6IHtcclxuXHRcdFx0bW91c2Vkb3duOiAnbW91c2V1cCcsXHJcblx0XHRcdHRvdWNoc3RhcnQ6ICd0b3VjaGVuZCcsXHJcblx0XHRcdHBvaW50ZXJkb3duOiAndG91Y2hlbmQnLFxyXG5cdFx0XHRNU1BvaW50ZXJEb3duOiAndG91Y2hlbmQnXHJcblx0XHR9LFxyXG5cdFx0TU9WRToge1xyXG5cdFx0XHRtb3VzZWRvd246ICdtb3VzZW1vdmUnLFxyXG5cdFx0XHR0b3VjaHN0YXJ0OiAndG91Y2htb3ZlJyxcclxuXHRcdFx0cG9pbnRlcmRvd246ICd0b3VjaG1vdmUnLFxyXG5cdFx0XHRNU1BvaW50ZXJEb3duOiAndG91Y2htb3ZlJ1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChlbGVtZW50LCBkcmFnU3RhcnRUYXJnZXQpIHtcclxuXHRcdHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50O1xyXG5cdFx0dGhpcy5fZHJhZ1N0YXJ0VGFyZ2V0ID0gZHJhZ1N0YXJ0VGFyZ2V0IHx8IGVsZW1lbnQ7XHJcblx0fSxcclxuXHJcblx0ZW5hYmxlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fZW5hYmxlZCkgeyByZXR1cm47IH1cclxuXHJcblx0XHRMLkRvbUV2ZW50Lm9uKHRoaXMuX2RyYWdTdGFydFRhcmdldCwgTC5EcmFnZ2FibGUuU1RBUlQuam9pbignICcpLCB0aGlzLl9vbkRvd24sIHRoaXMpO1xyXG5cclxuXHRcdHRoaXMuX2VuYWJsZWQgPSB0cnVlO1xyXG5cdH0sXHJcblxyXG5cdGRpc2FibGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fZW5hYmxlZCkgeyByZXR1cm47IH1cclxuXHJcblx0XHRMLkRvbUV2ZW50Lm9mZih0aGlzLl9kcmFnU3RhcnRUYXJnZXQsIEwuRHJhZ2dhYmxlLlNUQVJULmpvaW4oJyAnKSwgdGhpcy5fb25Eb3duLCB0aGlzKTtcclxuXHJcblx0XHR0aGlzLl9lbmFibGVkID0gZmFsc2U7XHJcblx0XHR0aGlzLl9tb3ZlZCA9IGZhbHNlO1xyXG5cdH0sXHJcblxyXG5cdF9vbkRvd246IGZ1bmN0aW9uIChlKSB7XHJcblx0XHR0aGlzLl9tb3ZlZCA9IGZhbHNlO1xyXG5cclxuXHRcdGlmIChlLnNoaWZ0S2V5IHx8ICgoZS53aGljaCAhPT0gMSkgJiYgKGUuYnV0dG9uICE9PSAxKSAmJiAhZS50b3VjaGVzKSkgeyByZXR1cm47IH1cclxuXHJcblx0XHRMLkRvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbihlKTtcclxuXHJcblx0XHRpZiAoTC5EcmFnZ2FibGUuX2Rpc2FibGVkKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdEwuRG9tVXRpbC5kaXNhYmxlSW1hZ2VEcmFnKCk7XHJcblx0XHRMLkRvbVV0aWwuZGlzYWJsZVRleHRTZWxlY3Rpb24oKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbW92aW5nKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdHRoaXMuZmlyZSgnZG93bicpO1xyXG5cclxuXHRcdHZhciBmaXJzdCA9IGUudG91Y2hlcyA/IGUudG91Y2hlc1swXSA6IGU7XHJcblxyXG5cdFx0dGhpcy5fc3RhcnRQb2ludCA9IG5ldyBMLlBvaW50KGZpcnN0LmNsaWVudFgsIGZpcnN0LmNsaWVudFkpO1xyXG5cdFx0dGhpcy5fc3RhcnRQb3MgPSB0aGlzLl9uZXdQb3MgPSBMLkRvbVV0aWwuZ2V0UG9zaXRpb24odGhpcy5fZWxlbWVudCk7XHJcblxyXG5cdFx0TC5Eb21FdmVudFxyXG5cdFx0ICAgIC5vbihkb2N1bWVudCwgTC5EcmFnZ2FibGUuTU9WRVtlLnR5cGVdLCB0aGlzLl9vbk1vdmUsIHRoaXMpXHJcblx0XHQgICAgLm9uKGRvY3VtZW50LCBMLkRyYWdnYWJsZS5FTkRbZS50eXBlXSwgdGhpcy5fb25VcCwgdGhpcyk7XHJcblx0fSxcclxuXHJcblx0X29uTW92ZTogZnVuY3Rpb24gKGUpIHtcclxuXHRcdGlmIChlLnRvdWNoZXMgJiYgZS50b3VjaGVzLmxlbmd0aCA+IDEpIHtcclxuXHRcdFx0dGhpcy5fbW92ZWQgPSB0cnVlO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGZpcnN0ID0gKGUudG91Y2hlcyAmJiBlLnRvdWNoZXMubGVuZ3RoID09PSAxID8gZS50b3VjaGVzWzBdIDogZSksXHJcblx0XHQgICAgbmV3UG9pbnQgPSBuZXcgTC5Qb2ludChmaXJzdC5jbGllbnRYLCBmaXJzdC5jbGllbnRZKSxcclxuXHRcdCAgICBvZmZzZXQgPSBuZXdQb2ludC5zdWJ0cmFjdCh0aGlzLl9zdGFydFBvaW50KTtcclxuXHJcblx0XHRpZiAoIW9mZnNldC54ICYmICFvZmZzZXQueSkgeyByZXR1cm47IH1cclxuXHRcdGlmIChMLkJyb3dzZXIudG91Y2ggJiYgTWF0aC5hYnMob2Zmc2V0LngpICsgTWF0aC5hYnMob2Zmc2V0LnkpIDwgMykgeyByZXR1cm47IH1cclxuXHJcblx0XHRMLkRvbUV2ZW50LnByZXZlbnREZWZhdWx0KGUpO1xyXG5cclxuXHRcdGlmICghdGhpcy5fbW92ZWQpIHtcclxuXHRcdFx0dGhpcy5maXJlKCdkcmFnc3RhcnQnKTtcclxuXHJcblx0XHRcdHRoaXMuX21vdmVkID0gdHJ1ZTtcclxuXHRcdFx0dGhpcy5fc3RhcnRQb3MgPSBMLkRvbVV0aWwuZ2V0UG9zaXRpb24odGhpcy5fZWxlbWVudCkuc3VidHJhY3Qob2Zmc2V0KTtcclxuXHJcblx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyhkb2N1bWVudC5ib2R5LCAnbGVhZmxldC1kcmFnZ2luZycpO1xyXG5cdFx0XHRMLkRvbVV0aWwuYWRkQ2xhc3MoZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50LCAnbGVhZmxldC1kcmFnLXRhcmdldCcpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX25ld1BvcyA9IHRoaXMuX3N0YXJ0UG9zLmFkZChvZmZzZXQpO1xyXG5cdFx0dGhpcy5fbW92aW5nID0gdHJ1ZTtcclxuXHJcblx0XHRMLlV0aWwuY2FuY2VsQW5pbUZyYW1lKHRoaXMuX2FuaW1SZXF1ZXN0KTtcclxuXHRcdHRoaXMuX2FuaW1SZXF1ZXN0ID0gTC5VdGlsLnJlcXVlc3RBbmltRnJhbWUodGhpcy5fdXBkYXRlUG9zaXRpb24sIHRoaXMsIHRydWUsIHRoaXMuX2RyYWdTdGFydFRhcmdldCk7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZVBvc2l0aW9uOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLmZpcmUoJ3ByZWRyYWcnKTtcclxuXHRcdEwuRG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9lbGVtZW50LCB0aGlzLl9uZXdQb3MpO1xyXG5cdFx0dGhpcy5maXJlKCdkcmFnJyk7XHJcblx0fSxcclxuXHJcblx0X29uVXA6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRMLkRvbVV0aWwucmVtb3ZlQ2xhc3MoZG9jdW1lbnQuYm9keSwgJ2xlYWZsZXQtZHJhZ2dpbmcnKTtcclxuXHRcdEwuRG9tVXRpbC5yZW1vdmVDbGFzcyhlLnRhcmdldCB8fCBlLnNyY0VsZW1lbnQsICdsZWFmbGV0LWRyYWctdGFyZ2V0Jyk7XHJcblxyXG5cdFx0Zm9yICh2YXIgaSBpbiBMLkRyYWdnYWJsZS5NT1ZFKSB7XHJcblx0XHRcdEwuRG9tRXZlbnRcclxuXHRcdFx0ICAgIC5vZmYoZG9jdW1lbnQsIEwuRHJhZ2dhYmxlLk1PVkVbaV0sIHRoaXMuX29uTW92ZSwgdGhpcylcclxuXHRcdFx0ICAgIC5vZmYoZG9jdW1lbnQsIEwuRHJhZ2dhYmxlLkVORFtpXSwgdGhpcy5fb25VcCwgdGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0TC5Eb21VdGlsLmVuYWJsZUltYWdlRHJhZygpO1xyXG5cdFx0TC5Eb21VdGlsLmVuYWJsZVRleHRTZWxlY3Rpb24oKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbW92ZWQgJiYgdGhpcy5fbW92aW5nKSB7XHJcblx0XHRcdC8vIGVuc3VyZSBkcmFnIGlzIG5vdCBmaXJlZCBhZnRlciBkcmFnZW5kXHJcblx0XHRcdEwuVXRpbC5jYW5jZWxBbmltRnJhbWUodGhpcy5fYW5pbVJlcXVlc3QpO1xyXG5cclxuXHRcdFx0dGhpcy5maXJlKCdkcmFnZW5kJywge1xyXG5cdFx0XHRcdGRpc3RhbmNlOiB0aGlzLl9uZXdQb3MuZGlzdGFuY2VUbyh0aGlzLl9zdGFydFBvcylcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fbW92aW5nID0gZmFsc2U7XHJcblx0fVxyXG59KTtcclxuXG4vKlxuXHRMLkhhbmRsZXIgaXMgYSBiYXNlIGNsYXNzIGZvciBoYW5kbGVyIGNsYXNzZXMgdGhhdCBhcmUgdXNlZCBpbnRlcm5hbGx5IHRvIGluamVjdFxuXHRpbnRlcmFjdGlvbiBmZWF0dXJlcyBsaWtlIGRyYWdnaW5nIHRvIGNsYXNzZXMgbGlrZSBNYXAgYW5kIE1hcmtlci5cbiovXG5cbkwuSGFuZGxlciA9IEwuQ2xhc3MuZXh0ZW5kKHtcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG1hcCkge1xuXHRcdHRoaXMuX21hcCA9IG1hcDtcblx0fSxcblxuXHRlbmFibGU6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fZW5hYmxlZCkgeyByZXR1cm47IH1cblxuXHRcdHRoaXMuX2VuYWJsZWQgPSB0cnVlO1xuXHRcdHRoaXMuYWRkSG9va3MoKTtcblx0fSxcblxuXHRkaXNhYmxlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9lbmFibGVkKSB7IHJldHVybjsgfVxuXG5cdFx0dGhpcy5fZW5hYmxlZCA9IGZhbHNlO1xuXHRcdHRoaXMucmVtb3ZlSG9va3MoKTtcblx0fSxcblxuXHRlbmFibGVkOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuICEhdGhpcy5fZW5hYmxlZDtcblx0fVxufSk7XG5cbi8qXG4gKiBMLkhhbmRsZXIuTWFwRHJhZyBpcyB1c2VkIHRvIG1ha2UgdGhlIG1hcCBkcmFnZ2FibGUgKHdpdGggcGFubmluZyBpbmVydGlhKSwgZW5hYmxlZCBieSBkZWZhdWx0LlxuICovXG5cbkwuTWFwLm1lcmdlT3B0aW9ucyh7XG5cdGRyYWdnaW5nOiB0cnVlLFxuXG5cdGluZXJ0aWE6ICFMLkJyb3dzZXIuYW5kcm9pZDIzLFxuXHRpbmVydGlhRGVjZWxlcmF0aW9uOiAzNDAwLCAvLyBweC9zXjJcblx0aW5lcnRpYU1heFNwZWVkOiBJbmZpbml0eSwgLy8gcHgvc1xuXHRpbmVydGlhVGhyZXNob2xkOiBMLkJyb3dzZXIudG91Y2ggPyAzMiA6IDE4LCAvLyBtc1xuXHRlYXNlTGluZWFyaXR5OiAwLjI1LFxuXG5cdC8vIFRPRE8gcmVmYWN0b3IsIG1vdmUgdG8gQ1JTXG5cdHdvcmxkQ29weUp1bXA6IGZhbHNlXG59KTtcblxuTC5NYXAuRHJhZyA9IEwuSGFuZGxlci5leHRlbmQoe1xuXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5fZHJhZ2dhYmxlKSB7XG5cdFx0XHR2YXIgbWFwID0gdGhpcy5fbWFwO1xuXG5cdFx0XHR0aGlzLl9kcmFnZ2FibGUgPSBuZXcgTC5EcmFnZ2FibGUobWFwLl9tYXBQYW5lLCBtYXAuX2NvbnRhaW5lcik7XG5cblx0XHRcdHRoaXMuX2RyYWdnYWJsZS5vbih7XG5cdFx0XHRcdGRvd246IHRoaXMuX29uRG93bixcblx0XHRcdFx0ZHJhZ3N0YXJ0OiB0aGlzLl9vbkRyYWdTdGFydCxcblx0XHRcdFx0ZHJhZzogdGhpcy5fb25EcmFnLFxuXHRcdFx0XHRkcmFnZW5kOiB0aGlzLl9vbkRyYWdFbmRcblx0XHRcdH0sIHRoaXMpO1xuXG5cdFx0XHRpZiAobWFwLm9wdGlvbnMud29ybGRDb3B5SnVtcCkge1xuXHRcdFx0XHR0aGlzLl9kcmFnZ2FibGUub24oJ3ByZWRyYWcnLCB0aGlzLl9vblByZURyYWcsIHRoaXMpO1xuXHRcdFx0XHRtYXAub24oJ3ZpZXdyZXNldCcsIHRoaXMuX29uVmlld1Jlc2V0LCB0aGlzKTtcblxuXHRcdFx0XHRtYXAud2hlblJlYWR5KHRoaXMuX29uVmlld1Jlc2V0LCB0aGlzKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0dGhpcy5fZHJhZ2dhYmxlLmVuYWJsZSgpO1xuXHR9LFxuXG5cdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fZHJhZ2dhYmxlLmRpc2FibGUoKTtcblx0fSxcblxuXHRtb3ZlZDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9kcmFnZ2FibGUgJiYgdGhpcy5fZHJhZ2dhYmxlLl9tb3ZlZDtcblx0fSxcblxuXHRfb25Eb3duOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX21hcC5fcGFuQW5pbSkge1xuXHRcdFx0dGhpcy5fbWFwLl9wYW5BbmltLnN0b3AoKTtcblx0XHR9XG5cdH0sXG5cblx0X29uRHJhZ1N0YXJ0OiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcDtcblxuXHRcdG1hcFxuXHRcdCAgICAuZmlyZSgnbW92ZXN0YXJ0Jylcblx0XHQgICAgLmZpcmUoJ2RyYWdzdGFydCcpO1xuXG5cdFx0aWYgKG1hcC5vcHRpb25zLmluZXJ0aWEpIHtcblx0XHRcdHRoaXMuX3Bvc2l0aW9ucyA9IFtdO1xuXHRcdFx0dGhpcy5fdGltZXMgPSBbXTtcblx0XHR9XG5cdH0sXG5cblx0X29uRHJhZzogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9tYXAub3B0aW9ucy5pbmVydGlhKSB7XG5cdFx0XHR2YXIgdGltZSA9IHRoaXMuX2xhc3RUaW1lID0gK25ldyBEYXRlKCksXG5cdFx0XHQgICAgcG9zID0gdGhpcy5fbGFzdFBvcyA9IHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zO1xuXG5cdFx0XHR0aGlzLl9wb3NpdGlvbnMucHVzaChwb3MpO1xuXHRcdFx0dGhpcy5fdGltZXMucHVzaCh0aW1lKTtcblxuXHRcdFx0aWYgKHRpbWUgLSB0aGlzLl90aW1lc1swXSA+IDIwMCkge1xuXHRcdFx0XHR0aGlzLl9wb3NpdGlvbnMuc2hpZnQoKTtcblx0XHRcdFx0dGhpcy5fdGltZXMuc2hpZnQoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLl9tYXBcblx0XHQgICAgLmZpcmUoJ21vdmUnKVxuXHRcdCAgICAuZmlyZSgnZHJhZycpO1xuXHR9LFxuXG5cdF9vblZpZXdSZXNldDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBweENlbnRlciA9IHRoaXMuX21hcC5nZXRTaXplKCkuZGl2aWRlQnkoMiksXG5cdFx0ICAgIHB4V29ybGRDZW50ZXIgPSB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KFswLCAwXSk7XG5cblx0XHR0aGlzLl9pbml0aWFsV29ybGRPZmZzZXQgPSBweFdvcmxkQ2VudGVyLnN1YnRyYWN0KHB4Q2VudGVyKS54O1xuXHRcdHRoaXMuX3dvcmxkV2lkdGggPSB0aGlzLl9tYXAuZ2V0UGl4ZWxXb3JsZEJvdW5kcygpLmdldFNpemUoKS54O1xuXHR9LFxuXG5cdF9vblByZURyYWc6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBUT0RPIHJlZmFjdG9yIHRvIGJlIGFibGUgdG8gYWRqdXN0IG1hcCBwYW5lIHBvc2l0aW9uIGFmdGVyIHpvb21cblx0XHR2YXIgd29ybGRXaWR0aCA9IHRoaXMuX3dvcmxkV2lkdGgsXG5cdFx0ICAgIGhhbGZXaWR0aCA9IE1hdGgucm91bmQod29ybGRXaWR0aCAvIDIpLFxuXHRcdCAgICBkeCA9IHRoaXMuX2luaXRpYWxXb3JsZE9mZnNldCxcblx0XHQgICAgeCA9IHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zLngsXG5cdFx0ICAgIG5ld1gxID0gKHggLSBoYWxmV2lkdGggKyBkeCkgJSB3b3JsZFdpZHRoICsgaGFsZldpZHRoIC0gZHgsXG5cdFx0ICAgIG5ld1gyID0gKHggKyBoYWxmV2lkdGggKyBkeCkgJSB3b3JsZFdpZHRoIC0gaGFsZldpZHRoIC0gZHgsXG5cdFx0ICAgIG5ld1ggPSBNYXRoLmFicyhuZXdYMSArIGR4KSA8IE1hdGguYWJzKG5ld1gyICsgZHgpID8gbmV3WDEgOiBuZXdYMjtcblxuXHRcdHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zLnggPSBuZXdYO1xuXHR9LFxuXG5cdF9vbkRyYWdFbmQ6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgb3B0aW9ucyA9IG1hcC5vcHRpb25zLFxuXHRcdCAgICBkZWxheSA9ICtuZXcgRGF0ZSgpIC0gdGhpcy5fbGFzdFRpbWUsXG5cblx0XHQgICAgbm9JbmVydGlhID0gIW9wdGlvbnMuaW5lcnRpYSB8fCBkZWxheSA+IG9wdGlvbnMuaW5lcnRpYVRocmVzaG9sZCB8fCAhdGhpcy5fcG9zaXRpb25zWzBdO1xuXG5cdFx0bWFwLmZpcmUoJ2RyYWdlbmQnLCBlKTtcblxuXHRcdGlmIChub0luZXJ0aWEpIHtcblx0XHRcdG1hcC5maXJlKCdtb3ZlZW5kJyk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR2YXIgZGlyZWN0aW9uID0gdGhpcy5fbGFzdFBvcy5zdWJ0cmFjdCh0aGlzLl9wb3NpdGlvbnNbMF0pLFxuXHRcdFx0ICAgIGR1cmF0aW9uID0gKHRoaXMuX2xhc3RUaW1lICsgZGVsYXkgLSB0aGlzLl90aW1lc1swXSkgLyAxMDAwLFxuXHRcdFx0ICAgIGVhc2UgPSBvcHRpb25zLmVhc2VMaW5lYXJpdHksXG5cblx0XHRcdCAgICBzcGVlZFZlY3RvciA9IGRpcmVjdGlvbi5tdWx0aXBseUJ5KGVhc2UgLyBkdXJhdGlvbiksXG5cdFx0XHQgICAgc3BlZWQgPSBzcGVlZFZlY3Rvci5kaXN0YW5jZVRvKFswLCAwXSksXG5cblx0XHRcdCAgICBsaW1pdGVkU3BlZWQgPSBNYXRoLm1pbihvcHRpb25zLmluZXJ0aWFNYXhTcGVlZCwgc3BlZWQpLFxuXHRcdFx0ICAgIGxpbWl0ZWRTcGVlZFZlY3RvciA9IHNwZWVkVmVjdG9yLm11bHRpcGx5QnkobGltaXRlZFNwZWVkIC8gc3BlZWQpLFxuXG5cdFx0XHQgICAgZGVjZWxlcmF0aW9uRHVyYXRpb24gPSBsaW1pdGVkU3BlZWQgLyAob3B0aW9ucy5pbmVydGlhRGVjZWxlcmF0aW9uICogZWFzZSksXG5cdFx0XHQgICAgb2Zmc2V0ID0gbGltaXRlZFNwZWVkVmVjdG9yLm11bHRpcGx5QnkoLWRlY2VsZXJhdGlvbkR1cmF0aW9uIC8gMikucm91bmQoKTtcblxuXHRcdFx0aWYgKCFvZmZzZXQueCB8fCAhb2Zmc2V0LnkpIHtcblx0XHRcdFx0bWFwLmZpcmUoJ21vdmVlbmQnKTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b2Zmc2V0ID0gbWFwLl9saW1pdE9mZnNldChvZmZzZXQsIG1hcC5vcHRpb25zLm1heEJvdW5kcyk7XG5cblx0XHRcdFx0TC5VdGlsLnJlcXVlc3RBbmltRnJhbWUoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdG1hcC5wYW5CeShvZmZzZXQsIHtcblx0XHRcdFx0XHRcdGR1cmF0aW9uOiBkZWNlbGVyYXRpb25EdXJhdGlvbixcblx0XHRcdFx0XHRcdGVhc2VMaW5lYXJpdHk6IGVhc2UsXG5cdFx0XHRcdFx0XHRub01vdmVTdGFydDogdHJ1ZVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0pO1xuXG5MLk1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICdkcmFnZ2luZycsIEwuTWFwLkRyYWcpO1xuXG4vKlxuICogTC5IYW5kbGVyLkRvdWJsZUNsaWNrWm9vbSBpcyB1c2VkIHRvIGhhbmRsZSBkb3VibGUtY2xpY2sgem9vbSBvbiB0aGUgbWFwLCBlbmFibGVkIGJ5IGRlZmF1bHQuXG4gKi9cblxuTC5NYXAubWVyZ2VPcHRpb25zKHtcblx0ZG91YmxlQ2xpY2tab29tOiB0cnVlXG59KTtcblxuTC5NYXAuRG91YmxlQ2xpY2tab29tID0gTC5IYW5kbGVyLmV4dGVuZCh7XG5cdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fbWFwLm9uKCdkYmxjbGljaycsIHRoaXMuX29uRG91YmxlQ2xpY2ssIHRoaXMpO1xuXHR9LFxuXG5cdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fbWFwLm9mZignZGJsY2xpY2snLCB0aGlzLl9vbkRvdWJsZUNsaWNrLCB0aGlzKTtcblx0fSxcblxuXHRfb25Eb3VibGVDbGljazogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuXHRcdCAgICB6b29tID0gbWFwLmdldFpvb20oKSArIChlLm9yaWdpbmFsRXZlbnQuc2hpZnRLZXkgPyAtMSA6IDEpO1xuXG5cdFx0aWYgKG1hcC5vcHRpb25zLmRvdWJsZUNsaWNrWm9vbSA9PT0gJ2NlbnRlcicpIHtcblx0XHRcdG1hcC5zZXRab29tKHpvb20pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtYXAuc2V0Wm9vbUFyb3VuZChlLmNvbnRhaW5lclBvaW50LCB6b29tKTtcblx0XHR9XG5cdH1cbn0pO1xuXG5MLk1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICdkb3VibGVDbGlja1pvb20nLCBMLk1hcC5Eb3VibGVDbGlja1pvb20pO1xuXG4vKlxuICogTC5IYW5kbGVyLlNjcm9sbFdoZWVsWm9vbSBpcyB1c2VkIGJ5IEwuTWFwIHRvIGVuYWJsZSBtb3VzZSBzY3JvbGwgd2hlZWwgem9vbSBvbiB0aGUgbWFwLlxuICovXG5cbkwuTWFwLm1lcmdlT3B0aW9ucyh7XG5cdHNjcm9sbFdoZWVsWm9vbTogdHJ1ZVxufSk7XG5cbkwuTWFwLlNjcm9sbFdoZWVsWm9vbSA9IEwuSGFuZGxlci5leHRlbmQoe1xuXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdEwuRG9tRXZlbnQub24odGhpcy5fbWFwLl9jb250YWluZXIsIHtcblx0XHRcdG1vdXNld2hlZWw6IHRoaXMuX29uV2hlZWxTY3JvbGwsXG5cdFx0XHRNb3pNb3VzZVBpeGVsU2Nyb2xsOiBMLkRvbUV2ZW50LnByZXZlbnREZWZhdWx0XG5cdFx0fSwgdGhpcyk7XG5cblx0XHR0aGlzLl9kZWx0YSA9IDA7XG5cdH0sXG5cblx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHRMLkRvbUV2ZW50Lm9mZih0aGlzLl9tYXAuX2NvbnRhaW5lciwge1xuXHRcdFx0bW91c2V3aGVlbDogdGhpcy5fb25XaGVlbFNjcm9sbCxcblx0XHRcdE1vek1vdXNlUGl4ZWxTY3JvbGw6IEwuRG9tRXZlbnQucHJldmVudERlZmF1bHRcblx0XHR9LCB0aGlzKTtcblx0fSxcblxuXHRfb25XaGVlbFNjcm9sbDogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgZGVsdGEgPSBMLkRvbUV2ZW50LmdldFdoZWVsRGVsdGEoZSk7XG5cblx0XHR0aGlzLl9kZWx0YSArPSBkZWx0YTtcblx0XHR0aGlzLl9sYXN0TW91c2VQb3MgPSB0aGlzLl9tYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZSk7XG5cblx0XHRpZiAoIXRoaXMuX3N0YXJ0VGltZSkge1xuXHRcdFx0dGhpcy5fc3RhcnRUaW1lID0gK25ldyBEYXRlKCk7XG5cdFx0fVxuXG5cdFx0dmFyIGxlZnQgPSBNYXRoLm1heCg0MCAtICgrbmV3IERhdGUoKSAtIHRoaXMuX3N0YXJ0VGltZSksIDApO1xuXG5cdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVyKTtcblx0XHR0aGlzLl90aW1lciA9IHNldFRpbWVvdXQoTC5iaW5kKHRoaXMuX3BlcmZvcm1ab29tLCB0aGlzKSwgbGVmdCk7XG5cblx0XHRMLkRvbUV2ZW50LnN0b3AoZSk7XG5cdH0sXG5cblx0X3BlcmZvcm1ab29tOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgZGVsdGEgPSB0aGlzLl9kZWx0YSxcblx0XHQgICAgem9vbSA9IG1hcC5nZXRab29tKCk7XG5cblx0XHRkZWx0YSA9IGRlbHRhID4gMCA/IE1hdGguY2VpbChkZWx0YSkgOiBNYXRoLmZsb29yKGRlbHRhKTtcblx0XHRkZWx0YSA9IE1hdGgubWF4KE1hdGgubWluKGRlbHRhLCA0KSwgLTQpO1xuXHRcdGRlbHRhID0gbWFwLl9saW1pdFpvb20oem9vbSArIGRlbHRhKSAtIHpvb207XG5cblx0XHR0aGlzLl9kZWx0YSA9IDA7XG5cdFx0dGhpcy5fc3RhcnRUaW1lID0gbnVsbDtcblxuXHRcdGlmICghZGVsdGEpIHsgcmV0dXJuOyB9XG5cblx0XHRpZiAobWFwLm9wdGlvbnMuc2Nyb2xsV2hlZWxab29tID09PSAnY2VudGVyJykge1xuXHRcdFx0bWFwLnNldFpvb20oem9vbSArIGRlbHRhKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWFwLnNldFpvb21Bcm91bmQodGhpcy5fbGFzdE1vdXNlUG9zLCB6b29tICsgZGVsdGEpO1xuXHRcdH1cblx0fVxufSk7XG5cbkwuTWFwLmFkZEluaXRIb29rKCdhZGRIYW5kbGVyJywgJ3Njcm9sbFdoZWVsWm9vbScsIEwuTWFwLlNjcm9sbFdoZWVsWm9vbSk7XG5cbi8qXG4gKiBMLlBvc0FuaW1hdGlvbiBpcyB1c2VkIGJ5IExlYWZsZXQgaW50ZXJuYWxseSBmb3IgcGFuIGFuaW1hdGlvbnMuXG4gKi9cblxuTC5Qb3NBbmltYXRpb24gPSBMLkV2ZW50ZWQuZXh0ZW5kKHtcblxuXHRydW46IGZ1bmN0aW9uIChlbCwgbmV3UG9zLCBkdXJhdGlvbiwgZWFzZUxpbmVhcml0eSkgeyAvLyAoSFRNTEVsZW1lbnQsIFBvaW50WywgTnVtYmVyLCBOdW1iZXJdKVxuXHRcdHRoaXMuc3RvcCgpO1xuXG5cdFx0dGhpcy5fZWwgPSBlbDtcblx0XHR0aGlzLl9pblByb2dyZXNzID0gdHJ1ZTtcblx0XHR0aGlzLl9uZXdQb3MgPSBuZXdQb3M7XG5cblx0XHR0aGlzLmZpcmUoJ3N0YXJ0Jyk7XG5cblx0XHRlbC5zdHlsZVtMLkRvbVV0aWwuVFJBTlNJVElPTl0gPSAnYWxsICcgKyAoZHVyYXRpb24gfHwgMC4yNSkgK1xuXHRcdCAgICAgICAgJ3MgY3ViaWMtYmV6aWVyKDAsMCwnICsgKGVhc2VMaW5lYXJpdHkgfHwgMC41KSArICcsMSknO1xuXG5cdFx0TC5Eb21FdmVudC5vbihlbCwgTC5Eb21VdGlsLlRSQU5TSVRJT05fRU5ELCB0aGlzLl9vblRyYW5zaXRpb25FbmQsIHRoaXMpO1xuXHRcdEwuRG9tVXRpbC5zZXRQb3NpdGlvbihlbCwgbmV3UG9zKTtcblxuXHRcdC8vIHRvZ2dsZSByZWZsb3csIENocm9tZSBmbGlja2VycyBmb3Igc29tZSByZWFzb24gaWYgeW91IGRvbid0IGRvIHRoaXNcblx0XHRMLlV0aWwuZmFsc2VGbihlbC5vZmZzZXRXaWR0aCk7XG5cblx0XHQvLyB0aGVyZSdzIG5vIG5hdGl2ZSB3YXkgdG8gdHJhY2sgdmFsdWUgdXBkYXRlcyBvZiB0cmFuc2l0aW9uZWQgcHJvcGVydGllcywgc28gd2UgaW1pdGF0ZSB0aGlzXG5cdFx0dGhpcy5fc3RlcFRpbWVyID0gc2V0SW50ZXJ2YWwoTC5iaW5kKHRoaXMuX29uU3RlcCwgdGhpcyksIDUwKTtcblx0fSxcblxuXHRzdG9wOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9pblByb2dyZXNzKSB7IHJldHVybjsgfVxuXG5cdFx0Ly8gaWYgd2UganVzdCByZW1vdmVkIHRoZSB0cmFuc2l0aW9uIHByb3BlcnR5LCB0aGUgZWxlbWVudCB3b3VsZCBqdW1wIHRvIGl0cyBmaW5hbCBwb3NpdGlvbixcblx0XHQvLyBzbyB3ZSBuZWVkIHRvIG1ha2UgaXQgc3RheSBhdCB0aGUgY3VycmVudCBwb3NpdGlvblxuXG5cdFx0dGhpcy5fbmV3UG9zID0gdGhpcy5fZ2V0UG9zKCk7XG5cdFx0TC5Eb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX2VsLCB0aGlzLl9uZXdQb3MpO1xuXG5cdFx0dGhpcy5fb25UcmFuc2l0aW9uRW5kKCk7XG5cdFx0TC5VdGlsLmZhbHNlRm4odGhpcy5fZWwub2Zmc2V0V2lkdGgpOyAvLyBmb3JjZSByZWZsb3cgaW4gY2FzZSB3ZSBhcmUgYWJvdXQgdG8gc3RhcnQgYSBuZXcgYW5pbWF0aW9uXG5cdH0sXG5cblx0X29uU3RlcDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBzdGVwUG9zID0gdGhpcy5fZ2V0UG9zKCk7XG5cdFx0aWYgKCFzdGVwUG9zKSB7XG5cdFx0XHR0aGlzLl9vblRyYW5zaXRpb25FbmQoKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0Ly8ganNoaW50IGNhbWVsY2FzZTogZmFsc2Vcblx0XHQvLyBtYWtlIEwuRG9tVXRpbC5nZXRQb3NpdGlvbiByZXR1cm4gaW50ZXJtZWRpYXRlIHBvc2l0aW9uIHZhbHVlIGR1cmluZyBhbmltYXRpb25cblx0XHR0aGlzLl9lbC5fbGVhZmxldF9wb3MgPSBzdGVwUG9zO1xuXG5cdFx0dGhpcy5maXJlKCdzdGVwJyk7XG5cdH0sXG5cblx0Ly8geW91IGNhbid0IGVhc2lseSBnZXQgaW50ZXJtZWRpYXRlIHZhbHVlcyBvZiBwcm9wZXJ0aWVzIGFuaW1hdGVkIHdpdGggQ1NTMyBUcmFuc2l0aW9ucyxcblx0Ly8gd2UgbmVlZCB0byBwYXJzZSBjb21wdXRlZCBzdHlsZSAoaW4gY2FzZSBvZiB0cmFuc2Zvcm0gaXQgcmV0dXJucyBtYXRyaXggc3RyaW5nKVxuXG5cdF90cmFuc2Zvcm1SZTogLyhbLStdPyg/OlxcZCpcXC4pP1xcZCspXFxEKiwgKFstK10/KD86XFxkKlxcLik/XFxkKylcXEQqXFwpLyxcblxuXHRfZ2V0UG9zOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGxlZnQsIHRvcCwgbWF0Y2hlcyxcblx0XHQgICAgZWwgPSB0aGlzLl9lbCxcblx0XHQgICAgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG5cblx0XHRpZiAoTC5Ccm93c2VyLmFueTNkKSB7XG5cdFx0XHRtYXRjaGVzID0gc3R5bGVbTC5Eb21VdGlsLlRSQU5TRk9STV0ubWF0Y2godGhpcy5fdHJhbnNmb3JtUmUpO1xuXHRcdFx0aWYgKCFtYXRjaGVzKSB7IHJldHVybjsgfVxuXHRcdFx0bGVmdCA9IHBhcnNlRmxvYXQobWF0Y2hlc1sxXSk7XG5cdFx0XHR0b3AgID0gcGFyc2VGbG9hdChtYXRjaGVzWzJdKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bGVmdCA9IHBhcnNlRmxvYXQoc3R5bGUubGVmdCk7XG5cdFx0XHR0b3AgID0gcGFyc2VGbG9hdChzdHlsZS50b3ApO1xuXHRcdH1cblxuXHRcdHJldHVybiBuZXcgTC5Qb2ludChsZWZ0LCB0b3AsIHRydWUpO1xuXHR9LFxuXG5cdF9vblRyYW5zaXRpb25FbmQ6IGZ1bmN0aW9uICgpIHtcblx0XHRMLkRvbUV2ZW50Lm9mZih0aGlzLl9lbCwgTC5Eb21VdGlsLlRSQU5TSVRJT05fRU5ELCB0aGlzLl9vblRyYW5zaXRpb25FbmQsIHRoaXMpO1xuXG5cdFx0aWYgKCF0aGlzLl9pblByb2dyZXNzKSB7IHJldHVybjsgfVxuXHRcdHRoaXMuX2luUHJvZ3Jlc3MgPSBmYWxzZTtcblxuXHRcdHRoaXMuX2VsLnN0eWxlW0wuRG9tVXRpbC5UUkFOU0lUSU9OXSA9ICcnO1xuXG5cdFx0Ly8ganNoaW50IGNhbWVsY2FzZTogZmFsc2Vcblx0XHQvLyBtYWtlIHN1cmUgTC5Eb21VdGlsLmdldFBvc2l0aW9uIHJldHVybnMgdGhlIGZpbmFsIHBvc2l0aW9uIHZhbHVlIGFmdGVyIGFuaW1hdGlvblxuXHRcdHRoaXMuX2VsLl9sZWFmbGV0X3BvcyA9IHRoaXMuX25ld1BvcztcblxuXHRcdGNsZWFySW50ZXJ2YWwodGhpcy5fc3RlcFRpbWVyKTtcblxuXHRcdHRoaXMuZmlyZSgnc3RlcCcpLmZpcmUoJ2VuZCcpO1xuXHR9XG5cbn0pO1xuXG4vKlxuICogRXh0ZW5kcyBMLk1hcCB0byBoYW5kbGUgcGFubmluZyBhbmltYXRpb25zLlxuICovXG5cbkwuTWFwLmluY2x1ZGUoe1xuXG5cdHNldFZpZXc6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20sIG9wdGlvbnMpIHtcblxuXHRcdHpvb20gPSB6b29tID09PSB1bmRlZmluZWQgPyB0aGlzLl96b29tIDogdGhpcy5fbGltaXRab29tKHpvb20pO1xuXHRcdGNlbnRlciA9IHRoaXMuX2xpbWl0Q2VudGVyKEwubGF0TG5nKGNlbnRlciksIHpvb20sIHRoaXMub3B0aW9ucy5tYXhCb3VuZHMpO1xuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdFx0aWYgKHRoaXMuX3BhbkFuaW0pIHtcblx0XHRcdHRoaXMuX3BhbkFuaW0uc3RvcCgpO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLl9sb2FkZWQgJiYgIW9wdGlvbnMucmVzZXQgJiYgb3B0aW9ucyAhPT0gdHJ1ZSkge1xuXG5cdFx0XHRpZiAob3B0aW9ucy5hbmltYXRlICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0b3B0aW9ucy56b29tID0gTC5leHRlbmQoe2FuaW1hdGU6IG9wdGlvbnMuYW5pbWF0ZX0sIG9wdGlvbnMuem9vbSk7XG5cdFx0XHRcdG9wdGlvbnMucGFuID0gTC5leHRlbmQoe2FuaW1hdGU6IG9wdGlvbnMuYW5pbWF0ZX0sIG9wdGlvbnMucGFuKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gdHJ5IGFuaW1hdGluZyBwYW4gb3Igem9vbVxuXHRcdFx0dmFyIGFuaW1hdGVkID0gKHRoaXMuX3pvb20gIT09IHpvb20pID9cblx0XHRcdFx0dGhpcy5fdHJ5QW5pbWF0ZWRab29tICYmIHRoaXMuX3RyeUFuaW1hdGVkWm9vbShjZW50ZXIsIHpvb20sIG9wdGlvbnMuem9vbSkgOlxuXHRcdFx0XHR0aGlzLl90cnlBbmltYXRlZFBhbihjZW50ZXIsIG9wdGlvbnMucGFuKTtcblxuXHRcdFx0aWYgKGFuaW1hdGVkKSB7XG5cdFx0XHRcdC8vIHByZXZlbnQgcmVzaXplIGhhbmRsZXIgY2FsbCwgdGhlIHZpZXcgd2lsbCByZWZyZXNoIGFmdGVyIGFuaW1hdGlvbiBhbnl3YXlcblx0XHRcdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX3NpemVUaW1lcik7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIGFuaW1hdGlvbiBkaWRuJ3Qgc3RhcnQsIGp1c3QgcmVzZXQgdGhlIG1hcCB2aWV3XG5cdFx0dGhpcy5fcmVzZXRWaWV3KGNlbnRlciwgem9vbSk7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRwYW5CeTogZnVuY3Rpb24gKG9mZnNldCwgb3B0aW9ucykge1xuXHRcdG9mZnNldCA9IEwucG9pbnQob2Zmc2V0KS5yb3VuZCgpO1xuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdFx0aWYgKCFvZmZzZXQueCAmJiAhb2Zmc2V0LnkpIHtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGlmICghdGhpcy5fcGFuQW5pbSkge1xuXHRcdFx0dGhpcy5fcGFuQW5pbSA9IG5ldyBMLlBvc0FuaW1hdGlvbigpO1xuXG5cdFx0XHR0aGlzLl9wYW5BbmltLm9uKHtcblx0XHRcdFx0J3N0ZXAnOiB0aGlzLl9vblBhblRyYW5zaXRpb25TdGVwLFxuXHRcdFx0XHQnZW5kJzogdGhpcy5fb25QYW5UcmFuc2l0aW9uRW5kXG5cdFx0XHR9LCB0aGlzKTtcblx0XHR9XG5cblx0XHQvLyBkb24ndCBmaXJlIG1vdmVzdGFydCBpZiBhbmltYXRpbmcgaW5lcnRpYVxuXHRcdGlmICghb3B0aW9ucy5ub01vdmVTdGFydCkge1xuXHRcdFx0dGhpcy5maXJlKCdtb3Zlc3RhcnQnKTtcblx0XHR9XG5cblx0XHQvLyBhbmltYXRlIHBhbiB1bmxlc3MgYW5pbWF0ZTogZmFsc2Ugc3BlY2lmaWVkXG5cdFx0aWYgKG9wdGlvbnMuYW5pbWF0ZSAhPT0gZmFsc2UpIHtcblx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9tYXBQYW5lLCAnbGVhZmxldC1wYW4tYW5pbScpO1xuXG5cdFx0XHR2YXIgbmV3UG9zID0gdGhpcy5fZ2V0TWFwUGFuZVBvcygpLnN1YnRyYWN0KG9mZnNldCk7XG5cdFx0XHR0aGlzLl9wYW5BbmltLnJ1bih0aGlzLl9tYXBQYW5lLCBuZXdQb3MsIG9wdGlvbnMuZHVyYXRpb24gfHwgMC4yNSwgb3B0aW9ucy5lYXNlTGluZWFyaXR5KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fcmF3UGFuQnkob2Zmc2V0KTtcblx0XHRcdHRoaXMuZmlyZSgnbW92ZScpLmZpcmUoJ21vdmVlbmQnKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRfb25QYW5UcmFuc2l0aW9uU3RlcDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuZmlyZSgnbW92ZScpO1xuXHR9LFxuXG5cdF9vblBhblRyYW5zaXRpb25FbmQ6IGZ1bmN0aW9uICgpIHtcblx0XHRMLkRvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fbWFwUGFuZSwgJ2xlYWZsZXQtcGFuLWFuaW0nKTtcblx0XHR0aGlzLmZpcmUoJ21vdmVlbmQnKTtcblx0fSxcblxuXHRfdHJ5QW5pbWF0ZWRQYW46IGZ1bmN0aW9uIChjZW50ZXIsIG9wdGlvbnMpIHtcblx0XHQvLyBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIG5ldyBhbmQgY3VycmVudCBjZW50ZXJzIGluIHBpeGVsc1xuXHRcdHZhciBvZmZzZXQgPSB0aGlzLl9nZXRDZW50ZXJPZmZzZXQoY2VudGVyKS5fZmxvb3IoKTtcblxuXHRcdC8vIGRvbid0IGFuaW1hdGUgdG9vIGZhciB1bmxlc3MgYW5pbWF0ZTogdHJ1ZSBzcGVjaWZpZWQgaW4gb3B0aW9uc1xuXHRcdGlmICgob3B0aW9ucyAmJiBvcHRpb25zLmFuaW1hdGUpICE9PSB0cnVlICYmICF0aGlzLmdldFNpemUoKS5jb250YWlucyhvZmZzZXQpKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdFx0dGhpcy5wYW5CeShvZmZzZXQsIG9wdGlvbnMpO1xuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cbn0pO1xuXG4vKlxuICogRXh0ZW5kcyBMLk1hcCB0byBoYW5kbGUgem9vbSBhbmltYXRpb25zLlxuICovXG5cbkwuTWFwLm1lcmdlT3B0aW9ucyh7XG5cdHpvb21BbmltYXRpb246IHRydWUsXG5cdHpvb21BbmltYXRpb25UaHJlc2hvbGQ6IDRcbn0pO1xuXG52YXIgem9vbUFuaW1hdGVkID0gTC5Eb21VdGlsLlRSQU5TSVRJT04gJiYgTC5Ccm93c2VyLmFueTNkICYmICFMLkJyb3dzZXIubW9iaWxlT3BlcmE7XG5cbmlmICh6b29tQW5pbWF0ZWQpIHtcblxuXHRMLk1hcC5hZGRJbml0SG9vayhmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gZG9uJ3QgYW5pbWF0ZSBvbiBicm93c2VycyB3aXRob3V0IGhhcmR3YXJlLWFjY2VsZXJhdGVkIHRyYW5zaXRpb25zIG9yIG9sZCBBbmRyb2lkL09wZXJhXG5cdFx0dGhpcy5fem9vbUFuaW1hdGVkID0gdGhpcy5vcHRpb25zLnpvb21BbmltYXRpb247XG5cblx0XHQvLyB6b29tIHRyYW5zaXRpb25zIHJ1biB3aXRoIHRoZSBzYW1lIGR1cmF0aW9uIGZvciBhbGwgbGF5ZXJzLCBzbyBpZiBvbmUgb2YgdHJhbnNpdGlvbmVuZCBldmVudHNcblx0XHQvLyBoYXBwZW5zIGFmdGVyIHN0YXJ0aW5nIHpvb20gYW5pbWF0aW9uIChwcm9wYWdhdGluZyB0byB0aGUgbWFwIHBhbmUpLCB3ZSBrbm93IHRoYXQgaXQgZW5kZWQgZ2xvYmFsbHlcblx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XG5cdFx0XHRMLkRvbUV2ZW50Lm9uKHRoaXMuX21hcFBhbmUsIEwuRG9tVXRpbC5UUkFOU0lUSU9OX0VORCwgdGhpcy5fY2F0Y2hUcmFuc2l0aW9uRW5kLCB0aGlzKTtcblx0XHR9XG5cdH0pO1xufVxuXG5MLk1hcC5pbmNsdWRlKCF6b29tQW5pbWF0ZWQgPyB7fSA6IHtcblxuXHRfY2F0Y2hUcmFuc2l0aW9uRW5kOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmICh0aGlzLl9hbmltYXRpbmdab29tICYmIGUucHJvcGVydHlOYW1lLmluZGV4T2YoJ3RyYW5zZm9ybScpID49IDApIHtcblx0XHRcdHRoaXMuX29uWm9vbVRyYW5zaXRpb25FbmQoKTtcblx0XHR9XG5cdH0sXG5cblx0X25vdGhpbmdUb0FuaW1hdGU6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gIXRoaXMuX2NvbnRhaW5lci5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdsZWFmbGV0LXpvb20tYW5pbWF0ZWQnKS5sZW5ndGg7XG5cdH0sXG5cblx0X3RyeUFuaW1hdGVkWm9vbTogZnVuY3Rpb24gKGNlbnRlciwgem9vbSwgb3B0aW9ucykge1xuXG5cdFx0aWYgKHRoaXMuX2FuaW1hdGluZ1pvb20pIHsgcmV0dXJuIHRydWU7IH1cblxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdFx0Ly8gZG9uJ3QgYW5pbWF0ZSBpZiBkaXNhYmxlZCwgbm90IHN1cHBvcnRlZCBvciB6b29tIGRpZmZlcmVuY2UgaXMgdG9vIGxhcmdlXG5cdFx0aWYgKCF0aGlzLl96b29tQW5pbWF0ZWQgfHwgb3B0aW9ucy5hbmltYXRlID09PSBmYWxzZSB8fCB0aGlzLl9ub3RoaW5nVG9BbmltYXRlKCkgfHxcblx0XHQgICAgICAgIE1hdGguYWJzKHpvb20gLSB0aGlzLl96b29tKSA+IHRoaXMub3B0aW9ucy56b29tQW5pbWF0aW9uVGhyZXNob2xkKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdFx0Ly8gb2Zmc2V0IGlzIHRoZSBwaXhlbCBjb29yZHMgb2YgdGhlIHpvb20gb3JpZ2luIHJlbGF0aXZlIHRvIHRoZSBjdXJyZW50IGNlbnRlclxuXHRcdHZhciBzY2FsZSA9IHRoaXMuZ2V0Wm9vbVNjYWxlKHpvb20pLFxuXHRcdCAgICBvZmZzZXQgPSB0aGlzLl9nZXRDZW50ZXJPZmZzZXQoY2VudGVyKS5fZGl2aWRlQnkoMSAtIDEgLyBzY2FsZSk7XG5cblx0XHQvLyBkb24ndCBhbmltYXRlIGlmIHRoZSB6b29tIG9yaWdpbiBpc24ndCB3aXRoaW4gb25lIHNjcmVlbiBmcm9tIHRoZSBjdXJyZW50IGNlbnRlciwgdW5sZXNzIGZvcmNlZFxuXHRcdGlmIChvcHRpb25zLmFuaW1hdGUgIT09IHRydWUgJiYgIXRoaXMuZ2V0U2l6ZSgpLmNvbnRhaW5zKG9mZnNldCkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0XHRMLlV0aWwucmVxdWVzdEFuaW1GcmFtZShmdW5jdGlvbiAoKSB7XG5cdFx0XHR0aGlzXG5cdFx0XHQgICAgLmZpcmUoJ21vdmVzdGFydCcpXG5cdFx0XHQgICAgLmZpcmUoJ3pvb21zdGFydCcpXG5cdFx0XHQgICAgLl9hbmltYXRlWm9vbShjZW50ZXIsIHpvb20sIHRydWUpO1xuXHRcdH0sIHRoaXMpO1xuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0X2FuaW1hdGVab29tOiBmdW5jdGlvbiAoY2VudGVyLCB6b29tLCBzdGFydEFuaW0pIHtcblx0XHRpZiAoc3RhcnRBbmltKSB7XG5cdFx0XHR0aGlzLl9hbmltYXRpbmdab29tID0gdHJ1ZTtcblxuXHRcdFx0Ly8gcmVtZW1iZXIgd2hhdCBjZW50ZXIvem9vbSB0byBzZXQgYWZ0ZXIgYW5pbWF0aW9uXG5cdFx0XHR0aGlzLl9hbmltYXRlVG9DZW50ZXIgPSBjZW50ZXI7XG5cdFx0XHR0aGlzLl9hbmltYXRlVG9ab29tID0gem9vbTtcblxuXHRcdFx0Ly8gZGlzYWJsZSBhbnkgZHJhZ2dpbmcgZHVyaW5nIGFuaW1hdGlvblxuXHRcdFx0aWYgKEwuRHJhZ2dhYmxlKSB7XG5cdFx0XHRcdEwuRHJhZ2dhYmxlLl9kaXNhYmxlZCA9IHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9tYXBQYW5lLCAnbGVhZmxldC16b29tLWFuaW0nKTtcblx0XHR9XG5cblx0XHR2YXIgc2NhbGUgPSB0aGlzLmdldFpvb21TY2FsZSh6b29tKSxcblx0XHRcdG9yaWdpbiA9IHRoaXMuX2dldENlbnRlckxheWVyUG9pbnQoKS5hZGQodGhpcy5fZ2V0Q2VudGVyT2Zmc2V0KGNlbnRlcikuX2RpdmlkZUJ5KDEgLSAxIC8gc2NhbGUpKTtcblxuXHRcdHRoaXMuZmlyZSgnem9vbWFuaW0nLCB7XG5cdFx0XHRjZW50ZXI6IGNlbnRlcixcblx0XHRcdHpvb206IHpvb20sXG5cdFx0XHRvcmlnaW46IG9yaWdpbixcblx0XHRcdHNjYWxlOiBzY2FsZVxuXHRcdH0pO1xuXHR9LFxuXG5cdF9vblpvb21UcmFuc2l0aW9uRW5kOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR0aGlzLl9hbmltYXRpbmdab29tID0gZmFsc2U7XG5cblx0XHRMLkRvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fbWFwUGFuZSwgJ2xlYWZsZXQtem9vbS1hbmltJyk7XG5cblx0XHR0aGlzLl9yZXNldFZpZXcodGhpcy5fYW5pbWF0ZVRvQ2VudGVyLCB0aGlzLl9hbmltYXRlVG9ab29tLCB0cnVlLCB0cnVlKTtcblxuXHRcdGlmIChMLkRyYWdnYWJsZSkge1xuXHRcdFx0TC5EcmFnZ2FibGUuX2Rpc2FibGVkID0gZmFsc2U7XG5cdFx0fVxuXHR9XG59KTtcblxuLypcclxuICogRXh0ZW5kcyB0aGUgZXZlbnQgaGFuZGxpbmcgY29kZSB3aXRoIGRvdWJsZSB0YXAgc3VwcG9ydCBmb3IgbW9iaWxlIGJyb3dzZXJzLlxyXG4gKi9cclxuXHJcbkwuZXh0ZW5kKEwuRG9tRXZlbnQsIHtcclxuXHJcblx0X3RvdWNoc3RhcnQ6IEwuQnJvd3Nlci5tc1BvaW50ZXIgPyAnTVNQb2ludGVyRG93bicgOiBMLkJyb3dzZXIucG9pbnRlciA/ICdwb2ludGVyZG93bicgOiAndG91Y2hzdGFydCcsXHJcblx0X3RvdWNoZW5kOiBMLkJyb3dzZXIubXNQb2ludGVyID8gJ01TUG9pbnRlclVwJyA6IEwuQnJvd3Nlci5wb2ludGVyID8gJ3BvaW50ZXJ1cCcgOiAndG91Y2hlbmQnLFxyXG5cclxuXHQvLyBpbnNwaXJlZCBieSBaZXB0byB0b3VjaCBjb2RlIGJ5IFRob21hcyBGdWNoc1xyXG5cdGFkZERvdWJsZVRhcExpc3RlbmVyOiBmdW5jdGlvbiAob2JqLCBoYW5kbGVyLCBpZCkge1xyXG5cdFx0dmFyIGxhc3QsIHRvdWNoLFxyXG5cdFx0ICAgIGRvdWJsZVRhcCA9IGZhbHNlLFxyXG5cdFx0ICAgIGRlbGF5ID0gMjUwLFxyXG5cdFx0ICAgIHRyYWNrZWRUb3VjaGVzID0gW107XHJcblxyXG5cdFx0ZnVuY3Rpb24gb25Ub3VjaFN0YXJ0KGUpIHtcclxuXHRcdFx0dmFyIGNvdW50O1xyXG5cclxuXHRcdFx0aWYgKEwuQnJvd3Nlci5wb2ludGVyKSB7XHJcblx0XHRcdFx0dHJhY2tlZFRvdWNoZXMucHVzaChlLnBvaW50ZXJJZCk7XHJcblx0XHRcdFx0Y291bnQgPSB0cmFja2VkVG91Y2hlcy5sZW5ndGg7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0Y291bnQgPSBlLnRvdWNoZXMubGVuZ3RoO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoY291bnQgPiAxKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdFx0dmFyIG5vdyA9IERhdGUubm93KCksXHJcblx0XHRcdCAgICBkZWx0YSA9IG5vdyAtIChsYXN0IHx8IG5vdyk7XHJcblxyXG5cdFx0XHR0b3VjaCA9IGUudG91Y2hlcyA/IGUudG91Y2hlc1swXSA6IGU7XHJcblx0XHRcdGRvdWJsZVRhcCA9IChkZWx0YSA+IDAgJiYgZGVsdGEgPD0gZGVsYXkpO1xyXG5cdFx0XHRsYXN0ID0gbm93O1xyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIG9uVG91Y2hFbmQoZSkge1xyXG5cdFx0XHRpZiAoTC5Ccm93c2VyLnBvaW50ZXIpIHtcclxuXHRcdFx0XHR2YXIgaWR4ID0gdHJhY2tlZFRvdWNoZXMuaW5kZXhPZihlLnBvaW50ZXJJZCk7XHJcblx0XHRcdFx0aWYgKGlkeCA9PT0gLTEpIHsgcmV0dXJuOyB9XHJcblx0XHRcdFx0dHJhY2tlZFRvdWNoZXMuc3BsaWNlKGlkeCwgMSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChkb3VibGVUYXApIHtcclxuXHRcdFx0XHRpZiAoTC5Ccm93c2VyLnBvaW50ZXIpIHtcclxuXHRcdFx0XHRcdC8vIHdvcmsgYXJvdW5kIC50eXBlIGJlaW5nIHJlYWRvbmx5IHdpdGggTVNQb2ludGVyKiBldmVudHNcclxuXHRcdFx0XHRcdHZhciBuZXdUb3VjaCA9IHt9LFxyXG5cdFx0XHRcdFx0XHRwcm9wLCBpO1xyXG5cclxuXHRcdFx0XHRcdGZvciAoaSBpbiB0b3VjaCkge1xyXG5cdFx0XHRcdFx0XHRwcm9wID0gdG91Y2hbaV07XHJcblx0XHRcdFx0XHRcdG5ld1RvdWNoW2ldID0gcHJvcCAmJiBwcm9wLmJpbmQgPyBwcm9wLmJpbmQodG91Y2gpIDogcHJvcDtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHRvdWNoID0gbmV3VG91Y2g7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHRvdWNoLnR5cGUgPSAnZGJsY2xpY2snO1xyXG5cdFx0XHRcdGhhbmRsZXIodG91Y2gpO1xyXG5cdFx0XHRcdGxhc3QgPSBudWxsO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHByZSA9ICdfbGVhZmxldF8nLFxyXG5cdFx0ICAgIHRvdWNoc3RhcnQgPSB0aGlzLl90b3VjaHN0YXJ0LFxyXG5cdFx0ICAgIHRvdWNoZW5kID0gdGhpcy5fdG91Y2hlbmQ7XHJcblxyXG5cdFx0b2JqW3ByZSArIHRvdWNoc3RhcnQgKyBpZF0gPSBvblRvdWNoU3RhcnQ7XHJcblx0XHRvYmpbcHJlICsgdG91Y2hlbmQgKyBpZF0gPSBvblRvdWNoRW5kO1xyXG5cclxuXHRcdC8vIG9uIHBvaW50ZXIgd2UgbmVlZCB0byBsaXN0ZW4gb24gdGhlIGRvY3VtZW50LCBvdGhlcndpc2UgYSBkcmFnIHN0YXJ0aW5nIG9uIHRoZSBtYXAgYW5kIG1vdmluZyBvZmYgc2NyZWVuXHJcblx0XHQvLyB3aWxsIG5vdCBjb21lIHRocm91Z2ggdG8gdXMsIHNvIHdlIHdpbGwgbG9zZSB0cmFjayBvZiBob3cgbWFueSB0b3VjaGVzIGFyZSBvbmdvaW5nXHJcblx0XHR2YXIgZW5kRWxlbWVudCA9IEwuQnJvd3Nlci5wb2ludGVyID8gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50IDogb2JqO1xyXG5cclxuXHRcdG9iai5hZGRFdmVudExpc3RlbmVyKHRvdWNoc3RhcnQsIG9uVG91Y2hTdGFydCwgZmFsc2UpO1xyXG5cclxuXHRcdGVuZEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcih0b3VjaGVuZCwgb25Ub3VjaEVuZCwgZmFsc2UpO1xyXG5cdFx0aWYgKEwuQnJvd3Nlci5wb2ludGVyKSB7XHJcblx0XHRcdGVuZEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihMLkRvbUV2ZW50LlBPSU5URVJfQ0FOQ0VMLCBvblRvdWNoRW5kLCBmYWxzZSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0cmVtb3ZlRG91YmxlVGFwTGlzdGVuZXI6IGZ1bmN0aW9uIChvYmosIGlkKSB7XHJcblx0XHR2YXIgcHJlID0gJ19sZWFmbGV0XycsXHJcblx0XHQgICAgZW5kRWxlbWVudCA9IEwuQnJvd3Nlci5wb2ludGVyID8gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50IDogb2JqLFxyXG5cdFx0ICAgIHRvdWNoZW5kID0gb2JqW3ByZSArIHRoaXMuX3RvdWNoZW5kICsgaWRdO1xyXG5cclxuXHRcdG9iai5yZW1vdmVFdmVudExpc3RlbmVyKHRoaXMuX3RvdWNoc3RhcnQsIG9ialtwcmUgKyB0aGlzLl90b3VjaHN0YXJ0ICsgaWRdLCBmYWxzZSk7XHJcblxyXG5cdFx0ZW5kRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKHRoaXMuX3RvdWNoZW5kLCB0b3VjaGVuZCwgZmFsc2UpO1xyXG5cdFx0aWYgKEwuQnJvd3Nlci5wb2ludGVyKSB7XHJcblx0XHRcdGVuZEVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihMLkRvbUV2ZW50LlBPSU5URVJfQ0FOQ0VMLCB0b3VjaGVuZCwgZmFsc2UpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH1cclxufSk7XHJcblxuLypcbiAqIEV4dGVuZHMgTC5Eb21FdmVudCB0byBwcm92aWRlIHRvdWNoIHN1cHBvcnQgZm9yIEludGVybmV0IEV4cGxvcmVyIGFuZCBXaW5kb3dzLWJhc2VkIGRldmljZXMuXG4gKi9cblxuTC5leHRlbmQoTC5Eb21FdmVudCwge1xuXG5cdFBPSU5URVJfRE9XTjogICBMLkJyb3dzZXIubXNQb2ludGVyID8gJ01TUG9pbnRlckRvd24nICAgOiAncG9pbnRlcmRvd24nLFxuXHRQT0lOVEVSX01PVkU6ICAgTC5Ccm93c2VyLm1zUG9pbnRlciA/ICdNU1BvaW50ZXJNb3ZlJyAgIDogJ3BvaW50ZXJtb3ZlJyxcblx0UE9JTlRFUl9VUDogICAgIEwuQnJvd3Nlci5tc1BvaW50ZXIgPyAnTVNQb2ludGVyVXAnICAgICA6ICdwb2ludGVydXAnLFxuXHRQT0lOVEVSX0NBTkNFTDogTC5Ccm93c2VyLm1zUG9pbnRlciA/ICdNU1BvaW50ZXJDYW5jZWwnIDogJ3BvaW50ZXJjYW5jZWwnLFxuXG5cdF9wb2ludGVyczoge30sXG5cblx0Ly8gUHJvdmlkZXMgYSB0b3VjaCBldmVudHMgd3JhcHBlciBmb3IgKG1zKXBvaW50ZXIgZXZlbnRzLlxuXHQvLyByZWYgaHR0cDovL3d3dy53My5vcmcvVFIvcG9pbnRlcmV2ZW50cy8gaHR0cHM6Ly93d3cudzMub3JnL0J1Z3MvUHVibGljL3Nob3dfYnVnLmNnaT9pZD0yMjg5MFxuXG5cdGFkZFBvaW50ZXJMaXN0ZW5lcjogZnVuY3Rpb24gKG9iaiwgdHlwZSwgaGFuZGxlciwgaWQpIHtcblxuXHRcdGlmICh0eXBlID09PSAndG91Y2hzdGFydCcpIHtcblx0XHRcdHRoaXMuX2FkZFBvaW50ZXJTdGFydChvYmosIGhhbmRsZXIsIGlkKTtcblxuXHRcdH0gZWxzZSBpZiAodHlwZSA9PT0gJ3RvdWNobW92ZScpIHtcblx0XHRcdHRoaXMuX2FkZFBvaW50ZXJNb3ZlKG9iaiwgaGFuZGxlciwgaWQpO1xuXG5cdFx0fSBlbHNlIGlmICh0eXBlID09PSAndG91Y2hlbmQnKSB7XG5cdFx0XHR0aGlzLl9hZGRQb2ludGVyRW5kKG9iaiwgaGFuZGxlciwgaWQpO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHJlbW92ZVBvaW50ZXJMaXN0ZW5lcjogZnVuY3Rpb24gKG9iaiwgdHlwZSwgaWQpIHtcblx0XHR2YXIgaGFuZGxlciA9IG9ialsnX2xlYWZsZXRfJyArIHR5cGUgKyBpZF07XG5cblx0XHRpZiAodHlwZSA9PT0gJ3RvdWNoc3RhcnQnKSB7XG5cdFx0XHRvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGlzLlBPSU5URVJfRE9XTiwgaGFuZGxlciwgZmFsc2UpO1xuXG5cdFx0fSBlbHNlIGlmICh0eXBlID09PSAndG91Y2htb3ZlJykge1xuXHRcdFx0b2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIodGhpcy5QT0lOVEVSX01PVkUsIGhhbmRsZXIsIGZhbHNlKTtcblxuXHRcdH0gZWxzZSBpZiAodHlwZSA9PT0gJ3RvdWNoZW5kJykge1xuXHRcdFx0b2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIodGhpcy5QT0lOVEVSX1VQLCBoYW5kbGVyLCBmYWxzZSk7XG5cdFx0XHRvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGlzLlBPSU5URVJfQ0FOQ0VMLCBoYW5kbGVyLCBmYWxzZSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0X2FkZFBvaW50ZXJTdGFydDogZnVuY3Rpb24gKG9iaiwgaGFuZGxlciwgaWQpIHtcblx0XHR2YXIgb25Eb3duID0gTC5iaW5kKGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRMLkRvbUV2ZW50LnByZXZlbnREZWZhdWx0KGUpO1xuXG5cdFx0XHR0aGlzLl9wb2ludGVyc1tlLnBvaW50ZXJJZF0gPSBlO1xuXHRcdFx0dGhpcy5faGFuZGxlUG9pbnRlcihlLCBoYW5kbGVyKTtcblx0XHR9LCB0aGlzKTtcblxuXHRcdG9ialsnX2xlYWZsZXRfdG91Y2hzdGFydCcgKyBpZF0gPSBvbkRvd247XG5cdFx0b2JqLmFkZEV2ZW50TGlzdGVuZXIodGhpcy5QT0lOVEVSX0RPV04sIG9uRG93biwgZmFsc2UpO1xuXG5cdFx0Ly8gbmVlZCB0byBhbHNvIGxpc3RlbiBmb3IgZW5kIGV2ZW50cyB0byBrZWVwIHRoZSBfcG9pbnRlcnMgb2JqZWN0IGFjY3VyYXRlXG5cdFx0aWYgKCF0aGlzLl9wb2ludGVyRG9jTGlzdGVuZXIpIHtcblx0XHRcdHZhciByZW1vdmVQb2ludGVyID0gTC5iaW5kKGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdGRlbGV0ZSB0aGlzLl9wb2ludGVyc1tlLnBvaW50ZXJJZF07XG5cdFx0XHR9LCB0aGlzKTtcblxuXHRcdFx0Ly8gd2UgbGlzdGVuIGRvY3VtZW50RWxlbWVudCBhcyBhbnkgZHJhZ3MgdGhhdCBlbmQgYnkgbW92aW5nIHRoZSB0b3VjaCBvZmYgdGhlIHNjcmVlbiBnZXQgZmlyZWQgdGhlcmVcblx0XHRcdGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKHRoaXMuUE9JTlRFUl9VUCwgcmVtb3ZlUG9pbnRlciwgZmFsc2UpO1xuXHRcdFx0ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIodGhpcy5QT0lOVEVSX0NBTkNFTCwgcmVtb3ZlUG9pbnRlciwgZmFsc2UpO1xuXG5cdFx0XHR0aGlzLl9wb2ludGVyRG9jTGlzdGVuZXIgPSB0cnVlO1xuXHRcdH1cblx0fSxcblxuXHRfaGFuZGxlUG9pbnRlcjogZnVuY3Rpb24gKGUsIGhhbmRsZXIpIHtcblx0XHRlLnRvdWNoZXMgPSBbXTtcblx0XHRmb3IgKHZhciBpIGluIHRoaXMuX3BvaW50ZXJzKSB7XG5cdFx0XHRlLnRvdWNoZXMucHVzaCh0aGlzLl9wb2ludGVyc1tpXSk7XG5cdFx0fVxuXHRcdGUuY2hhbmdlZFRvdWNoZXMgPSBbZV07XG5cblx0XHRoYW5kbGVyKGUpO1xuXHR9LFxuXG5cdF9hZGRQb2ludGVyTW92ZTogZnVuY3Rpb24gKG9iaiwgaGFuZGxlciwgaWQpIHtcblx0XHR2YXIgb25Nb3ZlID0gTC5iaW5kKGZ1bmN0aW9uIChlKSB7XG5cdFx0XHQvLyBkb24ndCBmaXJlIHRvdWNoIG1vdmVzIHdoZW4gbW91c2UgaXNuJ3QgZG93blxuXHRcdFx0aWYgKChlLnBvaW50ZXJUeXBlID09PSBlLk1TUE9JTlRFUl9UWVBFX01PVVNFIHx8IGUucG9pbnRlclR5cGUgPT09ICdtb3VzZScpICYmIGUuYnV0dG9ucyA9PT0gMCkgeyByZXR1cm47IH1cblxuXHRcdFx0dGhpcy5fcG9pbnRlcnNbZS5wb2ludGVySWRdID0gZTtcblx0XHRcdHRoaXMuX2hhbmRsZVBvaW50ZXIoZSwgaGFuZGxlcik7XG5cdFx0fSwgdGhpcyk7XG5cblx0XHRvYmpbJ19sZWFmbGV0X3RvdWNobW92ZScgKyBpZF0gPSBvbk1vdmU7XG5cdFx0b2JqLmFkZEV2ZW50TGlzdGVuZXIodGhpcy5QT0lOVEVSX01PVkUsIG9uTW92ZSwgZmFsc2UpO1xuXHR9LFxuXG5cdF9hZGRQb2ludGVyRW5kOiBmdW5jdGlvbiAob2JqLCBoYW5kbGVyLCBpZCkge1xuXHRcdHZhciBvblVwID0gTC5iaW5kKGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRkZWxldGUgdGhpcy5fcG9pbnRlcnNbZS5wb2ludGVySWRdO1xuXHRcdFx0dGhpcy5faGFuZGxlUG9pbnRlcihlLCBoYW5kbGVyKTtcblx0XHR9LCB0aGlzKTtcblxuXHRcdG9ialsnX2xlYWZsZXRfdG91Y2hlbmQnICsgaWRdID0gb25VcDtcblx0XHRvYmouYWRkRXZlbnRMaXN0ZW5lcih0aGlzLlBPSU5URVJfVVAsIG9uVXAsIGZhbHNlKTtcblx0XHRvYmouYWRkRXZlbnRMaXN0ZW5lcih0aGlzLlBPSU5URVJfQ0FOQ0VMLCBvblVwLCBmYWxzZSk7XG5cdH1cbn0pO1xuXG4vKlxuICogTC5IYW5kbGVyLlRvdWNoWm9vbSBpcyB1c2VkIGJ5IEwuTWFwIHRvIGFkZCBwaW5jaCB6b29tIG9uIHN1cHBvcnRlZCBtb2JpbGUgYnJvd3NlcnMuXG4gKi9cblxuTC5NYXAubWVyZ2VPcHRpb25zKHtcblx0dG91Y2hab29tOiBMLkJyb3dzZXIudG91Y2ggJiYgIUwuQnJvd3Nlci5hbmRyb2lkMjMsXG5cdGJvdW5jZUF0Wm9vbUxpbWl0czogdHJ1ZVxufSk7XG5cbkwuTWFwLlRvdWNoWm9vbSA9IEwuSGFuZGxlci5leHRlbmQoe1xuXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdEwuRG9tRXZlbnQub24odGhpcy5fbWFwLl9jb250YWluZXIsICd0b3VjaHN0YXJ0JywgdGhpcy5fb25Ub3VjaFN0YXJ0LCB0aGlzKTtcblx0fSxcblxuXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdEwuRG9tRXZlbnQub2ZmKHRoaXMuX21hcC5fY29udGFpbmVyLCAndG91Y2hzdGFydCcsIHRoaXMuX29uVG91Y2hTdGFydCwgdGhpcyk7XG5cdH0sXG5cblx0X29uVG91Y2hTdGFydDogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwO1xuXG5cdFx0aWYgKCFlLnRvdWNoZXMgfHwgZS50b3VjaGVzLmxlbmd0aCAhPT0gMiB8fCBtYXAuX2FuaW1hdGluZ1pvb20gfHwgdGhpcy5fem9vbWluZykgeyByZXR1cm47IH1cblxuXHRcdHZhciBwMSA9IG1hcC5tb3VzZUV2ZW50VG9MYXllclBvaW50KGUudG91Y2hlc1swXSksXG5cdFx0ICAgIHAyID0gbWFwLm1vdXNlRXZlbnRUb0xheWVyUG9pbnQoZS50b3VjaGVzWzFdKSxcblx0XHQgICAgdmlld0NlbnRlciA9IG1hcC5fZ2V0Q2VudGVyTGF5ZXJQb2ludCgpO1xuXG5cdFx0dGhpcy5fc3RhcnRDZW50ZXIgPSBwMS5hZGQocDIpLl9kaXZpZGVCeSgyKTtcblx0XHR0aGlzLl9zdGFydERpc3QgPSBwMS5kaXN0YW5jZVRvKHAyKTtcblxuXHRcdHRoaXMuX21vdmVkID0gZmFsc2U7XG5cdFx0dGhpcy5fem9vbWluZyA9IHRydWU7XG5cblx0XHR0aGlzLl9jZW50ZXJPZmZzZXQgPSB2aWV3Q2VudGVyLnN1YnRyYWN0KHRoaXMuX3N0YXJ0Q2VudGVyKTtcblxuXHRcdGlmIChtYXAuX3BhbkFuaW0pIHtcblx0XHRcdG1hcC5fcGFuQW5pbS5zdG9wKCk7XG5cdFx0fVxuXG5cdFx0TC5Eb21FdmVudFxuXHRcdCAgICAub24oZG9jdW1lbnQsICd0b3VjaG1vdmUnLCB0aGlzLl9vblRvdWNoTW92ZSwgdGhpcylcblx0XHQgICAgLm9uKGRvY3VtZW50LCAndG91Y2hlbmQnLCB0aGlzLl9vblRvdWNoRW5kLCB0aGlzKTtcblxuXHRcdEwuRG9tRXZlbnQucHJldmVudERlZmF1bHQoZSk7XG5cdH0sXG5cblx0X29uVG91Y2hNb3ZlOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmICghZS50b3VjaGVzIHx8IGUudG91Y2hlcy5sZW5ndGggIT09IDIgfHwgIXRoaXMuX3pvb21pbmcpIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuXHRcdCAgICBwMSA9IG1hcC5tb3VzZUV2ZW50VG9MYXllclBvaW50KGUudG91Y2hlc1swXSksXG5cdFx0ICAgIHAyID0gbWFwLm1vdXNlRXZlbnRUb0xheWVyUG9pbnQoZS50b3VjaGVzWzFdKTtcblxuXHRcdHRoaXMuX3NjYWxlID0gcDEuZGlzdGFuY2VUbyhwMikgLyB0aGlzLl9zdGFydERpc3Q7XG5cdFx0dGhpcy5fZGVsdGEgPSBwMS5fYWRkKHAyKS5fZGl2aWRlQnkoMikuX3N1YnRyYWN0KHRoaXMuX3N0YXJ0Q2VudGVyKTtcblxuXHRcdGlmICghbWFwLm9wdGlvbnMuYm91bmNlQXRab29tTGltaXRzICYmXG5cdFx0ICAgICgobWFwLmdldFpvb20oKSA9PT0gbWFwLmdldE1pblpvb20oKSAmJiB0aGlzLl9zY2FsZSA8IDEpIHx8XG5cdFx0ICAgICAobWFwLmdldFpvb20oKSA9PT0gbWFwLmdldE1heFpvb20oKSAmJiB0aGlzLl9zY2FsZSA+IDEpKSkgeyByZXR1cm47IH1cblxuXHRcdGlmICghdGhpcy5fbW92ZWQpIHtcblx0XHRcdG1hcFxuXHRcdFx0ICAgIC5maXJlKCdtb3Zlc3RhcnQnKVxuXHRcdFx0ICAgIC5maXJlKCd6b29tc3RhcnQnKTtcblxuXHRcdFx0dGhpcy5fbW92ZWQgPSB0cnVlO1xuXHRcdH1cblxuXHRcdEwuVXRpbC5jYW5jZWxBbmltRnJhbWUodGhpcy5fYW5pbVJlcXVlc3QpO1xuXHRcdHRoaXMuX2FuaW1SZXF1ZXN0ID0gTC5VdGlsLnJlcXVlc3RBbmltRnJhbWUodGhpcy5fdXBkYXRlT25Nb3ZlLCB0aGlzLCB0cnVlLCB0aGlzLl9tYXAuX2NvbnRhaW5lcik7XG5cblx0XHRMLkRvbUV2ZW50LnByZXZlbnREZWZhdWx0KGUpO1xuXHR9LFxuXG5cdF91cGRhdGVPbk1vdmU6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwO1xuXG5cdFx0aWYgKG1hcC5vcHRpb25zLnRvdWNoWm9vbSA9PT0gJ2NlbnRlcicpIHtcblx0XHRcdHRoaXMuX2NlbnRlciA9IG1hcC5nZXRDZW50ZXIoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fY2VudGVyID0gbWFwLmxheWVyUG9pbnRUb0xhdExuZyh0aGlzLl9nZXRUYXJnZXRDZW50ZXIoKSk7XG5cdFx0fVxuXHRcdHRoaXMuX3pvb20gPSBtYXAuZ2V0U2NhbGVab29tKHRoaXMuX3NjYWxlKTtcblxuXHRcdG1hcC5fYW5pbWF0ZVpvb20odGhpcy5fY2VudGVyLCB0aGlzLl96b29tKTtcblx0fSxcblxuXHRfb25Ub3VjaEVuZDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5fbW92ZWQgfHwgIXRoaXMuX3pvb21pbmcpIHtcblx0XHRcdHRoaXMuX3pvb21pbmcgPSBmYWxzZTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLl96b29taW5nID0gZmFsc2U7XG5cdFx0TC5VdGlsLmNhbmNlbEFuaW1GcmFtZSh0aGlzLl9hbmltUmVxdWVzdCk7XG5cblx0XHRMLkRvbUV2ZW50XG5cdFx0ICAgIC5vZmYoZG9jdW1lbnQsICd0b3VjaG1vdmUnLCB0aGlzLl9vblRvdWNoTW92ZSlcblx0XHQgICAgLm9mZihkb2N1bWVudCwgJ3RvdWNoZW5kJywgdGhpcy5fb25Ub3VjaEVuZCk7XG5cblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuXHRcdCAgICBvbGRab29tID0gbWFwLmdldFpvb20oKSxcblx0XHQgICAgem9vbURlbHRhID0gdGhpcy5fem9vbSAtIG9sZFpvb20sXG5cdFx0ICAgIGZpbmFsWm9vbSA9IG1hcC5fbGltaXRab29tKG9sZFpvb20gKyAoem9vbURlbHRhID4gMCA/IE1hdGguY2VpbCh6b29tRGVsdGEpIDogTWF0aC5mbG9vcih6b29tRGVsdGEpKSk7XG5cblx0XHRtYXAuX2FuaW1hdGVab29tKHRoaXMuX2NlbnRlciwgZmluYWxab29tLCB0cnVlKTtcblx0fSxcblxuXHRfZ2V0VGFyZ2V0Q2VudGVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGNlbnRlck9mZnNldCA9IHRoaXMuX2NlbnRlck9mZnNldC5zdWJ0cmFjdCh0aGlzLl9kZWx0YSkuZGl2aWRlQnkodGhpcy5fc2NhbGUpO1xuXHRcdHJldHVybiB0aGlzLl9zdGFydENlbnRlci5hZGQoY2VudGVyT2Zmc2V0KTtcblx0fVxufSk7XG5cbkwuTWFwLmFkZEluaXRIb29rKCdhZGRIYW5kbGVyJywgJ3RvdWNoWm9vbScsIEwuTWFwLlRvdWNoWm9vbSk7XG5cbi8qXG4gKiBMLk1hcC5UYXAgaXMgdXNlZCB0byBlbmFibGUgbW9iaWxlIGhhY2tzIGxpa2UgcXVpY2sgdGFwcyBhbmQgbG9uZyBob2xkLlxuICovXG5cbkwuTWFwLm1lcmdlT3B0aW9ucyh7XG5cdHRhcDogdHJ1ZSxcblx0dGFwVG9sZXJhbmNlOiAxNVxufSk7XG5cbkwuTWFwLlRhcCA9IEwuSGFuZGxlci5leHRlbmQoe1xuXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdEwuRG9tRXZlbnQub24odGhpcy5fbWFwLl9jb250YWluZXIsICd0b3VjaHN0YXJ0JywgdGhpcy5fb25Eb3duLCB0aGlzKTtcblx0fSxcblxuXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdEwuRG9tRXZlbnQub2ZmKHRoaXMuX21hcC5fY29udGFpbmVyLCAndG91Y2hzdGFydCcsIHRoaXMuX29uRG93biwgdGhpcyk7XG5cdH0sXG5cblx0X29uRG93bjogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAoIWUudG91Y2hlcykgeyByZXR1cm47IH1cblxuXHRcdEwuRG9tRXZlbnQucHJldmVudERlZmF1bHQoZSk7XG5cblx0XHR0aGlzLl9maXJlQ2xpY2sgPSB0cnVlO1xuXG5cdFx0Ly8gZG9uJ3Qgc2ltdWxhdGUgY2xpY2sgb3IgdHJhY2sgbG9uZ3ByZXNzIGlmIG1vcmUgdGhhbiAxIHRvdWNoXG5cdFx0aWYgKGUudG91Y2hlcy5sZW5ndGggPiAxKSB7XG5cdFx0XHR0aGlzLl9maXJlQ2xpY2sgPSBmYWxzZTtcblx0XHRcdGNsZWFyVGltZW91dCh0aGlzLl9ob2xkVGltZW91dCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIGZpcnN0ID0gZS50b3VjaGVzWzBdLFxuXHRcdCAgICBlbCA9IGZpcnN0LnRhcmdldDtcblxuXHRcdHRoaXMuX3N0YXJ0UG9zID0gdGhpcy5fbmV3UG9zID0gbmV3IEwuUG9pbnQoZmlyc3QuY2xpZW50WCwgZmlyc3QuY2xpZW50WSk7XG5cblx0XHQvLyBpZiB0b3VjaGluZyBhIGxpbmssIGhpZ2hsaWdodCBpdFxuXHRcdGlmIChlbC50YWdOYW1lICYmIGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2EnKSB7XG5cdFx0XHRMLkRvbVV0aWwuYWRkQ2xhc3MoZWwsICdsZWFmbGV0LWFjdGl2ZScpO1xuXHRcdH1cblxuXHRcdC8vIHNpbXVsYXRlIGxvbmcgaG9sZCBidXQgc2V0dGluZyBhIHRpbWVvdXRcblx0XHR0aGlzLl9ob2xkVGltZW91dCA9IHNldFRpbWVvdXQoTC5iaW5kKGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmICh0aGlzLl9pc1RhcFZhbGlkKCkpIHtcblx0XHRcdFx0dGhpcy5fZmlyZUNsaWNrID0gZmFsc2U7XG5cdFx0XHRcdHRoaXMuX29uVXAoKTtcblx0XHRcdFx0dGhpcy5fc2ltdWxhdGVFdmVudCgnY29udGV4dG1lbnUnLCBmaXJzdCk7XG5cdFx0XHR9XG5cdFx0fSwgdGhpcyksIDEwMDApO1xuXHRcdFxuXHRcdHRoaXMuX3NpbXVsYXRlRXZlbnQoJ21vdXNlZG93bicsIGZpcnN0KTtcblxuXHRcdEwuRG9tRXZlbnQub24oZG9jdW1lbnQsIHtcblx0XHRcdHRvdWNobW92ZTogdGhpcy5fb25Nb3ZlLFxuXHRcdFx0dG91Y2hlbmQ6IHRoaXMuX29uVXBcblx0XHR9LCB0aGlzKTtcblx0fSxcblxuXHRfb25VcDogZnVuY3Rpb24gKGUpIHtcblx0XHRjbGVhclRpbWVvdXQodGhpcy5faG9sZFRpbWVvdXQpO1xuXG5cdFx0TC5Eb21FdmVudC5vZmYoZG9jdW1lbnQsIHtcblx0XHRcdHRvdWNobW92ZTogdGhpcy5fb25Nb3ZlLFxuXHRcdFx0dG91Y2hlbmQ6IHRoaXMuX29uVXBcblx0XHR9LCB0aGlzKTtcblxuXHRcdGlmICh0aGlzLl9maXJlQ2xpY2sgJiYgZSAmJiBlLmNoYW5nZWRUb3VjaGVzKSB7XG5cblx0XHRcdHZhciBmaXJzdCA9IGUuY2hhbmdlZFRvdWNoZXNbMF0sXG5cdFx0XHQgICAgZWwgPSBmaXJzdC50YXJnZXQ7XG5cblx0XHRcdGlmIChlbCAmJiBlbC50YWdOYW1lICYmIGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2EnKSB7XG5cdFx0XHRcdEwuRG9tVXRpbC5yZW1vdmVDbGFzcyhlbCwgJ2xlYWZsZXQtYWN0aXZlJyk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHRoaXMuX3NpbXVsYXRlRXZlbnQoJ21vdXNldXAnLCBmaXJzdCk7XG5cblx0XHRcdC8vIHNpbXVsYXRlIGNsaWNrIGlmIHRoZSB0b3VjaCBkaWRuJ3QgbW92ZSB0b28gbXVjaFxuXHRcdFx0aWYgKHRoaXMuX2lzVGFwVmFsaWQoKSkge1xuXHRcdFx0XHR0aGlzLl9zaW11bGF0ZUV2ZW50KCdjbGljaycsIGZpcnN0KTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0X2lzVGFwVmFsaWQ6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fbmV3UG9zLmRpc3RhbmNlVG8odGhpcy5fc3RhcnRQb3MpIDw9IHRoaXMuX21hcC5vcHRpb25zLnRhcFRvbGVyYW5jZTtcblx0fSxcblxuXHRfb25Nb3ZlOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBmaXJzdCA9IGUudG91Y2hlc1swXTtcblx0XHR0aGlzLl9uZXdQb3MgPSBuZXcgTC5Qb2ludChmaXJzdC5jbGllbnRYLCBmaXJzdC5jbGllbnRZKTtcblx0fSxcblxuXHRfc2ltdWxhdGVFdmVudDogZnVuY3Rpb24gKHR5cGUsIGUpIHtcblx0XHR2YXIgc2ltdWxhdGVkRXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnTW91c2VFdmVudHMnKTtcblxuXHRcdHNpbXVsYXRlZEV2ZW50Ll9zaW11bGF0ZWQgPSB0cnVlO1xuXHRcdGUudGFyZ2V0Ll9zaW11bGF0ZWRDbGljayA9IHRydWU7XG5cblx0XHRzaW11bGF0ZWRFdmVudC5pbml0TW91c2VFdmVudChcblx0XHQgICAgICAgIHR5cGUsIHRydWUsIHRydWUsIHdpbmRvdywgMSxcblx0XHQgICAgICAgIGUuc2NyZWVuWCwgZS5zY3JlZW5ZLFxuXHRcdCAgICAgICAgZS5jbGllbnRYLCBlLmNsaWVudFksXG5cdFx0ICAgICAgICBmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgMCwgbnVsbCk7XG5cblx0XHRlLnRhcmdldC5kaXNwYXRjaEV2ZW50KHNpbXVsYXRlZEV2ZW50KTtcblx0fVxufSk7XG5cbmlmIChMLkJyb3dzZXIudG91Y2ggJiYgIUwuQnJvd3Nlci5wb2ludGVyKSB7XG5cdEwuTWFwLmFkZEluaXRIb29rKCdhZGRIYW5kbGVyJywgJ3RhcCcsIEwuTWFwLlRhcCk7XG59XG5cbi8qXG4gKiBMLkhhbmRsZXIuU2hpZnREcmFnWm9vbSBpcyB1c2VkIHRvIGFkZCBzaGlmdC1kcmFnIHpvb20gaW50ZXJhY3Rpb24gdG8gdGhlIG1hcFxuICAqICh6b29tIHRvIGEgc2VsZWN0ZWQgYm91bmRpbmcgYm94KSwgZW5hYmxlZCBieSBkZWZhdWx0LlxuICovXG5cbkwuTWFwLm1lcmdlT3B0aW9ucyh7XG5cdGJveFpvb206IHRydWVcbn0pO1xuXG5MLk1hcC5Cb3hab29tID0gTC5IYW5kbGVyLmV4dGVuZCh7XG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChtYXApIHtcblx0XHR0aGlzLl9tYXAgPSBtYXA7XG5cdFx0dGhpcy5fY29udGFpbmVyID0gbWFwLl9jb250YWluZXI7XG5cdFx0dGhpcy5fcGFuZSA9IG1hcC5fcGFuZXMub3ZlcmxheVBhbmU7XG5cdH0sXG5cblx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHRMLkRvbUV2ZW50Lm9uKHRoaXMuX2NvbnRhaW5lciwgJ21vdXNlZG93bicsIHRoaXMuX29uTW91c2VEb3duLCB0aGlzKTtcblx0fSxcblxuXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdEwuRG9tRXZlbnQub2ZmKHRoaXMuX2NvbnRhaW5lciwgJ21vdXNlZG93bicsIHRoaXMuX29uTW91c2VEb3duLCB0aGlzKTtcblx0fSxcblxuXHRtb3ZlZDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9tb3ZlZDtcblx0fSxcblxuXHRfb25Nb3VzZURvd246IGZ1bmN0aW9uIChlKSB7XG5cdFx0dGhpcy5fbW92ZWQgPSBmYWxzZTtcblxuXHRcdGlmICghZS5zaGlmdEtleSB8fCAoKGUud2hpY2ggIT09IDEpICYmIChlLmJ1dHRvbiAhPT0gMSkpKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdFx0TC5Eb21VdGlsLmRpc2FibGVUZXh0U2VsZWN0aW9uKCk7XG5cdFx0TC5Eb21VdGlsLmRpc2FibGVJbWFnZURyYWcoKTtcblxuXHRcdHRoaXMuX3N0YXJ0UG9pbnQgPSB0aGlzLl9tYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZSk7XG5cblx0XHRMLkRvbUV2ZW50Lm9uKGRvY3VtZW50LCB7XG5cdFx0XHRtb3VzZW1vdmU6IHRoaXMuX29uTW91c2VNb3ZlLFxuXHRcdCAgICBtb3VzZXVwOiB0aGlzLl9vbk1vdXNlVXAsXG5cdFx0ICAgIGtleWRvd246IHRoaXMuX29uS2V5RG93blxuXHRcdH0sIHRoaXMpO1xuXHR9LFxuXG5cdF9vbk1vdXNlTW92ZTogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAoIXRoaXMuX21vdmVkKSB7XG5cdFx0XHR0aGlzLl9tb3ZlZCA9IHRydWU7XG5cblx0XHRcdHRoaXMuX2JveCA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsICdsZWFmbGV0LXpvb20tYm94JywgdGhpcy5fY29udGFpbmVyKTtcblx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWNyb3NzaGFpcicpO1xuXG5cdFx0XHR0aGlzLl9tYXAuZmlyZSgnYm94em9vbXN0YXJ0Jyk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fcG9pbnQgPSB0aGlzLl9tYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZSk7XG5cblx0XHR2YXIgYm91bmRzID0gbmV3IEwuQm91bmRzKHRoaXMuX3BvaW50LCB0aGlzLl9zdGFydFBvaW50KSxcblx0XHQgICAgc2l6ZSA9IGJvdW5kcy5nZXRTaXplKCk7XG5cblx0XHRMLkRvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fYm94LCBib3VuZHMubWluKTtcblxuXHRcdHRoaXMuX2JveC5zdHlsZS53aWR0aCAgPSBzaXplLnggKyAncHgnO1xuXHRcdHRoaXMuX2JveC5zdHlsZS5oZWlnaHQgPSBzaXplLnkgKyAncHgnO1xuXHR9LFxuXG5cdF9maW5pc2g6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fbW92ZWQpIHtcblx0XHRcdEwuRG9tVXRpbC5yZW1vdmUodGhpcy5fYm94KTtcblx0XHRcdEwuRG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWNyb3NzaGFpcicpO1xuXHRcdH1cblxuXHRcdEwuRG9tVXRpbC5lbmFibGVUZXh0U2VsZWN0aW9uKCk7XG5cdFx0TC5Eb21VdGlsLmVuYWJsZUltYWdlRHJhZygpO1xuXG5cdFx0TC5Eb21FdmVudC5vZmYoZG9jdW1lbnQsIHtcblx0XHRcdG1vdXNlbW92ZTogdGhpcy5fb25Nb3VzZU1vdmUsXG5cdFx0ICAgIG1vdXNldXA6IHRoaXMuX29uTW91c2VVcCxcblx0XHQgICAga2V5ZG93bjogdGhpcy5fb25LZXlEb3duXG5cdFx0fSwgdGhpcyk7XG5cdH0sXG5cblx0X29uTW91c2VVcDogZnVuY3Rpb24gKCkge1xuXG5cdFx0dGhpcy5fZmluaXNoKCk7XG5cblx0XHRpZiAoIXRoaXMuX21vdmVkKSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIGJvdW5kcyA9IG5ldyBMLkxhdExuZ0JvdW5kcyhcblx0XHQgICAgICAgIHRoaXMuX21hcC5jb250YWluZXJQb2ludFRvTGF0TG5nKHRoaXMuX3N0YXJ0UG9pbnQpLFxuXHRcdCAgICAgICAgdGhpcy5fbWFwLmNvbnRhaW5lclBvaW50VG9MYXRMbmcodGhpcy5fcG9pbnQpKTtcblxuXHRcdHRoaXMuX21hcFxuXHRcdFx0LmZpdEJvdW5kcyhib3VuZHMpXG5cdFx0XHQuZmlyZSgnYm94em9vbWVuZCcsIHtib3hab29tQm91bmRzOiBib3VuZHN9KTtcblx0fSxcblxuXHRfb25LZXlEb3duOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmIChlLmtleUNvZGUgPT09IDI3KSB7XG5cdFx0XHR0aGlzLl9maW5pc2goKTtcblx0XHR9XG5cdH1cbn0pO1xuXG5MLk1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICdib3hab29tJywgTC5NYXAuQm94Wm9vbSk7XG5cbi8qXG4gKiBMLk1hcC5LZXlib2FyZCBpcyBoYW5kbGluZyBrZXlib2FyZCBpbnRlcmFjdGlvbiB3aXRoIHRoZSBtYXAsIGVuYWJsZWQgYnkgZGVmYXVsdC5cbiAqL1xuXG5MLk1hcC5tZXJnZU9wdGlvbnMoe1xuXHRrZXlib2FyZDogdHJ1ZSxcblx0a2V5Ym9hcmRQYW5PZmZzZXQ6IDgwLFxuXHRrZXlib2FyZFpvb21PZmZzZXQ6IDFcbn0pO1xuXG5MLk1hcC5LZXlib2FyZCA9IEwuSGFuZGxlci5leHRlbmQoe1xuXG5cdGtleUNvZGVzOiB7XG5cdFx0bGVmdDogICAgWzM3XSxcblx0XHRyaWdodDogICBbMzldLFxuXHRcdGRvd246ICAgIFs0MF0sXG5cdFx0dXA6ICAgICAgWzM4XSxcblx0XHR6b29tSW46ICBbMTg3LCAxMDcsIDYxLCAxNzFdLFxuXHRcdHpvb21PdXQ6IFsxODksIDEwOSwgMTczXVxuXHR9LFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChtYXApIHtcblx0XHR0aGlzLl9tYXAgPSBtYXA7XG5cblx0XHR0aGlzLl9zZXRQYW5PZmZzZXQobWFwLm9wdGlvbnMua2V5Ym9hcmRQYW5PZmZzZXQpO1xuXHRcdHRoaXMuX3NldFpvb21PZmZzZXQobWFwLm9wdGlvbnMua2V5Ym9hcmRab29tT2Zmc2V0KTtcblx0fSxcblxuXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBjb250YWluZXIgPSB0aGlzLl9tYXAuX2NvbnRhaW5lcjtcblxuXHRcdC8vIG1ha2UgdGhlIGNvbnRhaW5lciBmb2N1c2FibGUgYnkgdGFiYmluZ1xuXHRcdGlmIChjb250YWluZXIudGFiSW5kZXggPT09IC0xKSB7XG5cdFx0XHRjb250YWluZXIudGFiSW5kZXggPSAnMCc7XG5cdFx0fVxuXG5cdFx0TC5Eb21FdmVudC5vbihjb250YWluZXIsIHtcblx0XHQgICAgZm9jdXM6IHRoaXMuX29uRm9jdXMsXG5cdFx0ICAgIGJsdXI6IHRoaXMuX29uQmx1cixcblx0XHQgICAgbW91c2Vkb3duOiB0aGlzLl9vbk1vdXNlRG93blxuXHRcdH0sIHRoaXMpO1xuXG5cdFx0dGhpcy5fbWFwLm9uKHtcblx0XHRcdGZvY3VzOiB0aGlzLl9hZGRIb29rcyxcblx0XHQgICAgYmx1cjogdGhpcy5fcmVtb3ZlSG9va3Ncblx0XHR9LCB0aGlzKTtcblx0fSxcblxuXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3JlbW92ZUhvb2tzKCk7XG5cblx0XHRMLkRvbUV2ZW50Lm9mZih0aGlzLl9tYXAuX2NvbnRhaW5lciwge1xuXHRcdCAgICBmb2N1czogdGhpcy5fb25Gb2N1cyxcblx0XHQgICAgYmx1cjogdGhpcy5fb25CbHVyLFxuXHRcdCAgICBtb3VzZWRvd246IHRoaXMuX29uTW91c2VEb3duXG5cdFx0fSwgdGhpcyk7XG5cblx0XHR0aGlzLl9tYXAub2ZmKHtcblx0XHRcdGZvY3VzOiB0aGlzLl9hZGRIb29rcyxcblx0XHQgICAgYmx1cjogdGhpcy5fcmVtb3ZlSG9va3Ncblx0XHR9LCB0aGlzKTtcblx0fSxcblxuXHRfb25Nb3VzZURvd246IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fZm9jdXNlZCkgeyByZXR1cm47IH1cblxuXHRcdHZhciBib2R5ID0gZG9jdW1lbnQuYm9keSxcblx0XHQgICAgZG9jRWwgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsXG5cdFx0ICAgIHRvcCA9IGJvZHkuc2Nyb2xsVG9wIHx8IGRvY0VsLnNjcm9sbFRvcCxcblx0XHQgICAgbGVmdCA9IGJvZHkuc2Nyb2xsTGVmdCB8fCBkb2NFbC5zY3JvbGxMZWZ0O1xuXG5cdFx0dGhpcy5fbWFwLl9jb250YWluZXIuZm9jdXMoKTtcblxuXHRcdHdpbmRvdy5zY3JvbGxUbyhsZWZ0LCB0b3ApO1xuXHR9LFxuXG5cdF9vbkZvY3VzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fZm9jdXNlZCA9IHRydWU7XG5cdFx0dGhpcy5fbWFwLmZpcmUoJ2ZvY3VzJyk7XG5cdH0sXG5cblx0X29uQmx1cjogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX2ZvY3VzZWQgPSBmYWxzZTtcblx0XHR0aGlzLl9tYXAuZmlyZSgnYmx1cicpO1xuXHR9LFxuXG5cdF9zZXRQYW5PZmZzZXQ6IGZ1bmN0aW9uIChwYW4pIHtcblx0XHR2YXIga2V5cyA9IHRoaXMuX3BhbktleXMgPSB7fSxcblx0XHQgICAgY29kZXMgPSB0aGlzLmtleUNvZGVzLFxuXHRcdCAgICBpLCBsZW47XG5cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjb2Rlcy5sZWZ0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRrZXlzW2NvZGVzLmxlZnRbaV1dID0gWy0xICogcGFuLCAwXTtcblx0XHR9XG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY29kZXMucmlnaHQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGtleXNbY29kZXMucmlnaHRbaV1dID0gW3BhbiwgMF07XG5cdFx0fVxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNvZGVzLmRvd24ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGtleXNbY29kZXMuZG93bltpXV0gPSBbMCwgcGFuXTtcblx0XHR9XG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY29kZXMudXAubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGtleXNbY29kZXMudXBbaV1dID0gWzAsIC0xICogcGFuXTtcblx0XHR9XG5cdH0sXG5cblx0X3NldFpvb21PZmZzZXQ6IGZ1bmN0aW9uICh6b29tKSB7XG5cdFx0dmFyIGtleXMgPSB0aGlzLl96b29tS2V5cyA9IHt9LFxuXHRcdCAgICBjb2RlcyA9IHRoaXMua2V5Q29kZXMsXG5cdFx0ICAgIGksIGxlbjtcblxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNvZGVzLnpvb21Jbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0a2V5c1tjb2Rlcy56b29tSW5baV1dID0gem9vbTtcblx0XHR9XG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY29kZXMuem9vbU91dC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0a2V5c1tjb2Rlcy56b29tT3V0W2ldXSA9IC16b29tO1xuXHRcdH1cblx0fSxcblxuXHRfYWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHRMLkRvbUV2ZW50Lm9uKGRvY3VtZW50LCAna2V5ZG93bicsIHRoaXMuX29uS2V5RG93biwgdGhpcyk7XG5cdH0sXG5cblx0X3JlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0TC5Eb21FdmVudC5vZmYoZG9jdW1lbnQsICdrZXlkb3duJywgdGhpcy5fb25LZXlEb3duLCB0aGlzKTtcblx0fSxcblxuXHRfb25LZXlEb3duOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmIChlLmFsdEtleSB8fCBlLmN0cmxLZXkgfHwgZS5tZXRhS2V5KSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIGtleSA9IGUua2V5Q29kZSxcblx0XHQgICAgbWFwID0gdGhpcy5fbWFwO1xuXG5cdFx0aWYgKGtleSBpbiB0aGlzLl9wYW5LZXlzKSB7XG5cblx0XHRcdGlmIChtYXAuX3BhbkFuaW0gJiYgbWFwLl9wYW5BbmltLl9pblByb2dyZXNzKSB7IHJldHVybjsgfVxuXG5cdFx0XHRtYXAucGFuQnkodGhpcy5fcGFuS2V5c1trZXldKTtcblxuXHRcdFx0aWYgKG1hcC5vcHRpb25zLm1heEJvdW5kcykge1xuXHRcdFx0XHRtYXAucGFuSW5zaWRlQm91bmRzKG1hcC5vcHRpb25zLm1heEJvdW5kcyk7XG5cdFx0XHR9XG5cblx0XHR9IGVsc2UgaWYgKGtleSBpbiB0aGlzLl96b29tS2V5cykge1xuXHRcdFx0bWFwLnNldFpvb20obWFwLmdldFpvb20oKSArIHRoaXMuX3pvb21LZXlzW2tleV0pO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRMLkRvbUV2ZW50LnN0b3AoZSk7XG5cdH1cbn0pO1xuXG5MLk1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICdrZXlib2FyZCcsIEwuTWFwLktleWJvYXJkKTtcblxuLypcbiAqIEwuSGFuZGxlci5NYXJrZXJEcmFnIGlzIHVzZWQgaW50ZXJuYWxseSBieSBMLk1hcmtlciB0byBtYWtlIHRoZSBtYXJrZXJzIGRyYWdnYWJsZS5cbiAqL1xuXG5MLkhhbmRsZXIuTWFya2VyRHJhZyA9IEwuSGFuZGxlci5leHRlbmQoe1xuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobWFya2VyKSB7XG5cdFx0dGhpcy5fbWFya2VyID0gbWFya2VyO1xuXHR9LFxuXG5cdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGljb24gPSB0aGlzLl9tYXJrZXIuX2ljb247XG5cblx0XHRpZiAoIXRoaXMuX2RyYWdnYWJsZSkge1xuXHRcdFx0dGhpcy5fZHJhZ2dhYmxlID0gbmV3IEwuRHJhZ2dhYmxlKGljb24sIGljb24pO1xuXHRcdH1cblxuXHRcdHRoaXMuX2RyYWdnYWJsZS5vbih7XG5cdFx0XHRkcmFnc3RhcnQ6IHRoaXMuX29uRHJhZ1N0YXJ0LFxuXHRcdFx0ZHJhZzogdGhpcy5fb25EcmFnLFxuXHRcdFx0ZHJhZ2VuZDogdGhpcy5fb25EcmFnRW5kXG5cdFx0fSwgdGhpcykuZW5hYmxlKCk7XG5cblx0XHRMLkRvbVV0aWwuYWRkQ2xhc3MoaWNvbiwgJ2xlYWZsZXQtbWFya2VyLWRyYWdnYWJsZScpO1xuXHR9LFxuXG5cdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fZHJhZ2dhYmxlLm9mZih7XG5cdFx0XHRkcmFnc3RhcnQ6IHRoaXMuX29uRHJhZ1N0YXJ0LFxuXHRcdFx0ZHJhZzogdGhpcy5fb25EcmFnLFxuXHRcdFx0ZHJhZ2VuZDogdGhpcy5fb25EcmFnRW5kXG5cdFx0fSwgdGhpcykuZGlzYWJsZSgpO1xuXG5cdFx0TC5Eb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX21hcmtlci5faWNvbiwgJ2xlYWZsZXQtbWFya2VyLWRyYWdnYWJsZScpO1xuXHR9LFxuXG5cdG1vdmVkOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2RyYWdnYWJsZSAmJiB0aGlzLl9kcmFnZ2FibGUuX21vdmVkO1xuXHR9LFxuXG5cdF9vbkRyYWdTdGFydDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX21hcmtlclxuXHRcdCAgICAuY2xvc2VQb3B1cCgpXG5cdFx0ICAgIC5maXJlKCdtb3Zlc3RhcnQnKVxuXHRcdCAgICAuZmlyZSgnZHJhZ3N0YXJ0Jyk7XG5cdH0sXG5cblx0X29uRHJhZzogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBtYXJrZXIgPSB0aGlzLl9tYXJrZXIsXG5cdFx0ICAgIHNoYWRvdyA9IG1hcmtlci5fc2hhZG93LFxuXHRcdCAgICBpY29uUG9zID0gTC5Eb21VdGlsLmdldFBvc2l0aW9uKG1hcmtlci5faWNvbiksXG5cdFx0ICAgIGxhdGxuZyA9IG1hcmtlci5fbWFwLmxheWVyUG9pbnRUb0xhdExuZyhpY29uUG9zKTtcblxuXHRcdC8vIHVwZGF0ZSBzaGFkb3cgcG9zaXRpb25cblx0XHRpZiAoc2hhZG93KSB7XG5cdFx0XHRMLkRvbVV0aWwuc2V0UG9zaXRpb24oc2hhZG93LCBpY29uUG9zKTtcblx0XHR9XG5cblx0XHRtYXJrZXIuX2xhdGxuZyA9IGxhdGxuZztcblxuXHRcdG1hcmtlclxuXHRcdCAgICAuZmlyZSgnbW92ZScsIHtsYXRsbmc6IGxhdGxuZ30pXG5cdFx0ICAgIC5maXJlKCdkcmFnJyk7XG5cdH0sXG5cblx0X29uRHJhZ0VuZDogZnVuY3Rpb24gKGUpIHtcblx0XHR0aGlzLl9tYXJrZXJcblx0XHQgICAgLmZpcmUoJ21vdmVlbmQnKVxuXHRcdCAgICAuZmlyZSgnZHJhZ2VuZCcsIGUpO1xuXHR9XG59KTtcblxuLypcclxuICogTC5Db250cm9sIGlzIGEgYmFzZSBjbGFzcyBmb3IgaW1wbGVtZW50aW5nIG1hcCBjb250cm9scy4gSGFuZGxlcyBwb3NpdGlvbmluZy5cclxuICogQWxsIG90aGVyIGNvbnRyb2xzIGV4dGVuZCBmcm9tIHRoaXMgY2xhc3MuXHJcbiAqL1xyXG5cclxuTC5Db250cm9sID0gTC5DbGFzcy5leHRlbmQoe1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdHBvc2l0aW9uOiAndG9wcmlnaHQnXHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRcdEwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHR9LFxyXG5cclxuXHRnZXRQb3NpdGlvbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5wb3NpdGlvbjtcclxuXHR9LFxyXG5cclxuXHRzZXRQb3NpdGlvbjogZnVuY3Rpb24gKHBvc2l0aW9uKSB7XHJcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwO1xyXG5cclxuXHRcdGlmIChtYXApIHtcclxuXHRcdFx0bWFwLnJlbW92ZUNvbnRyb2wodGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5vcHRpb25zLnBvc2l0aW9uID0gcG9zaXRpb247XHJcblxyXG5cdFx0aWYgKG1hcCkge1xyXG5cdFx0XHRtYXAuYWRkQ29udHJvbCh0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRnZXRDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9jb250YWluZXI7XHJcblx0fSxcclxuXHJcblx0YWRkVG86IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdHRoaXMuX21hcCA9IG1hcDtcclxuXHJcblx0XHR2YXIgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyID0gdGhpcy5vbkFkZChtYXApLFxyXG5cdFx0ICAgIHBvcyA9IHRoaXMuZ2V0UG9zaXRpb24oKSxcclxuXHRcdCAgICBjb3JuZXIgPSBtYXAuX2NvbnRyb2xDb3JuZXJzW3Bvc107XHJcblxyXG5cdFx0TC5Eb21VdGlsLmFkZENsYXNzKGNvbnRhaW5lciwgJ2xlYWZsZXQtY29udHJvbCcpO1xyXG5cclxuXHRcdGlmIChwb3MuaW5kZXhPZignYm90dG9tJykgIT09IC0xKSB7XHJcblx0XHRcdGNvcm5lci5pbnNlcnRCZWZvcmUoY29udGFpbmVyLCBjb3JuZXIuZmlyc3RDaGlsZCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRjb3JuZXIuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRyZW1vdmU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdEwuRG9tVXRpbC5yZW1vdmUodGhpcy5fY29udGFpbmVyKTtcclxuXHJcblx0XHRpZiAodGhpcy5vblJlbW92ZSkge1xyXG5cdFx0XHR0aGlzLm9uUmVtb3ZlKHRoaXMuX21hcCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fbWFwID0gbnVsbDtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfcmVmb2N1c09uTWFwOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdHRoaXMuX21hcC5nZXRDb250YWluZXIoKS5mb2N1cygpO1xyXG5cdFx0fVxyXG5cdH1cclxufSk7XHJcblxyXG5MLmNvbnRyb2wgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgTC5Db250cm9sKG9wdGlvbnMpO1xyXG59O1xyXG5cclxuXHJcbi8vIGFkZHMgY29udHJvbC1yZWxhdGVkIG1ldGhvZHMgdG8gTC5NYXBcclxuXHJcbkwuTWFwLmluY2x1ZGUoe1xyXG5cdGFkZENvbnRyb2w6IGZ1bmN0aW9uIChjb250cm9sKSB7XHJcblx0XHRjb250cm9sLmFkZFRvKHRoaXMpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0cmVtb3ZlQ29udHJvbDogZnVuY3Rpb24gKGNvbnRyb2wpIHtcclxuXHRcdGNvbnRyb2wucmVtb3ZlKCk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfaW5pdENvbnRyb2xQb3M6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBjb3JuZXJzID0gdGhpcy5fY29udHJvbENvcm5lcnMgPSB7fSxcclxuXHRcdCAgICBsID0gJ2xlYWZsZXQtJyxcclxuXHRcdCAgICBjb250YWluZXIgPSB0aGlzLl9jb250cm9sQ29udGFpbmVyID1cclxuXHRcdCAgICAgICAgICAgIEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGwgKyAnY29udHJvbC1jb250YWluZXInLCB0aGlzLl9jb250YWluZXIpO1xyXG5cclxuXHRcdGZ1bmN0aW9uIGNyZWF0ZUNvcm5lcih2U2lkZSwgaFNpZGUpIHtcclxuXHRcdFx0dmFyIGNsYXNzTmFtZSA9IGwgKyB2U2lkZSArICcgJyArIGwgKyBoU2lkZTtcclxuXHJcblx0XHRcdGNvcm5lcnNbdlNpZGUgKyBoU2lkZV0gPSBMLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUsIGNvbnRhaW5lcik7XHJcblx0XHR9XHJcblxyXG5cdFx0Y3JlYXRlQ29ybmVyKCd0b3AnLCAnbGVmdCcpO1xyXG5cdFx0Y3JlYXRlQ29ybmVyKCd0b3AnLCAncmlnaHQnKTtcclxuXHRcdGNyZWF0ZUNvcm5lcignYm90dG9tJywgJ2xlZnQnKTtcclxuXHRcdGNyZWF0ZUNvcm5lcignYm90dG9tJywgJ3JpZ2h0Jyk7XHJcblx0fSxcclxuXHJcblx0X2NsZWFyQ29udHJvbFBvczogZnVuY3Rpb24gKCkge1xyXG5cdFx0TC5Eb21VdGlsLnJlbW92ZSh0aGlzLl9jb250cm9sQ29udGFpbmVyKTtcclxuXHR9XHJcbn0pO1xyXG5cbi8qXHJcbiAqIEwuQ29udHJvbC5BdHRyaWJ1dGlvbiBpcyB1c2VkIGZvciBkaXNwbGF5aW5nIGF0dHJpYnV0aW9uIG9uIHRoZSBtYXAgKGFkZGVkIGJ5IGRlZmF1bHQpLlxyXG4gKi9cclxuXHJcbkwuQ29udHJvbC5BdHRyaWJ1dGlvbiA9IEwuQ29udHJvbC5leHRlbmQoe1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdHBvc2l0aW9uOiAnYm90dG9tcmlnaHQnLFxyXG5cdFx0cHJlZml4OiAnPGEgaHJlZj1cImh0dHA6Ly9sZWFmbGV0anMuY29tXCIgdGl0bGU9XCJBIEpTIGxpYnJhcnkgZm9yIGludGVyYWN0aXZlIG1hcHNcIj5MZWFmbGV0PC9hPidcclxuXHR9LFxyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdFx0TC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuXHRcdHRoaXMuX2F0dHJpYnV0aW9ucyA9IHt9O1xyXG5cdH0sXHJcblxyXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHR0aGlzLl9jb250YWluZXIgPSBMLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCAnbGVhZmxldC1jb250cm9sLWF0dHJpYnV0aW9uJyk7XHJcblx0XHRMLkRvbUV2ZW50LmRpc2FibGVDbGlja1Byb3BhZ2F0aW9uKHRoaXMuX2NvbnRhaW5lcik7XHJcblxyXG5cdFx0Ly8gVE9ETyB1Z2x5LCByZWZhY3RvclxyXG5cdFx0Zm9yICh2YXIgaSBpbiBtYXAuX2xheWVycykge1xyXG5cdFx0XHRpZiAobWFwLl9sYXllcnNbaV0uZ2V0QXR0cmlidXRpb24pIHtcclxuXHRcdFx0XHR0aGlzLmFkZEF0dHJpYnV0aW9uKG1hcC5fbGF5ZXJzW2ldLmdldEF0dHJpYnV0aW9uKCkpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fdXBkYXRlKCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcclxuXHR9LFxyXG5cclxuXHRzZXRQcmVmaXg6IGZ1bmN0aW9uIChwcmVmaXgpIHtcclxuXHRcdHRoaXMub3B0aW9ucy5wcmVmaXggPSBwcmVmaXg7XHJcblx0XHR0aGlzLl91cGRhdGUoKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdGFkZEF0dHJpYnV0aW9uOiBmdW5jdGlvbiAodGV4dCkge1xyXG5cdFx0aWYgKCF0ZXh0KSB7IHJldHVybjsgfVxyXG5cclxuXHRcdGlmICghdGhpcy5fYXR0cmlidXRpb25zW3RleHRdKSB7XHJcblx0XHRcdHRoaXMuX2F0dHJpYnV0aW9uc1t0ZXh0XSA9IDA7XHJcblx0XHR9XHJcblx0XHR0aGlzLl9hdHRyaWJ1dGlvbnNbdGV4dF0rKztcclxuXHJcblx0XHR0aGlzLl91cGRhdGUoKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRyZW1vdmVBdHRyaWJ1dGlvbjogZnVuY3Rpb24gKHRleHQpIHtcclxuXHRcdGlmICghdGV4dCkgeyByZXR1cm47IH1cclxuXHJcblx0XHRpZiAodGhpcy5fYXR0cmlidXRpb25zW3RleHRdKSB7XHJcblx0XHRcdHRoaXMuX2F0dHJpYnV0aW9uc1t0ZXh0XS0tO1xyXG5cdFx0XHR0aGlzLl91cGRhdGUoKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX21hcCkgeyByZXR1cm47IH1cclxuXHJcblx0XHR2YXIgYXR0cmlicyA9IFtdO1xyXG5cclxuXHRcdGZvciAodmFyIGkgaW4gdGhpcy5fYXR0cmlidXRpb25zKSB7XHJcblx0XHRcdGlmICh0aGlzLl9hdHRyaWJ1dGlvbnNbaV0pIHtcclxuXHRcdFx0XHRhdHRyaWJzLnB1c2goaSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgcHJlZml4QW5kQXR0cmlicyA9IFtdO1xyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMucHJlZml4KSB7XHJcblx0XHRcdHByZWZpeEFuZEF0dHJpYnMucHVzaCh0aGlzLm9wdGlvbnMucHJlZml4KTtcclxuXHRcdH1cclxuXHRcdGlmIChhdHRyaWJzLmxlbmd0aCkge1xyXG5cdFx0XHRwcmVmaXhBbmRBdHRyaWJzLnB1c2goYXR0cmlicy5qb2luKCcsICcpKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9jb250YWluZXIuaW5uZXJIVE1MID0gcHJlZml4QW5kQXR0cmlicy5qb2luKCcgfCAnKTtcclxuXHR9XHJcbn0pO1xyXG5cclxuTC5NYXAubWVyZ2VPcHRpb25zKHtcclxuXHRhdHRyaWJ1dGlvbkNvbnRyb2w6IHRydWVcclxufSk7XHJcblxyXG5MLk1hcC5hZGRJbml0SG9vayhmdW5jdGlvbiAoKSB7XHJcblx0aWYgKHRoaXMub3B0aW9ucy5hdHRyaWJ1dGlvbkNvbnRyb2wpIHtcclxuXHRcdHRoaXMuYXR0cmlidXRpb25Db250cm9sID0gKG5ldyBMLkNvbnRyb2wuQXR0cmlidXRpb24oKSkuYWRkVG8odGhpcyk7XHJcblx0fVxyXG59KTtcclxuXHJcbkwuY29udHJvbC5hdHRyaWJ1dGlvbiA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBMLkNvbnRyb2wuQXR0cmlidXRpb24ob3B0aW9ucyk7XHJcbn07XHJcblxuLypcclxuICogTC5Db250cm9sLlpvb20gaXMgdXNlZCBmb3IgdGhlIGRlZmF1bHQgem9vbSBidXR0b25zIG9uIHRoZSBtYXAuXHJcbiAqL1xyXG5cclxuTC5Db250cm9sLlpvb20gPSBMLkNvbnRyb2wuZXh0ZW5kKHtcclxuICAgIG9wdGlvbnM6IHtcclxuICAgICAgICBwb3NpdGlvbjogJ3RvcGxlZnQnLFxyXG4gICAgICAgIHpvb21JblRleHQ6ICcrJyxcclxuICAgICAgICB6b29tSW5UaXRsZTogJ1pvb20gaW4nLFxyXG4gICAgICAgIHpvb21PdXRUZXh0OiAnLScsXHJcbiAgICAgICAgem9vbU91dFRpdGxlOiAnWm9vbSBvdXQnXHJcbiAgICB9LFxyXG5cclxuICAgIG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcbiAgICAgICAgdmFyIHpvb21OYW1lID0gJ2xlYWZsZXQtY29udHJvbC16b29tJyxcclxuICAgICAgICAgICAgY29udGFpbmVyID0gTC5Eb21VdGlsLmNyZWF0ZSgnZGl2Jywgem9vbU5hbWUgKyAnIGxlYWZsZXQtYmFyJyksXHJcbiAgICAgICAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XHJcblxyXG4gICAgICAgIHRoaXMuX3pvb21JbkJ1dHRvbiAgPSB0aGlzLl9jcmVhdGVCdXR0b24ob3B0aW9ucy56b29tSW5UZXh0LCBvcHRpb25zLnpvb21JblRpdGxlLFxyXG4gICAgICAgICAgICAgICAgem9vbU5hbWUgKyAnLWluJywgIGNvbnRhaW5lciwgdGhpcy5fem9vbUluKTtcclxuICAgICAgICB0aGlzLl96b29tT3V0QnV0dG9uID0gdGhpcy5fY3JlYXRlQnV0dG9uKG9wdGlvbnMuem9vbU91dFRleHQsIG9wdGlvbnMuem9vbU91dFRpdGxlLFxyXG4gICAgICAgICAgICAgICAgem9vbU5hbWUgKyAnLW91dCcsIGNvbnRhaW5lciwgdGhpcy5fem9vbU91dCk7XHJcblxyXG4gICAgICAgIHRoaXMuX3VwZGF0ZURpc2FibGVkKCk7XHJcbiAgICAgICAgbWFwLm9uKCd6b29tZW5kIHpvb21sZXZlbHNjaGFuZ2UnLCB0aGlzLl91cGRhdGVEaXNhYmxlZCwgdGhpcyk7XHJcblxyXG4gICAgICAgIHJldHVybiBjb250YWluZXI7XHJcbiAgICB9LFxyXG5cclxuICAgIG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XHJcbiAgICAgICAgbWFwLm9mZignem9vbWVuZCB6b29tbGV2ZWxzY2hhbmdlJywgdGhpcy5fdXBkYXRlRGlzYWJsZWQsIHRoaXMpO1xyXG4gICAgfSxcclxuXHJcbiAgICBfem9vbUluOiBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgIHRoaXMuX21hcC56b29tSW4oZS5zaGlmdEtleSA/IDMgOiAxKTtcclxuICAgIH0sXHJcblxyXG4gICAgX3pvb21PdXQ6IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgdGhpcy5fbWFwLnpvb21PdXQoZS5zaGlmdEtleSA/IDMgOiAxKTtcclxuICAgIH0sXHJcblxyXG4gICAgX2NyZWF0ZUJ1dHRvbjogZnVuY3Rpb24gKGh0bWwsIHRpdGxlLCBjbGFzc05hbWUsIGNvbnRhaW5lciwgZm4pIHtcclxuICAgICAgICB2YXIgbGluayA9IEwuRG9tVXRpbC5jcmVhdGUoJ2EnLCBjbGFzc05hbWUsIGNvbnRhaW5lcik7XHJcbiAgICAgICAgbGluay5pbm5lckhUTUwgPSBodG1sO1xyXG4gICAgICAgIGxpbmsuaHJlZiA9ICcjJztcclxuICAgICAgICBsaW5rLnRpdGxlID0gdGl0bGU7XHJcblxyXG4gICAgICAgIEwuRG9tRXZlbnRcclxuICAgICAgICAgICAgLm9uKGxpbmssICdtb3VzZWRvd24gZGJsY2xpY2snLCBMLkRvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbilcclxuICAgICAgICAgICAgLm9uKGxpbmssICdjbGljaycsIEwuRG9tRXZlbnQuc3RvcClcclxuICAgICAgICAgICAgLm9uKGxpbmssICdjbGljaycsIGZuLCB0aGlzKVxyXG4gICAgICAgICAgICAub24obGluaywgJ2NsaWNrJywgdGhpcy5fcmVmb2N1c09uTWFwLCB0aGlzKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGxpbms7XHJcbiAgICB9LFxyXG5cclxuICAgIF91cGRhdGVEaXNhYmxlZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBtYXAgPSB0aGlzLl9tYXAsXHJcbiAgICAgICAgICAgIGNsYXNzTmFtZSA9ICdsZWFmbGV0LWRpc2FibGVkJztcclxuXHJcbiAgICAgICAgTC5Eb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX3pvb21JbkJ1dHRvbiwgY2xhc3NOYW1lKTtcclxuICAgICAgICBMLkRvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fem9vbU91dEJ1dHRvbiwgY2xhc3NOYW1lKTtcclxuXHJcbiAgICAgICAgaWYgKG1hcC5fem9vbSA9PT0gbWFwLmdldE1pblpvb20oKSkge1xyXG4gICAgICAgICAgICBMLkRvbVV0aWwuYWRkQ2xhc3ModGhpcy5fem9vbU91dEJ1dHRvbiwgY2xhc3NOYW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG1hcC5fem9vbSA9PT0gbWFwLmdldE1heFpvb20oKSkge1xyXG4gICAgICAgICAgICBMLkRvbVV0aWwuYWRkQ2xhc3ModGhpcy5fem9vbUluQnV0dG9uLCBjbGFzc05hbWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSk7XHJcblxyXG5MLk1hcC5tZXJnZU9wdGlvbnMoe1xyXG4gICAgem9vbUNvbnRyb2w6IHRydWVcclxufSk7XHJcblxyXG5MLk1hcC5hZGRJbml0SG9vayhmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAodGhpcy5vcHRpb25zLnpvb21Db250cm9sKSB7XHJcbiAgICAgICAgdGhpcy56b29tQ29udHJvbCA9IG5ldyBMLkNvbnRyb2wuWm9vbSgpO1xyXG4gICAgICAgIHRoaXMuYWRkQ29udHJvbCh0aGlzLnpvb21Db250cm9sKTtcclxuICAgIH1cclxufSk7XHJcblxyXG5MLmNvbnRyb2wuem9vbSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICByZXR1cm4gbmV3IEwuQ29udHJvbC5ab29tKG9wdGlvbnMpO1xyXG59O1xyXG5cclxuXG4vKlxuICogTC5Db250cm9sLlNjYWxlIGlzIHVzZWQgZm9yIGRpc3BsYXlpbmcgbWV0cmljL2ltcGVyaWFsIHNjYWxlIG9uIHRoZSBtYXAuXG4gKi9cblxuTC5Db250cm9sLlNjYWxlID0gTC5Db250cm9sLmV4dGVuZCh7XG5cdG9wdGlvbnM6IHtcblx0XHRwb3NpdGlvbjogJ2JvdHRvbWxlZnQnLFxuXHRcdG1heFdpZHRoOiAxMDAsXG5cdFx0bWV0cmljOiB0cnVlLFxuXHRcdGltcGVyaWFsOiB0cnVlXG5cdFx0Ly8gdXBkYXRlV2hlbklkbGU6IGZhbHNlXG5cdH0sXG5cblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcblx0XHR2YXIgY2xhc3NOYW1lID0gJ2xlYWZsZXQtY29udHJvbC1zY2FsZScsXG5cdFx0ICAgIGNvbnRhaW5lciA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSksXG5cdFx0ICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cblx0XHR0aGlzLl9hZGRTY2FsZXMob3B0aW9ucywgY2xhc3NOYW1lICsgJy1saW5lJywgY29udGFpbmVyKTtcblxuXHRcdG1hcC5vbihvcHRpb25zLnVwZGF0ZVdoZW5JZGxlID8gJ21vdmVlbmQnIDogJ21vdmUnLCB0aGlzLl91cGRhdGUsIHRoaXMpO1xuXHRcdG1hcC53aGVuUmVhZHkodGhpcy5fdXBkYXRlLCB0aGlzKTtcblxuXHRcdHJldHVybiBjb250YWluZXI7XG5cdH0sXG5cblx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcblx0XHRtYXAub2ZmKHRoaXMub3B0aW9ucy51cGRhdGVXaGVuSWRsZSA/ICdtb3ZlZW5kJyA6ICdtb3ZlJywgdGhpcy5fdXBkYXRlLCB0aGlzKTtcblx0fSxcblxuXHRfYWRkU2NhbGVzOiBmdW5jdGlvbiAob3B0aW9ucywgY2xhc3NOYW1lLCBjb250YWluZXIpIHtcblx0XHRpZiAob3B0aW9ucy5tZXRyaWMpIHtcblx0XHRcdHRoaXMuX21TY2FsZSA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSwgY29udGFpbmVyKTtcblx0XHR9XG5cdFx0aWYgKG9wdGlvbnMuaW1wZXJpYWwpIHtcblx0XHRcdHRoaXMuX2lTY2FsZSA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSwgY29udGFpbmVyKTtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIHkgPSBtYXAuZ2V0U2l6ZSgpLnkgLyAyO1xuXG5cdFx0dmFyIG1heE1ldGVycyA9IEwuQ1JTLkVhcnRoLmRpc3RhbmNlKFxuXHRcdFx0XHRtYXAuY29udGFpbmVyUG9pbnRUb0xhdExuZyhbMCwgeV0pLFxuXHRcdFx0XHRtYXAuY29udGFpbmVyUG9pbnRUb0xhdExuZyhbdGhpcy5vcHRpb25zLm1heFdpZHRoLCB5XSkpO1xuXG5cdFx0dGhpcy5fdXBkYXRlU2NhbGVzKG1heE1ldGVycyk7XG5cdH0sXG5cblx0X3VwZGF0ZVNjYWxlczogZnVuY3Rpb24gKG1heE1ldGVycykge1xuXHRcdGlmICh0aGlzLm9wdGlvbnMubWV0cmljICYmIG1heE1ldGVycykge1xuXHRcdFx0dGhpcy5fdXBkYXRlTWV0cmljKG1heE1ldGVycyk7XG5cdFx0fVxuXHRcdGlmICh0aGlzLm9wdGlvbnMuaW1wZXJpYWwgJiYgbWF4TWV0ZXJzKSB7XG5cdFx0XHR0aGlzLl91cGRhdGVJbXBlcmlhbChtYXhNZXRlcnMpO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlTWV0cmljOiBmdW5jdGlvbiAobWF4TWV0ZXJzKSB7XG5cdFx0dmFyIG1ldGVycyA9IHRoaXMuX2dldFJvdW5kTnVtKG1heE1ldGVycyksXG5cdFx0ICAgIGxhYmVsID0gbWV0ZXJzIDwgMTAwMCA/IG1ldGVycyArICcgbScgOiAobWV0ZXJzIC8gMTAwMCkgKyAnIGttJztcblxuXHRcdHRoaXMuX3VwZGF0ZVNjYWxlKHRoaXMuX21TY2FsZSwgbGFiZWwsIG1ldGVycyAvIG1heE1ldGVycyk7XG5cdH0sXG5cblx0X3VwZGF0ZUltcGVyaWFsOiBmdW5jdGlvbiAobWF4TWV0ZXJzKSB7XG5cdFx0dmFyIG1heEZlZXQgPSBtYXhNZXRlcnMgKiAzLjI4MDgzOTksXG5cdFx0ICAgIG1heE1pbGVzLCBtaWxlcywgZmVldDtcblxuXHRcdGlmIChtYXhGZWV0ID4gNTI4MCkge1xuXHRcdFx0bWF4TWlsZXMgPSBtYXhGZWV0IC8gNTI4MDtcblx0XHRcdG1pbGVzID0gdGhpcy5fZ2V0Um91bmROdW0obWF4TWlsZXMpO1xuXHRcdFx0dGhpcy5fdXBkYXRlU2NhbGUodGhpcy5faVNjYWxlLCBtaWxlcyArICcgbWknLCBtaWxlcyAvIG1heE1pbGVzKTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRmZWV0ID0gdGhpcy5fZ2V0Um91bmROdW0obWF4RmVldCk7XG5cdFx0XHR0aGlzLl91cGRhdGVTY2FsZSh0aGlzLl9pU2NhbGUsIGZlZXQgKyAnIGZ0JywgZmVldCAvIG1heEZlZXQpO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlU2NhbGU6IGZ1bmN0aW9uIChzY2FsZSwgdGV4dCwgcmF0aW8pIHtcblx0XHRzY2FsZS5zdHlsZS53aWR0aCA9IChNYXRoLnJvdW5kKHRoaXMub3B0aW9ucy5tYXhXaWR0aCAqIHJhdGlvKSAtIDEwKSArICdweCc7XG5cdFx0c2NhbGUuaW5uZXJIVE1MID0gdGV4dDtcblx0fSxcblxuXHRfZ2V0Um91bmROdW06IGZ1bmN0aW9uIChudW0pIHtcblx0XHR2YXIgcG93MTAgPSBNYXRoLnBvdygxMCwgKE1hdGguZmxvb3IobnVtKSArICcnKS5sZW5ndGggLSAxKSxcblx0XHQgICAgZCA9IG51bSAvIHBvdzEwO1xuXG5cdFx0ZCA9IGQgPj0gMTAgPyAxMCA6XG5cdFx0ICAgIGQgPj0gNSA/IDUgOlxuXHRcdCAgICBkID49IDMgPyAzIDpcblx0XHQgICAgZCA+PSAyID8gMiA6IDE7XG5cblx0XHRyZXR1cm4gcG93MTAgKiBkO1xuXHR9XG59KTtcblxuTC5jb250cm9sLnNjYWxlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0cmV0dXJuIG5ldyBMLkNvbnRyb2wuU2NhbGUob3B0aW9ucyk7XG59O1xuXG4vKlxyXG4gKiBMLkNvbnRyb2wuTGF5ZXJzIGlzIGEgY29udHJvbCB0byBhbGxvdyB1c2VycyB0byBzd2l0Y2ggYmV0d2VlbiBkaWZmZXJlbnQgbGF5ZXJzIG9uIHRoZSBtYXAuXHJcbiAqL1xyXG5cclxuTC5Db250cm9sLkxheWVycyA9IEwuQ29udHJvbC5leHRlbmQoe1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdGNvbGxhcHNlZDogdHJ1ZSxcclxuXHRcdHBvc2l0aW9uOiAndG9wcmlnaHQnLFxyXG5cdFx0YXV0b1pJbmRleDogdHJ1ZVxyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChiYXNlTGF5ZXJzLCBvdmVybGF5cywgb3B0aW9ucykge1xyXG5cdFx0TC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuXHRcdHRoaXMuX2xheWVycyA9IHt9O1xyXG5cdFx0dGhpcy5fbGFzdFpJbmRleCA9IDA7XHJcblx0XHR0aGlzLl9oYW5kbGluZ0NsaWNrID0gZmFsc2U7XHJcblxyXG5cdFx0Zm9yICh2YXIgaSBpbiBiYXNlTGF5ZXJzKSB7XHJcblx0XHRcdHRoaXMuX2FkZExheWVyKGJhc2VMYXllcnNbaV0sIGkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAoaSBpbiBvdmVybGF5cykge1xyXG5cdFx0XHR0aGlzLl9hZGRMYXllcihvdmVybGF5c1tpXSwgaSwgdHJ1ZSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0b25BZGQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX2luaXRMYXlvdXQoKTtcclxuXHRcdHRoaXMuX3VwZGF0ZSgpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLl9jb250YWluZXI7XHJcblx0fSxcclxuXHJcblx0YWRkQmFzZUxheWVyOiBmdW5jdGlvbiAobGF5ZXIsIG5hbWUpIHtcclxuXHRcdHRoaXMuX2FkZExheWVyKGxheWVyLCBuYW1lKTtcclxuXHRcdHJldHVybiB0aGlzLl91cGRhdGUoKTtcclxuXHR9LFxyXG5cclxuXHRhZGRPdmVybGF5OiBmdW5jdGlvbiAobGF5ZXIsIG5hbWUpIHtcclxuXHRcdHRoaXMuX2FkZExheWVyKGxheWVyLCBuYW1lLCB0cnVlKTtcclxuXHRcdHJldHVybiB0aGlzLl91cGRhdGUoKTtcclxuXHR9LFxyXG5cclxuXHRyZW1vdmVMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHRsYXllci5vZmYoJ2FkZCByZW1vdmUnLCB0aGlzLl9vbkxheWVyQ2hhbmdlLCB0aGlzKTtcclxuXHJcblx0XHRkZWxldGUgdGhpcy5fbGF5ZXJzW0wuc3RhbXAobGF5ZXIpXTtcclxuXHRcdHJldHVybiB0aGlzLl91cGRhdGUoKTtcclxuXHR9LFxyXG5cclxuXHRfaW5pdExheW91dDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGNsYXNzTmFtZSA9ICdsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzJyxcclxuXHRcdCAgICBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIgPSBMLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUpO1xyXG5cclxuXHRcdC8vIG1ha2VzIHRoaXMgd29yayBvbiBJRSB0b3VjaCBkZXZpY2VzIGJ5IHN0b3BwaW5nIGl0IGZyb20gZmlyaW5nIGEgbW91c2VvdXQgZXZlbnQgd2hlbiB0aGUgdG91Y2ggaXMgcmVsZWFzZWRcclxuXHRcdGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGFzcG9wdXAnLCB0cnVlKTtcclxuXHJcblx0XHRpZiAoIUwuQnJvd3Nlci50b3VjaCkge1xyXG5cdFx0XHRMLkRvbUV2ZW50XHJcblx0XHRcdFx0LmRpc2FibGVDbGlja1Byb3BhZ2F0aW9uKGNvbnRhaW5lcilcclxuXHRcdFx0XHQuZGlzYWJsZVNjcm9sbFByb3BhZ2F0aW9uKGNvbnRhaW5lcik7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRMLkRvbUV2ZW50Lm9uKGNvbnRhaW5lciwgJ2NsaWNrJywgTC5Eb21FdmVudC5zdG9wUHJvcGFnYXRpb24pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBmb3JtID0gdGhpcy5fZm9ybSA9IEwuRG9tVXRpbC5jcmVhdGUoJ2Zvcm0nLCBjbGFzc05hbWUgKyAnLWxpc3QnKTtcclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmNvbGxhcHNlZCkge1xyXG5cdFx0XHRpZiAoIUwuQnJvd3Nlci5hbmRyb2lkKSB7XHJcblx0XHRcdFx0TC5Eb21FdmVudC5vbihjb250YWluZXIsIHtcclxuXHRcdFx0XHRcdG1vdXNlZW50ZXI6IHRoaXMuX2V4cGFuZCxcclxuXHRcdFx0XHRcdG1vdXNlbGVhdmU6IHRoaXMuX2NvbGxhcHNlXHJcblx0XHRcdFx0fSwgdGhpcyk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciBsaW5rID0gdGhpcy5fbGF5ZXJzTGluayA9IEwuRG9tVXRpbC5jcmVhdGUoJ2EnLCBjbGFzc05hbWUgKyAnLXRvZ2dsZScsIGNvbnRhaW5lcik7XHJcblx0XHRcdGxpbmsuaHJlZiA9ICcjJztcclxuXHRcdFx0bGluay50aXRsZSA9ICdMYXllcnMnO1xyXG5cclxuXHRcdFx0aWYgKEwuQnJvd3Nlci50b3VjaCkge1xyXG5cdFx0XHRcdEwuRG9tRXZlbnRcclxuXHRcdFx0XHQgICAgLm9uKGxpbmssICdjbGljaycsIEwuRG9tRXZlbnQuc3RvcClcclxuXHRcdFx0XHQgICAgLm9uKGxpbmssICdjbGljaycsIHRoaXMuX2V4cGFuZCwgdGhpcyk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0TC5Eb21FdmVudC5vbihsaW5rLCAnZm9jdXMnLCB0aGlzLl9leHBhbmQsIHRoaXMpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyB3b3JrIGFyb3VuZCBmb3IgRmlyZWZveCBBbmRyb2lkIGlzc3VlIGh0dHBzOi8vZ2l0aHViLmNvbS9MZWFmbGV0L0xlYWZsZXQvaXNzdWVzLzIwMzNcclxuXHRcdFx0TC5Eb21FdmVudC5vbihmb3JtLCAnY2xpY2snLCBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdFx0c2V0VGltZW91dChMLmJpbmQodGhpcy5fb25JbnB1dENsaWNrLCB0aGlzKSwgMCk7XHJcblx0XHRcdH0sIHRoaXMpO1xyXG5cclxuXHRcdFx0dGhpcy5fbWFwLm9uKCdjbGljaycsIHRoaXMuX2NvbGxhcHNlLCB0aGlzKTtcclxuXHRcdFx0Ly8gVE9ETyBrZXlib2FyZCBhY2Nlc3NpYmlsaXR5XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLl9leHBhbmQoKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9iYXNlTGF5ZXJzTGlzdCA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSArICctYmFzZScsIGZvcm0pO1xyXG5cdFx0dGhpcy5fc2VwYXJhdG9yID0gTC5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgY2xhc3NOYW1lICsgJy1zZXBhcmF0b3InLCBmb3JtKTtcclxuXHRcdHRoaXMuX292ZXJsYXlzTGlzdCA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSArICctb3ZlcmxheXMnLCBmb3JtKTtcclxuXHJcblx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQoZm9ybSk7XHJcblx0fSxcclxuXHJcblx0X2FkZExheWVyOiBmdW5jdGlvbiAobGF5ZXIsIG5hbWUsIG92ZXJsYXkpIHtcclxuXHRcdGxheWVyLm9uKCdhZGQgcmVtb3ZlJywgdGhpcy5fb25MYXllckNoYW5nZSwgdGhpcyk7XHJcblxyXG5cdFx0dmFyIGlkID0gTC5zdGFtcChsYXllcik7XHJcblxyXG5cdFx0dGhpcy5fbGF5ZXJzW2lkXSA9IHtcclxuXHRcdFx0bGF5ZXI6IGxheWVyLFxyXG5cdFx0XHRuYW1lOiBuYW1lLFxyXG5cdFx0XHRvdmVybGF5OiBvdmVybGF5XHJcblx0XHR9O1xyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuYXV0b1pJbmRleCAmJiBsYXllci5zZXRaSW5kZXgpIHtcclxuXHRcdFx0dGhpcy5fbGFzdFpJbmRleCsrO1xyXG5cdFx0XHRsYXllci5zZXRaSW5kZXgodGhpcy5fbGFzdFpJbmRleCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9jb250YWluZXIpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0dGhpcy5fYmFzZUxheWVyc0xpc3QuaW5uZXJIVE1MID0gJyc7XHJcblx0XHR0aGlzLl9vdmVybGF5c0xpc3QuaW5uZXJIVE1MID0gJyc7XHJcblxyXG5cdFx0dmFyIGJhc2VMYXllcnNQcmVzZW50LCBvdmVybGF5c1ByZXNlbnQsIGksIG9iajtcclxuXHJcblx0XHRmb3IgKGkgaW4gdGhpcy5fbGF5ZXJzKSB7XHJcblx0XHRcdG9iaiA9IHRoaXMuX2xheWVyc1tpXTtcclxuXHRcdFx0dGhpcy5fYWRkSXRlbShvYmopO1xyXG5cdFx0XHRvdmVybGF5c1ByZXNlbnQgPSBvdmVybGF5c1ByZXNlbnQgfHwgb2JqLm92ZXJsYXk7XHJcblx0XHRcdGJhc2VMYXllcnNQcmVzZW50ID0gYmFzZUxheWVyc1ByZXNlbnQgfHwgIW9iai5vdmVybGF5O1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX3NlcGFyYXRvci5zdHlsZS5kaXNwbGF5ID0gb3ZlcmxheXNQcmVzZW50ICYmIGJhc2VMYXllcnNQcmVzZW50ID8gJycgOiAnbm9uZSc7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X29uTGF5ZXJDaGFuZ2U6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRpZiAoIXRoaXMuX2hhbmRsaW5nQ2xpY2spIHtcclxuXHRcdFx0dGhpcy5fdXBkYXRlKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIG92ZXJsYXkgPSB0aGlzLl9sYXllcnNbTC5zdGFtcChlLnRhcmdldCldLm92ZXJsYXk7XHJcblxyXG5cdFx0dmFyIHR5cGUgPSBvdmVybGF5ID9cclxuXHRcdFx0KGUudHlwZSA9PT0gJ2FkZCcgPyAnb3ZlcmxheWFkZCcgOiAnb3ZlcmxheXJlbW92ZScpIDpcclxuXHRcdFx0KGUudHlwZSA9PT0gJ2FkZCcgPyAnYmFzZWxheWVyY2hhbmdlJyA6IG51bGwpO1xyXG5cclxuXHRcdGlmICh0eXBlKSB7XHJcblx0XHRcdHRoaXMuX21hcC5maXJlKHR5cGUsIGUudGFyZ2V0KTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBJRTcgYnVncyBvdXQgaWYgeW91IGNyZWF0ZSBhIHJhZGlvIGR5bmFtaWNhbGx5LCBzbyB5b3UgaGF2ZSB0byBkbyBpdCB0aGlzIGhhY2t5IHdheSAoc2VlIGh0dHA6Ly9iaXQubHkvUHFZTEJlKVxyXG5cdF9jcmVhdGVSYWRpb0VsZW1lbnQ6IGZ1bmN0aW9uIChuYW1lLCBjaGVja2VkKSB7XHJcblxyXG5cdFx0dmFyIHJhZGlvSHRtbCA9ICc8aW5wdXQgdHlwZT1cInJhZGlvXCIgY2xhc3M9XCJsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXNlbGVjdG9yXCIgbmFtZT1cIicgK1xyXG5cdFx0XHRcdG5hbWUgKyAnXCInICsgKGNoZWNrZWQgPyAnIGNoZWNrZWQ9XCJjaGVja2VkXCInIDogJycpICsgJy8+JztcclxuXHJcblx0XHR2YXIgcmFkaW9GcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG5cdFx0cmFkaW9GcmFnbWVudC5pbm5lckhUTUwgPSByYWRpb0h0bWw7XHJcblxyXG5cdFx0cmV0dXJuIHJhZGlvRnJhZ21lbnQuZmlyc3RDaGlsZDtcclxuXHR9LFxyXG5cclxuXHRfYWRkSXRlbTogZnVuY3Rpb24gKG9iaikge1xyXG5cdFx0dmFyIGxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGFiZWwnKSxcclxuXHRcdCAgICBjaGVja2VkID0gdGhpcy5fbWFwLmhhc0xheWVyKG9iai5sYXllciksXHJcblx0XHQgICAgaW5wdXQ7XHJcblxyXG5cdFx0aWYgKG9iai5vdmVybGF5KSB7XHJcblx0XHRcdGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcclxuXHRcdFx0aW5wdXQudHlwZSA9ICdjaGVja2JveCc7XHJcblx0XHRcdGlucHV0LmNsYXNzTmFtZSA9ICdsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXNlbGVjdG9yJztcclxuXHRcdFx0aW5wdXQuZGVmYXVsdENoZWNrZWQgPSBjaGVja2VkO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0aW5wdXQgPSB0aGlzLl9jcmVhdGVSYWRpb0VsZW1lbnQoJ2xlYWZsZXQtYmFzZS1sYXllcnMnLCBjaGVja2VkKTtcclxuXHRcdH1cclxuXHJcblx0XHRpbnB1dC5sYXllcklkID0gTC5zdGFtcChvYmoubGF5ZXIpO1xyXG5cclxuXHRcdEwuRG9tRXZlbnQub24oaW5wdXQsICdjbGljaycsIHRoaXMuX29uSW5wdXRDbGljaywgdGhpcyk7XHJcblxyXG5cdFx0dmFyIG5hbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XHJcblx0XHRuYW1lLmlubmVySFRNTCA9ICcgJyArIG9iai5uYW1lO1xyXG5cclxuXHRcdGxhYmVsLmFwcGVuZENoaWxkKGlucHV0KTtcclxuXHRcdGxhYmVsLmFwcGVuZENoaWxkKG5hbWUpO1xyXG5cclxuXHRcdHZhciBjb250YWluZXIgPSBvYmoub3ZlcmxheSA/IHRoaXMuX292ZXJsYXlzTGlzdCA6IHRoaXMuX2Jhc2VMYXllcnNMaXN0O1xyXG5cdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKGxhYmVsKTtcclxuXHJcblx0XHRyZXR1cm4gbGFiZWw7XHJcblx0fSxcclxuXHJcblx0X29uSW5wdXRDbGljazogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGlucHV0cyA9IHRoaXMuX2Zvcm0uZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2lucHV0JyksXHJcblx0XHQgICAgaW5wdXQsIGxheWVyLCBoYXNMYXllcjtcclxuXHJcblx0XHR0aGlzLl9oYW5kbGluZ0NsaWNrID0gdHJ1ZTtcclxuXHJcblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gaW5wdXRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdGlucHV0ID0gaW5wdXRzW2ldO1xyXG5cdFx0XHRsYXllciA9IHRoaXMuX2xheWVyc1tpbnB1dC5sYXllcklkXS5sYXllcjtcclxuXHRcdFx0aGFzTGF5ZXIgPSB0aGlzLl9tYXAuaGFzTGF5ZXIobGF5ZXIpO1xyXG5cclxuXHRcdFx0aWYgKGlucHV0LmNoZWNrZWQgJiYgIWhhc0xheWVyKSB7XHJcblx0XHRcdFx0dGhpcy5fbWFwLmFkZExheWVyKGxheWVyKTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIWlucHV0LmNoZWNrZWQgJiYgaGFzTGF5ZXIpIHtcclxuXHRcdFx0XHR0aGlzLl9tYXAucmVtb3ZlTGF5ZXIobGF5ZXIpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5faGFuZGxpbmdDbGljayA9IGZhbHNlO1xyXG5cclxuXHRcdHRoaXMuX3JlZm9jdXNPbk1hcCgpO1xyXG5cdH0sXHJcblxyXG5cdF9leHBhbmQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdEwuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLWV4cGFuZGVkJyk7XHJcblx0fSxcclxuXHJcblx0X2NvbGxhcHNlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRMLkRvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC1jb250cm9sLWxheWVycy1leHBhbmRlZCcpO1xyXG5cdH1cclxufSk7XHJcblxyXG5MLmNvbnRyb2wubGF5ZXJzID0gZnVuY3Rpb24gKGJhc2VMYXllcnMsIG92ZXJsYXlzLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBMLkNvbnRyb2wuTGF5ZXJzKGJhc2VMYXllcnMsIG92ZXJsYXlzLCBvcHRpb25zKTtcclxufTtcclxuXG4vKlxuICogTC5Qb3NBbmltYXRpb24gZmFsbGJhY2sgaW1wbGVtZW50YXRpb24gdGhhdCBwb3dlcnMgTGVhZmxldCBwYW4gYW5pbWF0aW9uc1xuICogaW4gYnJvd3NlcnMgdGhhdCBkb24ndCBzdXBwb3J0IENTUzMgVHJhbnNpdGlvbnMuXG4gKi9cblxuTC5Qb3NBbmltYXRpb24gPSBMLkRvbVV0aWwuVFJBTlNJVElPTiA/IEwuUG9zQW5pbWF0aW9uIDogTC5Qb3NBbmltYXRpb24uZXh0ZW5kKHtcblxuXHRydW46IGZ1bmN0aW9uIChlbCwgbmV3UG9zLCBkdXJhdGlvbiwgZWFzZUxpbmVhcml0eSkgeyAvLyAoSFRNTEVsZW1lbnQsIFBvaW50WywgTnVtYmVyLCBOdW1iZXJdKVxuXHRcdHRoaXMuc3RvcCgpO1xuXG5cdFx0dGhpcy5fZWwgPSBlbDtcblx0XHR0aGlzLl9pblByb2dyZXNzID0gdHJ1ZTtcblx0XHR0aGlzLl9kdXJhdGlvbiA9IGR1cmF0aW9uIHx8IDAuMjU7XG5cdFx0dGhpcy5fZWFzZU91dFBvd2VyID0gMSAvIE1hdGgubWF4KGVhc2VMaW5lYXJpdHkgfHwgMC41LCAwLjIpO1xuXG5cdFx0dGhpcy5fc3RhcnRQb3MgPSBMLkRvbVV0aWwuZ2V0UG9zaXRpb24oZWwpO1xuXHRcdHRoaXMuX29mZnNldCA9IG5ld1Bvcy5zdWJ0cmFjdCh0aGlzLl9zdGFydFBvcyk7XG5cdFx0dGhpcy5fc3RhcnRUaW1lID0gK25ldyBEYXRlKCk7XG5cblx0XHR0aGlzLmZpcmUoJ3N0YXJ0Jyk7XG5cblx0XHR0aGlzLl9hbmltYXRlKCk7XG5cdH0sXG5cblx0c3RvcDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5faW5Qcm9ncmVzcykgeyByZXR1cm47IH1cblxuXHRcdHRoaXMuX3N0ZXAoKTtcblx0XHR0aGlzLl9jb21wbGV0ZSgpO1xuXHR9LFxuXG5cdF9hbmltYXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gYW5pbWF0aW9uIGxvb3Bcblx0XHR0aGlzLl9hbmltSWQgPSBMLlV0aWwucmVxdWVzdEFuaW1GcmFtZSh0aGlzLl9hbmltYXRlLCB0aGlzKTtcblx0XHR0aGlzLl9zdGVwKCk7XG5cdH0sXG5cblx0X3N0ZXA6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgZWxhcHNlZCA9ICgrbmV3IERhdGUoKSkgLSB0aGlzLl9zdGFydFRpbWUsXG5cdFx0ICAgIGR1cmF0aW9uID0gdGhpcy5fZHVyYXRpb24gKiAxMDAwO1xuXG5cdFx0aWYgKGVsYXBzZWQgPCBkdXJhdGlvbikge1xuXHRcdFx0dGhpcy5fcnVuRnJhbWUodGhpcy5fZWFzZU91dChlbGFwc2VkIC8gZHVyYXRpb24pKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fcnVuRnJhbWUoMSk7XG5cdFx0XHR0aGlzLl9jb21wbGV0ZSgpO1xuXHRcdH1cblx0fSxcblxuXHRfcnVuRnJhbWU6IGZ1bmN0aW9uIChwcm9ncmVzcykge1xuXHRcdHZhciBwb3MgPSB0aGlzLl9zdGFydFBvcy5hZGQodGhpcy5fb2Zmc2V0Lm11bHRpcGx5QnkocHJvZ3Jlc3MpKTtcblx0XHRMLkRvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fZWwsIHBvcyk7XG5cblx0XHR0aGlzLmZpcmUoJ3N0ZXAnKTtcblx0fSxcblxuXHRfY29tcGxldGU6IGZ1bmN0aW9uICgpIHtcblx0XHRMLlV0aWwuY2FuY2VsQW5pbUZyYW1lKHRoaXMuX2FuaW1JZCk7XG5cblx0XHR0aGlzLl9pblByb2dyZXNzID0gZmFsc2U7XG5cdFx0dGhpcy5maXJlKCdlbmQnKTtcblx0fSxcblxuXHRfZWFzZU91dDogZnVuY3Rpb24gKHQpIHtcblx0XHRyZXR1cm4gMSAtIE1hdGgucG93KDEgLSB0LCB0aGlzLl9lYXNlT3V0UG93ZXIpO1xuXHR9XG59KTtcblxuLypcclxuICogUHJvdmlkZXMgTC5NYXAgd2l0aCBjb252ZW5pZW50IHNob3J0Y3V0cyBmb3IgdXNpbmcgYnJvd3NlciBnZW9sb2NhdGlvbiBmZWF0dXJlcy5cclxuICovXHJcblxyXG5MLk1hcC5pbmNsdWRlKHtcclxuXHRfZGVmYXVsdExvY2F0ZU9wdGlvbnM6IHtcclxuXHRcdHRpbWVvdXQ6IDEwMDAwLFxyXG5cdFx0d2F0Y2g6IGZhbHNlXHJcblx0XHQvLyBzZXRWaWV3OiBmYWxzZVxyXG5cdFx0Ly8gbWF4Wm9vbTogPE51bWJlcj5cclxuXHRcdC8vIG1heGltdW1BZ2U6IDBcclxuXHRcdC8vIGVuYWJsZUhpZ2hBY2N1cmFjeTogZmFsc2VcclxuXHR9LFxyXG5cclxuXHRsb2NhdGU6IGZ1bmN0aW9uICgvKk9iamVjdCovIG9wdGlvbnMpIHtcclxuXHJcblx0XHRvcHRpb25zID0gdGhpcy5fbG9jYXRlT3B0aW9ucyA9IEwuZXh0ZW5kKHRoaXMuX2RlZmF1bHRMb2NhdGVPcHRpb25zLCBvcHRpb25zKTtcclxuXHJcblx0XHRpZiAoIW5hdmlnYXRvci5nZW9sb2NhdGlvbikge1xyXG5cdFx0XHR0aGlzLl9oYW5kbGVHZW9sb2NhdGlvbkVycm9yKHtcclxuXHRcdFx0XHRjb2RlOiAwLFxyXG5cdFx0XHRcdG1lc3NhZ2U6ICdHZW9sb2NhdGlvbiBub3Qgc3VwcG9ydGVkLidcclxuXHRcdFx0fSk7XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBvblJlc3BvbnNlID0gTC5iaW5kKHRoaXMuX2hhbmRsZUdlb2xvY2F0aW9uUmVzcG9uc2UsIHRoaXMpLFxyXG5cdFx0XHRvbkVycm9yID0gTC5iaW5kKHRoaXMuX2hhbmRsZUdlb2xvY2F0aW9uRXJyb3IsIHRoaXMpO1xyXG5cclxuXHRcdGlmIChvcHRpb25zLndhdGNoKSB7XHJcblx0XHRcdHRoaXMuX2xvY2F0aW9uV2F0Y2hJZCA9XHJcblx0XHRcdCAgICAgICAgbmF2aWdhdG9yLmdlb2xvY2F0aW9uLndhdGNoUG9zaXRpb24ob25SZXNwb25zZSwgb25FcnJvciwgb3B0aW9ucyk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRuYXZpZ2F0b3IuZ2VvbG9jYXRpb24uZ2V0Q3VycmVudFBvc2l0aW9uKG9uUmVzcG9uc2UsIG9uRXJyb3IsIG9wdGlvbnMpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0c3RvcExvY2F0ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKG5hdmlnYXRvci5nZW9sb2NhdGlvbikge1xyXG5cdFx0XHRuYXZpZ2F0b3IuZ2VvbG9jYXRpb24uY2xlYXJXYXRjaCh0aGlzLl9sb2NhdGlvbldhdGNoSWQpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKHRoaXMuX2xvY2F0ZU9wdGlvbnMpIHtcclxuXHRcdFx0dGhpcy5fbG9jYXRlT3B0aW9ucy5zZXRWaWV3ID0gZmFsc2U7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfaGFuZGxlR2VvbG9jYXRpb25FcnJvcjogZnVuY3Rpb24gKGVycm9yKSB7XHJcblx0XHR2YXIgYyA9IGVycm9yLmNvZGUsXHJcblx0XHQgICAgbWVzc2FnZSA9IGVycm9yLm1lc3NhZ2UgfHxcclxuXHRcdCAgICAgICAgICAgIChjID09PSAxID8gJ3Blcm1pc3Npb24gZGVuaWVkJyA6XHJcblx0XHQgICAgICAgICAgICAoYyA9PT0gMiA/ICdwb3NpdGlvbiB1bmF2YWlsYWJsZScgOiAndGltZW91dCcpKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbG9jYXRlT3B0aW9ucy5zZXRWaWV3ICYmICF0aGlzLl9sb2FkZWQpIHtcclxuXHRcdFx0dGhpcy5maXRXb3JsZCgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuZmlyZSgnbG9jYXRpb25lcnJvcicsIHtcclxuXHRcdFx0Y29kZTogYyxcclxuXHRcdFx0bWVzc2FnZTogJ0dlb2xvY2F0aW9uIGVycm9yOiAnICsgbWVzc2FnZSArICcuJ1xyXG5cdFx0fSk7XHJcblx0fSxcclxuXHJcblx0X2hhbmRsZUdlb2xvY2F0aW9uUmVzcG9uc2U6IGZ1bmN0aW9uIChwb3MpIHtcclxuXHRcdHZhciBsYXQgPSBwb3MuY29vcmRzLmxhdGl0dWRlLFxyXG5cdFx0ICAgIGxuZyA9IHBvcy5jb29yZHMubG9uZ2l0dWRlLFxyXG5cdFx0ICAgIGxhdGxuZyA9IG5ldyBMLkxhdExuZyhsYXQsIGxuZyksXHJcblxyXG5cdFx0ICAgIGxhdEFjY3VyYWN5ID0gMTgwICogcG9zLmNvb3Jkcy5hY2N1cmFjeSAvIDQwMDc1MDE3LFxyXG5cdFx0ICAgIGxuZ0FjY3VyYWN5ID0gbGF0QWNjdXJhY3kgLyBNYXRoLmNvcygoTWF0aC5QSSAvIDE4MCkgKiBsYXQpLFxyXG5cclxuXHRcdCAgICBib3VuZHMgPSBMLmxhdExuZ0JvdW5kcyhcclxuXHRcdCAgICAgICAgICAgIFtsYXQgLSBsYXRBY2N1cmFjeSwgbG5nIC0gbG5nQWNjdXJhY3ldLFxyXG5cdFx0ICAgICAgICAgICAgW2xhdCArIGxhdEFjY3VyYWN5LCBsbmcgKyBsbmdBY2N1cmFjeV0pLFxyXG5cclxuXHRcdCAgICBvcHRpb25zID0gdGhpcy5fbG9jYXRlT3B0aW9ucztcclxuXHJcblx0XHRpZiAob3B0aW9ucy5zZXRWaWV3KSB7XHJcblx0XHRcdHZhciB6b29tID0gdGhpcy5nZXRCb3VuZHNab29tKGJvdW5kcyk7XHJcblx0XHRcdHRoaXMuc2V0VmlldyhsYXRsbmcsIG9wdGlvbnMubWF4Wm9vbSA/IE1hdGgubWluKHpvb20sIG9wdGlvbnMubWF4Wm9vbSkgOiB6b29tKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgZGF0YSA9IHtcclxuXHRcdFx0bGF0bG5nOiBsYXRsbmcsXHJcblx0XHRcdGJvdW5kczogYm91bmRzLFxyXG5cdFx0XHR0aW1lc3RhbXA6IHBvcy50aW1lc3RhbXBcclxuXHRcdH07XHJcblxyXG5cdFx0Zm9yICh2YXIgaSBpbiBwb3MuY29vcmRzKSB7XHJcblx0XHRcdGlmICh0eXBlb2YgcG9zLmNvb3Jkc1tpXSA9PT0gJ251bWJlcicpIHtcclxuXHRcdFx0XHRkYXRhW2ldID0gcG9zLmNvb3Jkc1tpXTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuZmlyZSgnbG9jYXRpb25mb3VuZCcsIGRhdGEpO1xyXG5cdH1cclxufSk7XHJcbiIsIi8qKlxuKiBAcHJlc2VydmUgSFRNTDUgU2hpdiAzLjcuMiB8IEBhZmFya2FzIEBqZGFsdG9uIEBqb25fbmVhbCBAcmVtIHwgTUlUL0dQTDIgTGljZW5zZWRcbiovXG47KGZ1bmN0aW9uKHdpbmRvdywgZG9jdW1lbnQpIHtcbi8qanNoaW50IGV2aWw6dHJ1ZSAqL1xuICAvKiogdmVyc2lvbiAqL1xuICB2YXIgdmVyc2lvbiA9ICczLjcuMic7XG5cbiAgLyoqIFByZXNldCBvcHRpb25zICovXG4gIHZhciBvcHRpb25zID0gd2luZG93Lmh0bWw1IHx8IHt9O1xuXG4gIC8qKiBVc2VkIHRvIHNraXAgcHJvYmxlbSBlbGVtZW50cyAqL1xuICB2YXIgcmVTa2lwID0gL148fF4oPzpidXR0b258bWFwfHNlbGVjdHx0ZXh0YXJlYXxvYmplY3R8aWZyYW1lfG9wdGlvbnxvcHRncm91cCkkL2k7XG5cbiAgLyoqIE5vdCBhbGwgZWxlbWVudHMgY2FuIGJlIGNsb25lZCBpbiBJRSAqKi9cbiAgdmFyIHNhdmVDbG9uZXMgPSAvXig/OmF8Ynxjb2RlfGRpdnxmaWVsZHNldHxoMXxoMnxoM3xoNHxoNXxoNnxpfGxhYmVsfGxpfG9sfHB8cXxzcGFufHN0cm9uZ3xzdHlsZXx0YWJsZXx0Ym9keXx0ZHx0aHx0cnx1bCkkL2k7XG5cbiAgLyoqIERldGVjdCB3aGV0aGVyIHRoZSBicm93c2VyIHN1cHBvcnRzIGRlZmF1bHQgaHRtbDUgc3R5bGVzICovXG4gIHZhciBzdXBwb3J0c0h0bWw1U3R5bGVzO1xuXG4gIC8qKiBOYW1lIG9mIHRoZSBleHBhbmRvLCB0byB3b3JrIHdpdGggbXVsdGlwbGUgZG9jdW1lbnRzIG9yIHRvIHJlLXNoaXYgb25lIGRvY3VtZW50ICovXG4gIHZhciBleHBhbmRvID0gJ19odG1sNXNoaXYnO1xuXG4gIC8qKiBUaGUgaWQgZm9yIHRoZSB0aGUgZG9jdW1lbnRzIGV4cGFuZG8gKi9cbiAgdmFyIGV4cGFuSUQgPSAwO1xuXG4gIC8qKiBDYWNoZWQgZGF0YSBmb3IgZWFjaCBkb2N1bWVudCAqL1xuICB2YXIgZXhwYW5kb0RhdGEgPSB7fTtcblxuICAvKiogRGV0ZWN0IHdoZXRoZXIgdGhlIGJyb3dzZXIgc3VwcG9ydHMgdW5rbm93biBlbGVtZW50cyAqL1xuICB2YXIgc3VwcG9ydHNVbmtub3duRWxlbWVudHM7XG5cbiAgKGZ1bmN0aW9uKCkge1xuICAgIHRyeSB7XG4gICAgICAgIHZhciBhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgICAgICBhLmlubmVySFRNTCA9ICc8eHl6PjwveHl6Pic7XG4gICAgICAgIC8vaWYgdGhlIGhpZGRlbiBwcm9wZXJ0eSBpcyBpbXBsZW1lbnRlZCB3ZSBjYW4gYXNzdW1lLCB0aGF0IHRoZSBicm93c2VyIHN1cHBvcnRzIGJhc2ljIEhUTUw1IFN0eWxlc1xuICAgICAgICBzdXBwb3J0c0h0bWw1U3R5bGVzID0gKCdoaWRkZW4nIGluIGEpO1xuXG4gICAgICAgIHN1cHBvcnRzVW5rbm93bkVsZW1lbnRzID0gYS5jaGlsZE5vZGVzLmxlbmd0aCA9PSAxIHx8IChmdW5jdGlvbigpIHtcbiAgICAgICAgICAvLyBhc3NpZ24gYSBmYWxzZSBwb3NpdGl2ZSBpZiB1bmFibGUgdG8gc2hpdlxuICAgICAgICAgIChkb2N1bWVudC5jcmVhdGVFbGVtZW50KSgnYScpO1xuICAgICAgICAgIHZhciBmcmFnID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0eXBlb2YgZnJhZy5jbG9uZU5vZGUgPT0gJ3VuZGVmaW5lZCcgfHxcbiAgICAgICAgICAgIHR5cGVvZiBmcmFnLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQgPT0gJ3VuZGVmaW5lZCcgfHxcbiAgICAgICAgICAgIHR5cGVvZiBmcmFnLmNyZWF0ZUVsZW1lbnQgPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICApO1xuICAgICAgICB9KCkpO1xuICAgIH0gY2F0Y2goZSkge1xuICAgICAgLy8gYXNzaWduIGEgZmFsc2UgcG9zaXRpdmUgaWYgZGV0ZWN0aW9uIGZhaWxzID0+IHVuYWJsZSB0byBzaGl2XG4gICAgICBzdXBwb3J0c0h0bWw1U3R5bGVzID0gdHJ1ZTtcbiAgICAgIHN1cHBvcnRzVW5rbm93bkVsZW1lbnRzID0gdHJ1ZTtcbiAgICB9XG5cbiAgfSgpKTtcblxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHN0eWxlIHNoZWV0IHdpdGggdGhlIGdpdmVuIENTUyB0ZXh0IGFuZCBhZGRzIGl0IHRvIHRoZSBkb2N1bWVudC5cbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtEb2N1bWVudH0gb3duZXJEb2N1bWVudCBUaGUgZG9jdW1lbnQuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjc3NUZXh0IFRoZSBDU1MgdGV4dC5cbiAgICogQHJldHVybnMge1N0eWxlU2hlZXR9IFRoZSBzdHlsZSBlbGVtZW50LlxuICAgKi9cbiAgZnVuY3Rpb24gYWRkU3R5bGVTaGVldChvd25lckRvY3VtZW50LCBjc3NUZXh0KSB7XG4gICAgdmFyIHAgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3AnKSxcbiAgICAgICAgcGFyZW50ID0gb3duZXJEb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdIHx8IG93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG4gICAgcC5pbm5lckhUTUwgPSAneDxzdHlsZT4nICsgY3NzVGV4dCArICc8L3N0eWxlPic7XG4gICAgcmV0dXJuIHBhcmVudC5pbnNlcnRCZWZvcmUocC5sYXN0Q2hpbGQsIHBhcmVudC5maXJzdENoaWxkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiBgaHRtbDUuZWxlbWVudHNgIGFzIGFuIGFycmF5LlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcmV0dXJucyB7QXJyYXl9IEFuIGFycmF5IG9mIHNoaXZlZCBlbGVtZW50IG5vZGUgbmFtZXMuXG4gICAqL1xuICBmdW5jdGlvbiBnZXRFbGVtZW50cygpIHtcbiAgICB2YXIgZWxlbWVudHMgPSBodG1sNS5lbGVtZW50cztcbiAgICByZXR1cm4gdHlwZW9mIGVsZW1lbnRzID09ICdzdHJpbmcnID8gZWxlbWVudHMuc3BsaXQoJyAnKSA6IGVsZW1lbnRzO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4dGVuZHMgdGhlIGJ1aWx0LWluIGxpc3Qgb2YgaHRtbDUgZWxlbWVudHNcbiAgICogQG1lbWJlck9mIGh0bWw1XG4gICAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBuZXdFbGVtZW50cyB3aGl0ZXNwYWNlIHNlcGFyYXRlZCBsaXN0IG9yIGFycmF5IG9mIG5ldyBlbGVtZW50IG5hbWVzIHRvIHNoaXZcbiAgICogQHBhcmFtIHtEb2N1bWVudH0gb3duZXJEb2N1bWVudCBUaGUgY29udGV4dCBkb2N1bWVudC5cbiAgICovXG4gIGZ1bmN0aW9uIGFkZEVsZW1lbnRzKG5ld0VsZW1lbnRzLCBvd25lckRvY3VtZW50KSB7XG4gICAgdmFyIGVsZW1lbnRzID0gaHRtbDUuZWxlbWVudHM7XG4gICAgaWYodHlwZW9mIGVsZW1lbnRzICE9ICdzdHJpbmcnKXtcbiAgICAgIGVsZW1lbnRzID0gZWxlbWVudHMuam9pbignICcpO1xuICAgIH1cbiAgICBpZih0eXBlb2YgbmV3RWxlbWVudHMgIT0gJ3N0cmluZycpe1xuICAgICAgbmV3RWxlbWVudHMgPSBuZXdFbGVtZW50cy5qb2luKCcgJyk7XG4gICAgfVxuICAgIGh0bWw1LmVsZW1lbnRzID0gZWxlbWVudHMgKycgJysgbmV3RWxlbWVudHM7XG4gICAgc2hpdkRvY3VtZW50KG93bmVyRG9jdW1lbnQpO1xuICB9XG5cbiAgIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBkYXRhIGFzc29jaWF0ZWQgdG8gdGhlIGdpdmVuIGRvY3VtZW50XG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7RG9jdW1lbnR9IG93bmVyRG9jdW1lbnQgVGhlIGRvY3VtZW50LlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBBbiBvYmplY3Qgb2YgZGF0YS5cbiAgICovXG4gIGZ1bmN0aW9uIGdldEV4cGFuZG9EYXRhKG93bmVyRG9jdW1lbnQpIHtcbiAgICB2YXIgZGF0YSA9IGV4cGFuZG9EYXRhW293bmVyRG9jdW1lbnRbZXhwYW5kb11dO1xuICAgIGlmICghZGF0YSkge1xuICAgICAgICBkYXRhID0ge307XG4gICAgICAgIGV4cGFuSUQrKztcbiAgICAgICAgb3duZXJEb2N1bWVudFtleHBhbmRvXSA9IGV4cGFuSUQ7XG4gICAgICAgIGV4cGFuZG9EYXRhW2V4cGFuSURdID0gZGF0YTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICAvKipcbiAgICogcmV0dXJucyBhIHNoaXZlZCBlbGVtZW50IGZvciB0aGUgZ2l2ZW4gbm9kZU5hbWUgYW5kIGRvY3VtZW50XG4gICAqIEBtZW1iZXJPZiBodG1sNVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbm9kZU5hbWUgbmFtZSBvZiB0aGUgZWxlbWVudFxuICAgKiBAcGFyYW0ge0RvY3VtZW50fSBvd25lckRvY3VtZW50IFRoZSBjb250ZXh0IGRvY3VtZW50LlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgc2hpdmVkIGVsZW1lbnQuXG4gICAqL1xuICBmdW5jdGlvbiBjcmVhdGVFbGVtZW50KG5vZGVOYW1lLCBvd25lckRvY3VtZW50LCBkYXRhKXtcbiAgICBpZiAoIW93bmVyRG9jdW1lbnQpIHtcbiAgICAgICAgb3duZXJEb2N1bWVudCA9IGRvY3VtZW50O1xuICAgIH1cbiAgICBpZihzdXBwb3J0c1Vua25vd25FbGVtZW50cyl7XG4gICAgICAgIHJldHVybiBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQobm9kZU5hbWUpO1xuICAgIH1cbiAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgZGF0YSA9IGdldEV4cGFuZG9EYXRhKG93bmVyRG9jdW1lbnQpO1xuICAgIH1cbiAgICB2YXIgbm9kZTtcblxuICAgIGlmIChkYXRhLmNhY2hlW25vZGVOYW1lXSkge1xuICAgICAgICBub2RlID0gZGF0YS5jYWNoZVtub2RlTmFtZV0uY2xvbmVOb2RlKCk7XG4gICAgfSBlbHNlIGlmIChzYXZlQ2xvbmVzLnRlc3Qobm9kZU5hbWUpKSB7XG4gICAgICAgIG5vZGUgPSAoZGF0YS5jYWNoZVtub2RlTmFtZV0gPSBkYXRhLmNyZWF0ZUVsZW0obm9kZU5hbWUpKS5jbG9uZU5vZGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBub2RlID0gZGF0YS5jcmVhdGVFbGVtKG5vZGVOYW1lKTtcbiAgICB9XG5cbiAgICAvLyBBdm9pZCBhZGRpbmcgc29tZSBlbGVtZW50cyB0byBmcmFnbWVudHMgaW4gSUUgPCA5IGJlY2F1c2VcbiAgICAvLyAqIEF0dHJpYnV0ZXMgbGlrZSBgbmFtZWAgb3IgYHR5cGVgIGNhbm5vdCBiZSBzZXQvY2hhbmdlZCBvbmNlIGFuIGVsZW1lbnRcbiAgICAvLyAgIGlzIGluc2VydGVkIGludG8gYSBkb2N1bWVudC9mcmFnbWVudFxuICAgIC8vICogTGluayBlbGVtZW50cyB3aXRoIGBzcmNgIGF0dHJpYnV0ZXMgdGhhdCBhcmUgaW5hY2Nlc3NpYmxlLCBhcyB3aXRoXG4gICAgLy8gICBhIDQwMyByZXNwb25zZSwgd2lsbCBjYXVzZSB0aGUgdGFiL3dpbmRvdyB0byBjcmFzaFxuICAgIC8vICogU2NyaXB0IGVsZW1lbnRzIGFwcGVuZGVkIHRvIGZyYWdtZW50cyB3aWxsIGV4ZWN1dGUgd2hlbiB0aGVpciBgc3JjYFxuICAgIC8vICAgb3IgYHRleHRgIHByb3BlcnR5IGlzIHNldFxuICAgIHJldHVybiBub2RlLmNhbkhhdmVDaGlsZHJlbiAmJiAhcmVTa2lwLnRlc3Qobm9kZU5hbWUpICYmICFub2RlLnRhZ1VybiA/IGRhdGEuZnJhZy5hcHBlbmRDaGlsZChub2RlKSA6IG5vZGU7XG4gIH1cblxuICAvKipcbiAgICogcmV0dXJucyBhIHNoaXZlZCBEb2N1bWVudEZyYWdtZW50IGZvciB0aGUgZ2l2ZW4gZG9jdW1lbnRcbiAgICogQG1lbWJlck9mIGh0bWw1XG4gICAqIEBwYXJhbSB7RG9jdW1lbnR9IG93bmVyRG9jdW1lbnQgVGhlIGNvbnRleHQgZG9jdW1lbnQuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBzaGl2ZWQgRG9jdW1lbnRGcmFnbWVudC5cbiAgICovXG4gIGZ1bmN0aW9uIGNyZWF0ZURvY3VtZW50RnJhZ21lbnQob3duZXJEb2N1bWVudCwgZGF0YSl7XG4gICAgaWYgKCFvd25lckRvY3VtZW50KSB7XG4gICAgICAgIG93bmVyRG9jdW1lbnQgPSBkb2N1bWVudDtcbiAgICB9XG4gICAgaWYoc3VwcG9ydHNVbmtub3duRWxlbWVudHMpe1xuICAgICAgICByZXR1cm4gb3duZXJEb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgfVxuICAgIGRhdGEgPSBkYXRhIHx8IGdldEV4cGFuZG9EYXRhKG93bmVyRG9jdW1lbnQpO1xuICAgIHZhciBjbG9uZSA9IGRhdGEuZnJhZy5jbG9uZU5vZGUoKSxcbiAgICAgICAgaSA9IDAsXG4gICAgICAgIGVsZW1zID0gZ2V0RWxlbWVudHMoKSxcbiAgICAgICAgbCA9IGVsZW1zLmxlbmd0aDtcbiAgICBmb3IoO2k8bDtpKyspe1xuICAgICAgICBjbG9uZS5jcmVhdGVFbGVtZW50KGVsZW1zW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIGNsb25lO1xuICB9XG5cbiAgLyoqXG4gICAqIFNoaXZzIHRoZSBgY3JlYXRlRWxlbWVudGAgYW5kIGBjcmVhdGVEb2N1bWVudEZyYWdtZW50YCBtZXRob2RzIG9mIHRoZSBkb2N1bWVudC5cbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtEb2N1bWVudHxEb2N1bWVudEZyYWdtZW50fSBvd25lckRvY3VtZW50IFRoZSBkb2N1bWVudC5cbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgb2YgdGhlIGRvY3VtZW50LlxuICAgKi9cbiAgZnVuY3Rpb24gc2hpdk1ldGhvZHMob3duZXJEb2N1bWVudCwgZGF0YSkge1xuICAgIGlmICghZGF0YS5jYWNoZSkge1xuICAgICAgICBkYXRhLmNhY2hlID0ge307XG4gICAgICAgIGRhdGEuY3JlYXRlRWxlbSA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudDtcbiAgICAgICAgZGF0YS5jcmVhdGVGcmFnID0gb3duZXJEb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50O1xuICAgICAgICBkYXRhLmZyYWcgPSBkYXRhLmNyZWF0ZUZyYWcoKTtcbiAgICB9XG5cblxuICAgIG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uKG5vZGVOYW1lKSB7XG4gICAgICAvL2Fib3J0IHNoaXZcbiAgICAgIGlmICghaHRtbDUuc2hpdk1ldGhvZHMpIHtcbiAgICAgICAgICByZXR1cm4gZGF0YS5jcmVhdGVFbGVtKG5vZGVOYW1lKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KG5vZGVOYW1lLCBvd25lckRvY3VtZW50LCBkYXRhKTtcbiAgICB9O1xuXG4gICAgb3duZXJEb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50ID0gRnVuY3Rpb24oJ2gsZicsICdyZXR1cm4gZnVuY3Rpb24oKXsnICtcbiAgICAgICd2YXIgbj1mLmNsb25lTm9kZSgpLGM9bi5jcmVhdGVFbGVtZW50OycgK1xuICAgICAgJ2guc2hpdk1ldGhvZHMmJignICtcbiAgICAgICAgLy8gdW5yb2xsIHRoZSBgY3JlYXRlRWxlbWVudGAgY2FsbHNcbiAgICAgICAgZ2V0RWxlbWVudHMoKS5qb2luKCkucmVwbGFjZSgvW1xcd1xcLTpdKy9nLCBmdW5jdGlvbihub2RlTmFtZSkge1xuICAgICAgICAgIGRhdGEuY3JlYXRlRWxlbShub2RlTmFtZSk7XG4gICAgICAgICAgZGF0YS5mcmFnLmNyZWF0ZUVsZW1lbnQobm9kZU5hbWUpO1xuICAgICAgICAgIHJldHVybiAnYyhcIicgKyBub2RlTmFtZSArICdcIiknO1xuICAgICAgICB9KSArXG4gICAgICAnKTtyZXR1cm4gbn0nXG4gICAgKShodG1sNSwgZGF0YS5mcmFnKTtcbiAgfVxuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIC8qKlxuICAgKiBTaGl2cyB0aGUgZ2l2ZW4gZG9jdW1lbnQuXG4gICAqIEBtZW1iZXJPZiBodG1sNVxuICAgKiBAcGFyYW0ge0RvY3VtZW50fSBvd25lckRvY3VtZW50IFRoZSBkb2N1bWVudCB0byBzaGl2LlxuICAgKiBAcmV0dXJucyB7RG9jdW1lbnR9IFRoZSBzaGl2ZWQgZG9jdW1lbnQuXG4gICAqL1xuICBmdW5jdGlvbiBzaGl2RG9jdW1lbnQob3duZXJEb2N1bWVudCkge1xuICAgIGlmICghb3duZXJEb2N1bWVudCkge1xuICAgICAgICBvd25lckRvY3VtZW50ID0gZG9jdW1lbnQ7XG4gICAgfVxuICAgIHZhciBkYXRhID0gZ2V0RXhwYW5kb0RhdGEob3duZXJEb2N1bWVudCk7XG5cbiAgICBpZiAoaHRtbDUuc2hpdkNTUyAmJiAhc3VwcG9ydHNIdG1sNVN0eWxlcyAmJiAhZGF0YS5oYXNDU1MpIHtcbiAgICAgIGRhdGEuaGFzQ1NTID0gISFhZGRTdHlsZVNoZWV0KG93bmVyRG9jdW1lbnQsXG4gICAgICAgIC8vIGNvcnJlY3RzIGJsb2NrIGRpc3BsYXkgbm90IGRlZmluZWQgaW4gSUU2LzcvOC85XG4gICAgICAgICdhcnRpY2xlLGFzaWRlLGRpYWxvZyxmaWdjYXB0aW9uLGZpZ3VyZSxmb290ZXIsaGVhZGVyLGhncm91cCxtYWluLG5hdixzZWN0aW9ue2Rpc3BsYXk6YmxvY2t9JyArXG4gICAgICAgIC8vIGFkZHMgc3R5bGluZyBub3QgcHJlc2VudCBpbiBJRTYvNy84LzlcbiAgICAgICAgJ21hcmt7YmFja2dyb3VuZDojRkYwO2NvbG9yOiMwMDB9JyArXG4gICAgICAgIC8vIGhpZGVzIG5vbi1yZW5kZXJlZCBlbGVtZW50c1xuICAgICAgICAndGVtcGxhdGV7ZGlzcGxheTpub25lfSdcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICghc3VwcG9ydHNVbmtub3duRWxlbWVudHMpIHtcbiAgICAgIHNoaXZNZXRob2RzKG93bmVyRG9jdW1lbnQsIGRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gb3duZXJEb2N1bWVudDtcbiAgfVxuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIC8qKlxuICAgKiBUaGUgYGh0bWw1YCBvYmplY3QgaXMgZXhwb3NlZCBzbyB0aGF0IG1vcmUgZWxlbWVudHMgY2FuIGJlIHNoaXZlZCBhbmRcbiAgICogZXhpc3Rpbmcgc2hpdmluZyBjYW4gYmUgZGV0ZWN0ZWQgb24gaWZyYW1lcy5cbiAgICogQHR5cGUgT2JqZWN0XG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIC8vIG9wdGlvbnMgY2FuIGJlIGNoYW5nZWQgYmVmb3JlIHRoZSBzY3JpcHQgaXMgaW5jbHVkZWRcbiAgICogaHRtbDUgPSB7ICdlbGVtZW50cyc6ICdtYXJrIHNlY3Rpb24nLCAnc2hpdkNTUyc6IGZhbHNlLCAnc2hpdk1ldGhvZHMnOiBmYWxzZSB9O1xuICAgKi9cbiAgdmFyIGh0bWw1ID0ge1xuXG4gICAgLyoqXG4gICAgICogQW4gYXJyYXkgb3Igc3BhY2Ugc2VwYXJhdGVkIHN0cmluZyBvZiBub2RlIG5hbWVzIG9mIHRoZSBlbGVtZW50cyB0byBzaGl2LlxuICAgICAqIEBtZW1iZXJPZiBodG1sNVxuICAgICAqIEB0eXBlIEFycmF5fFN0cmluZ1xuICAgICAqL1xuICAgICdlbGVtZW50cyc6IG9wdGlvbnMuZWxlbWVudHMgfHwgJ2FiYnIgYXJ0aWNsZSBhc2lkZSBhdWRpbyBiZGkgY2FudmFzIGRhdGEgZGF0YWxpc3QgZGV0YWlscyBkaWFsb2cgZmlnY2FwdGlvbiBmaWd1cmUgZm9vdGVyIGhlYWRlciBoZ3JvdXAgbWFpbiBtYXJrIG1ldGVyIG5hdiBvdXRwdXQgcGljdHVyZSBwcm9ncmVzcyBzZWN0aW9uIHN1bW1hcnkgdGVtcGxhdGUgdGltZSB2aWRlbycsXG5cbiAgICAvKipcbiAgICAgKiBjdXJyZW50IHZlcnNpb24gb2YgaHRtbDVzaGl2XG4gICAgICovXG4gICAgJ3ZlcnNpb24nOiB2ZXJzaW9uLFxuXG4gICAgLyoqXG4gICAgICogQSBmbGFnIHRvIGluZGljYXRlIHRoYXQgdGhlIEhUTUw1IHN0eWxlIHNoZWV0IHNob3VsZCBiZSBpbnNlcnRlZC5cbiAgICAgKiBAbWVtYmVyT2YgaHRtbDVcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICovXG4gICAgJ3NoaXZDU1MnOiAob3B0aW9ucy5zaGl2Q1NTICE9PSBmYWxzZSksXG5cbiAgICAvKipcbiAgICAgKiBJcyBlcXVhbCB0byB0cnVlIGlmIGEgYnJvd3NlciBzdXBwb3J0cyBjcmVhdGluZyB1bmtub3duL0hUTUw1IGVsZW1lbnRzXG4gICAgICogQG1lbWJlck9mIGh0bWw1XG4gICAgICogQHR5cGUgYm9vbGVhblxuICAgICAqL1xuICAgICdzdXBwb3J0c1Vua25vd25FbGVtZW50cyc6IHN1cHBvcnRzVW5rbm93bkVsZW1lbnRzLFxuXG4gICAgLyoqXG4gICAgICogQSBmbGFnIHRvIGluZGljYXRlIHRoYXQgdGhlIGRvY3VtZW50J3MgYGNyZWF0ZUVsZW1lbnRgIGFuZCBgY3JlYXRlRG9jdW1lbnRGcmFnbWVudGBcbiAgICAgKiBtZXRob2RzIHNob3VsZCBiZSBvdmVyd3JpdHRlbi5cbiAgICAgKiBAbWVtYmVyT2YgaHRtbDVcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICovXG4gICAgJ3NoaXZNZXRob2RzJzogKG9wdGlvbnMuc2hpdk1ldGhvZHMgIT09IGZhbHNlKSxcblxuICAgIC8qKlxuICAgICAqIEEgc3RyaW5nIHRvIGRlc2NyaWJlIHRoZSB0eXBlIG9mIGBodG1sNWAgb2JqZWN0IChcImRlZmF1bHRcIiBvciBcImRlZmF1bHQgcHJpbnRcIikuXG4gICAgICogQG1lbWJlck9mIGh0bWw1XG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICovXG4gICAgJ3R5cGUnOiAnZGVmYXVsdCcsXG5cbiAgICAvLyBzaGl2cyB0aGUgZG9jdW1lbnQgYWNjb3JkaW5nIHRvIHRoZSBzcGVjaWZpZWQgYGh0bWw1YCBvYmplY3Qgb3B0aW9uc1xuICAgICdzaGl2RG9jdW1lbnQnOiBzaGl2RG9jdW1lbnQsXG5cbiAgICAvL2NyZWF0ZXMgYSBzaGl2ZWQgZWxlbWVudFxuICAgIGNyZWF0ZUVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnQsXG5cbiAgICAvL2NyZWF0ZXMgYSBzaGl2ZWQgZG9jdW1lbnRGcmFnbWVudFxuICAgIGNyZWF0ZURvY3VtZW50RnJhZ21lbnQ6IGNyZWF0ZURvY3VtZW50RnJhZ21lbnQsXG5cbiAgICAvL2V4dGVuZHMgbGlzdCBvZiBlbGVtZW50c1xuICAgIGFkZEVsZW1lbnRzOiBhZGRFbGVtZW50c1xuICB9O1xuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIC8vIGV4cG9zZSBodG1sNVxuICB3aW5kb3cuaHRtbDUgPSBodG1sNTtcblxuICAvLyBzaGl2IHRoZSBkb2N1bWVudFxuICBzaGl2RG9jdW1lbnQoZG9jdW1lbnQpO1xuXG59KHRoaXMsIGRvY3VtZW50KSk7XG4iLCJpZiAoIUFycmF5LnByb3RvdHlwZS5tYXApXG57XG4gIEFycmF5LnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbihmdW4gLyosIHRoaXNBcmcgKi8pXG4gIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGlmICh0aGlzID09PSB2b2lkIDAgfHwgdGhpcyA9PT0gbnVsbClcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcblxuICAgIHZhciB0ID0gT2JqZWN0KHRoaXMpO1xuICAgIHZhciBsZW4gPSB0Lmxlbmd0aCA+Pj4gMDtcbiAgICBpZiAodHlwZW9mIGZ1biAhPT0gXCJmdW5jdGlvblwiKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuXG4gICAgdmFyIHJlcyA9IG5ldyBBcnJheShsZW4pO1xuICAgIHZhciB0aGlzQXJnID0gYXJndW1lbnRzLmxlbmd0aCA+PSAyID8gYXJndW1lbnRzWzFdIDogdm9pZCAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAge1xuICAgICAgLy8gTk9URTogQWJzb2x1dGUgY29ycmVjdG5lc3Mgd291bGQgZGVtYW5kIE9iamVjdC5kZWZpbmVQcm9wZXJ0eVxuICAgICAgLy8gICAgICAgYmUgdXNlZC4gIEJ1dCB0aGlzIG1ldGhvZCBpcyBmYWlybHkgbmV3LCBhbmQgZmFpbHVyZSBpc1xuICAgICAgLy8gICAgICAgcG9zc2libGUgb25seSBpZiBPYmplY3QucHJvdG90eXBlIG9yIEFycmF5LnByb3RvdHlwZVxuICAgICAgLy8gICAgICAgaGFzIGEgcHJvcGVydHkgfGl8ICh2ZXJ5IHVubGlrZWx5KSwgc28gdXNlIGEgbGVzcy1jb3JyZWN0XG4gICAgICAvLyAgICAgICBidXQgbW9yZSBwb3J0YWJsZSBhbHRlcm5hdGl2ZS5cbiAgICAgIGlmIChpIGluIHQpXG4gICAgICAgIHJlc1tpXSA9IGZ1bi5jYWxsKHRoaXNBcmcsIHRbaV0sIGksIHQpO1xuICAgIH1cblxuICAgIHJldHVybiByZXM7XG4gIH07XG59XG5cbi8qIHJlZHVjZSBpbXBsZW1pbnRhdGlvbiBieSBNb3ppbGEgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvUmVkdWNlP3JlZGlyZWN0bG9jYWxlPWVuLVVTJnJlZGlyZWN0c2x1Zz1KYXZhU2NyaXB0JTJGUmVmZXJlbmNlJTJGR2xvYmFsX09iamVjdHMlMkZBcnJheSUyRlJlZHVjZSovXG5pZiAoJ2Z1bmN0aW9uJyAhPT0gdHlwZW9mIEFycmF5LnByb3RvdHlwZS5yZWR1Y2UpIHtcbiAgQXJyYXkucHJvdG90eXBlLnJlZHVjZSA9IGZ1bmN0aW9uKGNhbGxiYWNrLCBvcHRfaW5pdGlhbFZhbHVlKXtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgaWYgKG51bGwgPT09IHRoaXMgfHwgJ3VuZGVmaW5lZCcgPT09IHR5cGVvZiB0aGlzKSB7XG4gICAgICAvLyBBdCB0aGUgbW9tZW50IGFsbCBtb2Rlcm4gYnJvd3NlcnMsIHRoYXQgc3VwcG9ydCBzdHJpY3QgbW9kZSwgaGF2ZVxuICAgICAgLy8gbmF0aXZlIGltcGxlbWVudGF0aW9uIG9mIEFycmF5LnByb3RvdHlwZS5yZWR1Y2UuIEZvciBpbnN0YW5jZSwgSUU4XG4gICAgICAvLyBkb2VzIG5vdCBzdXBwb3J0IHN0cmljdCBtb2RlLCBzbyB0aGlzIGNoZWNrIGlzIGFjdHVhbGx5IHVzZWxlc3MuXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICdBcnJheS5wcm90b3R5cGUucmVkdWNlIGNhbGxlZCBvbiBudWxsIG9yIHVuZGVmaW5lZCcpO1xuICAgIH1cbiAgICBpZiAoJ2Z1bmN0aW9uJyAhPT0gdHlwZW9mIGNhbGxiYWNrKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGNhbGxiYWNrICsgJyBpcyBub3QgYSBmdW5jdGlvbicpO1xuICAgIH1cbiAgICB2YXIgaW5kZXgsIHZhbHVlLFxuICAgICAgICBsZW5ndGggPSB0aGlzLmxlbmd0aCA+Pj4gMCxcbiAgICAgICAgaXNWYWx1ZVNldCA9IGZhbHNlO1xuICAgIGlmICgxIDwgYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgdmFsdWUgPSBvcHRfaW5pdGlhbFZhbHVlO1xuICAgICAgaXNWYWx1ZVNldCA9IHRydWU7XG4gICAgfVxuICAgIGZvciAoaW5kZXggPSAwOyBsZW5ndGggPiBpbmRleDsgKytpbmRleCkge1xuICAgICAgaWYgKHRoaXMuaGFzT3duUHJvcGVydHkoaW5kZXgpKSB7XG4gICAgICAgIGlmIChpc1ZhbHVlU2V0KSB7XG4gICAgICAgICAgdmFsdWUgPSBjYWxsYmFjayh2YWx1ZSwgdGhpc1tpbmRleF0sIGluZGV4LCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IHRoaXNbaW5kZXhdO1xuICAgICAgICAgIGlzVmFsdWVTZXQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghaXNWYWx1ZVNldCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUmVkdWNlIG9mIGVtcHR5IGFycmF5IHdpdGggbm8gaW5pdGlhbCB2YWx1ZScpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG59XG5cbi8vIEZyb20gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvZm9yRWFjaFxuLy8gUHJvZHVjdGlvbiBzdGVwcyBvZiBFQ01BLTI2MiwgRWRpdGlvbiA1LCAxNS40LjQuMThcbi8vIFJlZmVyZW5jZTogaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuNC40LjE4XG5pZiAoIUFycmF5LnByb3RvdHlwZS5mb3JFYWNoKSB7XG5cbiAgQXJyYXkucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIHZhciBULCBrO1xuXG4gICAgaWYgKHRoaXMgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcInRoaXMgaXMgbnVsbCBvciBub3QgZGVmaW5lZFwiKTtcbiAgICB9XG5cbiAgICB2YXIga1ZhbHVlLFxuICAgICAgICAvLyAxLiBMZXQgTyBiZSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgVG9PYmplY3QgcGFzc2luZyB0aGUgfHRoaXN8IHZhbHVlIGFzIHRoZSBhcmd1bWVudC5cbiAgICAgICAgTyA9IE9iamVjdCh0aGlzKSxcblxuICAgICAgICAvLyAyLiBMZXQgbGVuVmFsdWUgYmUgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIHRoZSBHZXQgaW50ZXJuYWwgbWV0aG9kIG9mIE8gd2l0aCB0aGUgYXJndW1lbnQgXCJsZW5ndGhcIi5cbiAgICAgICAgLy8gMy4gTGV0IGxlbiBiZSBUb1VpbnQzMihsZW5WYWx1ZSkuXG4gICAgICAgIGxlbiA9IE8ubGVuZ3RoID4+PiAwOyAvLyBIYWNrIHRvIGNvbnZlcnQgTy5sZW5ndGggdG8gYSBVSW50MzJcblxuICAgIC8vIDQuIElmIElzQ2FsbGFibGUoY2FsbGJhY2spIGlzIGZhbHNlLCB0aHJvdyBhIFR5cGVFcnJvciBleGNlcHRpb24uXG4gICAgLy8gU2VlOiBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3g5LjExXG4gICAgaWYgKHt9LnRvU3RyaW5nLmNhbGwoY2FsbGJhY2spICE9PSBcIltvYmplY3QgRnVuY3Rpb25dXCIpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoY2FsbGJhY2sgKyBcIiBpcyBub3QgYSBmdW5jdGlvblwiKTtcbiAgICB9XG5cbiAgICAvLyA1LiBJZiB0aGlzQXJnIHdhcyBzdXBwbGllZCwgbGV0IFQgYmUgdGhpc0FyZzsgZWxzZSBsZXQgVCBiZSB1bmRlZmluZWQuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMikge1xuICAgICAgVCA9IHRoaXNBcmc7XG4gICAgfVxuXG4gICAgLy8gNi4gTGV0IGsgYmUgMFxuICAgIGsgPSAwO1xuXG4gICAgLy8gNy4gUmVwZWF0LCB3aGlsZSBrIDwgbGVuXG4gICAgd2hpbGUgKGsgPCBsZW4pIHtcblxuICAgICAgLy8gYS4gTGV0IFBrIGJlIFRvU3RyaW5nKGspLlxuICAgICAgLy8gICBUaGlzIGlzIGltcGxpY2l0IGZvciBMSFMgb3BlcmFuZHMgb2YgdGhlIGluIG9wZXJhdG9yXG4gICAgICAvLyBiLiBMZXQga1ByZXNlbnQgYmUgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIHRoZSBIYXNQcm9wZXJ0eSBpbnRlcm5hbCBtZXRob2Qgb2YgTyB3aXRoIGFyZ3VtZW50IFBrLlxuICAgICAgLy8gICBUaGlzIHN0ZXAgY2FuIGJlIGNvbWJpbmVkIHdpdGggY1xuICAgICAgLy8gYy4gSWYga1ByZXNlbnQgaXMgdHJ1ZSwgdGhlblxuICAgICAgaWYgKGsgaW4gTykge1xuXG4gICAgICAgIC8vIGkuIExldCBrVmFsdWUgYmUgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIHRoZSBHZXQgaW50ZXJuYWwgbWV0aG9kIG9mIE8gd2l0aCBhcmd1bWVudCBQay5cbiAgICAgICAga1ZhbHVlID0gT1trXTtcblxuICAgICAgICAvLyBpaS4gQ2FsbCB0aGUgQ2FsbCBpbnRlcm5hbCBtZXRob2Qgb2YgY2FsbGJhY2sgd2l0aCBUIGFzIHRoZSB0aGlzIHZhbHVlIGFuZFxuICAgICAgICAvLyBhcmd1bWVudCBsaXN0IGNvbnRhaW5pbmcga1ZhbHVlLCBrLCBhbmQgTy5cbiAgICAgICAgY2FsbGJhY2suY2FsbChULCBrVmFsdWUsIGssIE8pO1xuICAgICAgfVxuICAgICAgLy8gZC4gSW5jcmVhc2UgayBieSAxLlxuICAgICAgaysrO1xuICAgIH1cbiAgICAvLyA4LiByZXR1cm4gdW5kZWZpbmVkXG4gIH07XG59XG5cbi8vIEZyb20gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2tleXNcbmlmICghT2JqZWN0LmtleXMpIHtcbiAgT2JqZWN0LmtleXMgPSAoZnVuY3Rpb24gKCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICB2YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LFxuICAgICAgICBoYXNEb250RW51bUJ1ZyA9ICEoe3RvU3RyaW5nOiBudWxsfSkucHJvcGVydHlJc0VudW1lcmFibGUoJ3RvU3RyaW5nJyksXG4gICAgICAgIGRvbnRFbnVtcyA9IFtcbiAgICAgICAgICAndG9TdHJpbmcnLFxuICAgICAgICAgICd0b0xvY2FsZVN0cmluZycsXG4gICAgICAgICAgJ3ZhbHVlT2YnLFxuICAgICAgICAgICdoYXNPd25Qcm9wZXJ0eScsXG4gICAgICAgICAgJ2lzUHJvdG90eXBlT2YnLFxuICAgICAgICAgICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsXG4gICAgICAgICAgJ2NvbnN0cnVjdG9yJ1xuICAgICAgICBdLFxuICAgICAgICBkb250RW51bXNMZW5ndGggPSBkb250RW51bXMubGVuZ3RoO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JyAmJiAodHlwZW9mIG9iaiAhPT0gJ2Z1bmN0aW9uJyB8fCBvYmogPT09IG51bGwpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5rZXlzIGNhbGxlZCBvbiBub24tb2JqZWN0Jyk7XG4gICAgICB9XG5cbiAgICAgIHZhciByZXN1bHQgPSBbXSwgcHJvcCwgaTtcblxuICAgICAgZm9yIChwcm9wIGluIG9iaikge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2gocHJvcCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGhhc0RvbnRFbnVtQnVnKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBkb250RW51bXNMZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgZG9udEVudW1zW2ldKSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goZG9udEVudW1zW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgfSgpKTtcbn1cblxuLy8gRnJvbSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9zb21lXG5pZiAoIUFycmF5LnByb3RvdHlwZS5zb21lKVxue1xuICBBcnJheS5wcm90b3R5cGUuc29tZSA9IGZ1bmN0aW9uKGZ1biAvKiwgdGhpc0FyZyAqLylcbiAge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGlmICh0aGlzID09PSB2b2lkIDAgfHwgdGhpcyA9PT0gbnVsbClcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcblxuICAgIHZhciB0ID0gT2JqZWN0KHRoaXMpO1xuICAgIHZhciBsZW4gPSB0Lmxlbmd0aCA+Pj4gMDtcbiAgICBpZiAodHlwZW9mIGZ1biAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcblxuICAgIHZhciB0aGlzQXJnID0gYXJndW1lbnRzLmxlbmd0aCA+PSAyID8gYXJndW1lbnRzWzFdIDogdm9pZCAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAge1xuICAgICAgaWYgKGkgaW4gdCAmJiBmdW4uY2FsbCh0aGlzQXJnLCB0W2ldLCBpLCB0KSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xufVxuXG4vLyBGcm9tIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L21hcFxuaWYgKCFBcnJheS5wcm90b3R5cGUubWFwKVxue1xuICBBcnJheS5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24oZnVuIC8qLCB0aGlzQXJnICovKVxuICB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBpZiAodGhpcyA9PT0gdm9pZCAwIHx8IHRoaXMgPT09IG51bGwpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG5cbiAgICB2YXIgdCA9IE9iamVjdCh0aGlzKTtcbiAgICB2YXIgbGVuID0gdC5sZW5ndGggPj4+IDA7XG4gICAgaWYgKHR5cGVvZiBmdW4gIT09IFwiZnVuY3Rpb25cIilcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcblxuICAgIHZhciByZXMgPSBuZXcgQXJyYXkobGVuKTtcbiAgICB2YXIgdGhpc0FyZyA9IGFyZ3VtZW50cy5sZW5ndGggPj0gMiA/IGFyZ3VtZW50c1sxXSA6IHZvaWQgMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgIHtcbiAgICAgIC8vIE5PVEU6IEFic29sdXRlIGNvcnJlY3RuZXNzIHdvdWxkIGRlbWFuZCBPYmplY3QuZGVmaW5lUHJvcGVydHlcbiAgICAgIC8vICAgICAgIGJlIHVzZWQuICBCdXQgdGhpcyBtZXRob2QgaXMgZmFpcmx5IG5ldywgYW5kIGZhaWx1cmUgaXNcbiAgICAgIC8vICAgICAgIHBvc3NpYmxlIG9ubHkgaWYgT2JqZWN0LnByb3RvdHlwZSBvciBBcnJheS5wcm90b3R5cGVcbiAgICAgIC8vICAgICAgIGhhcyBhIHByb3BlcnR5IHxpfCAodmVyeSB1bmxpa2VseSksIHNvIHVzZSBhIGxlc3MtY29ycmVjdFxuICAgICAgLy8gICAgICAgYnV0IG1vcmUgcG9ydGFibGUgYWx0ZXJuYXRpdmUuXG4gICAgICBpZiAoaSBpbiB0KVxuICAgICAgICByZXNbaV0gPSBmdW4uY2FsbCh0aGlzQXJnLCB0W2ldLCBpLCB0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xuICB9O1xufVxuXG4vL0Zyb20gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvZmlsdGVyXG5pZiAoIUFycmF5LnByb3RvdHlwZS5maWx0ZXIpXG57XG4gIEFycmF5LnByb3RvdHlwZS5maWx0ZXIgPSBmdW5jdGlvbihmdW4gLyosIHRoaXNBcmcgKi8pXG4gIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGlmICh0aGlzID09PSB2b2lkIDAgfHwgdGhpcyA9PT0gbnVsbClcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcblxuICAgIHZhciB0ID0gT2JqZWN0KHRoaXMpO1xuICAgIHZhciBsZW4gPSB0Lmxlbmd0aCA+Pj4gMDtcbiAgICBpZiAodHlwZW9mIGZ1biAhPSBcImZ1bmN0aW9uXCIpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG5cbiAgICB2YXIgcmVzID0gW107XG4gICAgdmFyIHRoaXNBcmcgPSBhcmd1bWVudHMubGVuZ3RoID49IDIgPyBhcmd1bWVudHNbMV0gOiB2b2lkIDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICB7XG4gICAgICBpZiAoaSBpbiB0KVxuICAgICAge1xuICAgICAgICB2YXIgdmFsID0gdFtpXTtcblxuICAgICAgICAvLyBOT1RFOiBUZWNobmljYWxseSB0aGlzIHNob3VsZCBPYmplY3QuZGVmaW5lUHJvcGVydHkgYXRcbiAgICAgICAgLy8gICAgICAgdGhlIG5leHQgaW5kZXgsIGFzIHB1c2ggY2FuIGJlIGFmZmVjdGVkIGJ5XG4gICAgICAgIC8vICAgICAgIHByb3BlcnRpZXMgb24gT2JqZWN0LnByb3RvdHlwZSBhbmQgQXJyYXkucHJvdG90eXBlLlxuICAgICAgICAvLyAgICAgICBCdXQgdGhhdCBtZXRob2QncyBuZXcsIGFuZCBjb2xsaXNpb25zIHNob3VsZCBiZVxuICAgICAgICAvLyAgICAgICByYXJlLCBzbyB1c2UgdGhlIG1vcmUtY29tcGF0aWJsZSBhbHRlcm5hdGl2ZS5cbiAgICAgICAgaWYgKGZ1bi5jYWxsKHRoaXNBcmcsIHZhbCwgaSwgdCkpXG4gICAgICAgICAgcmVzLnB1c2godmFsKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xuICB9O1xufVxuXG4vL0Zyb20gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRnVuY3Rpb24vYmluZFxuaWYgKCFGdW5jdGlvbi5wcm90b3R5cGUuYmluZCkge1xuICBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uIChvVGhpcykge1xuICAgIGlmICh0eXBlb2YgdGhpcyAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAvLyBjbG9zZXN0IHRoaW5nIHBvc3NpYmxlIHRvIHRoZSBFQ01BU2NyaXB0IDUgaW50ZXJuYWwgSXNDYWxsYWJsZSBmdW5jdGlvblxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kIC0gd2hhdCBpcyB0cnlpbmcgdG8gYmUgYm91bmQgaXMgbm90IGNhbGxhYmxlXCIpO1xuICAgIH1cblxuICAgIHZhciBhQXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSksXG4gICAgICAgIGZUb0JpbmQgPSB0aGlzLFxuICAgICAgICBmTk9QID0gZnVuY3Rpb24gKCkge30sXG4gICAgICAgIGZCb3VuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gZlRvQmluZC5hcHBseSh0aGlzIGluc3RhbmNlb2YgZk5PUCAmJiBvVGhpc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB0aGlzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IG9UaGlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFBcmdzLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG4gICAgICAgIH07XG5cbiAgICBmTk9QLnByb3RvdHlwZSA9IHRoaXMucHJvdG90eXBlO1xuICAgIGZCb3VuZC5wcm90b3R5cGUgPSBuZXcgZk5PUCgpO1xuXG4gICAgcmV0dXJuIGZCb3VuZDtcbiAgfTtcbn1cblxuLy9Gcm9tIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2luZGV4T2Y/cmVkaXJlY3Rsb2NhbGU9ZW4tVVMmcmVkaXJlY3RzbHVnPUphdmFTY3JpcHQlMkZSZWZlcmVuY2UlMkZHbG9iYWxfT2JqZWN0cyUyRkFycmF5JTJGaW5kZXhPZlxuaWYgKCFBcnJheS5wcm90b3R5cGUuaW5kZXhPZikge1xuICBBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIChzZWFyY2hFbGVtZW50LCBmcm9tSW5kZXgpIHtcbiAgICBpZiAoIHRoaXMgPT09IHVuZGVmaW5lZCB8fCB0aGlzID09PSBudWxsICkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvciggJ1widGhpc1wiIGlzIG51bGwgb3Igbm90IGRlZmluZWQnICk7XG4gICAgfVxuXG4gICAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoID4+PiAwOyAvLyBIYWNrIHRvIGNvbnZlcnQgb2JqZWN0Lmxlbmd0aCB0byBhIFVJbnQzMlxuXG4gICAgZnJvbUluZGV4ID0gK2Zyb21JbmRleCB8fCAwO1xuXG4gICAgaWYgKE1hdGguYWJzKGZyb21JbmRleCkgPT09IEluZmluaXR5KSB7XG4gICAgICBmcm9tSW5kZXggPSAwO1xuICAgIH1cblxuICAgIGlmIChmcm9tSW5kZXggPCAwKSB7XG4gICAgICBmcm9tSW5kZXggKz0gbGVuZ3RoO1xuICAgICAgaWYgKGZyb21JbmRleCA8IDApIHtcbiAgICAgICAgZnJvbUluZGV4ID0gMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKDtmcm9tSW5kZXggPCBsZW5ndGg7IGZyb21JbmRleCsrKSB7XG4gICAgICBpZiAodGhpc1tmcm9tSW5kZXhdID09PSBzZWFyY2hFbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBmcm9tSW5kZXg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIC0xO1xuICB9O1xufVxuIiwiaWYgKHR5cGVvZiBQcm9taXNlICE9PSAnZnVuY3Rpb24nKSB7XG4gIChmdW5jdGlvbigpIHtcbiAgdmFyIGRlZmluZSwgcmVxdWlyZU1vZHVsZSwgcmVxdWlyZSwgcmVxdWlyZWpzO1xuXG4gIChmdW5jdGlvbigpIHtcbiAgICB2YXIgcmVnaXN0cnkgPSB7fSwgc2VlbiA9IHt9O1xuXG4gICAgZGVmaW5lID0gZnVuY3Rpb24obmFtZSwgZGVwcywgY2FsbGJhY2spIHtcbiAgICAgIHJlZ2lzdHJ5W25hbWVdID0geyBkZXBzOiBkZXBzLCBjYWxsYmFjazogY2FsbGJhY2sgfTtcbiAgICB9O1xuXG4gICAgcmVxdWlyZWpzID0gcmVxdWlyZSA9IHJlcXVpcmVNb2R1bGUgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmVxdWlyZWpzLl9lYWtfc2VlbiA9IHJlZ2lzdHJ5O1xuXG4gICAgICBpZiAoc2VlbltuYW1lXSkgeyByZXR1cm4gc2VlbltuYW1lXTsgfVxuICAgICAgc2VlbltuYW1lXSA9IHt9O1xuXG4gICAgICBpZiAoIXJlZ2lzdHJ5W25hbWVdKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBmaW5kIG1vZHVsZSBcIiArIG5hbWUpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbW9kID0gcmVnaXN0cnlbbmFtZV0sXG4gICAgICAgICAgZGVwcyA9IG1vZC5kZXBzLFxuICAgICAgICAgIGNhbGxiYWNrID0gbW9kLmNhbGxiYWNrLFxuICAgICAgICAgIHJlaWZpZWQgPSBbXSxcbiAgICAgICAgICBleHBvcnRzO1xuXG4gICAgICBmb3IgKHZhciBpPTAsIGw9ZGVwcy5sZW5ndGg7IGk8bDsgaSsrKSB7XG4gICAgICAgIGlmIChkZXBzW2ldID09PSAnZXhwb3J0cycpIHtcbiAgICAgICAgICByZWlmaWVkLnB1c2goZXhwb3J0cyA9IHt9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWlmaWVkLnB1c2gocmVxdWlyZU1vZHVsZShyZXNvbHZlKGRlcHNbaV0pKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHZhbHVlID0gY2FsbGJhY2suYXBwbHkodGhpcywgcmVpZmllZCk7XG4gICAgICByZXR1cm4gc2VlbltuYW1lXSA9IGV4cG9ydHMgfHwgdmFsdWU7XG5cbiAgICAgIGZ1bmN0aW9uIHJlc29sdmUoY2hpbGQpIHtcbiAgICAgICAgaWYgKGNoaWxkLmNoYXJBdCgwKSAhPT0gJy4nKSB7IHJldHVybiBjaGlsZDsgfVxuICAgICAgICB2YXIgcGFydHMgPSBjaGlsZC5zcGxpdChcIi9cIik7XG4gICAgICAgIHZhciBwYXJlbnRCYXNlID0gbmFtZS5zcGxpdChcIi9cIikuc2xpY2UoMCwgLTEpO1xuXG4gICAgICAgIGZvciAodmFyIGk9MCwgbD1wYXJ0cy5sZW5ndGg7IGk8bDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHBhcnQgPSBwYXJ0c1tpXTtcblxuICAgICAgICAgIGlmIChwYXJ0ID09PSAnLi4nKSB7IHBhcmVudEJhc2UucG9wKCk7IH1cbiAgICAgICAgICBlbHNlIGlmIChwYXJ0ID09PSAnLicpIHsgY29udGludWU7IH1cbiAgICAgICAgICBlbHNlIHsgcGFyZW50QmFzZS5wdXNoKHBhcnQpOyB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGFyZW50QmFzZS5qb2luKFwiL1wiKTtcbiAgICAgIH1cbiAgICB9O1xuICB9KSgpO1xuXG4gIGRlZmluZShcInByb21pc2UvYWxsXCIsXG4gICAgW1wiLi91dGlsc1wiLFwiZXhwb3J0c1wiXSxcbiAgICBmdW5jdGlvbihfX2RlcGVuZGVuY3kxX18sIF9fZXhwb3J0c19fKSB7XG4gICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgIC8qIGdsb2JhbCB0b1N0cmluZyAqL1xuXG4gICAgICB2YXIgaXNBcnJheSA9IF9fZGVwZW5kZW5jeTFfXy5pc0FycmF5O1xuICAgICAgdmFyIGlzRnVuY3Rpb24gPSBfX2RlcGVuZGVuY3kxX18uaXNGdW5jdGlvbjtcblxuICAgICAgLyoqXG4gICAgICAgIFJldHVybnMgYSBwcm9taXNlIHRoYXQgaXMgZnVsZmlsbGVkIHdoZW4gYWxsIHRoZSBnaXZlbiBwcm9taXNlcyBoYXZlIGJlZW5cbiAgICAgICAgZnVsZmlsbGVkLCBvciByZWplY3RlZCBpZiBhbnkgb2YgdGhlbSBiZWNvbWUgcmVqZWN0ZWQuIFRoZSByZXR1cm4gcHJvbWlzZVxuICAgICAgICBpcyBmdWxmaWxsZWQgd2l0aCBhbiBhcnJheSB0aGF0IGdpdmVzIGFsbCB0aGUgdmFsdWVzIGluIHRoZSBvcmRlciB0aGV5IHdlcmVcbiAgICAgICAgcGFzc2VkIGluIHRoZSBgcHJvbWlzZXNgIGFycmF5IGFyZ3VtZW50LlxuXG4gICAgICAgIEV4YW1wbGU6XG5cbiAgICAgICAgYGBgamF2YXNjcmlwdFxuICAgICAgICB2YXIgcHJvbWlzZTEgPSBSU1ZQLnJlc29sdmUoMSk7XG4gICAgICAgIHZhciBwcm9taXNlMiA9IFJTVlAucmVzb2x2ZSgyKTtcbiAgICAgICAgdmFyIHByb21pc2UzID0gUlNWUC5yZXNvbHZlKDMpO1xuICAgICAgICB2YXIgcHJvbWlzZXMgPSBbIHByb21pc2UxLCBwcm9taXNlMiwgcHJvbWlzZTMgXTtcblxuICAgICAgICBSU1ZQLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbihhcnJheSl7XG4gICAgICAgICAgLy8gVGhlIGFycmF5IGhlcmUgd291bGQgYmUgWyAxLCAyLCAzIF07XG4gICAgICAgIH0pO1xuICAgICAgICBgYGBcblxuICAgICAgICBJZiBhbnkgb2YgdGhlIGBwcm9taXNlc2AgZ2l2ZW4gdG8gYFJTVlAuYWxsYCBhcmUgcmVqZWN0ZWQsIHRoZSBmaXJzdCBwcm9taXNlXG4gICAgICAgIHRoYXQgaXMgcmVqZWN0ZWQgd2lsbCBiZSBnaXZlbiBhcyBhbiBhcmd1bWVudCB0byB0aGUgcmV0dXJuZWQgcHJvbWlzZXMnc1xuICAgICAgICByZWplY3Rpb24gaGFuZGxlci4gRm9yIGV4YW1wbGU6XG5cbiAgICAgICAgRXhhbXBsZTpcblxuICAgICAgICBgYGBqYXZhc2NyaXB0XG4gICAgICAgIHZhciBwcm9taXNlMSA9IFJTVlAucmVzb2x2ZSgxKTtcbiAgICAgICAgdmFyIHByb21pc2UyID0gUlNWUC5yZWplY3QobmV3IEVycm9yKFwiMlwiKSk7XG4gICAgICAgIHZhciBwcm9taXNlMyA9IFJTVlAucmVqZWN0KG5ldyBFcnJvcihcIjNcIikpO1xuICAgICAgICB2YXIgcHJvbWlzZXMgPSBbIHByb21pc2UxLCBwcm9taXNlMiwgcHJvbWlzZTMgXTtcblxuICAgICAgICBSU1ZQLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbihhcnJheSl7XG4gICAgICAgICAgLy8gQ29kZSBoZXJlIG5ldmVyIHJ1bnMgYmVjYXVzZSB0aGVyZSBhcmUgcmVqZWN0ZWQgcHJvbWlzZXMhXG4gICAgICAgIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgLy8gZXJyb3IubWVzc2FnZSA9PT0gXCIyXCJcbiAgICAgICAgfSk7XG4gICAgICAgIGBgYFxuXG4gICAgICAgIEBtZXRob2QgYWxsXG4gICAgICAgIEBmb3IgUlNWUFxuICAgICAgICBAcGFyYW0ge0FycmF5fSBwcm9taXNlc1xuICAgICAgICBAcGFyYW0ge1N0cmluZ30gbGFiZWxcbiAgICAgICAgQHJldHVybiB7UHJvbWlzZX0gcHJvbWlzZSB0aGF0IGlzIGZ1bGZpbGxlZCB3aGVuIGFsbCBgcHJvbWlzZXNgIGhhdmUgYmVlblxuICAgICAgICBmdWxmaWxsZWQsIG9yIHJlamVjdGVkIGlmIGFueSBvZiB0aGVtIGJlY29tZSByZWplY3RlZC5cbiAgICAgICovXG4gICAgICBmdW5jdGlvbiBhbGwocHJvbWlzZXMpIHtcbiAgICAgICAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgICAgICAgdmFyIFByb21pc2UgPSB0aGlzO1xuXG4gICAgICAgIGlmICghaXNBcnJheShwcm9taXNlcykpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdZb3UgbXVzdCBwYXNzIGFuIGFycmF5IHRvIGFsbC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0cyA9IFtdLCByZW1haW5pbmcgPSBwcm9taXNlcy5sZW5ndGgsXG4gICAgICAgICAgcHJvbWlzZTtcblxuICAgICAgICAgIGlmIChyZW1haW5pbmcgPT09IDApIHtcbiAgICAgICAgICAgIHJlc29sdmUoW10pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIHJlc29sdmVyKGluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgcmVzb2x2ZUFsbChpbmRleCwgdmFsdWUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiByZXNvbHZlQWxsKGluZGV4LCB2YWx1ZSkge1xuICAgICAgICAgICAgcmVzdWx0c1tpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgICAgIGlmICgtLXJlbWFpbmluZyA9PT0gMCkge1xuICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvbWlzZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHByb21pc2UgPSBwcm9taXNlc1tpXTtcblxuICAgICAgICAgICAgaWYgKHByb21pc2UgJiYgaXNGdW5jdGlvbihwcm9taXNlLnRoZW4pKSB7XG4gICAgICAgICAgICAgIHByb21pc2UudGhlbihyZXNvbHZlcihpKSwgcmVqZWN0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc29sdmVBbGwoaSwgcHJvbWlzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgX19leHBvcnRzX18uYWxsID0gYWxsO1xuICAgIH0pO1xuICBkZWZpbmUoXCJwcm9taXNlL2FzYXBcIixcbiAgICBbXCJleHBvcnRzXCJdLFxuICAgIGZ1bmN0aW9uKF9fZXhwb3J0c19fKSB7XG4gICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgIHZhciBicm93c2VyR2xvYmFsID0gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSA/IHdpbmRvdyA6IHt9O1xuICAgICAgdmFyIEJyb3dzZXJNdXRhdGlvbk9ic2VydmVyID0gYnJvd3Nlckdsb2JhbC5NdXRhdGlvbk9ic2VydmVyIHx8IGJyb3dzZXJHbG9iYWwuV2ViS2l0TXV0YXRpb25PYnNlcnZlcjtcbiAgICAgIHZhciBsb2NhbCA9ICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykgPyBnbG9iYWwgOiAodGhpcyA9PT0gdW5kZWZpbmVkPyB3aW5kb3c6dGhpcyk7XG5cbiAgICAgIC8vIG5vZGVcbiAgICAgIGZ1bmN0aW9uIHVzZU5leHRUaWNrKCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmbHVzaCk7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHVzZU11dGF0aW9uT2JzZXJ2ZXIoKSB7XG4gICAgICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICAgICAgdmFyIG9ic2VydmVyID0gbmV3IEJyb3dzZXJNdXRhdGlvbk9ic2VydmVyKGZsdXNoKTtcbiAgICAgICAgdmFyIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gICAgICAgIG9ic2VydmVyLm9ic2VydmUobm9kZSwgeyBjaGFyYWN0ZXJEYXRhOiB0cnVlIH0pO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBub2RlLmRhdGEgPSAoaXRlcmF0aW9ucyA9ICsraXRlcmF0aW9ucyAlIDIpO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiB1c2VTZXRUaW1lb3V0KCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgbG9jYWwuc2V0VGltZW91dChmbHVzaCwgMSk7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHZhciBxdWV1ZSA9IFtdO1xuICAgICAgZnVuY3Rpb24gZmx1c2goKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgdHVwbGUgPSBxdWV1ZVtpXTtcbiAgICAgICAgICB2YXIgY2FsbGJhY2sgPSB0dXBsZVswXSwgYXJnID0gdHVwbGVbMV07XG4gICAgICAgICAgY2FsbGJhY2soYXJnKTtcbiAgICAgICAgfVxuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2NoZWR1bGVGbHVzaDtcblxuICAgICAgLy8gRGVjaWRlIHdoYXQgYXN5bmMgbWV0aG9kIHRvIHVzZSB0byB0cmlnZ2VyaW5nIHByb2Nlc3Npbmcgb2YgcXVldWVkIGNhbGxiYWNrczpcbiAgICAgIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYge30udG9TdHJpbmcuY2FsbChwcm9jZXNzKSA9PT0gJ1tvYmplY3QgcHJvY2Vzc10nKSB7XG4gICAgICAgIHNjaGVkdWxlRmx1c2ggPSB1c2VOZXh0VGljaygpO1xuICAgICAgfSBlbHNlIGlmIChCcm93c2VyTXV0YXRpb25PYnNlcnZlcikge1xuICAgICAgICBzY2hlZHVsZUZsdXNoID0gdXNlTXV0YXRpb25PYnNlcnZlcigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2NoZWR1bGVGbHVzaCA9IHVzZVNldFRpbWVvdXQoKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gYXNhcChjYWxsYmFjaywgYXJnKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSBxdWV1ZS5wdXNoKFtjYWxsYmFjaywgYXJnXSk7XG4gICAgICAgIGlmIChsZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAvLyBJZiBsZW5ndGggaXMgMSwgdGhhdCBtZWFucyB0aGF0IHdlIG5lZWQgdG8gc2NoZWR1bGUgYW4gYXN5bmMgZmx1c2guXG4gICAgICAgICAgLy8gSWYgYWRkaXRpb25hbCBjYWxsYmFja3MgYXJlIHF1ZXVlZCBiZWZvcmUgdGhlIHF1ZXVlIGlzIGZsdXNoZWQsIHRoZXlcbiAgICAgICAgICAvLyB3aWxsIGJlIHByb2Nlc3NlZCBieSB0aGlzIGZsdXNoIHRoYXQgd2UgYXJlIHNjaGVkdWxpbmcuXG4gICAgICAgICAgc2NoZWR1bGVGbHVzaCgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIF9fZXhwb3J0c19fLmFzYXAgPSBhc2FwO1xuICAgIH0pO1xuICBkZWZpbmUoXCJwcm9taXNlL2NvbmZpZ1wiLFxuICAgIFtcImV4cG9ydHNcIl0sXG4gICAgZnVuY3Rpb24oX19leHBvcnRzX18pIHtcbiAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgdmFyIGNvbmZpZyA9IHtcbiAgICAgICAgaW5zdHJ1bWVudDogZmFsc2VcbiAgICAgIH07XG5cbiAgICAgIGZ1bmN0aW9uIGNvbmZpZ3VyZShuYW1lLCB2YWx1ZSkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgIGNvbmZpZ1tuYW1lXSA9IHZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBjb25maWdbbmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgX19leHBvcnRzX18uY29uZmlnID0gY29uZmlnO1xuICAgICAgX19leHBvcnRzX18uY29uZmlndXJlID0gY29uZmlndXJlO1xuICAgIH0pO1xuICBkZWZpbmUoXCJwcm9taXNlL3BvbHlmaWxsXCIsXG4gICAgW1wiLi9wcm9taXNlXCIsXCIuL3V0aWxzXCIsXCJleHBvcnRzXCJdLFxuICAgIGZ1bmN0aW9uKF9fZGVwZW5kZW5jeTFfXywgX19kZXBlbmRlbmN5Ml9fLCBfX2V4cG9ydHNfXykge1xuICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAvKmdsb2JhbCBzZWxmKi9cbiAgICAgIHZhciBSU1ZQUHJvbWlzZSA9IF9fZGVwZW5kZW5jeTFfXy5Qcm9taXNlO1xuICAgICAgdmFyIGlzRnVuY3Rpb24gPSBfX2RlcGVuZGVuY3kyX18uaXNGdW5jdGlvbjtcblxuICAgICAgZnVuY3Rpb24gcG9seWZpbGwoKSB7XG4gICAgICAgIHZhciBsb2NhbDtcblxuICAgICAgICBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBsb2NhbCA9IGdsb2JhbDtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuZG9jdW1lbnQpIHtcbiAgICAgICAgICBsb2NhbCA9IHdpbmRvdztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsb2NhbCA9IHNlbGY7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZXM2UHJvbWlzZVN1cHBvcnQgPVxuICAgICAgICAgIFwiUHJvbWlzZVwiIGluIGxvY2FsICYmXG4gICAgICAgICAgLy8gU29tZSBvZiB0aGVzZSBtZXRob2RzIGFyZSBtaXNzaW5nIGZyb21cbiAgICAgICAgICAvLyBGaXJlZm94L0Nocm9tZSBleHBlcmltZW50YWwgaW1wbGVtZW50YXRpb25zXG4gICAgICAgICAgXCJyZXNvbHZlXCIgaW4gbG9jYWwuUHJvbWlzZSAmJlxuICAgICAgICAgIFwicmVqZWN0XCIgaW4gbG9jYWwuUHJvbWlzZSAmJlxuICAgICAgICAgIFwiYWxsXCIgaW4gbG9jYWwuUHJvbWlzZSAmJlxuICAgICAgICAgIFwicmFjZVwiIGluIGxvY2FsLlByb21pc2UgJiZcbiAgICAgICAgICAvLyBPbGRlciB2ZXJzaW9uIG9mIHRoZSBzcGVjIGhhZCBhIHJlc29sdmVyIG9iamVjdFxuICAgICAgICAgIC8vIGFzIHRoZSBhcmcgcmF0aGVyIHRoYW4gYSBmdW5jdGlvblxuICAgICAgICAgIChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciByZXNvbHZlO1xuICAgICAgICAgICAgbmV3IGxvY2FsLlByb21pc2UoZnVuY3Rpb24ocikgeyByZXNvbHZlID0gcjsgfSk7XG4gICAgICAgICAgICByZXR1cm4gaXNGdW5jdGlvbihyZXNvbHZlKTtcbiAgICAgICAgICB9KCkpO1xuXG4gICAgICAgIGlmICghZXM2UHJvbWlzZVN1cHBvcnQpIHtcbiAgICAgICAgICBsb2NhbC5Qcm9taXNlID0gUlNWUFByb21pc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgX19leHBvcnRzX18ucG9seWZpbGwgPSBwb2x5ZmlsbDtcbiAgICB9KTtcbiAgZGVmaW5lKFwicHJvbWlzZS9wcm9taXNlXCIsXG4gICAgW1wiLi9jb25maWdcIixcIi4vdXRpbHNcIixcIi4vYWxsXCIsXCIuL3JhY2VcIixcIi4vcmVzb2x2ZVwiLFwiLi9yZWplY3RcIixcIi4vYXNhcFwiLFwiZXhwb3J0c1wiXSxcbiAgICBmdW5jdGlvbihfX2RlcGVuZGVuY3kxX18sIF9fZGVwZW5kZW5jeTJfXywgX19kZXBlbmRlbmN5M19fLCBfX2RlcGVuZGVuY3k0X18sIF9fZGVwZW5kZW5jeTVfXywgX19kZXBlbmRlbmN5Nl9fLCBfX2RlcGVuZGVuY3k3X18sIF9fZXhwb3J0c19fKSB7XG4gICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgIHZhciBjb25maWcgPSBfX2RlcGVuZGVuY3kxX18uY29uZmlnO1xuICAgICAgdmFyIGNvbmZpZ3VyZSA9IF9fZGVwZW5kZW5jeTFfXy5jb25maWd1cmU7XG4gICAgICB2YXIgb2JqZWN0T3JGdW5jdGlvbiA9IF9fZGVwZW5kZW5jeTJfXy5vYmplY3RPckZ1bmN0aW9uO1xuICAgICAgdmFyIGlzRnVuY3Rpb24gPSBfX2RlcGVuZGVuY3kyX18uaXNGdW5jdGlvbjtcbiAgICAgIHZhciBub3cgPSBfX2RlcGVuZGVuY3kyX18ubm93O1xuICAgICAgdmFyIGFsbCA9IF9fZGVwZW5kZW5jeTNfXy5hbGw7XG4gICAgICB2YXIgcmFjZSA9IF9fZGVwZW5kZW5jeTRfXy5yYWNlO1xuICAgICAgdmFyIHN0YXRpY1Jlc29sdmUgPSBfX2RlcGVuZGVuY3k1X18ucmVzb2x2ZTtcbiAgICAgIHZhciBzdGF0aWNSZWplY3QgPSBfX2RlcGVuZGVuY3k2X18ucmVqZWN0O1xuICAgICAgdmFyIGFzYXAgPSBfX2RlcGVuZGVuY3k3X18uYXNhcDtcblxuICAgICAgdmFyIGNvdW50ZXIgPSAwO1xuXG4gICAgICBjb25maWcuYXN5bmMgPSBhc2FwOyAvLyBkZWZhdWx0IGFzeW5jIGlzIGFzYXA7XG5cbiAgICAgIGZ1bmN0aW9uIFByb21pc2UocmVzb2x2ZXIpIHtcbiAgICAgICAgaWYgKCFpc0Z1bmN0aW9uKHJlc29sdmVyKSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1lvdSBtdXN0IHBhc3MgYSByZXNvbHZlciBmdW5jdGlvbiBhcyB0aGUgZmlyc3QgYXJndW1lbnQgdG8gdGhlIHByb21pc2UgY29uc3RydWN0b3InKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQcm9taXNlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGYWlsZWQgdG8gY29uc3RydWN0ICdQcm9taXNlJzogUGxlYXNlIHVzZSB0aGUgJ25ldycgb3BlcmF0b3IsIHRoaXMgb2JqZWN0IGNvbnN0cnVjdG9yIGNhbm5vdCBiZSBjYWxsZWQgYXMgYSBmdW5jdGlvbi5cIik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9zdWJzY3JpYmVycyA9IFtdO1xuXG4gICAgICAgIGludm9rZVJlc29sdmVyKHJlc29sdmVyLCB0aGlzKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gaW52b2tlUmVzb2x2ZXIocmVzb2x2ZXIsIHByb21pc2UpIHtcbiAgICAgICAgZnVuY3Rpb24gcmVzb2x2ZVByb21pc2UodmFsdWUpIHtcbiAgICAgICAgICByZXNvbHZlKHByb21pc2UsIHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdFByb21pc2UocmVhc29uKSB7XG4gICAgICAgICAgcmVqZWN0KHByb21pc2UsIHJlYXNvbik7XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJlc29sdmVyKHJlc29sdmVQcm9taXNlLCByZWplY3RQcm9taXNlKTtcbiAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgcmVqZWN0UHJvbWlzZShlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBpbnZva2VDYWxsYmFjayhzZXR0bGVkLCBwcm9taXNlLCBjYWxsYmFjaywgZGV0YWlsKSB7XG4gICAgICAgIHZhciBoYXNDYWxsYmFjayA9IGlzRnVuY3Rpb24oY2FsbGJhY2spLFxuICAgICAgICAgICAgdmFsdWUsIGVycm9yLCBzdWNjZWVkZWQsIGZhaWxlZDtcblxuICAgICAgICBpZiAoaGFzQ2FsbGJhY2spIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFsdWUgPSBjYWxsYmFjayhkZXRhaWwpO1xuICAgICAgICAgICAgc3VjY2VlZGVkID0gdHJ1ZTtcbiAgICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgIGZhaWxlZCA9IHRydWU7XG4gICAgICAgICAgICBlcnJvciA9IGU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0gZGV0YWlsO1xuICAgICAgICAgIHN1Y2NlZWRlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFuZGxlVGhlbmFibGUocHJvbWlzZSwgdmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2UgaWYgKGhhc0NhbGxiYWNrICYmIHN1Y2NlZWRlZCkge1xuICAgICAgICAgIHJlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgICB9IGVsc2UgaWYgKGZhaWxlZCkge1xuICAgICAgICAgIHJlamVjdChwcm9taXNlLCBlcnJvcik7XG4gICAgICAgIH0gZWxzZSBpZiAoc2V0dGxlZCA9PT0gRlVMRklMTEVEKSB7XG4gICAgICAgICAgcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc2V0dGxlZCA9PT0gUkVKRUNURUQpIHtcbiAgICAgICAgICByZWplY3QocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBQRU5ESU5HICAgPSB2b2lkIDA7XG4gICAgICB2YXIgU0VBTEVEICAgID0gMDtcbiAgICAgIHZhciBGVUxGSUxMRUQgPSAxO1xuICAgICAgdmFyIFJFSkVDVEVEICA9IDI7XG5cbiAgICAgIGZ1bmN0aW9uIHN1YnNjcmliZShwYXJlbnQsIGNoaWxkLCBvbkZ1bGZpbGxtZW50LCBvblJlamVjdGlvbikge1xuICAgICAgICB2YXIgc3Vic2NyaWJlcnMgPSBwYXJlbnQuX3N1YnNjcmliZXJzO1xuICAgICAgICB2YXIgbGVuZ3RoID0gc3Vic2NyaWJlcnMubGVuZ3RoO1xuXG4gICAgICAgIHN1YnNjcmliZXJzW2xlbmd0aF0gPSBjaGlsZDtcbiAgICAgICAgc3Vic2NyaWJlcnNbbGVuZ3RoICsgRlVMRklMTEVEXSA9IG9uRnVsZmlsbG1lbnQ7XG4gICAgICAgIHN1YnNjcmliZXJzW2xlbmd0aCArIFJFSkVDVEVEXSAgPSBvblJlamVjdGlvbjtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gcHVibGlzaChwcm9taXNlLCBzZXR0bGVkKSB7XG4gICAgICAgIHZhciBjaGlsZCwgY2FsbGJhY2ssIHN1YnNjcmliZXJzID0gcHJvbWlzZS5fc3Vic2NyaWJlcnMsIGRldGFpbCA9IHByb21pc2UuX2RldGFpbDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN1YnNjcmliZXJzLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgICAgY2hpbGQgPSBzdWJzY3JpYmVyc1tpXTtcbiAgICAgICAgICBjYWxsYmFjayA9IHN1YnNjcmliZXJzW2kgKyBzZXR0bGVkXTtcblxuICAgICAgICAgIGludm9rZUNhbGxiYWNrKHNldHRsZWQsIGNoaWxkLCBjYWxsYmFjaywgZGV0YWlsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHByb21pc2UuX3N1YnNjcmliZXJzID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgUHJvbWlzZS5wcm90b3R5cGUgPSB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiBQcm9taXNlLFxuXG4gICAgICAgIF9zdGF0ZTogdW5kZWZpbmVkLFxuICAgICAgICBfZGV0YWlsOiB1bmRlZmluZWQsXG4gICAgICAgIF9zdWJzY3JpYmVyczogdW5kZWZpbmVkLFxuXG4gICAgICAgIHRoZW46IGZ1bmN0aW9uKG9uRnVsZmlsbG1lbnQsIG9uUmVqZWN0aW9uKSB7XG4gICAgICAgICAgdmFyIHByb21pc2UgPSB0aGlzO1xuXG4gICAgICAgICAgdmFyIHRoZW5Qcm9taXNlID0gbmV3IHRoaXMuY29uc3RydWN0b3IoZnVuY3Rpb24oKSB7fSk7XG5cbiAgICAgICAgICBpZiAodGhpcy5fc3RhdGUpIHtcbiAgICAgICAgICAgIHZhciBjYWxsYmFja3MgPSBhcmd1bWVudHM7XG4gICAgICAgICAgICBjb25maWcuYXN5bmMoZnVuY3Rpb24gaW52b2tlUHJvbWlzZUNhbGxiYWNrKCkge1xuICAgICAgICAgICAgICBpbnZva2VDYWxsYmFjayhwcm9taXNlLl9zdGF0ZSwgdGhlblByb21pc2UsIGNhbGxiYWNrc1twcm9taXNlLl9zdGF0ZSAtIDFdLCBwcm9taXNlLl9kZXRhaWwpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN1YnNjcmliZSh0aGlzLCB0aGVuUHJvbWlzZSwgb25GdWxmaWxsbWVudCwgb25SZWplY3Rpb24pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0aGVuUHJvbWlzZTtcbiAgICAgICAgfSxcblxuICAgICAgICAnY2F0Y2gnOiBmdW5jdGlvbihvblJlamVjdGlvbikge1xuICAgICAgICAgIHJldHVybiB0aGlzLnRoZW4obnVsbCwgb25SZWplY3Rpb24pO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBQcm9taXNlLmFsbCA9IGFsbDtcbiAgICAgIFByb21pc2UucmFjZSA9IHJhY2U7XG4gICAgICBQcm9taXNlLnJlc29sdmUgPSBzdGF0aWNSZXNvbHZlO1xuICAgICAgUHJvbWlzZS5yZWplY3QgPSBzdGF0aWNSZWplY3Q7XG5cbiAgICAgIGZ1bmN0aW9uIGhhbmRsZVRoZW5hYmxlKHByb21pc2UsIHZhbHVlKSB7XG4gICAgICAgIHZhciB0aGVuID0gbnVsbCxcbiAgICAgICAgcmVzb2x2ZWQ7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAocHJvbWlzZSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJBIHByb21pc2VzIGNhbGxiYWNrIGNhbm5vdCByZXR1cm4gdGhhdCBzYW1lIHByb21pc2UuXCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChvYmplY3RPckZ1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgICAgICAgdGhlbiA9IHZhbHVlLnRoZW47XG5cbiAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKHRoZW4pKSB7XG4gICAgICAgICAgICAgIHRoZW4uY2FsbCh2YWx1ZSwgZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc29sdmVkKSB7IHJldHVybiB0cnVlOyB9XG4gICAgICAgICAgICAgICAgcmVzb2x2ZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB2YWwpIHtcbiAgICAgICAgICAgICAgICAgIHJlc29sdmUocHJvbWlzZSwgdmFsKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgZnVsZmlsbChwcm9taXNlLCB2YWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSwgZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc29sdmVkKSB7IHJldHVybiB0cnVlOyB9XG4gICAgICAgICAgICAgICAgcmVzb2x2ZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgcmVqZWN0KHByb21pc2UsIHZhbCk7XG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBpZiAocmVzb2x2ZWQpIHsgcmV0dXJuIHRydWU7IH1cbiAgICAgICAgICByZWplY3QocHJvbWlzZSwgZXJyb3IpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiByZXNvbHZlKHByb21pc2UsIHZhbHVlKSB7XG4gICAgICAgIGlmIChwcm9taXNlID09PSB2YWx1ZSkge1xuICAgICAgICAgIGZ1bGZpbGwocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgICB9IGVsc2UgaWYgKCFoYW5kbGVUaGVuYWJsZShwcm9taXNlLCB2YWx1ZSkpIHtcbiAgICAgICAgICBmdWxmaWxsKHByb21pc2UsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBmdWxmaWxsKHByb21pc2UsIHZhbHVlKSB7XG4gICAgICAgIGlmIChwcm9taXNlLl9zdGF0ZSAhPT0gUEVORElORykgeyByZXR1cm47IH1cbiAgICAgICAgcHJvbWlzZS5fc3RhdGUgPSBTRUFMRUQ7XG4gICAgICAgIHByb21pc2UuX2RldGFpbCA9IHZhbHVlO1xuXG4gICAgICAgIGNvbmZpZy5hc3luYyhwdWJsaXNoRnVsZmlsbG1lbnQsIHByb21pc2UpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiByZWplY3QocHJvbWlzZSwgcmVhc29uKSB7XG4gICAgICAgIGlmIChwcm9taXNlLl9zdGF0ZSAhPT0gUEVORElORykgeyByZXR1cm47IH1cbiAgICAgICAgcHJvbWlzZS5fc3RhdGUgPSBTRUFMRUQ7XG4gICAgICAgIHByb21pc2UuX2RldGFpbCA9IHJlYXNvbjtcblxuICAgICAgICBjb25maWcuYXN5bmMocHVibGlzaFJlamVjdGlvbiwgcHJvbWlzZSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHB1Ymxpc2hGdWxmaWxsbWVudChwcm9taXNlKSB7XG4gICAgICAgIHB1Ymxpc2gocHJvbWlzZSwgcHJvbWlzZS5fc3RhdGUgPSBGVUxGSUxMRUQpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBwdWJsaXNoUmVqZWN0aW9uKHByb21pc2UpIHtcbiAgICAgICAgcHVibGlzaChwcm9taXNlLCBwcm9taXNlLl9zdGF0ZSA9IFJFSkVDVEVEKTtcbiAgICAgIH1cblxuICAgICAgX19leHBvcnRzX18uUHJvbWlzZSA9IFByb21pc2U7XG4gICAgfSk7XG4gIGRlZmluZShcInByb21pc2UvcmFjZVwiLFxuICAgIFtcIi4vdXRpbHNcIixcImV4cG9ydHNcIl0sXG4gICAgZnVuY3Rpb24oX19kZXBlbmRlbmN5MV9fLCBfX2V4cG9ydHNfXykge1xuICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAvKiBnbG9iYWwgdG9TdHJpbmcgKi9cbiAgICAgIHZhciBpc0FycmF5ID0gX19kZXBlbmRlbmN5MV9fLmlzQXJyYXk7XG5cbiAgICAgIC8qKlxuICAgICAgICBgUlNWUC5yYWNlYCBhbGxvd3MgeW91IHRvIHdhdGNoIGEgc2VyaWVzIG9mIHByb21pc2VzIGFuZCBhY3QgYXMgc29vbiBhcyB0aGVcbiAgICAgICAgZmlyc3QgcHJvbWlzZSBnaXZlbiB0byB0aGUgYHByb21pc2VzYCBhcmd1bWVudCBmdWxmaWxscyBvciByZWplY3RzLlxuXG4gICAgICAgIEV4YW1wbGU6XG5cbiAgICAgICAgYGBgamF2YXNjcmlwdFxuICAgICAgICB2YXIgcHJvbWlzZTEgPSBuZXcgUlNWUC5Qcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgICAgICAgcmVzb2x2ZShcInByb21pc2UgMVwiKTtcbiAgICAgICAgICB9LCAyMDApO1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgcHJvbWlzZTIgPSBuZXcgUlNWUC5Qcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgICAgICAgcmVzb2x2ZShcInByb21pc2UgMlwiKTtcbiAgICAgICAgICB9LCAxMDApO1xuICAgICAgICB9KTtcblxuICAgICAgICBSU1ZQLnJhY2UoW3Byb21pc2UxLCBwcm9taXNlMl0pLnRoZW4oZnVuY3Rpb24ocmVzdWx0KXtcbiAgICAgICAgICAvLyByZXN1bHQgPT09IFwicHJvbWlzZSAyXCIgYmVjYXVzZSBpdCB3YXMgcmVzb2x2ZWQgYmVmb3JlIHByb21pc2UxXG4gICAgICAgICAgLy8gd2FzIHJlc29sdmVkLlxuICAgICAgICB9KTtcbiAgICAgICAgYGBgXG5cbiAgICAgICAgYFJTVlAucmFjZWAgaXMgZGV0ZXJtaW5pc3RpYyBpbiB0aGF0IG9ubHkgdGhlIHN0YXRlIG9mIHRoZSBmaXJzdCBjb21wbGV0ZWRcbiAgICAgICAgcHJvbWlzZSBtYXR0ZXJzLiBGb3IgZXhhbXBsZSwgZXZlbiBpZiBvdGhlciBwcm9taXNlcyBnaXZlbiB0byB0aGUgYHByb21pc2VzYFxuICAgICAgICBhcnJheSBhcmd1bWVudCBhcmUgcmVzb2x2ZWQsIGJ1dCB0aGUgZmlyc3QgY29tcGxldGVkIHByb21pc2UgaGFzIGJlY29tZVxuICAgICAgICByZWplY3RlZCBiZWZvcmUgdGhlIG90aGVyIHByb21pc2VzIGJlY2FtZSBmdWxmaWxsZWQsIHRoZSByZXR1cm5lZCBwcm9taXNlXG4gICAgICAgIHdpbGwgYmVjb21lIHJlamVjdGVkOlxuXG4gICAgICAgIGBgYGphdmFzY3JpcHRcbiAgICAgICAgdmFyIHByb21pc2UxID0gbmV3IFJTVlAuUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHJlc29sdmUoXCJwcm9taXNlIDFcIik7XG4gICAgICAgICAgfSwgMjAwKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIHByb21pc2UyID0gbmV3IFJTVlAuUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJwcm9taXNlIDJcIikpO1xuICAgICAgICAgIH0sIDEwMCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIFJTVlAucmFjZShbcHJvbWlzZTEsIHByb21pc2UyXSkudGhlbihmdW5jdGlvbihyZXN1bHQpe1xuICAgICAgICAgIC8vIENvZGUgaGVyZSBuZXZlciBydW5zIGJlY2F1c2UgdGhlcmUgYXJlIHJlamVjdGVkIHByb21pc2VzIVxuICAgICAgICB9LCBmdW5jdGlvbihyZWFzb24pe1xuICAgICAgICAgIC8vIHJlYXNvbi5tZXNzYWdlID09PSBcInByb21pc2UyXCIgYmVjYXVzZSBwcm9taXNlIDIgYmVjYW1lIHJlamVjdGVkIGJlZm9yZVxuICAgICAgICAgIC8vIHByb21pc2UgMSBiZWNhbWUgZnVsZmlsbGVkXG4gICAgICAgIH0pO1xuICAgICAgICBgYGBcblxuICAgICAgICBAbWV0aG9kIHJhY2VcbiAgICAgICAgQGZvciBSU1ZQXG4gICAgICAgIEBwYXJhbSB7QXJyYXl9IHByb21pc2VzIGFycmF5IG9mIHByb21pc2VzIHRvIG9ic2VydmVcbiAgICAgICAgQHBhcmFtIHtTdHJpbmd9IGxhYmVsIG9wdGlvbmFsIHN0cmluZyBmb3IgZGVzY3JpYmluZyB0aGUgcHJvbWlzZSByZXR1cm5lZC5cbiAgICAgICAgVXNlZnVsIGZvciB0b29saW5nLlxuICAgICAgICBAcmV0dXJuIHtQcm9taXNlfSBhIHByb21pc2UgdGhhdCBiZWNvbWVzIGZ1bGZpbGxlZCB3aXRoIHRoZSB2YWx1ZSB0aGUgZmlyc3RcbiAgICAgICAgY29tcGxldGVkIHByb21pc2VzIGlzIHJlc29sdmVkIHdpdGggaWYgdGhlIGZpcnN0IGNvbXBsZXRlZCBwcm9taXNlIHdhc1xuICAgICAgICBmdWxmaWxsZWQsIG9yIHJlamVjdGVkIHdpdGggdGhlIHJlYXNvbiB0aGF0IHRoZSBmaXJzdCBjb21wbGV0ZWQgcHJvbWlzZVxuICAgICAgICB3YXMgcmVqZWN0ZWQgd2l0aC5cbiAgICAgICovXG4gICAgICBmdW5jdGlvbiByYWNlKHByb21pc2VzKSB7XG4gICAgICAgIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gICAgICAgIHZhciBQcm9taXNlID0gdGhpcztcblxuICAgICAgICBpZiAoIWlzQXJyYXkocHJvbWlzZXMpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignWW91IG11c3QgcGFzcyBhbiBhcnJheSB0byByYWNlLicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0cyA9IFtdLCBwcm9taXNlO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9taXNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcHJvbWlzZSA9IHByb21pc2VzW2ldO1xuXG4gICAgICAgICAgICBpZiAocHJvbWlzZSAmJiB0eXBlb2YgcHJvbWlzZS50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIHByb21pc2UudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzb2x2ZShwcm9taXNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBfX2V4cG9ydHNfXy5yYWNlID0gcmFjZTtcbiAgICB9KTtcbiAgZGVmaW5lKFwicHJvbWlzZS9yZWplY3RcIixcbiAgICBbXCJleHBvcnRzXCJdLFxuICAgIGZ1bmN0aW9uKF9fZXhwb3J0c19fKSB7XG4gICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgIC8qKlxuICAgICAgICBgUlNWUC5yZWplY3RgIHJldHVybnMgYSBwcm9taXNlIHRoYXQgd2lsbCBiZWNvbWUgcmVqZWN0ZWQgd2l0aCB0aGUgcGFzc2VkXG4gICAgICAgIGByZWFzb25gLiBgUlNWUC5yZWplY3RgIGlzIGVzc2VudGlhbGx5IHNob3J0aGFuZCBmb3IgdGhlIGZvbGxvd2luZzpcblxuICAgICAgICBgYGBqYXZhc2NyaXB0XG4gICAgICAgIHZhciBwcm9taXNlID0gbmV3IFJTVlAuUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ1dIT09QUycpKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAgICAgICAvLyBDb2RlIGhlcmUgZG9lc24ndCBydW4gYmVjYXVzZSB0aGUgcHJvbWlzZSBpcyByZWplY3RlZCFcbiAgICAgICAgfSwgZnVuY3Rpb24ocmVhc29uKXtcbiAgICAgICAgICAvLyByZWFzb24ubWVzc2FnZSA9PT0gJ1dIT09QUydcbiAgICAgICAgfSk7XG4gICAgICAgIGBgYFxuXG4gICAgICAgIEluc3RlYWQgb2Ygd3JpdGluZyB0aGUgYWJvdmUsIHlvdXIgY29kZSBub3cgc2ltcGx5IGJlY29tZXMgdGhlIGZvbGxvd2luZzpcblxuICAgICAgICBgYGBqYXZhc2NyaXB0XG4gICAgICAgIHZhciBwcm9taXNlID0gUlNWUC5yZWplY3QobmV3IEVycm9yKCdXSE9PUFMnKSk7XG5cbiAgICAgICAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAgICAgICAvLyBDb2RlIGhlcmUgZG9lc24ndCBydW4gYmVjYXVzZSB0aGUgcHJvbWlzZSBpcyByZWplY3RlZCFcbiAgICAgICAgfSwgZnVuY3Rpb24ocmVhc29uKXtcbiAgICAgICAgICAvLyByZWFzb24ubWVzc2FnZSA9PT0gJ1dIT09QUydcbiAgICAgICAgfSk7XG4gICAgICAgIGBgYFxuXG4gICAgICAgIEBtZXRob2QgcmVqZWN0XG4gICAgICAgIEBmb3IgUlNWUFxuICAgICAgICBAcGFyYW0ge0FueX0gcmVhc29uIHZhbHVlIHRoYXQgdGhlIHJldHVybmVkIHByb21pc2Ugd2lsbCBiZSByZWplY3RlZCB3aXRoLlxuICAgICAgICBAcGFyYW0ge1N0cmluZ30gbGFiZWwgb3B0aW9uYWwgc3RyaW5nIGZvciBpZGVudGlmeWluZyB0aGUgcmV0dXJuZWQgcHJvbWlzZS5cbiAgICAgICAgVXNlZnVsIGZvciB0b29saW5nLlxuICAgICAgICBAcmV0dXJuIHtQcm9taXNlfSBhIHByb21pc2UgdGhhdCB3aWxsIGJlY29tZSByZWplY3RlZCB3aXRoIHRoZSBnaXZlblxuICAgICAgICBgcmVhc29uYC5cbiAgICAgICovXG4gICAgICBmdW5jdGlvbiByZWplY3QocmVhc29uKSB7XG4gICAgICAgIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gICAgICAgIHZhciBQcm9taXNlID0gdGhpcztcblxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIHJlamVjdChyZWFzb24pO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgX19leHBvcnRzX18ucmVqZWN0ID0gcmVqZWN0O1xuICAgIH0pO1xuICBkZWZpbmUoXCJwcm9taXNlL3Jlc29sdmVcIixcbiAgICBbXCJleHBvcnRzXCJdLFxuICAgIGZ1bmN0aW9uKF9fZXhwb3J0c19fKSB7XG4gICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgIGZ1bmN0aW9uIHJlc29sdmUodmFsdWUpIHtcbiAgICAgICAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgICAgICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUuY29uc3RydWN0b3IgPT09IHRoaXMpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgUHJvbWlzZSA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHtcbiAgICAgICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIF9fZXhwb3J0c19fLnJlc29sdmUgPSByZXNvbHZlO1xuICAgIH0pO1xuICBkZWZpbmUoXCJwcm9taXNlL3V0aWxzXCIsXG4gICAgW1wiZXhwb3J0c1wiXSxcbiAgICBmdW5jdGlvbihfX2V4cG9ydHNfXykge1xuICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICBmdW5jdGlvbiBvYmplY3RPckZ1bmN0aW9uKHgpIHtcbiAgICAgICAgcmV0dXJuIGlzRnVuY3Rpb24oeCkgfHwgKHR5cGVvZiB4ID09PSBcIm9iamVjdFwiICYmIHggIT09IG51bGwpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBpc0Z1bmN0aW9uKHgpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB4ID09PSBcImZ1bmN0aW9uXCI7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGlzQXJyYXkoeCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHgpID09PSBcIltvYmplY3QgQXJyYXldXCI7XG4gICAgICB9XG5cbiAgICAgIC8vIERhdGUubm93IGlzIG5vdCBhdmFpbGFibGUgaW4gYnJvd3NlcnMgPCBJRTlcbiAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0RhdGUvbm93I0NvbXBhdGliaWxpdHlcbiAgICAgIHZhciBub3cgPSBEYXRlLm5vdyB8fCBmdW5jdGlvbigpIHsgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpOyB9O1xuXG5cbiAgICAgIF9fZXhwb3J0c19fLm9iamVjdE9yRnVuY3Rpb24gPSBvYmplY3RPckZ1bmN0aW9uO1xuICAgICAgX19leHBvcnRzX18uaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG4gICAgICBfX2V4cG9ydHNfXy5pc0FycmF5ID0gaXNBcnJheTtcbiAgICAgIF9fZXhwb3J0c19fLm5vdyA9IG5vdztcbiAgICB9KTtcbiAgcmVxdWlyZU1vZHVsZSgncHJvbWlzZS9wb2x5ZmlsbCcpLnBvbHlmaWxsKCk7XG4gIH0oKSk7XG59XG4iLCIvL0RHIGluaGVyaXRhbmNlXG52YXIgb2xkREcgPSB3aW5kb3cuREc7XG5ERyA9IG5ldyAoXG4gICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIERnQXBpID0gZnVuY3Rpb24gKCkge30sXG4gICAgICAgICAgICBEZ0FwaUNvcmUgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAgICAgICBEZ0FwaUNvcmUucHJvdG90eXBlID0gTDtcbiAgICAgICAgRGdBcGkucHJvdG90eXBlID0gbmV3IERnQXBpQ29yZSgpO1xuXG4gICAgICAgIHJldHVybiBEZ0FwaTtcbiAgICB9KSgpXG4pKCk7XG5cbmZvciAodmFyIHByb3AgaW4gb2xkREcpIHtcbiAgICBpZiAob2xkREcuaGFzT3duUHJvcGVydHkocHJvcCkgJiYgdHlwZW9mIERHW3Byb3BdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBER1twcm9wXSA9IG9sZERHW3Byb3BdO1xuICAgIH1cbn1cblxud2luZG93Ll9fZGdBcGlfXyA9IHdpbmRvdy5fX2RnQXBpX18gfHwge307XG5ERy52ZXJzaW9uID0gd2luZG93Ll9fZGdBcGlfXy52ZXJzaW9uO1xuREcuZGVidWcgPSB3aW5kb3cuX19kZ0FwaV9fLmRlYnVnO1xuREcuSWNvbi5EZWZhdWx0LmltYWdlUGF0aCAgPSAnLi4vaW1nL3ZlbmRvcnMvbGVhZmxldCc7XG5cbi8qIGVzbGludC1kaXNhYmxlICovXG4oZnVuY3Rpb24oaSxzLG8sZyxyLGEsbSl7aVsnR29vZ2xlQW5hbHl0aWNzT2JqZWN0J109cjtpW3JdPWlbcl18fGZ1bmN0aW9uKCl7XG4oaVtyXS5xPWlbcl0ucXx8W10pLnB1c2goYXJndW1lbnRzKX0saVtyXS5sPTEqbmV3IERhdGUoKTthPXMuY3JlYXRlRWxlbWVudChvKSxcbm09cy5nZXRFbGVtZW50c0J5VGFnTmFtZShvKVswXTthLmFzeW5jPTE7YS5zcmM9ZzttLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGEsbSlcbn0pKHdpbmRvdyxkb2N1bWVudCwnc2NyaXB0JywnaHR0cDovL3d3dy5nb29nbGUtYW5hbHl0aWNzLmNvbS9hbmFseXRpY3MuanMnLCdnYScpO1xuLyogZXNsaW50LWVuYWJsZSAqL1xuXG4vKmdsb2JhbCBnYTpmYWxzZSovXG5nYSgnY3JlYXRlJywgJ1VBLTM4MjQzMTgxLTInLCAnbm9uZScpO1xuZ2EoJ3NlbmQnLCAncGFnZXZpZXcnKTtcblxuLy90cmFjayBzdGF0aXN0aWNzXG52YXIgbmV3SW1nID0gbmV3IEltYWdlKCk7XG5uZXdJbWcuc3JjID0gJ2h0dHA6Ly9tYXBzLmFwaS4yZ2lzLnJ1L2FuYWx5dGljcy90cmFjay11c2VyLnBuZz8nICtcbiAgICAgICAgICAgICdzcj0nICsgd2luZG93LnNjcmVlbi53aWR0aCArICd4JyArIHdpbmRvdy5zY3JlZW4uaGVpZ2h0ICsgJyYnICtcbiAgICAgICAgICAgICd2PScgKyBERy52ZXJzaW9uO1xuXG4vLyBJbXByb3ZlIElIYW5kbGVyXG5ERy5NYXAuaW5jbHVkZSh7XG4gICAgYWRkSGFuZGxlcjogZnVuY3Rpb24gKG5hbWUsIEhhbmRsZXJDbGFzcykge1xuICAgICAgICBpZiAoIUhhbmRsZXJDbGFzcykgeyByZXR1cm4gdGhpczsgfVxuXG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zW25hbWVdLFxuICAgICAgICAgICAgcGFyYW0gPSAob3B0aW9ucyA9PT0gT2JqZWN0KG9wdGlvbnMpKSA/IG9wdGlvbnMgOiBudWxsLFxuICAgICAgICAgICAgaGFuZGxlciA9IHRoaXNbbmFtZV0gPSBuZXcgSGFuZGxlckNsYXNzKHRoaXMsIHBhcmFtKTtcblxuICAgICAgICB0aGlzLl9oYW5kbGVycy5wdXNoKGhhbmRsZXIpO1xuXG4gICAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgICAgICBoYW5kbGVyLmVuYWJsZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufSk7XG5cbi8vIEFwcGx5IGNsYXNzIHRvIG1hcCBjb250YWluZXIgZm9yIGRldGVjdCB3aGVuIHdlIGRvbnQgbmVlZCBob3ZlciBlZmZlY3RzXG5ERy5NYXAuYWRkSW5pdEhvb2soZnVuY3Rpb24gKCkge1xuICAgIGlmICghREcuQnJvd3Nlci50b3VjaCkge1xuICAgICAgICBERy5Eb21VdGlsLmFkZENsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ25vLXRvdWNoJyk7XG4gICAgfVxufSk7XG4iLCJ2YXIgaGFuZGxlcnMgPSB3aW5kb3cuX19kZ0FwaV9fLmNhbGxiYWNrcyB8fCBbXSxcbiAgICBjaGFpbiA9IFByb21pc2UucmVzb2x2ZSgpO1xuXG4vLyBkb250IHBvbGx1dGUgZ2xvYmFsIHNwYWNlIVxudHJ5IHtcbiAgICBkZWxldGUgd2luZG93Ll9fZGdBcGlfXztcbn0gY2F0Y2goZSkge1xuICAgIHdpbmRvdy5fX2RnQXBpX18gPSB1bmRlZmluZWQ7IC8vIGllOCBjYW50IGRlbGV0ZSBmcm9tIHdpbmRvdyBvYmplY3Rcbn1cblxuaGFuZGxlcnMuZm9yRWFjaChmdW5jdGlvbiAoaGFuZGxlcnMpIHtcbiAgICBjaGFpbiA9IGNoYWluLnRoZW4oaGFuZGxlcnNbMF0sIGhhbmRsZXJzWzFdKTtcbn0pO1xuXG5ERy50aGVuID0gZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHJldHVybiBjaGFpbi50aGVuKHJlc29sdmUsIHJlamVjdCk7XG59O1xuXG4vLyBJRTggdGhyb3cgZXJyb3IgaWYgYGNoYWluLmNhdGNoYFxuLyogZXNsaW50LWRpc2FibGUgZG90LW5vdGF0aW9uLCBuby1jb25zb2xlICovXG5jaGFpblsnY2F0Y2gnXShmdW5jdGlvbihlcnIpIHtcbiAgICBjb25zb2xlLmVycm9yKGVycik7XG59KTtcbi8qIGVzbGludC1lbmFibGUgZG90LW5vdGF0aW9uLCBuby1jb25zb2xlICovXG4iLCJERy5wbHVnaW4gPSBmdW5jdGlvbiAocGx1Z2lucykge1xuICAgIHZhciBjb3VudCxcbiAgICAgICAganNSZWcgPSBuZXcgUmVnRXhwKC8uanMkL2kpLFxuICAgICAgICBjc3NSZWcgPSBuZXcgUmVnRXhwKC8uY3NzJC9pKSxcblxuICAgIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICBmdW5jdGlvbiBjaGVja0xvYWRpbmcoKSB7XG4gICAgICAgICAgICBjb3VudC0tO1xuXG4gICAgICAgICAgICBpZiAoY291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBhcHBlbmRKUyhsaW5rKSB7XG4gICAgICAgICAgICB2YXIganMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgICAgICAgICAgIGpzLnNldEF0dHJpYnV0ZSgndHlwZScsICd0ZXh0L2phdmFzY3JpcHQnKTtcbiAgICAgICAgICAgIGpzLnNldEF0dHJpYnV0ZSgnc3JjJywgbGluayk7XG4gICAgICAgICAgICBqcy5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY2hlY2tMb2FkaW5nKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAganMub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBjaGVja0xvYWRpbmcoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBsb2FkL2Vycm9yIGZvciBJRVxuICAgICAgICAgICAganMub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChqcy5yZWFkeVN0YXRlID09PSAnY29tcGxldGUnIHx8IGpzLnJlYWR5U3RhdGUgPT09ICdsb2FkZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoZWNrTG9hZGluZygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF0uYXBwZW5kQ2hpbGQoanMpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gYXBwZW5kQ1NTKGxpbmspIHtcbiAgICAgICAgICAgIHZhciBjc3MgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaW5rJyk7XG4gICAgICAgICAgICBjc3Muc2V0QXR0cmlidXRlKCdyZWwnLCAnc3R5bGVzaGVldCcpO1xuICAgICAgICAgICAgY3NzLnNldEF0dHJpYnV0ZSgndHlwZScsICd0ZXh0L2NzcycpO1xuICAgICAgICAgICAgY3NzLnNldEF0dHJpYnV0ZSgnaHJlZicsIGxpbmspO1xuICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXS5hcHBlbmRDaGlsZChjc3MpO1xuXG4gICAgICAgICAgICBjaGVja0xvYWRpbmcoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGlzSnModXJsKSB7XG4gICAgICAgICAgICByZXR1cm4ganNSZWcudGVzdCh1cmwpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gaXNDc3ModXJsKSB7XG4gICAgICAgICAgICByZXR1cm4gY3NzUmVnLnRlc3QodXJsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGFwcGVuZEFzc2V0KGFzc2V0KSB7XG4gICAgICAgICAgICBpZiAoaXNKcyhhc3NldCkpIHtcbiAgICAgICAgICAgICAgICBhcHBlbmRKUyhhc3NldCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzQ3NzKGFzc2V0KSkge1xuICAgICAgICAgICAgICAgIGFwcGVuZENTUyhhc3NldCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvdW50LS07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoREcuVXRpbC5pc0FycmF5KHBsdWdpbnMpKSB7XG4gICAgICAgICAgICBjb3VudCA9IHBsdWdpbnMubGVuZ3RoO1xuICAgICAgICAgICAgcGx1Z2lucy5mb3JFYWNoKGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICAgICAgICAgICAgICBhcHBlbmRBc3NldChwbHVnaW4pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHBsdWdpbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb3VudCA9IDE7XG4gICAgICAgICAgICBhcHBlbmRBc3NldChwbHVnaW5zKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHByb21pc2U7XG59O1xuIiwiREcuYWpheCA9IChmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgd2luID0gd2luZG93LFxuICAgICAgICBkb2MgPSBkb2N1bWVudCxcblxuICAgICAgICBydXJsID0gL14oW1xcdy4rLV0rOik/KD86XFwvXFwvKFteXFwvPyM6XSopKD86OihcXGQrKXwpfCkvLFxuICAgICAgICB0d29IdW5kbyA9IC9eMjBcXGQkLyxcblxuICAgICAgICAvLyBEb2N1bWVudCBsb2NhdGlvblxuICAgICAgICBhamF4TG9jUGFydHMsXG4gICAgICAgIGFqYXhMb2NhdGlvbixcblxuICAgICAgICBieVRhZyA9ICdnZXRFbGVtZW50c0J5VGFnTmFtZScsXG4gICAgICAgIHJlYWR5U3RhdGUgPSAncmVhZHlTdGF0ZScsXG4gICAgICAgIGNvbnRlbnRUeXBlID0gJ0NvbnRlbnQtVHlwZScsXG4gICAgICAgIHJlcXVlc3RlZFdpdGggPSAnWC1SZXF1ZXN0ZWQtV2l0aCcsXG4gICAgICAgIGhlYWQgPSBkb2NbYnlUYWddKCdoZWFkJylbMF0sXG4gICAgICAgIHVuaXFpZCA9IDAsXG4gICAgICAgIGNhbGxiYWNrUHJlZml4ID0gJ2xfZGdfYWpheF9jYWxsYmFja18nICsgKCtuZXcgRGF0ZSgpKSxcbiAgICAgICAgbGFzdFZhbHVlLCAvLyBkYXRhIHN0b3JlZCBieSB0aGUgbW9zdCByZWNlbnQgSlNPTlAgY2FsbGJhY2tcbiAgICAgICAgeG1sSHR0cFJlcXVlc3QgPSAnWE1MSHR0cFJlcXVlc3QnLFxuICAgICAgICB4RG9tYWluUmVxdWVzdCA9ICdYRG9tYWluUmVxdWVzdCcsXG4gICAgICAgIG5vb3AgPSBmdW5jdGlvbiAoKSB7fSxcbiAgICAgICAgZGVmYXVsdEhlYWRlcnMgPSB7XG4gICAgICAgICAgICBjb250ZW50VHlwZTogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcsXG4gICAgICAgICAgICByZXF1ZXN0ZWRXaXRoOiB4bWxIdHRwUmVxdWVzdCxcbiAgICAgICAgICAgIGFjY2VwdDoge1xuICAgICAgICAgICAgICAgICcqJzogICd0ZXh0L2phdmFzY3JpcHQsIHRleHQvaHRtbCwgYXBwbGljYXRpb24veG1sLCB0ZXh0L3htbCwgKi8qJyxcbiAgICAgICAgICAgICAgICB4bWw6ICAnYXBwbGljYXRpb24veG1sLCB0ZXh0L3htbCcsXG4gICAgICAgICAgICAgICAgaHRtbDogJ3RleHQvaHRtbCcsXG4gICAgICAgICAgICAgICAgdGV4dDogJ3RleHQvcGxhaW4nLFxuICAgICAgICAgICAgICAgIGpzb246ICdhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L2phdmFzY3JpcHQnLFxuICAgICAgICAgICAgICAgIGpzOiAgICdhcHBsaWNhdGlvbi9qYXZhc2NyaXB0LCB0ZXh0L2phdmFzY3JpcHQnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8qZ2xvYmFsIFhEb21haW5SZXF1ZXN0OmZhbHNlLCBBY3RpdmVYT2JqZWN0OmZhbHNlICovXG4gICAgICAgIHhociA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgICAvLyBpcyBpdCB4LWRvbWFpblxuICAgICAgICAgICAgaWYgKG8uY3Jvc3NEb21haW4gPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgeGhyID0gd2luW3htbEh0dHBSZXF1ZXN0XSA/IG5ldyBYTUxIdHRwUmVxdWVzdCgpIDogbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoeGhyICYmICd3aXRoQ3JlZGVudGlhbHMnIGluIHhocikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geGhyO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAod2luW3hEb21haW5SZXF1ZXN0XSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFhEb21haW5SZXF1ZXN0KCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCcm93c2VyIGRvZXMgbm90IHN1cHBvcnQgY3Jvc3Mtb3JpZ2luIHJlcXVlc3RzJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh3aW5beG1sSHR0cFJlcXVlc3RdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFjdGl2ZVhPYmplY3QoJ01pY3Jvc29mdC5YTUxIVFRQJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2xvYmFsU2V0dXBPcHRpb25zID0ge1xuICAgICAgICAgICAgZGF0YUZpbHRlcjogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgIC8vIElFIG1heSB0aHJvdyBhbiBleGNlcHRpb24gd2hlbiBhY2Nlc3NpbmdcbiAgICAvLyBhIGZpZWxkIGZyb20gd2luZG93LmxvY2F0aW9uIGlmIGRvY3VtZW50LmRvbWFpbiBoYXMgYmVlbiBzZXRcbiAgICB0cnkge1xuICAgICAgICBhamF4TG9jYXRpb24gPSBsb2NhdGlvbi5ocmVmO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gVXNlIHRoZSBocmVmIGF0dHJpYnV0ZSBvZiBhbiBBIGVsZW1lbnRcbiAgICAgICAgLy8gc2luY2UgSUUgd2lsbCBtb2RpZnkgaXQgZ2l2ZW4gZG9jdW1lbnQubG9jYXRpb25cbiAgICAgICAgYWpheExvY2F0aW9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgICAgICBhamF4TG9jYXRpb24uaHJlZiA9ICcnO1xuICAgICAgICBhamF4TG9jYXRpb24gPSBhamF4TG9jYXRpb24uaHJlZjtcbiAgICB9XG5cbiAgICAvLyBTZWdtZW50IGxvY2F0aW9uIGludG8gcGFydHNcbiAgICBhamF4TG9jUGFydHMgPSBydXJsLmV4ZWMoYWpheExvY2F0aW9uLnRvTG93ZXJDYXNlKCkpIHx8IFtdO1xuXG4gICAgZnVuY3Rpb24gaGFuZGxlUmVhZHlTdGF0ZShyLCBzdWNjZXNzLCBlcnJvcikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gdXNlIF9hYm9ydGVkIHRvIG1pdGlnYXRlIGFnYWluc3QgSUUgZXJyIGMwMGMwMjNmXG4gICAgICAgICAgICAvLyAoY2FuJ3QgcmVhZCBwcm9wcyBvbiBhYm9ydGVkIHJlcXVlc3Qgb2JqZWN0cylcbiAgICAgICAgICAgIGlmIChyLl9hYm9ydGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yKHIucmVxdWVzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoci5yZXF1ZXN0ICYmIHIucmVxdWVzdFtyZWFkeVN0YXRlXSA9PT0gNCkge1xuICAgICAgICAgICAgICAgIHIucmVxdWVzdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBub29wO1xuICAgICAgICAgICAgICAgIGlmICh0d29IdW5kby50ZXN0KHIucmVxdWVzdC5zdGF0dXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3Moci5yZXF1ZXN0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcihyLnJlcXVlc3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRIZWFkZXJzKGh0dHAsIG8pIHtcbiAgICAgICAgdmFyIGhlYWRlcnMgPSBvLmhlYWRlcnMgfHwge30sXG4gICAgICAgICAgICBoO1xuXG4gICAgICAgIGhlYWRlcnMuQWNjZXB0ID0gaGVhZGVycy5BY2NlcHQgfHwgZGVmYXVsdEhlYWRlcnMuYWNjZXB0W28uZGF0YVR5cGVdIHx8IGRlZmF1bHRIZWFkZXJzLmFjY2VwdFsnKiddO1xuXG4gICAgICAgIC8vIGJyZWFrcyBjcm9zcy1vcmlnaW4gcmVxdWVzdHMgd2l0aCBsZWdhY3kgYnJvd3NlcnNcbiAgICAgICAgaWYgKCFvLmNyb3NzRG9tYWluICYmICFoZWFkZXJzW3JlcXVlc3RlZFdpdGhdKSB7XG4gICAgICAgICAgICBoZWFkZXJzW3JlcXVlc3RlZFdpdGhdID0gZGVmYXVsdEhlYWRlcnMucmVxdWVzdGVkV2l0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWhlYWRlcnNbY29udGVudFR5cGVdKSB7XG4gICAgICAgICAgICBoZWFkZXJzW2NvbnRlbnRUeXBlXSA9IG8uY29udGVudFR5cGUgfHwgZGVmYXVsdEhlYWRlcnMuY29udGVudFR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChoIGluIGhlYWRlcnMpIHtcbiAgICAgICAgICAgIGlmIChoZWFkZXJzLmhhc093blByb3BlcnR5KGgpICYmICdzZXRSZXF1ZXN0SGVhZGVyJyBpbiBodHRwKSB7XG4gICAgICAgICAgICAgICAgaHR0cC5zZXRSZXF1ZXN0SGVhZGVyKGgsIGhlYWRlcnNbaF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0Q3JlZGVudGlhbHMoaHR0cCwgbykge1xuICAgICAgICBpZiAodHlwZW9mIG8ud2l0aENyZWRlbnRpYWxzICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgaHR0cC53aXRoQ3JlZGVudGlhbHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBodHRwLndpdGhDcmVkZW50aWFscyA9ICEhby53aXRoQ3JlZGVudGlhbHM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZW5lcmFsQ2FsbGJhY2soZGF0YSkge1xuICAgICAgICBsYXN0VmFsdWUgPSBkYXRhO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVybGFwcGVuZCh1cmwsIHMpIHtcbiAgICAgICAgcmV0dXJuIHVybCArICgvXFw/Ly50ZXN0KHVybCkgPyAnJicgOiAnPycpICsgcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVKc29ucChvLCBmbiwgZXJyLCB1cmwpIHtcbiAgICAgICAgdmFyIHJlcUlkID0gdW5pcWlkKyssXG4gICAgICAgICAgICBjYmtleSA9IG8uanNvbnBDYWxsYmFjayB8fCAnY2FsbGJhY2snLCAvLyB0aGUgJ2NhbGxiYWNrJyBrZXlcbiAgICAgICAgICAgIGNidmFsID0gby5qc29ucENhbGxiYWNrTmFtZSB8fCBjYWxsYmFja1ByZWZpeCxcbiAgICAgICAgICAgIGNicmVnID0gbmV3IFJlZ0V4cCgnKChefFxcXFw/fCYpJyArIGNia2V5ICsgJyk9KFteJl0rKScpLFxuICAgICAgICAgICAgbWF0Y2ggPSB1cmwubWF0Y2goY2JyZWcpLFxuICAgICAgICAgICAgc2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpLFxuICAgICAgICAgICAgbG9hZGVkID0gMCxcbiAgICAgICAgICAgIGlzSUUxMCA9IG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignTVNJRSAxMC4wJykgIT09IC0xO1xuXG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgaWYgKG1hdGNoWzNdID09PSAnPycpIHtcbiAgICAgICAgICAgICAgICB1cmwgPSB1cmwucmVwbGFjZShjYnJlZywgJyQxPScgKyBjYnZhbCk7IC8vIHdpbGRjYXJkIGNhbGxiYWNrIGZ1bmMgbmFtZVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYnZhbCA9IG1hdGNoWzNdOyAvLyBwcm92aWRlZCBjYWxsYmFjayBmdW5jIG5hbWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHVybCA9IHVybGFwcGVuZCh1cmwsIGNia2V5ICsgJz0nICsgY2J2YWwpOyAvLyBubyBjYWxsYmFjayBkZXRhaWxzLCBhZGQgJ2VtXG4gICAgICAgIH1cblxuICAgICAgICB3aW5bY2J2YWxdID0gZ2VuZXJhbENhbGxiYWNrO1xuXG4gICAgICAgIHNjcmlwdC50eXBlID0gJ3RleHQvamF2YXNjcmlwdCc7XG4gICAgICAgIHNjcmlwdC5zcmMgPSB1cmw7XG4gICAgICAgIHNjcmlwdC5hc3luYyA9IHRydWU7XG4gICAgICAgIGlmICh0eXBlb2Ygc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSAhPT0gJ3VuZGVmaW5lZCcgJiYgIWlzSUUxMCkge1xuICAgICAgICAgICAgLy8gbmVlZCB0aGlzIGZvciBJRSBkdWUgdG8gb3V0LW9mLW9yZGVyIG9ucmVhZHlzdGF0ZWNoYW5nZSgpLCBiaW5kaW5nIHNjcmlwdFxuICAgICAgICAgICAgLy8gZXhlY3V0aW9uIHRvIGFuIGV2ZW50IGxpc3RlbmVyIGdpdmVzIHVzIGNvbnRyb2wgb3ZlciB3aGVuIHRoZSBzY3JpcHRcbiAgICAgICAgICAgIC8vIGlzIGV4ZWN1dGVkLiBTZWUgaHR0cDovL2phdWJvdXJnLm5ldC8yMDEwLzA3L2xvYWRpbmctc2NyaXB0LWFzLW9uY2xpY2staGFuZGxlci1vZi5odG1sXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gaWYgdGhpcyBoYWNrIGlzIHVzZWQgaW4gSUUxMCBqc29ucCBjYWxsYmFjayBhcmUgbmV2ZXIgY2FsbGVkXG4gICAgICAgICAgICBzY3JpcHQuZXZlbnQgPSAnb25jbGljayc7XG4gICAgICAgICAgICBzY3JpcHQuaHRtbEZvciA9IHNjcmlwdC5pZCA9ICdfcmVxdWVzdF8nICsgcmVxSWQ7XG4gICAgICAgIH1cblxuICAgICAgICBzY3JpcHQub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHNjcmlwdC5vbmVycm9yID0gc2NyaXB0Lm9ubG9hZCA9IHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgZXJyKHt9LCAnUmVxdWVzdCB1bmtub3duIGVycm9yJywge30pO1xuICAgICAgICAgICAgbGFzdFZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaGVhZC5yZW1vdmVDaGlsZChzY3JpcHQpO1xuICAgICAgICAgICAgbG9hZGVkID0gMTtcbiAgICAgICAgfTtcbiAgICAgICAgc2NyaXB0Lm9ubG9hZCA9IHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoKHNjcmlwdFtyZWFkeVN0YXRlXSAmJiBzY3JpcHRbcmVhZHlTdGF0ZV0gIT09ICdjb21wbGV0ZScgJiYgc2NyaXB0W3JlYWR5U3RhdGVdICE9PSAnbG9hZGVkJykgfHwgbG9hZGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2NyaXB0Lm9uZXJyb3IgPSBzY3JpcHQub25sb2FkID0gc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICAgICAgICBpZiAoc2NyaXB0Lm9uY2xpY2spIHtcbiAgICAgICAgICAgICAgICBzY3JpcHQub25jbGljaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2FsbCB0aGUgdXNlciBjYWxsYmFjayB3aXRoIHRoZSBsYXN0IHZhbHVlIHN0b3JlZCBhbmQgY2xlYW4gdXAgdmFsdWVzIGFuZCBzY3JpcHRzLlxuICAgICAgICAgICAgZm4obGFzdFZhbHVlKTtcbiAgICAgICAgICAgIGxhc3RWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGhlYWQucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgICAgIGxvYWRlZCA9IDE7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gQWRkIHRoZSBzY3JpcHQgdG8gdGhlIERPTSBoZWFkXG4gICAgICAgIGhlYWQuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcblxuICAgICAgICAvLyBFbmFibGUgSlNPTlAgdGltZW91dFxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWJvcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzY3JpcHQub25lcnJvciA9IHNjcmlwdC5vbmxvYWQgPSBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBlcnIoe30sICdSZXF1ZXN0IGlzIGFib3J0ZWQ6IHRpbWVvdXQnLCB7fSk7XG4gICAgICAgICAgICAgICAgbGFzdFZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGhlYWQucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgICAgICAgICBsb2FkZWQgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFJlcXVlc3QoZm4sIGVycikge1xuICAgICAgICB2YXIgbyA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgICAgIG1ldGhvZCA9IChvLnR5cGUgfHwgJ0dFVCcpLnRvVXBwZXJDYXNlKCksXG4gICAgICAgICAgICB1cmwgPSB0eXBlb2YgbyA9PT0gJ3N0cmluZycgPyBvIDogby51cmwsXG4gICAgICAgICAgICAvLyBjb252ZXJ0IG5vbi1zdHJpbmcgb2JqZWN0cyB0byBxdWVyeS1zdHJpbmcgZm9ybSB1bmxlc3Mgby5wcm9jZXNzRGF0YSBpcyBmYWxzZVxuICAgICAgICAgICAgZGF0YSA9IChvLnByb2Nlc3NEYXRhICE9PSBmYWxzZSAmJiBvLmRhdGEgJiYgdHlwZW9mIG8uZGF0YSAhPT0gJ3N0cmluZycpID8gQWpheC50b1F1ZXJ5U3RyaW5nKG8uZGF0YSkgOiAoby5kYXRhIHx8IG51bGwpLFxuICAgICAgICAgICAgaHR0cCxcbiAgICAgICAgICAgIHNlbmRXYWl0ID0gZmFsc2U7XG5cbiAgICAgICAgLy8gaWYgd2UncmUgd29ya2luZyBvbiBhIEdFVCByZXF1ZXN0IGFuZCB3ZSBoYXZlIGRhdGEgdGhlbiB3ZSBzaG91bGQgYXBwZW5kXG4gICAgICAgIC8vIHF1ZXJ5IHN0cmluZyB0byBlbmQgb2YgVVJMIGFuZCBub3QgcG9zdCBkYXRhXG4gICAgICAgIGlmICgoby50eXBlID09PSAnanNvbnAnIHx8IG1ldGhvZCA9PT0gJ0dFVCcpICYmIGRhdGEpIHtcbiAgICAgICAgICAgIHVybCA9IHVybGFwcGVuZCh1cmwsIGRhdGEpO1xuICAgICAgICAgICAgZGF0YSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoby50eXBlID09PSAnanNvbnAnKSB7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlSnNvbnAobywgZm4sIGVyciwgdXJsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGh0dHAgPSB4aHIobyk7XG4gICAgICAgIGh0dHAub3BlbihtZXRob2QsIHVybCwgby5hc3luYyA9PT0gZmFsc2UgPyBmYWxzZSA6IHRydWUpO1xuXG4gICAgICAgIHNldEhlYWRlcnMoaHR0cCwgbyk7XG4gICAgICAgIHNldENyZWRlbnRpYWxzKGh0dHAsIG8pO1xuXG4gICAgICAgIGlmICh3aW5beERvbWFpblJlcXVlc3RdICYmIGh0dHAgaW5zdGFuY2VvZiB3aW5beERvbWFpblJlcXVlc3RdKSB7XG4gICAgICAgICAgICBodHRwLm9ubG9hZCA9IGZuO1xuICAgICAgICAgICAgaHR0cC5vbmVycm9yID0gZXJyO1xuICAgICAgICAgICAgc2VuZFdhaXQgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaHR0cC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBoYW5kbGVSZWFkeVN0YXRlKHRoaXMsIGZuLCBlcnIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZW5kV2FpdCkge1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaHR0cC5zZW5kKGRhdGEpO1xuICAgICAgICAgICAgfSwgMjAwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGh0dHAuc2VuZChkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaHR0cDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBidWlsZFBhcmFtcyhwcmVmaXgsIG9iaiwgdHJhZGl0aW9uYWwsIGFkZCkge1xuICAgICAgICB2YXIgbmFtZSwgaSwgdixcbiAgICAgICAgICAgIHJicmFja2V0ID0gL1xcW1xcXSQvO1xuXG4gICAgICAgIGlmIChERy5VdGlsLmlzQXJyYXkob2JqKSkge1xuICAgICAgICAvLyBTZXJpYWxpemUgYXJyYXkgaXRlbS5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IG9iaiAmJiBpIDwgb2JqLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdiA9IG9ialtpXTtcbiAgICAgICAgICAgICAgICBpZiAodHJhZGl0aW9uYWwgfHwgcmJyYWNrZXQudGVzdChwcmVmaXgpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRyZWF0IGVhY2ggYXJyYXkgaXRlbSBhcyBhIHNjYWxhci5cbiAgICAgICAgICAgICAgICAgICAgYWRkKHByZWZpeCwgdik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYnVpbGRQYXJhbXMocHJlZml4ICsgJ1snICsgKHR5cGVvZiB2ID09PSAnb2JqZWN0JyA/IGkgOiAnJykgKyAnXScsIHYsIHRyYWRpdGlvbmFsLCBhZGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChvYmogJiYgb2JqLnRvU3RyaW5nKCkgPT09ICdbb2JqZWN0IE9iamVjdF0nKSB7XG4gICAgICAgICAgICAvLyBTZXJpYWxpemUgb2JqZWN0IGl0ZW0uXG4gICAgICAgICAgICBmb3IgKG5hbWUgaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBidWlsZFBhcmFtcyhwcmVmaXggKyAnWycgKyBuYW1lICsgJ10nLCBvYmpbbmFtZV0sIHRyYWRpdGlvbmFsLCBhZGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFNlcmlhbGl6ZSBzY2FsYXIgaXRlbS5cbiAgICAgICAgICAgIGFkZChwcmVmaXgsIG9iaik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRUeXBlKHVybCkge1xuICAgICAgICB2YXIgbSA9IHVybC5tYXRjaCgvXFwuKGpzb258anNvbnB8aHRtbHx4bWwpKFxcP3wkKS8pO1xuICAgICAgICByZXR1cm4gbSA/IG1bMV0gOiAnanMnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzQ3Jvc3NEb21haW4odXJsKSB7XG4gICAgICAgIHZhciBwYXJ0cyA9IHJ1cmwuZXhlYyh1cmwudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgIHJldHVybiAhIShwYXJ0cyAmJlxuICAgICAgICAgICAgICAgIChwYXJ0c1sxXSAhPT0gYWpheExvY1BhcnRzWzFdIHx8IHBhcnRzWzJdICE9PSBhamF4TG9jUGFydHNbMl0gfHxcbiAgICAgICAgICAgICAgICAgICAgKHBhcnRzWzNdIHx8IChwYXJ0c1sxXSA9PT0gJ2h0dHA6JyA/ICc4MCcgOiAnNDQzJykpICE9PVxuICAgICAgICAgICAgICAgICAgICAgICAgKGFqYXhMb2NQYXJ0c1szXSB8fCAoYWpheExvY1BhcnRzWzFdID09PSAnaHR0cDonID8gJzgwJyA6ICc0NDMnKSkpXG4gICAgICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRvUmVxdWVzdChvKSB7XG5cbiAgICAgICAgaWYgKCEoJ2Nyb3NzRG9tYWluJyBpbiBvKSkge1xuICAgICAgICAgICAgby5jcm9zc0RvbWFpbiA9IGlzQ3Jvc3NEb21haW4oby51cmwpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNlbGYgPSB7fTtcbiAgICAgICAgc2VsZi5wcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgc2VsZi5hYm9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzZWxmLl9hYm9ydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZWplY3QoJ2Fib3J0ZWQnKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHNlbGYudXJsID0gby51cmw7XG4gICAgICAgICAgICBzZWxmLnRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgICAgc2VsZi5vcHRpb25zID0gbztcblxuICAgICAgICAgICAgc2VsZi5fYWJvcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgc2VsZi5fZXJyZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHNlbGYuX3Jlc3BvbnNlQXJncyA9IHt9O1xuXG4gICAgICAgICAgICB2YXIgdHlwZSA9IG8udHlwZSA9PT0gJ2pzb25wJyA/IG8udHlwZSA6IChvLmRhdGFUeXBlIHx8IHNldFR5cGUoc2VsZi51cmwpKTtcblxuICAgICAgICAgICAgaWYgKG8udGltZW91dCkge1xuICAgICAgICAgICAgICAgIHNlbGYudGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmFib3J0KCk7XG4gICAgICAgICAgICAgICAgfSwgby50aW1lb3V0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gY29tcGxldGUocmVzcCkge1xuICAgICAgICAgICAgICAgIGlmIChvLnRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHNlbGYudGltZW91dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNlbGYudGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuX2VycmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChyZXNwKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gc3VjY2VzcyhyZXNwKSB7XG4gICAgICAgICAgICAgICAgcmVzcCA9ICh0eXBlICE9PSAnanNvbnAnKSA/IHNlbGYucmVxdWVzdCA6IHJlc3A7XG4gICAgICAgICAgICAgICAgLy8gdXNlIGdsb2JhbCBkYXRhIGZpbHRlciBvbiByZXNwb25zZSB0ZXh0XG4gICAgICAgICAgICAgICAgdmFyIGZpbHRlcmVkUmVzcG9uc2UgPSBnbG9iYWxTZXR1cE9wdGlvbnMuZGF0YUZpbHRlcihyZXNwLnJlc3BvbnNlVGV4dCwgdHlwZSksXG4gICAgICAgICAgICAgICAgICAgIHIgPSBmaWx0ZXJlZFJlc3BvbnNlO1xuXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzcC5yZXNwb25zZVRleHQgPSByO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY2FuJ3QgYXNzaWduIHRoaXMgaW4gSUU8PTgsIGp1c3QgaWdub3JlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWV2YWwgKi9cbiAgICAgICAgICAgICAgICBpZiAocikge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnanNvbic6XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3AgPSB3aW4uSlNPTiA/IHdpbi5KU09OLnBhcnNlKHIpIDogZXZhbCgnKCcgKyByICsgJyknKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcihyZXNwLCAnQ291bGQgbm90IHBhcnNlIEpTT04gaW4gcmVzcG9uc2UnLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2pzJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3AgPSBldmFsKCcoJyArIHIgKyAnKScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2h0bWwnOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcCA9IHI7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAneG1sJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3AgPSByZXNwLnJlc3BvbnNlWE1MICYmIHJlc3AucmVzcG9uc2VYTUwucGFyc2VFcnJvciAmJiByZXNwLnJlc3BvbnNlWE1MLnBhcnNlRXJyb3IuZXJyb3JDb2RlICYmIHJlc3AucmVzcG9uc2VYTUwucGFyc2VFcnJvci5yZWFzb24gPyBudWxsIDogcmVzcC5yZXNwb25zZVhNTDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tZXZhbCAqL1xuICAgICAgICAgICAgICAgIHNlbGYuX3Jlc3BvbnNlQXJncy5yZXNwID0gcmVzcDtcbiAgICAgICAgICAgICAgICBjb21wbGV0ZShyZXNwKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gZXJyb3IocmVzcCwgbXNnLCB0KSB7XG4gICAgICAgICAgICAgICAgcmVzcCA9IHNlbGYucmVxdWVzdDtcbiAgICAgICAgICAgICAgICBzZWxmLl9yZXNwb25zZUFyZ3MucmVzcCA9IHJlc3A7XG4gICAgICAgICAgICAgICAgc2VsZi5fcmVzcG9uc2VBcmdzLm1zZyA9IG1zZztcbiAgICAgICAgICAgICAgICBzZWxmLl9yZXNwb25zZUFyZ3MudCA9IHQ7XG4gICAgICAgICAgICAgICAgc2VsZi5fZXJyZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbXBsZXRlKHJlc3ApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZWxmLnJlcXVlc3QgPSBnZXRSZXF1ZXN0LmNhbGwoc2VsZiwgc3VjY2VzcywgZXJyb3IpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBBamF4KHVybCwgb3B0aW9ucykge1xuXG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodXJsKSA9PT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSB1cmw7XG4gICAgICAgICAgICB1cmwgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIG9wdGlvbnMudXJsID0gdXJsIHx8IG9wdGlvbnMudXJsO1xuXG4gICAgICAgIHZhciByZXF1ZXN0UHJvbWlzZSA9IGRvUmVxdWVzdChvcHRpb25zKSxcbiAgICAgICAgICAgIHJlc3VsdFByb21pc2UgPSByZXF1ZXN0UHJvbWlzZS5wcm9taXNlO1xuXG4gICAgICAgIGlmIChvcHRpb25zLnN1Y2Nlc3MgfHwgb3B0aW9ucy5lcnJvciB8fCBvcHRpb25zLmNvbXBsZXRlKSB7XG4gICAgICAgICAgICByZXN1bHRQcm9taXNlLnRoZW4ob3B0aW9ucy5zdWNjZXNzLCBvcHRpb25zLmVycm9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdFByb21pc2UuYWJvcnQgPSByZXF1ZXN0UHJvbWlzZS5hYm9ydDtcblxuICAgICAgICByZXR1cm4gcmVzdWx0UHJvbWlzZTtcbiAgICB9XG5cbiAgICBBamF4LnNldHVwID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIGZvciAodmFyIGsgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkoaykpIHtcbiAgICAgICAgICAgICAgICBnbG9iYWxTZXR1cE9wdGlvbnNba10gPSBvcHRpb25zW2tdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIEFqYXgudG9RdWVyeVN0cmluZyA9IGZ1bmN0aW9uIChvLCB0cmFkKSB7XG4gICAgICAgIHZhciBwcmVmaXgsIGksXG4gICAgICAgICAgICB0cmFkaXRpb25hbCA9IHRyYWQgfHwgZmFsc2UsXG4gICAgICAgICAgICBzID0gW10sXG4gICAgICAgICAgICBlbmMgPSBlbmNvZGVVUklDb21wb25lbnQsXG4gICAgICAgICAgICBhZGQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIC8vIElmIHZhbHVlIGlzIGEgZnVuY3Rpb24sIGludm9rZSBpdCBhbmQgcmV0dXJuIGl0cyB2YWx1ZVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSB8fCAnJztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzW3MubGVuZ3RoXSA9IGVuYyhrZXkpICsgJz0nICsgZW5jKHZhbHVlKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgLy8gSWYgYW4gYXJyYXkgd2FzIHBhc3NlZCBpbiwgYXNzdW1lIHRoYXQgaXQgaXMgYW4gYXJyYXkgb2YgZm9ybSBlbGVtZW50cy5cbiAgICAgICAgaWYgKERHLlV0aWwuaXNBcnJheShvKSkge1xuICAgICAgICAgICAgZm9yIChpID0gMDsgbyAmJiBpIDwgby5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGFkZChvW2ldLm5hbWUsIG9baV0udmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSWYgdHJhZGl0aW9uYWwsIGVuY29kZSB0aGUgXCJvbGRcIiB3YXkgKHRoZSB3YXkgMS4zLjIgb3Igb2xkZXJcbiAgICAgICAgICAgIC8vIGRpZCBpdCksIG90aGVyd2lzZSBlbmNvZGUgcGFyYW1zIHJlY3Vyc2l2ZWx5LlxuICAgICAgICAgICAgZm9yIChwcmVmaXggaW4gbykge1xuICAgICAgICAgICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KHByZWZpeCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYnVpbGRQYXJhbXMocHJlZml4LCBvW3ByZWZpeF0sIHRyYWRpdGlvbmFsLCBhZGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNwYWNlcyBzaG91bGQgYmUgKyBhY2NvcmRpbmcgdG8gc3BlY1xuICAgICAgICByZXR1cm4gcy5qb2luKCcmJykucmVwbGFjZSgvJTIwL2csICcrJyk7XG4gICAgfTtcblxuICAgIHZhciB0ZXN0eGhyID0gd2luW3htbEh0dHBSZXF1ZXN0XSA/IG5ldyBYTUxIdHRwUmVxdWVzdCgpIDogbnVsbDtcblxuICAgIEFqYXguY29yc1N1cHBvcnQgPSAhKCEodGVzdHhociAmJiAnd2l0aENyZWRlbnRpYWxzJyBpbiB0ZXN0eGhyKSAmJiAhd2luW3hEb21haW5SZXF1ZXN0XSkgJiZcbiAgICAgICAgLy8gY29ycyBub3QgYXZhaWxhYmxlIGluIElFIGFuZCB3aXRoIGN5cmlsbGljIGRvbWFpblxuICAgICAgICAhKERHLkJyb3dzZXIuaWUgJiYgZG9jdW1lbnQubG9jYXRpb24uaG9zdC50b0xvd2VyQ2FzZSgpLnNlYXJjaCgvW9CwLdGPXS8pICE9IC0xKTtcblxuICAgIHJldHVybiBBamF4O1xufSkoKTtcbiIsIkRHLkxhYmVsID0gREcuTGF5ZXIuZXh0ZW5kKHtcblxuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgb2Zmc2V0OiBuZXcgREcuUG9pbnQoMTIsIDE1KSxcbiAgICAgICAgY2xhc3NOYW1lOiAnZGctbGFiZWwnLFxuICAgICAgICB6SW5kZXhPZmZzZXQ6IDBcbiAgICB9LFxuXG4gICAgX3R5cGVPZlN0cmluZyA6IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCgncycpLFxuICAgIF9kZWZhdWx0WkluZGV4OiAxMDAsXG5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbiAoY29udGVudCwgb3B0aW9ucykge1xuICAgICAgICBERy5VdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG5cbiAgICAgICAgdGhpcy5fYW5pbWF0ZWQgPSBERy5Ccm93c2VyLmFueTNkO1xuICAgICAgICB0aGlzLl9jb250ZW50ID0gY29udGVudDtcbiAgICB9LFxuXG4gICAgb25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcbiAgICAgICAgdGhpcy5fbWFwID0gbWFwO1xuXG4gICAgICAgIGlmICghdGhpcy5fZWwpIHtcbiAgICAgICAgICAgIHRoaXMuX2luaXRET00oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3Zpc2libGUgPSB0cnVlO1xuXG4gICAgICAgIHRoaXNcbiAgICAgICAgICAgIC5zZXRDb250ZW50KHRoaXMuX2NvbnRlbnQpXG4gICAgICAgICAgICAuX29uVmlld1Jlc2V0KCk7XG5cbiAgICAgICAgbWFwXG4gICAgICAgICAgICAub24oJ3ZpZXdyZXNldCcsIHRoaXMuX29uVmlld1Jlc2V0LCB0aGlzKVxuICAgICAgICAgICAgLm9uKCd6b29tYW5pbScsIHRoaXMuX29uWm9vbUFuaW1hdGlvbiwgdGhpcyk7XG4gICAgfSxcblxuICAgIG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XG4gICAgICAgIG1hcFxuICAgICAgICAgICAgLm9mZigndmlld3Jlc2V0JywgdGhpcy5fb25WaWV3UmVzZXQsIHRoaXMpXG4gICAgICAgICAgICAub2ZmKCd6b29tYW5pbScsIHRoaXMuX29uWm9vbUFuaW1hdGlvbiwgdGhpcyk7XG5cbiAgICAgICAgdGhpcy5fdmlzaWJsZSA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuX2VsLnJlbW92ZUNoaWxkKHRoaXMuX2NvbnRhaW5lcik7XG4gICAgICAgIERHLlV0aWwuZmFsc2VGbih0aGlzLl9jb250YWluZXIub2Zmc2V0V2lkdGgpOyAvLyB3ZSBuZWVkIHJlZmxvdyBoZXJlXG4gICAgICAgIHRoaXMuX2NvbnRhaW5lciA9IG51bGw7XG5cbiAgICAgICAgbWFwLmdldFBhbmVzKCkubWFya2VyUGFuZS5yZW1vdmVDaGlsZCh0aGlzLl9lbCk7XG4gICAgICAgIHRoaXMuX2VsID0gbnVsbDtcbiAgICB9LFxuXG4gICAgX2luaXRET006IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fZWwgPSBERy5Eb21VdGlsLmNyZWF0ZShcbiAgICAgICAgICAgICAgICAgICAgICAgICdkaXYnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmNsYXNzTmFtZSArICcgbGVhZmxldC16b29tLScgKyAodGhpcy5fYW5pbWF0ZWQgPyAnYW5pbWF0ZWQnIDogJ2hpZGUnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX21hcC5nZXRQYW5lcygpLm1hcmtlclBhbmUpO1xuICAgICAgICB0aGlzLl9lbC5zdHlsZS56SW5kZXggPSB0aGlzLl9kZWZhdWx0WkluZGV4ICsgdGhpcy5vcHRpb25zLnpJbmRleE9mZnNldDtcblxuICAgICAgICB0aGlzLl9jb250YWluZXIgPSBERy5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgdGhpcy5vcHRpb25zLmNsYXNzTmFtZSArICdfX2NvbnRlbnQnLCB0aGlzLl9lbCk7XG4gICAgICAgIERHLkRvbVV0aWwuZGlzYWJsZVRleHRTZWxlY3Rpb24odGhpcy5fY29udGFpbmVyKTtcbiAgICAgICAgREcuRG9tRXZlbnRcbiAgICAgICAgICAgIC5kaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbih0aGlzLl9lbClcbiAgICAgICAgICAgIC5vbih0aGlzLl9jb250YWluZXIsICdtb3VzZXdoZWVsJywgREcuRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uKVxuICAgICAgICAgICAgLm9uKHRoaXMuX2NvbnRhaW5lciwgJ2NvbnRleHRtZW51JywgREcuRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uKTtcbiAgICB9LFxuXG4gICAgX29uVmlld1Jlc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl92aXNpYmxlICYmIHRoaXMuX2xhdGxuZykge1xuICAgICAgICAgICAgREcuRG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9lbCwgdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcpLmFkZCh0aGlzLm9wdGlvbnMub2Zmc2V0KSwgREcuQnJvd3Nlci5pZSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX29uWm9vbUFuaW1hdGlvbjogZnVuY3Rpb24gKG9wdCkge1xuICAgICAgICBpZiAodGhpcy5fbGF0bG5nKSB7XG4gICAgICAgICAgICBERy5Eb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX2VsLCB0aGlzLl9tYXAuX2xhdExuZ1RvTmV3TGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcsIG9wdC56b29tLCBvcHQuY2VudGVyKS5hZGQodGhpcy5vcHRpb25zLm9mZnNldCkpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHNldE9mZnNldDogZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgICAgIGlmIChwb2ludCBpbnN0YW5jZW9mIERHLlBvaW50KSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMub2Zmc2V0ID0gcG9pbnQ7XG4gICAgICAgICAgICB0aGlzLl9vblZpZXdSZXNldCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzZXRaSW5kZXhPZmZzZXQ6IGZ1bmN0aW9uICh6SW5kZXgpIHtcbiAgICAgICAgaWYgKCFpc05hTigrekluZGV4KSkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLnpJbmRleE9mZnNldCA9ICt6SW5kZXg7XG4gICAgICAgICAgICBpZiAodGhpcy5fdmlzaWJsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2VsLnN0eWxlLnpJbmRleCA9IHRoaXMuX2RlZmF1bHRaSW5kZXggKyB0aGlzLm9wdGlvbnMuekluZGV4T2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzZXRDb250ZW50OiBmdW5jdGlvbiAoY29udGVudCkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGNvbnRlbnQpICE9PSB0aGlzLl90eXBlT2ZTdHJpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NvbnRlbnQgPSBjb250ZW50O1xuICAgICAgICBpZiAodGhpcy5fdmlzaWJsZSkge1xuICAgICAgICAgICAgdGhpcy5fY29udGFpbmVyLmlubmVySFRNTCA9IGNvbnRlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHNldFBvc2l0aW9uOiBmdW5jdGlvbiAobGF0bG5nKSB7XG4gICAgICAgIGlmICghKGxhdGxuZyBpbnN0YW5jZW9mIERHLkxhdExuZykpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbGF0bG5nID0gbGF0bG5nO1xuICAgICAgICB0aGlzLl9vblZpZXdSZXNldCgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59KTtcblxuREcubGFiZWwgPSBmdW5jdGlvbiAoY29udGVudCwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgREcuTGFiZWwoY29udGVudCwgb3B0aW9ucyk7XG59O1xuIiwiREcuTWFya2VyLmluY2x1ZGUoe1xuXG4gICAgYmluZExhYmVsOiBmdW5jdGlvbiAoY29udGVudCwgb3B0aW9ucykge1xuICAgICAgICBpZiAodGhpcy5fbGFiZWwpIHtcbiAgICAgICAgICAgIHRoaXMuX2xhYmVsLnNldENvbnRlbnQoY29udGVudCk7XG4gICAgICAgICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMub2Zmc2V0ICE9PSBvcHRpb25zLm9mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sYWJlbC5zZXRPZmZzZXQodGhpcy5vcHRpb25zLm9mZnNldCA9IG9wdGlvbnMub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zdGF0aWMgIT09IG9wdGlvbnMuc3RhdGljKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudW5iaW5kTGFiZWwoKS5iaW5kTGFiZWwoY29udGVudCwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3B0aW9ucyA9IERHLmV4dGVuZCh7XG4gICAgICAgICAgICAgICAgb2Zmc2V0OiBuZXcgREcuUG9pbnQoNSwgNSlcbiAgICAgICAgICAgIH0sIG9wdGlvbnMpO1xuXG4gICAgICAgICAgICB0aGlzLl9sYWJlbCA9IERHLmxhYmVsKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG4gICAgICAgICAgICB0aGlzLm9uY2UoJ3JlbW92ZScsIHRoaXMudW5iaW5kTGFiZWwpO1xuXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5zdGF0aWMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNob3dMYWJlbCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzXG4gICAgICAgICAgICAgICAgICAgIC5vbignbW91c2VvdmVyJywgdGhpcy5fbW91c2VPdmVyTGFiZWwpXG4gICAgICAgICAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCB0aGlzLl9tb3VzZU91dExhYmVsKVxuICAgICAgICAgICAgICAgICAgICAub24oJ2RyYWdzdGFydCcsIHRoaXMuX2RyYWdTdGFydExhYmVsKVxuICAgICAgICAgICAgICAgICAgICAub24oJ2RyYWdlbmQnLCB0aGlzLl9kcmFnRW5kTGFiZWwpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuX21hcCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVMYWJlbFpJbmRleCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uY2UoJ2FkZCcsIHRoaXMuX3VwZGF0ZUxhYmVsWkluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgdW5iaW5kTGFiZWw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2xhYmVsKSB7XG4gICAgICAgICAgICB0aGlzXG4gICAgICAgICAgICAgICAgLmhpZGVMYWJlbCgpXG4gICAgICAgICAgICAgICAgLm9mZigncmVtb3ZlJywgdGhpcy51bmJpbmRMYWJlbClcbiAgICAgICAgICAgICAgICAub2ZmKCdtb3VzZW92ZXInLCB0aGlzLl9tb3VzZU92ZXJMYWJlbClcbiAgICAgICAgICAgICAgICAub2ZmKCdtb3VzZW91dCcsIHRoaXMuX21vdXNlT3V0TGFiZWwpXG4gICAgICAgICAgICAgICAgLm9mZignZHJhZ3N0YXJ0JywgdGhpcy5fZHJhZ1N0YXJ0TGFiZWwpXG4gICAgICAgICAgICAgICAgLm9mZignZHJhZ2VuZCcsIHRoaXMuX2RyYWdFbmRMYWJlbClcbiAgICAgICAgICAgICAgICAub2ZmKCdtb3ZlJywgdGhpcy5fdXBkYXRlUG9zaXRpb24pXG4gICAgICAgICAgICAgICAgLm9mZignYWRkJywgdGhpcy5fdXBkYXRlTGFiZWxaSW5kZXgpO1xuXG4gICAgICAgICAgICB0aGlzLl9sYWJlbCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGdldExhYmVsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sYWJlbCA/IHRoaXMuX2xhYmVsIDogbnVsbDtcbiAgICB9LFxuXG4gICAgX29yaWdpbmFsVXBkYXRlWkluZGV4OiBERy5NYXJrZXIucHJvdG90eXBlLl91cGRhdGVaSW5kZXgsXG4gICAgX3VwZGF0ZVpJbmRleDogZnVuY3Rpb24gKG9mZnNldCkge1xuICAgICAgICB0aGlzLl9vcmlnaW5hbFVwZGF0ZVpJbmRleChvZmZzZXQpO1xuICAgICAgICB0aGlzLl91cGRhdGVMYWJlbFpJbmRleCgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgX3VwZGF0ZUxhYmVsWkluZGV4OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9sYWJlbCAmJiB0aGlzLl9pY29uKSB7XG4gICAgICAgICAgICB0aGlzLl9sYWJlbC5zZXRaSW5kZXhPZmZzZXQodGhpcy5faWNvbi5zdHlsZS56SW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzaG93TGFiZWwgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9sYWJlbCkge1xuICAgICAgICAgICAgdGhpc1xuICAgICAgICAgICAgICAgIC5vbignbW92ZScsIHRoaXMuX3VwZGF0ZVBvc2l0aW9uKVxuICAgICAgICAgICAgICAgIC5fbWFwLmFkZExheWVyKHRoaXMuX2xhYmVsLnNldFBvc2l0aW9uKHRoaXMuZ2V0TGF0TG5nKCkpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBoaWRlTGFiZWwgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9sYWJlbCkge1xuICAgICAgICAgICAgdGhpc1xuICAgICAgICAgICAgICAgIC5vZmYoJ21vdmUnLCB0aGlzLl91cGRhdGVQb3NpdGlvbilcbiAgICAgICAgICAgICAgICAuX21hcC5yZW1vdmVMYXllcih0aGlzLl9sYWJlbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIF91cGRhdGVQb3NpdGlvbiA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fbGFiZWwuc2V0UG9zaXRpb24odGhpcy5nZXRMYXRMbmcoKSk7XG4gICAgfSxcblxuICAgIF9kcmFnU3RhcnRMYWJlbDogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9sYWJlbC5pc01hcmtlckRyYWdnaW5nID0gdHJ1ZTtcblxuICAgICAgICB0aGlzLmhpZGVMYWJlbCgpO1xuICAgIH0sXG5cbiAgICBfZHJhZ0VuZExhYmVsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2xhYmVsLmlzTWFya2VyRHJhZ2dpbmcgPSBmYWxzZTtcblxuICAgICAgICBpZiAodGhpcy5fbGFiZWwuaXNNb3VzZU92ZXJNYXJrZXIpIHtcbiAgICAgICAgICAgIHRoaXMuc2hvd0xhYmVsKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX21vdXNlT3ZlckxhYmVsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2xhYmVsLmlzTW91c2VPdmVyTWFya2VyID0gdHJ1ZTtcblxuICAgICAgICBpZiAoIXRoaXMuX2xhYmVsLmlzTWFya2VyRHJhZ2dpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuc2hvd0xhYmVsKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX21vdXNlT3V0TGFiZWw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fbGFiZWwuaXNNb3VzZU92ZXJNYXJrZXIgPSBmYWxzZTtcblxuICAgICAgICB0aGlzLmhpZGVMYWJlbCgpO1xuICAgIH1cbn0pO1xuXG5ERy5NYXJrZXIuYWRkSW5pdEhvb2soZnVuY3Rpb24gKCkge1xuICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLmxhYmVsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aGlzLmJpbmRMYWJlbCh0aGlzLm9wdGlvbnMubGFiZWwpO1xuICAgIH1cbn0pO1xuIiwiREcuUGF0aC5pbmNsdWRlKHtcbiAgICBiaW5kTGFiZWw6IGZ1bmN0aW9uIChjb250ZW50LCBvcHRpb25zKSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9sYWJlbCkge1xuICAgICAgICAgICAgdGhpcy5fbGFiZWwgPSBERy5sYWJlbChjb250ZW50LCBvcHRpb25zKTtcbiAgICAgICAgICAgIHRoaXMub24odGhpcy5fbGFiZWxFdmVudHMsIHRoaXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fbGFiZWwuc2V0Q29udGVudChjb250ZW50KTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX2xhYmVsLm9wdGlvbnMub2Zmc2V0ICE9PSBvcHRpb25zLm9mZnNldCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xhYmVsLnNldE9mZnNldChvcHRpb25zLm9mZnNldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHVuYmluZExhYmVsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9sYWJlbCkge1xuICAgICAgICAgICAgdGhpcy5vZmYodGhpcy5fbGFiZWxFdmVudHMsIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5fbWFwLnJlbW92ZUxheWVyKHRoaXMuX2xhYmVsKTtcbiAgICAgICAgICAgIHRoaXMuX2xhYmVsID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgZ2V0TGFiZWw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xhYmVsID8gdGhpcy5fbGFiZWwgOiBudWxsO1xuICAgIH0sXG5cbiAgICBfbGFiZWxFdmVudHMgOiB7XG4gICAgICAgICdtb3VzZW92ZXInOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX21hcC5hZGRMYXllcih0aGlzLl9sYWJlbC5zZXRQb3NpdGlvbihldmVudC5sYXRsbmcpKTtcbiAgICAgICAgfSxcbiAgICAgICAgJ21vdXNlbW92ZSc6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgdGhpcy5fbGFiZWwuc2V0UG9zaXRpb24oZXZlbnQubGF0bG5nKTtcbiAgICAgICAgfSxcbiAgICAgICAgJ21vdXNlb3V0JzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fbWFwLnJlbW92ZUxheWVyKHRoaXMuX2xhYmVsKTtcbiAgICAgICAgfSxcbiAgICAgICAgJ3JlbW92ZSc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX21hcC5yZW1vdmVMYXllcih0aGlzLl9sYWJlbCk7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuREcuUGF0aC5hZGRJbml0SG9vayhmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMubGFiZWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRoaXMuYmluZExhYmVsKHRoaXMub3B0aW9ucy5sYWJlbCk7XG4gICAgfVxufSk7XG4iLCJERy5Xa3QgPSB7fTtcblxuREcuV2t0LnRvR2VvSlNPTiA9IGZ1bmN0aW9uIChfKSB7XG4gICAgaWYgKERHLlV0aWwuaXNBcnJheShfKSkge1xuICAgICAgICBfID0gX1swXTtcbiAgICB9XG4gICAgdmFyIHBhcnRzID0gXy5zcGxpdCgnOycpO1xuICAgIF8gPSBwYXJ0cy5wb3AoKTtcblxuICAgIHZhciBpID0gMCxcbiAgICAgICAgc3JpZCA9IChwYXJ0cy5zaGlmdCgpIHx8ICcnKS5zcGxpdCgnPScpLnBvcCgpO1xuXG4gICAgZnVuY3Rpb24gJChyZSkge1xuICAgICAgICB2YXIgbWF0Y2ggPSBfLnN1YnN0cmluZyhpKS5tYXRjaChyZSk7XG4gICAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaSArPSBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hbMF07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcnMob2JqKSB7XG4gICAgICAgIGlmIChvYmogJiYgc3JpZC5tYXRjaCgvXFxkKy8pKSB7XG4gICAgICAgICAgICBvYmouY3JzID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICduYW1lJyxcbiAgICAgICAgICAgICAgICAncHJvcGVydGllcyc6IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3VybjpvZ2M6ZGVmOmNyczpFUFNHOjonICsgc3JpZFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdoaXRlKCkgeyAkKC9eXFxzKi8pOyB9XG5cbiAgICBmdW5jdGlvbiBtdWx0aWNvb3JkcygpIHtcbiAgICAgICAgd2hpdGUoKTtcbiAgICAgICAgdmFyIGRlcHRoID0gMCwgcmluZ3MgPSBbXSwgc3RhY2sgPSBbcmluZ3NdLFxuICAgICAgICAgICAgcG9pbnRlciA9IHJpbmdzLCBlbGVtO1xuICAgICAgICB3aGlsZSAoZWxlbSA9XG4gICAgICAgICAgICAkKC9eKFxcKCkvKSB8fFxuICAgICAgICAgICAgJCgvXihcXCkpLykgfHxcbiAgICAgICAgICAgICQoL14oXFwsKS8pIHx8XG4gICAgICAgICAgICAkKC9eWy0rXT8oWzAtOV0qXFwuWzAtOV0rfFswLTldKykvKSkge1xuICAgICAgICAgICAgaWYgKGVsZW0gPT09ICcoJykge1xuICAgICAgICAgICAgICAgIHN0YWNrLnB1c2gocG9pbnRlcik7XG4gICAgICAgICAgICAgICAgcG9pbnRlciA9IFtdO1xuICAgICAgICAgICAgICAgIHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdLnB1c2gocG9pbnRlcik7XG4gICAgICAgICAgICAgICAgZGVwdGgrKztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZWxlbSA9PT0gJyknKSB7XG4gICAgICAgICAgICAgICAgcG9pbnRlciA9IHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgIGRlcHRoLS07XG4gICAgICAgICAgICAgICAgaWYgKGRlcHRoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZWxlbSA9PT0gJywnKSB7XG4gICAgICAgICAgICAgICAgcG9pbnRlciA9IFtdO1xuICAgICAgICAgICAgICAgIHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdLnB1c2gocG9pbnRlcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBvaW50ZXIucHVzaChwYXJzZUZsb2F0KGVsZW0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhY2subGVuZ3RoID0gMDtcbiAgICAgICAgaWYgKGRlcHRoICE9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmluZ3M7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29vcmRzKCkge1xuICAgICAgICB2YXIgbGlzdCA9IFtdLCBpdGVtLCBwdDtcbiAgICAgICAgd2hpbGUgKHB0ID1cbiAgICAgICAgICAgICQoL15bLStdPyhbMC05XSpcXC5bMC05XSt8WzAtOV0rKS8pIHx8XG4gICAgICAgICAgICAkKC9eKFxcLCkvKSkge1xuICAgICAgICAgICAgaWYgKHB0ID09PSAnLCcpIHtcbiAgICAgICAgICAgICAgICBsaXN0LnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgaXRlbSA9IFtdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIWl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbSA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpdGVtLnB1c2gocGFyc2VGbG9hdChwdCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpdGUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgbGlzdC5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaXN0Lmxlbmd0aCA/IGxpc3QgOiBudWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBvaW50KCkge1xuICAgICAgICBpZiAoISQoL14ocG9pbnQpL2kpKSB7IHJldHVybiBudWxsOyB9XG4gICAgICAgIHdoaXRlKCk7XG4gICAgICAgIGlmICghJCgvXihcXCgpLykpIHsgcmV0dXJuIG51bGw7IH1cbiAgICAgICAgdmFyIGMgPSBjb29yZHMoKTtcbiAgICAgICAgd2hpdGUoKTtcbiAgICAgICAgaWYgKCEkKC9eKFxcKSkvKSkgeyByZXR1cm4gbnVsbDsgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ1BvaW50JyxcbiAgICAgICAgICAgIGNvb3JkaW5hdGVzOiBjWzBdXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbXVsdGlwb2ludCgpIHtcbiAgICAgICAgaWYgKCEkKC9eKG11bHRpcG9pbnQpL2kpKSB7IHJldHVybiBudWxsOyB9XG4gICAgICAgIHdoaXRlKCk7XG4gICAgICAgIHZhciBjID0gbXVsdGljb29yZHMoKTtcbiAgICAgICAgd2hpdGUoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdNdWx0aVBvaW50JyxcbiAgICAgICAgICAgIGNvb3JkaW5hdGVzOiBjXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbXVsdGlsaW5lc3RyaW5nKCkge1xuICAgICAgICBpZiAoISQoL14obXVsdGlsaW5lc3RyaW5nKS9pKSkgeyByZXR1cm4gbnVsbDsgfVxuICAgICAgICB3aGl0ZSgpO1xuICAgICAgICB2YXIgYyA9IG11bHRpY29vcmRzKCk7XG4gICAgICAgIHdoaXRlKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnTXVsdGlMaW5lU3RyaW5nJyxcbiAgICAgICAgICAgIGNvb3JkaW5hdGVzOiBjXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGluZXN0cmluZygpIHtcbiAgICAgICAgaWYgKCEkKC9eKGxpbmVzdHJpbmcpL2kpKSB7IHJldHVybiBudWxsOyB9XG4gICAgICAgIHdoaXRlKCk7XG4gICAgICAgIGlmICghJCgvXihcXCgpLykpIHsgcmV0dXJuIG51bGw7IH1cbiAgICAgICAgdmFyIGMgPSBjb29yZHMoKTtcbiAgICAgICAgaWYgKCEkKC9eKFxcKSkvKSkgeyByZXR1cm4gbnVsbDsgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ0xpbmVTdHJpbmcnLFxuICAgICAgICAgICAgY29vcmRpbmF0ZXM6IGNcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwb2x5Z29uKCkge1xuICAgICAgICBpZiAoISQoL14ocG9seWdvbikvaSkpIHsgcmV0dXJuIG51bGw7IH1cbiAgICAgICAgd2hpdGUoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdQb2x5Z29uJyxcbiAgICAgICAgICAgIGNvb3JkaW5hdGVzOiBtdWx0aWNvb3JkcygpXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbXVsdGlwb2x5Z29uKCkge1xuICAgICAgICBpZiAoISQoL14obXVsdGlwb2x5Z29uKS9pKSkgeyByZXR1cm4gbnVsbDsgfVxuICAgICAgICB3aGl0ZSgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ011bHRpUG9seWdvbicsXG4gICAgICAgICAgICBjb29yZGluYXRlczogbXVsdGljb29yZHMoKVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdlb21ldHJ5Y29sbGVjdGlvbigpIHtcbiAgICAgICAgdmFyIGdlb21ldHJpZXMgPSBbXSwgZ2VvbWV0cnk7XG5cbiAgICAgICAgaWYgKCEkKC9eKGdlb21ldHJ5Y29sbGVjdGlvbikvaSkpIHsgcmV0dXJuIG51bGw7IH1cbiAgICAgICAgd2hpdGUoKTtcblxuICAgICAgICBpZiAoISQoL14oXFwoKS8pKSB7IHJldHVybiBudWxsOyB9XG4gICAgICAgIHdoaWxlIChnZW9tZXRyeSA9IHJvb3QoKSkge1xuICAgICAgICAgICAgZ2VvbWV0cmllcy5wdXNoKGdlb21ldHJ5KTtcbiAgICAgICAgICAgIHdoaXRlKCk7XG4gICAgICAgICAgICAkKC9eKFxcLCkvKTtcbiAgICAgICAgICAgIHdoaXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEkKC9eKFxcKSkvKSkgeyByZXR1cm4gbnVsbDsgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnR2VvbWV0cnlDb2xsZWN0aW9uJyxcbiAgICAgICAgICAgIGdlb21ldHJpZXM6IGdlb21ldHJpZXNcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByb290KCkge1xuICAgICAgICByZXR1cm4gcG9pbnQoKSB8fFxuICAgICAgICAgICAgbGluZXN0cmluZygpIHx8XG4gICAgICAgICAgICBwb2x5Z29uKCkgfHxcbiAgICAgICAgICAgIG11bHRpcG9pbnQoKSB8fFxuICAgICAgICAgICAgbXVsdGlsaW5lc3RyaW5nKCkgfHxcbiAgICAgICAgICAgIG11bHRpcG9seWdvbigpIHx8XG4gICAgICAgICAgICBnZW9tZXRyeWNvbGxlY3Rpb24oKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY3JzKHJvb3QoKSk7XG59O1xuXG5ERy5Xa3QuZ2VvSnNvbkxheWVyID0gZnVuY3Rpb24gKGRhdGEsIG9wdHMpIHtcbiAgICByZXR1cm4gREcuZ2VvSnNvbihERy5Xa3QudG9HZW9KU09OKGRhdGEpLCBvcHRzKTtcbn07XG5cbkRHLldrdC50b0xhdExuZ3MgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBjb29yZHMgPSBERy5Xa3QudG9HZW9KU09OKGRhdGEpLmNvb3JkaW5hdGVzO1xuICAgIHJldHVybiBERy5VdGlsLmlzQXJyYXkoY29vcmRzKSA/XG4gICAgICAgIGNvb3Jkc1xuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoY29vcmQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gREcuVXRpbC5pc0FycmF5KGNvb3JkWzBdKSA/IERHLkdlb0pTT04uY29vcmRzVG9MYXRMbmdzKGNvb3JkKSA6IFtERy5HZW9KU09OLmNvb3Jkc1RvTGF0TG5nKGNvb3JkKV07XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnJlZHVjZShmdW5jdGlvbiAoYXJyLCBjb29yZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcnIuY29uY2F0KGNvb3JkKTtcbiAgICAgICAgICAgIH0pIDpcbiAgICAgICAgREcuR2VvSlNPTi5jb29yZHNUb0xhdExuZ3MoY29vcmRzKTtcbn07XG5cbkRHLldrdC50b1BvaW50cyA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgcmV0dXJuIERHLldrdC50b0dlb0pTT04oZGF0YSkuY29vcmRpbmF0ZXM7XG59O1xuXG5ERy5Xa3QucG9pbnRzVG9MYXRMbmdPbk1hcCA9IGZ1bmN0aW9uICh3a3QsIG1hcCkge1xuICAgIHJldHVybiAoZnVuY3Rpb24gcGFyc2VQb2ludHMocG9pbnRzKSB7XG4gICAgICAgIHJldHVybiAoQXJyYXkuaXNBcnJheShwb2ludHMpICYmIEFycmF5LmlzQXJyYXkocG9pbnRzWzBdKSkgP1xuICAgICAgICAgICAgcG9pbnRzLm1hcChwYXJzZVBvaW50cykgOlxuICAgICAgICAgICAgbWFwLmNvbnRhaW5lclBvaW50VG9MYXRMbmcocG9pbnRzKTtcbiAgICB9KShERy5Xa3QudG9Qb2ludHMod2t0KSk7XG59O1xuIiwiREcuY29uZmlnVGhlbWUgPSBERy5jb25maWdUaGVtZSB8fCB7fTtcblxuREcuY29uZmlnVGhlbWUuYmFsbG9vbk9wdGlvbnMgPSB7XG4gICAgb2Zmc2V0OiB7XG4gICAgICAgIHg6IDEsXG4gICAgICAgIHk6IC00M1xuICAgIH1cbn07XG4iLCIoZnVuY3Rpb24od2luZG93LCB1bmRlZmluZWQpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBpZiAoIXdpbmRvdykgcmV0dXJuOyAvLyBTZXJ2ZXIgc2lkZVxuXG52YXJcbiAgICBfYmFyb24gPSB3aW5kb3cuYmFyb24sIC8vIFN0b3JlZCBiYXJvbiB2YWx1ZSBmb3Igbm9Db25mbGljdCB1c2FnZVxuICAgICQgPSB3aW5kb3cualF1ZXJ5LCAvLyBUcnlpbmcgdG8gdXNlIGpRdWVyeVxuICAgIG9yaWdpbiA9IHtcbiAgICAgICAgdjogeyAvLyBWZXJ0aWNhbFxuICAgICAgICAgICAgeDogJ1knLCBwb3M6ICd0b3AnLCBjcm9zc1BvczogJ2xlZnQnLCBzaXplOiAnaGVpZ2h0JywgY3Jvc3NTaXplOiAnd2lkdGgnLFxuICAgICAgICAgICAgY2xpZW50OiAnY2xpZW50SGVpZ2h0JywgY3Jvc3NDbGllbnQ6ICdjbGllbnRXaWR0aCcsIG9mZnNldDogJ29mZnNldEhlaWdodCcsIGNyb3NzT2Zmc2V0OiAnb2Zmc2V0V2lkdGgnLCBvZmZzZXRQb3M6ICdvZmZzZXRUb3AnLFxuICAgICAgICAgICAgc2Nyb2xsOiAnc2Nyb2xsVG9wJywgc2Nyb2xsU2l6ZTogJ3Njcm9sbEhlaWdodCdcbiAgICAgICAgfSxcbiAgICAgICAgaDogeyAvLyBIb3Jpem9udGFsXG4gICAgICAgICAgICB4OiAnWCcsIHBvczogJ2xlZnQnLCBjcm9zc1BvczogJ3RvcCcsIHNpemU6ICd3aWR0aCcsIGNyb3NzU2l6ZTogJ2hlaWdodCcsXG4gICAgICAgICAgICBjbGllbnQ6ICdjbGllbnRXaWR0aCcsIGNyb3NzQ2xpZW50OiAnY2xpZW50SGVpZ2h0Jywgb2Zmc2V0OiAnb2Zmc2V0V2lkdGgnLCBjcm9zc09mZnNldDogJ29mZnNldEhlaWdodCcsIG9mZnNldFBvczogJ29mZnNldExlZnQnLFxuICAgICAgICAgICAgc2Nyb2xsOiAnc2Nyb2xsTGVmdCcsIHNjcm9sbFNpemU6ICdzY3JvbGxXaWR0aCdcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBlYWNoID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRvcikge1xuICAgICAgICB2YXIgaSA9IDA7XG5cbiAgICAgICAgaWYgKG9iai5sZW5ndGggPT09IHVuZGVmaW5lZCB8fCBvYmogPT09IHdpbmRvdykgb2JqID0gW29ial07XG5cbiAgICAgICAgd2hpbGUgKG9ialtpXSkge1xuICAgICAgICAgICAgaXRlcmF0b3IuY2FsbCh0aGlzLCBvYmpbaV0sIGkpO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGJhcm9uID0gZnVuY3Rpb24ocGFyYW1zKSB7IC8vIHRoaXMgLSB3aW5kb3cgb3IgalF1ZXJ5IGluc3RhbmNlXG4gICAgICAgIHZhciBqUXVlcnlNb2RlID0gZmFsc2UsLy8odGhpcyAmJiB0aGlzWzBdICYmIHRoaXNbMF0ubm9kZVR5cGUpLFxuICAgICAgICAgICAgcm9vdHMsXG4gICAgICAgICAgICAkO1xuXG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgICAgICAgJCA9IHBhcmFtcy4kIHx8IHdpbmRvdy5qUXVlcnk7XG5cbiAgICAgICAgaWYgKGpRdWVyeU1vZGUpIHtcbiAgICAgICAgICAgIHBhcmFtcy5yb290ID0gcm9vdHMgPSB0aGlzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcm9vdHMgPSAkKHBhcmFtcy5yb290IHx8IHBhcmFtcy5zY3JvbGxlcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IGJhcm9uLmZuLmNvbnN0cnVjdG9yKHJvb3RzLCBwYXJhbXMsICQpO1xuICAgIH07XG5cbiAgICBiYXJvbi5mbiA9IHtcbiAgICAgICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uKHJvb3RzLCBpbnB1dCwgJCkge1xuICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHZhbGlkYXRlKGlucHV0KTtcblxuICAgICAgICAgICAgcGFyYW1zLiQgPSAkO1xuICAgICAgICAgICAgZWFjaC5jYWxsKHRoaXMsIHJvb3RzLCBmdW5jdGlvbihyb290LCBpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxvY2FsUGFyYW1zID0gY2xvbmUocGFyYW1zKTtcblxuICAgICAgICAgICAgICAgIGlmIChwYXJhbXMucm9vdCAmJiBwYXJhbXMuc2Nyb2xsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxQYXJhbXMuc2Nyb2xsZXIgPSBwYXJhbXMuJChwYXJhbXMuc2Nyb2xsZXIsIHJvb3QpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWxvY2FsUGFyYW1zLnNjcm9sbGVyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxQYXJhbXMuc2Nyb2xsZXIgPSByb290O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxQYXJhbXMuc2Nyb2xsZXIgPSByb290O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGxvY2FsUGFyYW1zLnJvb3QgPSByb290O1xuICAgICAgICAgICAgICAgIHRoaXNbaV0gPSBpbml0KGxvY2FsUGFyYW1zKTtcbiAgICAgICAgICAgICAgICB0aGlzLmxlbmd0aCA9IGkgKyAxO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xuICAgICAgICB9LFxuXG4gICAgICAgIGRpc3Bvc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHRoaXMucGFyYW1zO1xuXG4gICAgICAgICAgICBlYWNoKHRoaXMsIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICBpdGVtLmRpc3Bvc2UocGFyYW1zKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5wYXJhbXMgPSBudWxsO1xuICAgICAgICB9LFxuXG4gICAgICAgIHVwZGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaSA9IDA7XG5cbiAgICAgICAgICAgIHdoaWxlICh0aGlzW2ldKSB7XG4gICAgICAgICAgICAgICAgdGhpc1tpXS51cGRhdGUuYXBwbHkodGhpc1tpXSwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgYmFyb246IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICAgICAgcGFyYW1zLnJvb3QgPSBbXTtcbiAgICAgICAgICAgIHBhcmFtcy5zY3JvbGxlciA9IHRoaXMucGFyYW1zLnNjcm9sbGVyO1xuXG4gICAgICAgICAgICBlYWNoLmNhbGwodGhpcywgdGhpcywgZnVuY3Rpb24oZWxlbSkge1xuICAgICAgICAgICAgICAgIHBhcmFtcy5yb290LnB1c2goZWxlbS5yb290KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcGFyYW1zLmRpcmVjdGlvbiA9ICh0aGlzLnBhcmFtcy5kaXJlY3Rpb24gPT0gJ3YnKSA/ICdoJyA6ICd2JztcbiAgICAgICAgICAgIHBhcmFtcy5fY2hhaW4gPSB0cnVlO1xuXG4gICAgICAgICAgICByZXR1cm4gYmFyb24ocGFyYW1zKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBtYW5hZ2VFdmVudHMoaXRlbSwgZXZlbnRNYW5hZ2VyLCBtb2RlKSB7XG4gICAgICAgIGl0ZW0uX2V2ZW50SGFuZGxlcnMgPSBpdGVtLl9ldmVudEhhbmRsZXJzIHx8IFsgLy8gQ3JlYXRpbmcgbmV3IGZ1bmN0aW9ucyBmb3Igb25lIGJhcm9uIGl0ZW0gb25seSBvbmUgdGltZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8vIG9uU2Nyb2xsOlxuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGl0ZW0uc2Nyb2xsZXIsXG5cbiAgICAgICAgICAgICAgICBoYW5kbGVyOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uc2Nyb2xsKGUpO1xuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICB0eXBlOiAnc2Nyb2xsJ1xuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIC8vIG9uTW91c2VEb3duOlxuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGl0ZW0uYmFyLFxuXG4gICAgICAgICAgICAgICAgaGFuZGxlcjogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0ID8gZS5wcmV2ZW50RGVmYXVsdCgpIDogZS5yZXR1cm5WYWx1ZSA9IGZhbHNlOyAvLyBUZXh0IHNlbGVjdGlvbiBkaXNhYmxpbmcgaW4gT3BlcmEuLi4gYW5kIGFsbCBvdGhlciBicm93c2Vycz9cbiAgICAgICAgICAgICAgICAgICAgaXRlbS5zZWxlY3Rpb24oKTsgLy8gRGlzYWJsZSB0ZXh0IHNlbGVjdGlvbiBpbiBpZThcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5kcmFnLm5vdyA9IDE7IC8vIFNhdmUgcHJpdmF0ZSBieXRlXG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIHR5cGU6ICd0b3VjaHN0YXJ0IG1vdXNlZG93bidcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAvLyBvbk1vdXNlVXA6XG4gICAgICAgICAgICAgICAgZWxlbWVudDogZG9jdW1lbnQsXG5cbiAgICAgICAgICAgICAgICBoYW5kbGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5zZWxlY3Rpb24oMSk7IC8vIEVuYWJsZSB0ZXh0IHNlbGVjdGlvblxuICAgICAgICAgICAgICAgICAgICBpdGVtLmRyYWcubm93ID0gMDtcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgdHlwZTogJ21vdXNldXAgYmx1ciB0b3VjaGVuZCdcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAvLyBvbkNvb3JkaW5hdGVSZXNldDpcbiAgICAgICAgICAgICAgICBlbGVtZW50OiBpdGVtLmJhcixcblxuICAgICAgICAgICAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUuYnV0dG9uICE9IDIpIHsgLy8gTm90IFJNXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLl9wb3MwKGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIHR5cGU6ICd0b3VjaHN0YXJ0IG1vdXNlZG93bidcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAvLyBvbk1vdXNlTW92ZTpcbiAgICAgICAgICAgICAgICBlbGVtZW50OiBkb2N1bWVudCxcblxuICAgICAgICAgICAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0uZHJhZy5ub3cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uZHJhZyhlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICB0eXBlOiAnbW91c2Vtb3ZlIHRvdWNobW92ZSdcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAvLyBvblJlc2l6ZTpcbiAgICAgICAgICAgICAgICBlbGVtZW50OiB3aW5kb3csXG5cbiAgICAgICAgICAgICAgICBoYW5kbGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS51cGRhdGUoKTtcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgdHlwZTogJ3Jlc2l6ZSdcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAvLyBzaXplQ2hhbmdlOlxuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGl0ZW0ucm9vdCxcblxuICAgICAgICAgICAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpdGVtLnVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICB0eXBlOiAnc2l6ZUNoYW5nZSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgXTtcblxuICAgICAgICBlYWNoKGl0ZW0uX2V2ZW50SGFuZGxlcnMsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoZXZlbnQuZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGV2ZW50TWFuYWdlcihldmVudC5lbGVtZW50LCBldmVudC50eXBlLCBldmVudC5oYW5kbGVyLCBtb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gaWYgKGl0ZW0uc2Nyb2xsZXIpIHtcbiAgICAgICAgLy8gICAgIGV2ZW50KGl0ZW0uc2Nyb2xsZXIsICdzY3JvbGwnLCBpdGVtLl9ldmVudEhhbmRsZXJzLm9uU2Nyb2xsLCBtb2RlKTtcbiAgICAgICAgLy8gfVxuICAgICAgICAvLyBpZiAoaXRlbS5iYXIpIHtcbiAgICAgICAgLy8gICAgIGV2ZW50KGl0ZW0uYmFyLCAndG91Y2hzdGFydCBtb3VzZWRvd24nLCBpdGVtLl9ldmVudEhhbmRsZXJzLm9uTW91c2VEb3duLCBtb2RlKTtcbiAgICAgICAgLy8gfVxuICAgICAgICAvLyBldmVudChkb2N1bWVudCwgJ21vdXNldXAgYmx1ciB0b3VjaGVuZCcsIGl0ZW0uX2V2ZW50SGFuZGxlcnMub25Nb3VzZVVwLCBtb2RlKTtcbiAgICAgICAgLy8gZXZlbnQoZG9jdW1lbnQsICd0b3VjaHN0YXJ0IG1vdXNlZG93bicsIGl0ZW0uX2V2ZW50SGFuZGxlcnMub25Db29yZGluYXRlUmVzZXQsIG1vZGUpO1xuICAgICAgICAvLyBldmVudChkb2N1bWVudCwgJ21vdXNlbW92ZSB0b3VjaG1vdmUnLCBpdGVtLl9ldmVudEhhbmRsZXJzLm9uTW91c2VNb3ZlLCBtb2RlKTtcbiAgICAgICAgLy8gZXZlbnQod2luZG93LCAncmVzaXplJywgaXRlbS5fZXZlbnRIYW5kbGVycy5vblJlc2l6ZSwgbW9kZSk7XG4gICAgICAgIC8vIGlmIChpdGVtLnJvb3QpIHtcbiAgICAgICAgLy8gICAgIGV2ZW50KGl0ZW0ucm9vdCwgJ3NpemVDaGFuZ2UnLCBpdGVtLl9ldmVudEhhbmRsZXJzLm9uUmVzaXplLCBtb2RlKTsgLy8gQ3VzdG9uIGV2ZW50IGZvciBhbHRlcm5hdGUgYmFyb24gdXBkYXRlIG1lY2hhbmlzbVxuICAgICAgICAvLyB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFuYWdlQXR0cihub2RlLCBkaXJlY3Rpb24sIG1vZGUpIHtcbiAgICAgICAgdmFyIGF0dHJOYW1lID0gJ2RhdGEtYmFyb24tJyArIGRpcmVjdGlvbjtcblxuICAgICAgICBpZiAobW9kZSA9PSAnb24nKSB7XG4gICAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShhdHRyTmFtZSwgJ2luaXRlZCcpO1xuICAgICAgICB9IGVsc2UgaWYgKG1vZGUgPT0gJ29mZicpIHtcbiAgICAgICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKGF0dHJOYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlLmdldEF0dHJpYnV0ZShhdHRyTmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbml0KHBhcmFtcykge1xuICAgICAgICBpZiAobWFuYWdlQXR0cihwYXJhbXMucm9vdCwgcGFyYW1zLmRpcmVjdGlvbikpIHJldHVybjtcblxuICAgICAgICB2YXIgb3V0ID0gbmV3IGl0ZW0ucHJvdG90eXBlLmNvbnN0cnVjdG9yKHBhcmFtcyk7IC8vIF9fcHJvdG9fXyBvZiByZXR1cm5pbmcgb2JqZWN0IGlzIGJhcm9uLnByb3RvdHlwZVxuXG4gICAgICAgIG1hbmFnZUV2ZW50cyhvdXQsIHBhcmFtcy5ldmVudCwgJ29uJyk7XG5cbiAgICAgICAgbWFuYWdlQXR0cihvdXQucm9vdCwgcGFyYW1zLmRpcmVjdGlvbiwgJ29uJyk7XG5cbiAgICAgICAgb3V0LnVwZGF0ZSgpO1xuXG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xvbmUoaW5wdXQpIHtcbiAgICAgICAgdmFyIG91dHB1dCA9IHt9O1xuXG4gICAgICAgIGlucHV0ID0gaW5wdXQgfHwge307XG5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIGlucHV0KSB7XG4gICAgICAgICAgICBpZiAoaW5wdXQuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIG91dHB1dFtrZXldID0gaW5wdXRba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGUoaW5wdXQpIHtcbiAgICAgICAgdmFyIG91dHB1dCA9IGNsb25lKGlucHV0KTtcblxuICAgICAgICBvdXRwdXQuZGlyZWN0aW9uID0gb3V0cHV0LmRpcmVjdGlvbiB8fCAndic7XG5cbiAgICAgICAgdmFyIGV2ZW50ID0gaW5wdXQuZXZlbnQgfHwgZnVuY3Rpb24oZWxlbSwgZXZlbnQsIGZ1bmMsIG1vZGUpIHtcbiAgICAgICAgICAgIG91dHB1dC4kKGVsZW0pW21vZGUgfHwgJ29uJ10oZXZlbnQsIGZ1bmMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIG91dHB1dC5ldmVudCA9IGZ1bmN0aW9uKGVsZW1zLCBlLCBmdW5jLCBtb2RlKSB7XG4gICAgICAgICAgICBlYWNoKGVsZW1zLCBmdW5jdGlvbihlbGVtKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQoZWxlbSwgZSwgZnVuYywgbW9kZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpcmUoZXZlbnROYW1lKSB7XG4gICAgICAgIC8qIGpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICAgICAgICBpZiAodGhpcy5ldmVudHMgJiYgdGhpcy5ldmVudHNbZXZlbnROYW1lXSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAgOyBpIDwgdGhpcy5ldmVudHNbZXZlbnROYW1lXS5sZW5ndGggOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKCBhcmd1bWVudHMsIDEgKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRzW2V2ZW50TmFtZV1baV0uYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgaXRlbSA9IHt9O1xuXG4gICAgaXRlbS5wcm90b3R5cGUgPSB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgICAgIHZhciAkLFxuICAgICAgICAgICAgICAgIGJhclBvcyxcbiAgICAgICAgICAgICAgICBzY3JvbGxlclBvczAsXG4gICAgICAgICAgICAgICAgdHJhY2ssXG4gICAgICAgICAgICAgICAgcmVzaXplUGF1c2VUaW1lcixcbiAgICAgICAgICAgICAgICBzY3JvbGxQYXVzZVRpbWVyLFxuICAgICAgICAgICAgICAgIHBhdXNlLFxuICAgICAgICAgICAgICAgIHNjcm9sbExhc3RGaXJlLFxuICAgICAgICAgICAgICAgIHJlc2l6ZUxhc3RGaXJlO1xuXG4gICAgICAgICAgICByZXNpemVMYXN0RmlyZSA9IHNjcm9sbExhc3RGaXJlID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG5cbiAgICAgICAgICAgICQgPSB0aGlzLiQgPSBwYXJhbXMuJDtcbiAgICAgICAgICAgIHRoaXMuZXZlbnQgPSBwYXJhbXMuZXZlbnQ7XG4gICAgICAgICAgICB0aGlzLmV2ZW50cyA9IHt9O1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBnZXROb2RlKHNlbCwgY29udGV4dCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAkKHNlbCwgY29udGV4dClbMF07IC8vIENhbiBiZSB1bmRlZmluZWRcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRE9NIGVsZW1lbnRzXG4gICAgICAgICAgICB0aGlzLnJvb3QgPSBwYXJhbXMucm9vdDsgLy8gQWx3YXlzIGh0bWwgbm9kZSwgbm90IGp1c3Qgc2VsZWN0b3JcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsZXIgPSBnZXROb2RlKHBhcmFtcy5zY3JvbGxlcik7IC8vIChwYXJhbXMuc2Nyb2xsZXIpID8gZ2V0Tm9kZShwYXJhbXMuc2Nyb2xsZXIsIHRoaXMucm9vdCkgOiB0aGlzLnJvb3Q7XG4gICAgICAgICAgICB0aGlzLmJhciA9IGdldE5vZGUocGFyYW1zLmJhciwgdGhpcy5yb290KTtcbiAgICAgICAgICAgIHRyYWNrID0gdGhpcy50cmFjayA9IGdldE5vZGUocGFyYW1zLnRyYWNrLCB0aGlzLnJvb3QpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnRyYWNrICYmIHRoaXMuYmFyKSB7XG4gICAgICAgICAgICAgICAgdHJhY2sgPSB0aGlzLmJhci5wYXJlbnROb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jbGlwcGVyID0gdGhpcy5zY3JvbGxlci5wYXJlbnROb2RlO1xuXG4gICAgICAgICAgICAvLyBQYXJhbWV0ZXJzXG4gICAgICAgICAgICB0aGlzLmRpcmVjdGlvbiA9IHBhcmFtcy5kaXJlY3Rpb247XG4gICAgICAgICAgICB0aGlzLm9yaWdpbiA9IG9yaWdpblt0aGlzLmRpcmVjdGlvbl07XG4gICAgICAgICAgICB0aGlzLmJhck9uQ2xzID0gcGFyYW1zLmJhck9uQ2xzO1xuICAgICAgICAgICAgdGhpcy5iYXJUb3BMaW1pdCA9IDA7XG4gICAgICAgICAgICBwYXVzZSA9IHBhcmFtcy5wYXVzZSAqIDEwMDAgfHwgMDtcblxuICAgICAgICAgICAgLy8gVXBkYXRpbmcgaGVpZ2h0IG9yIHdpZHRoIG9mIGJhclxuICAgICAgICAgICAgZnVuY3Rpb24gc2V0QmFyU2l6ZShzaXplKSB7XG4gICAgICAgICAgICAgICAgLyoganNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gICAgICAgICAgICAgICAgdmFyIGJhck1pblNpemUgPSB0aGlzLmJhck1pblNpemUgfHwgMjA7XG5cbiAgICAgICAgICAgICAgICBpZiAoc2l6ZSA+IDAgJiYgc2l6ZSA8IGJhck1pblNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgc2l6ZSA9IGJhck1pblNpemU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYmFyKSB7XG4gICAgICAgICAgICAgICAgICAgICQodGhpcy5iYXIpLmNzcyh0aGlzLm9yaWdpbi5zaXplLCBwYXJzZUludChzaXplLCAxMCkgKyAncHgnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFVwZGF0aW5nIHRvcCBvciBsZWZ0IGJhciBwb3NpdGlvblxuICAgICAgICAgICAgZnVuY3Rpb24gcG9zQmFyKHBvcykge1xuICAgICAgICAgICAgICAgIC8qIGpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmJhcikge1xuICAgICAgICAgICAgICAgICAgICAkKHRoaXMuYmFyKS5jc3ModGhpcy5vcmlnaW4ucG9zLCArcG9zICsgJ3B4Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBGcmVlIHBhdGggZm9yIGJhclxuICAgICAgICAgICAgZnVuY3Rpb24gaygpIHtcbiAgICAgICAgICAgICAgICAvKiBqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJhY2tbdGhpcy5vcmlnaW4uY2xpZW50XSAtIHRoaXMuYmFyVG9wTGltaXQgLSB0aGlzLmJhclt0aGlzLm9yaWdpbi5vZmZzZXRdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBSZWxhdGl2ZSBjb250ZW50IHRvcCBwb3NpdGlvbiB0byBiYXIgdG9wIHBvc2l0aW9uXG4gICAgICAgICAgICBmdW5jdGlvbiByZWxUb1BvcyhyKSB7XG4gICAgICAgICAgICAgICAgLyoganNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gICAgICAgICAgICAgICAgcmV0dXJuIHIgKiBrLmNhbGwodGhpcykgKyB0aGlzLmJhclRvcExpbWl0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBCYXIgcG9zaXRpb24gdG8gcmVsYXRpdmUgY29udGVudCBwb3NpdGlvblxuICAgICAgICAgICAgZnVuY3Rpb24gcG9zVG9SZWwodCkge1xuICAgICAgICAgICAgICAgIC8qIGpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICAgICAgICAgICAgICAgIHJldHVybiAodCAtIHRoaXMuYmFyVG9wTGltaXQpIC8gay5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDdXJzb3IgcG9zaXRpb24gaW4gbWFpbiBkaXJlY3Rpb24gaW4gcHggLy8gTm93IHdpdGggaU9zIHN1cHBvcnRcbiAgICAgICAgICAgIHRoaXMuY3Vyc29yID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlWydjbGllbnQnICsgdGhpcy5vcmlnaW4ueF0gfHwgKCgoZS5vcmlnaW5hbEV2ZW50IHx8IGUpLnRvdWNoZXMgfHwge30pWzBdIHx8IHt9KVsncGFnZScgKyB0aGlzLm9yaWdpbi54XTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIFRleHQgc2VsZWN0aW9uIHBvcyBwcmV2ZW50aW5nXG4gICAgICAgICAgICBmdW5jdGlvbiBkb250UG9zU2VsZWN0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5wb3MgPSBmdW5jdGlvbih4KSB7IC8vIEFic29sdXRlIHNjcm9sbGVyIHBvc2l0aW9uIGluIHB4XG4gICAgICAgICAgICAgICAgdmFyIGllID0gJ3BhZ2UnICsgdGhpcy5vcmlnaW4ueCArICdPZmZzZXQnLFxuICAgICAgICAgICAgICAgICAgICBrZXkgPSAodGhpcy5zY3JvbGxlcltpZV0pID8gaWUgOiB0aGlzLm9yaWdpbi5zY3JvbGw7XG5cbiAgICAgICAgICAgICAgICBpZiAoeCAhPT0gdW5kZWZpbmVkKSB0aGlzLnNjcm9sbGVyW2tleV0gPSB4O1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2Nyb2xsZXJba2V5XTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRoaXMucnBvcyA9IGZ1bmN0aW9uKHIpIHsgLy8gUmVsYXRpdmUgc2Nyb2xsZXIgcG9zaXRpb24gKDAuLjEpXG4gICAgICAgICAgICAgICAgdmFyIGZyZWUgPSB0aGlzLnNjcm9sbGVyW3RoaXMub3JpZ2luLnNjcm9sbFNpemVdIC0gdGhpcy5zY3JvbGxlclt0aGlzLm9yaWdpbi5jbGllbnRdLFxuICAgICAgICAgICAgICAgICAgICB4O1xuXG4gICAgICAgICAgICAgICAgaWYgKHIpIHggPSB0aGlzLnBvcyhyICogZnJlZSk7XG4gICAgICAgICAgICAgICAgZWxzZSB4ID0gdGhpcy5wb3MoKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB4IC8gKGZyZWUgfHwgMSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBTd2l0Y2ggb24gdGhlIGJhciBieSBhZGRpbmcgdXNlci1kZWZpbmVkIENTUyBjbGFzc25hbWUgdG8gc2Nyb2xsZXJcbiAgICAgICAgICAgIHRoaXMuYmFyT24gPSBmdW5jdGlvbihkaXNwb3NlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYmFyT25DbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpc3Bvc2UgfHwgdGhpcy5zY3JvbGxlclt0aGlzLm9yaWdpbi5jbGllbnRdID49IHRoaXMuc2Nyb2xsZXJbdGhpcy5vcmlnaW4uc2Nyb2xsU2l6ZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICQodGhpcy5yb290KS5yZW1vdmVDbGFzcyh0aGlzLmJhck9uQ2xzKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICQodGhpcy5yb290KS5hZGRDbGFzcyh0aGlzLmJhck9uQ2xzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRoaXMuX3BvczAgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgc2Nyb2xsZXJQb3MwID0gdGhpcy5jdXJzb3IoZSkgLSBiYXJQb3M7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0aGlzLmRyYWcgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxlclt0aGlzLm9yaWdpbi5zY3JvbGxdID0gcG9zVG9SZWwuY2FsbCh0aGlzLCB0aGlzLmN1cnNvcihlKSAtIHNjcm9sbGVyUG9zMCkgKiAodGhpcy5zY3JvbGxlclt0aGlzLm9yaWdpbi5zY3JvbGxTaXplXSAtIHRoaXMuc2Nyb2xsZXJbdGhpcy5vcmlnaW4uY2xpZW50XSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBUZXh0IHNlbGVjdGlvbiBwcmV2ZW50aW5nIG9uIGRyYWdcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uID0gZnVuY3Rpb24oZW5hYmxlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudChkb2N1bWVudCwgJ3NlbGVjdHBvcyBzZWxlY3RzdGFydCcsIGRvbnRQb3NTZWxlY3QsIGVuYWJsZSA/ICdvZmYnIDogJ29uJyk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBvblJlc2l6ZSAmIERPTSBtb2RpZmllZCBoYW5kbGVyXG4gICAgICAgICAgICB0aGlzLnJlc2l6ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgZGVsYXkgPSAwO1xuXG4gICAgICAgICAgICAgICAgaWYgKG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gcmVzaXplTGFzdEZpcmUgPCBwYXVzZSkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQocmVzaXplUGF1c2VUaW1lcik7XG4gICAgICAgICAgICAgICAgICAgIGRlbGF5ID0gcGF1c2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gdXBkKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGVsdGEgPSBzZWxmLnNjcm9sbGVyW3NlbGYub3JpZ2luLmNyb3NzT2Zmc2V0XSAtIHNlbGYuc2Nyb2xsZXJbc2VsZi5vcmlnaW4uY3Jvc3NDbGllbnRdO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuZnJlZXplICYmICFzZWxmLmNsaXBwZXIuc3R5bGVbc2VsZi5vcmlnaW4uY3Jvc3NTaXplXSkgeyAvLyBTb3VsZCBmaXJlIG9ubHkgb25jZVxuICAgICAgICAgICAgICAgICAgICAgICAgJChzZWxmLmNsaXBwZXIpLmNzcyhzZWxmLm9yaWdpbi5jcm9zc1NpemUsIHNlbGYuY2xpcHBlcltzZWxmLm9yaWdpbi5jcm9zc0NsaWVudF0gLSBkZWx0YSArICdweCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICQoc2VsZi5zY3JvbGxlcikuY3NzKHNlbGYub3JpZ2luLmNyb3NzU2l6ZSwgc2VsZi5jbGlwcGVyW3NlbGYub3JpZ2luLmNyb3NzQ2xpZW50XSArIGRlbHRhICsgJ3B4Jyk7XG5cbiAgICAgICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnVuc2hpZnQuY2FsbChhcmd1bWVudHMsICdyZXNpemUnKTtcbiAgICAgICAgICAgICAgICAgICAgZmlyZS5hcHBseShzZWxmLCBhcmd1bWVudHMpO1xuXG4gICAgICAgICAgICAgICAgICAgIHJlc2l6ZUxhc3RGaXJlID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGRlbGF5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc2l6ZVBhdXNlVGltZXIgPSBzZXRUaW1lb3V0KHVwZCwgZGVsYXkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHVwZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIG9uU2Nyb2xsIGhhbmRsZXJcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9sZEJhclNpemUsIG5ld0JhclNpemUsXG4gICAgICAgICAgICAgICAgICAgIGRlbGF5ID0gMCxcbiAgICAgICAgICAgICAgICAgICAgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgICBpZiAobmV3IERhdGUoKS5nZXRUaW1lKCkgLSBzY3JvbGxMYXN0RmlyZSA8IHBhdXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChzY3JvbGxQYXVzZVRpbWVyKTtcbiAgICAgICAgICAgICAgICAgICAgZGVsYXkgPSBwYXVzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiB1cGQoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmJhcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3QmFyU2l6ZSA9ICh0cmFja1tzZWxmLm9yaWdpbi5jbGllbnRdIC0gc2VsZi5iYXJUb3BMaW1pdCkgKiBzZWxmLnNjcm9sbGVyW3NlbGYub3JpZ2luLmNsaWVudF0gLyBzZWxmLnNjcm9sbGVyW3NlbGYub3JpZ2luLnNjcm9sbFNpemVdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQb3NpdGlvbmluZyBiYXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvbGRCYXJTaXplICE9IG5ld0JhclNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRCYXJTaXplLmNhbGwoc2VsZiwgbmV3QmFyU2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2xkQmFyU2l6ZSA9IG5ld0JhclNpemU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGJhclBvcyA9IHJlbFRvUG9zLmNhbGwoc2VsZiwgc2VsZi5ycG9zKCkpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NCYXIuY2FsbChzZWxmLCBiYXJQb3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnVuc2hpZnQuY2FsbCggYXJndW1lbnRzLCAnc2Nyb2xsJyApO1xuICAgICAgICAgICAgICAgICAgICBmaXJlLmFwcGx5KHNlbGYsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsTGFzdEZpcmUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoZGVsYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsUGF1c2VUaW1lciA9IHNldFRpbWVvdXQodXBkLCBkZWxheSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdXBkKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICB1cGRhdGU6IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICAgICAgZmlyZS5jYWxsKHRoaXMsICd1cGQnLCBwYXJhbXMpOyAvLyDQntCx0L3QvtCy0LvRj9C10Lwg0L/QsNGA0LDQvNC10YLRgNGLINCy0YHQtdGFINC/0LvQsNCz0LjQvdC+0LJcblxuICAgICAgICAgICAgdGhpcy5yZXNpemUoMSk7XG4gICAgICAgICAgICB0aGlzLmJhck9uKCk7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbCgpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBkaXNwb3NlOiBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgICAgIG1hbmFnZUV2ZW50cyh0aGlzLCB0aGlzLmV2ZW50LCAnb2ZmJyk7XG4gICAgICAgICAgICBtYW5hZ2VBdHRyKHRoaXMucm9vdCwgcGFyYW1zLmRpcmVjdGlvbiwgJ29mZicpO1xuICAgICAgICAgICAgJCh0aGlzLnNjcm9sbGVyKS5jc3ModGhpcy5vcmlnaW4uY3Jvc3NTaXplLCAnJyk7XG4gICAgICAgICAgICB0aGlzLmJhck9uKHRydWUpO1xuICAgICAgICAgICAgZmlyZS5jYWxsKHRoaXMsICdkaXNwb3NlJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb246IGZ1bmN0aW9uKGV2ZW50TmFtZSwgZnVuYywgYXJnKSB7XG4gICAgICAgICAgICB2YXIgbmFtZXMgPSBldmVudE5hbWUuc3BsaXQoJyAnKTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAgOyBpIDwgbmFtZXMubGVuZ3RoIDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWVzW2ldID09ICdpbml0Jykge1xuICAgICAgICAgICAgICAgICAgICBmdW5jLmNhbGwodGhpcywgYXJnKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmV2ZW50c1tuYW1lc1tpXV0gPSB0aGlzLmV2ZW50c1tuYW1lc1tpXV0gfHwgW107XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ldmVudHNbbmFtZXNbaV1dLnB1c2goZnVuY3Rpb24odXNlckFyZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnVuYy5jYWxsKHRoaXMsIHVzZXJBcmcgfHwgYXJnKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIGJhcm9uLmZuLmNvbnN0cnVjdG9yLnByb3RvdHlwZSA9IGJhcm9uLmZuO1xuICAgIGl0ZW0ucHJvdG90eXBlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSA9IGl0ZW0ucHJvdG90eXBlO1xuXG4gICAgLy8gVXNlIHdoZW4geW91IG5lZWQgXCJiYXJvblwiIGdsb2JhbCB2YXIgZm9yIGFub3RoZXIgcHVycG9zZXNcbiAgICBiYXJvbi5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHdpbmRvdy5iYXJvbiA9IF9iYXJvbjsgLy8gUmVzdG9yaW5nIG9yaWdpbmFsIHZhbHVlIG9mIFwiYmFyb25cIiBnbG9iYWwgdmFyXG5cbiAgICAgICAgcmV0dXJuIGJhcm9uO1xuICAgIH07XG5cbiAgICBiYXJvbi52ZXJzaW9uID0gJzAuNi42JztcblxuICAgIGlmICgkICYmICQuZm4pIHsgLy8gQWRkaW5nIGJhcm9uIHRvIGpRdWVyeSBhcyBwbHVnaW5cbiAgICAgICAgJC5mbi5iYXJvbiA9IGJhcm9uO1xuICAgIH1cbiAgICB3aW5kb3cuYmFyb24gPSBiYXJvbjsgLy8gVXNlIG5vQ29uZmxpY3QgbWV0aG9kIGlmIHlvdSBuZWVkIHdpbmRvdy5iYXJvbiB2YXIgZm9yIGFub3RoZXIgcHVycG9zZXNcbiAgICBpZiAod2luZG93Wydtb2R1bGUnXSAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGJhcm9uLm5vQ29uZmxpY3QoKTtcbiAgICB9XG59KSh3aW5kb3cpO1xuLyogRml4YWJsZSBlbGVtZW50cyBwbHVnaW4gZm9yIGJhcm9uIDAuNisgKi9cbihmdW5jdGlvbih3aW5kb3csIHVuZGVmaW5lZCkge1xuICAgIHZhciBmaXggPSBmdW5jdGlvbih1c2VyUGFyYW1zKSB7XG4gICAgICAgIHZhciBlbGVtZW50cywgdmlld1BvcnRTaXplLFxuICAgICAgICAgICAgcGFyYW1zID0geyAvLyBEZWZhdWx0IHBhcmFtc1xuICAgICAgICAgICAgICAgIG91dHNpZGU6ICcnLFxuICAgICAgICAgICAgICAgIGJlZm9yZTogJycsXG4gICAgICAgICAgICAgICAgYWZ0ZXI6ICcnLFxuICAgICAgICAgICAgICAgIHBhc3Q6ICcnLFxuICAgICAgICAgICAgICAgIGZ1dHVyZTogJycsXG4gICAgICAgICAgICAgICAgcmFkaXVzOiAwLFxuICAgICAgICAgICAgICAgIG1pblZpZXc6IDBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0b3BGaXhIZWlnaHRzID0gW10sIC8vIGlubGluZSBzdHlsZSBmb3IgZWxlbWVudFxuICAgICAgICAgICAgdG9wUmVhbEhlaWdodHMgPSBbXSwgLy8gcmVhbCBvZmZzZXQgcG9zaXRpb24gd2hlbiBub3QgZml4ZWRcbiAgICAgICAgICAgIGhlYWRlclRvcHMgPSBbXSxcbiAgICAgICAgICAgIHNjcm9sbGVyID0gdGhpcy5zY3JvbGxlcixcbiAgICAgICAgICAgIGV2ZW50TWFuYWdlciA9IHRoaXMuZXZlbnQsXG4gICAgICAgICAgICAkID0gdGhpcy4kLFxuICAgICAgICAgICAgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgZnVuY3Rpb24gZml4RWxlbWVudChpLCBwb3MpIHtcbiAgICAgICAgICAgIGlmICh2aWV3UG9ydFNpemUgPCAocGFyYW1zLm1pblZpZXcgfHwgMCkpIHsgLy8gTm8gaGVhZGVycyBmaXhpbmcgd2hlbiBubyBlbm91Z2h0IHNwYWNlIGZvciB2aWV3cG9ydFxuICAgICAgICAgICAgICAgIHBvcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHBvcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcG9zICs9ICdweCc7XG4gICAgICAgICAgICAgICAgdGhpcy4kKGVsZW1lbnRzW2ldKS5jc3ModGhpcy5vcmlnaW4ucG9zLCBwb3MpLmFkZENsYXNzKHBhcmFtcy5vdXRzaWRlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kKGVsZW1lbnRzW2ldKS5jc3ModGhpcy5vcmlnaW4ucG9zLCAnJykucmVtb3ZlQ2xhc3MocGFyYW1zLm91dHNpZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gYnViYmxlV2hlZWwoZSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ1doZWVsRXZlbnQnKTsgLy8gaSAtIGZvciBleHRyYSBieXRlXG4gICAgICAgICAgICAgICAgLy8gZXZ0LmluaXRXZWJLaXRXaGVlbEV2ZW50KGRlbHRhWCwgZGVsdGFZLCB3aW5kb3csIHNjcmVlblgsIHNjcmVlblksIGNsaWVudFgsIGNsaWVudFksIGN0cmxLZXksIGFsdEtleSwgc2hpZnRLZXksIG1ldGFLZXkpO1xuICAgICAgICAgICAgICAgIGkuaW5pdFdlYktpdFdoZWVsRXZlbnQoZS5vcmlnaW5hbEV2ZW50LndoZWVsRGVsdGFYLCBlLm9yaWdpbmFsRXZlbnQud2hlZWxEZWx0YVkpO1xuICAgICAgICAgICAgICAgIHNjcm9sbGVyLmRpc3BhdGNoRXZlbnQoaSk7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGluaXQoX3BhcmFtcykge1xuICAgICAgICAgICAgdmFyIHBvcztcblxuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIF9wYXJhbXMpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXNba2V5XSA9IF9wYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZWxlbWVudHMgPSB0aGlzLiQocGFyYW1zLmVsZW1lbnRzLCB0aGlzLnNjcm9sbGVyKTtcblxuICAgICAgICAgICAgaWYgKGVsZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgdmlld1BvcnRTaXplID0gdGhpcy5zY3JvbGxlclt0aGlzLm9yaWdpbi5jbGllbnRdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwIDsgaSA8IGVsZW1lbnRzLmxlbmd0aCA7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAvLyBWYXJpYWJsZSBoZWFkZXIgaGVpZ2h0c1xuICAgICAgICAgICAgICAgICAgICBwb3MgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgcG9zW3RoaXMub3JpZ2luLnNpemVdID0gZWxlbWVudHNbaV1bdGhpcy5vcmlnaW4ub2Zmc2V0XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnRzW2ldLnBhcmVudE5vZGUgIT09IHRoaXMuc2Nyb2xsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJChlbGVtZW50c1tpXS5wYXJlbnROb2RlKS5jc3MocG9zKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwb3MgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgcG9zW3RoaXMub3JpZ2luLmNyb3NzU2l6ZV0gPSBlbGVtZW50c1tpXS5wYXJlbnROb2RlW3RoaXMub3JpZ2luLmNyb3NzQ2xpZW50XTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kKGVsZW1lbnRzW2ldKS5jc3MocG9zKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBCZXR3ZWVuIGZpeGVkIGhlYWRlcnNcbiAgICAgICAgICAgICAgICAgICAgdmlld1BvcnRTaXplIC09IGVsZW1lbnRzW2ldW3RoaXMub3JpZ2luLm9mZnNldF07XG5cbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyVG9wc1tpXSA9IGVsZW1lbnRzW2ldLnBhcmVudE5vZGVbdGhpcy5vcmlnaW4ub2Zmc2V0UG9zXTsgLy8gTm8gcGFkZGluZ3MgZm9yIHBhcmVudE5vZGVcblxuICAgICAgICAgICAgICAgICAgICAvLyBTdW1tYXJ5IGVsZW1lbnRzIGhlaWdodCBhYm92ZSBjdXJyZW50XG4gICAgICAgICAgICAgICAgICAgIHRvcEZpeEhlaWdodHNbaV0gPSAodG9wRml4SGVpZ2h0c1tpIC0gMV0gfHwgMCk7IC8vIE5vdCB6ZXJvIGJlY2F1c2Ugb2YgbmVnYXRpdmUgbWFyZ2luc1xuICAgICAgICAgICAgICAgICAgICB0b3BSZWFsSGVpZ2h0c1tpXSA9ICh0b3BSZWFsSGVpZ2h0c1tpIC0gMV0gfHwgTWF0aC5taW4oaGVhZGVyVG9wc1tpXSwgMCkpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50c1tpIC0gMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcEZpeEhlaWdodHNbaV0gKz0gZWxlbWVudHNbaSAtIDFdW3RoaXMub3JpZ2luLm9mZnNldF07XG4gICAgICAgICAgICAgICAgICAgICAgICB0b3BSZWFsSGVpZ2h0c1tpXSArPSBlbGVtZW50c1tpIC0gMV1bdGhpcy5vcmlnaW4ub2Zmc2V0XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICggIShpID09IDAgJiYgaGVhZGVyVG9wc1tpXSA9PSAwKS8qICYmIGZvcmNlICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmV2ZW50KGVsZW1lbnRzW2ldLCAnbW91c2V3aGVlbCcsIGJ1YmJsZVdoZWVsLCAnb2ZmJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmV2ZW50KGVsZW1lbnRzW2ldLCAnbW91c2V3aGVlbCcsIGJ1YmJsZVdoZWVsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChwYXJhbXMubGltaXRlciAmJiBlbGVtZW50c1swXSkgeyAvLyBCb3R0b20gZWRnZSBvZiBmaXJzdCBoZWFkZXIgYXMgdG9wIGxpbWl0IGZvciB0cmFja1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy50cmFjayAmJiB0aGlzLnRyYWNrICE9IHRoaXMuc2Nyb2xsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zW3RoaXMub3JpZ2luLnBvc10gPSBlbGVtZW50c1swXS5wYXJlbnROb2RlW3RoaXMub3JpZ2luLm9mZnNldF07XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiQodGhpcy50cmFjaykuY3NzKHBvcyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJhclRvcExpbWl0ID0gZWxlbWVudHNbMF0ucGFyZW50Tm9kZVt0aGlzLm9yaWdpbi5vZmZzZXRdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMuYmFyVG9wTGltaXQgPSBlbGVtZW50c1swXS5wYXJlbnROb2RlW3RoaXMub3JpZ2luLm9mZnNldF07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5saW1pdGVyID09PSBmYWxzZSkgeyAvLyB1bmRlZmluZWQgKGluIHNlY29uZCBmaXggaW5zdGFuY2UpIHNob3VsZCBoYXZlIG5vIGluZmx1ZW5jZSBvbiBiYXIgbGltaXRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5iYXJUb3BMaW1pdCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZXZlbnQgPSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudDogZWxlbWVudHMsXG5cbiAgICAgICAgICAgICAgICBoYW5kbGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmVudCA9ICQodGhpcylbMF0ucGFyZW50Tm9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcCA9IHBhcmVudC5vZmZzZXRUb3AsXG4gICAgICAgICAgICAgICAgICAgICAgICBudW07XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gZmluZGluZyBudW0gLT4gZWxlbWVudHNbbnVtXSA9PT0gdGhpc1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCA7IGkgPCBlbGVtZW50cy5sZW5ndGggOyBpKysgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudHNbaV0gPT09IHRoaXMpIG51bSA9IGk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YXIgcG9zID0gdG9wIC0gdG9wRml4SGVpZ2h0c1tudW1dO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuc2Nyb2xsKSB7IC8vIFVzZXIgZGVmaW5lZCBjYWxsYmFja1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnNjcm9sbCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeDE6IHNlbGYuc2Nyb2xsZXIuc2Nyb2xsVG9wLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHgyOiBwb3NcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5zY3JvbGxlci5zY3JvbGxUb3AgPSBwb3M7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgdHlwZTogJ2NsaWNrJ1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKHBhcmFtcy5jbGlja2FibGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9ldmVudEhhbmRsZXJzLnB1c2goZXZlbnQpOyAvLyBGb3IgYXV0by1kaXNwb3NlXG4gICAgICAgICAgICAgICAgZXZlbnRNYW5hZ2VyKGV2ZW50LmVsZW1lbnQsIGV2ZW50LnR5cGUsIGV2ZW50LmhhbmRsZXIsICdvZmYnKTtcbiAgICAgICAgICAgICAgICBldmVudE1hbmFnZXIoZXZlbnQuZWxlbWVudCwgZXZlbnQudHlwZSwgZXZlbnQuaGFuZGxlciwgJ29uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm9uKCdpbml0JywgaW5pdCwgdXNlclBhcmFtcyk7XG5cbiAgICAgICAgdGhpcy5vbignaW5pdCBzY3JvbGwnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBmaXhTdGF0ZSwgaFRvcCxcbiAgICAgICAgICAgICAgICBmaXhGbGFnID0gW107IC8vIDEgLSBwYXN0LCAyIC0gZnV0dXJlLCAzIC0gY3VycmVudCAobm90IGZpeGVkKVxuXG4gICAgICAgICAgICBpZiAoZWxlbWVudHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hhbmdlO1xuXG4gICAgICAgICAgICAgICAgLy8gZml4RmxhZyB1cGRhdGVcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCA7IGkgPCBlbGVtZW50cy5sZW5ndGggOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZml4U3RhdGUgPSAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGVhZGVyVG9wc1tpXSAtIHRoaXMucG9zKCkgPCB0b3BSZWFsSGVpZ2h0c1tpXSArIHBhcmFtcy5yYWRpdXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhlYWRlciB0cnlpbmcgdG8gZ28gdXBcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpeFN0YXRlID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhUb3AgPSB0b3BGaXhIZWlnaHRzW2ldO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGhlYWRlclRvcHNbaV0gLSB0aGlzLnBvcygpID4gdG9wUmVhbEhlaWdodHNbaV0gKyB2aWV3UG9ydFNpemUgLSBwYXJhbXMucmFkaXVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBIZWFkZXIgdHJ5aW5nIHRvIGdvIGRvd25cbiAgICAgICAgICAgICAgICAgICAgICAgIGZpeFN0YXRlID0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhUb3AgPSB0b3BGaXhIZWlnaHRzW2ldICsgdmlld1BvcnRTaXplO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSGVhZGVyIGluIHZpZXdwb3J0XG4gICAgICAgICAgICAgICAgICAgICAgICBmaXhTdGF0ZSA9IDM7XG4gICAgICAgICAgICAgICAgICAgICAgICBoVG9wID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaXhTdGF0ZSAhPSBmaXhGbGFnW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaXhFbGVtZW50LmNhbGwodGhpcywgaSwgaFRvcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaXhGbGFnW2ldID0gZml4U3RhdGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gQWRkaW5nIHBvc2l0aW9uaW5nIGNsYXNzZXMgKG9uIGxhc3QgdG9wIGFuZCBmaXJzdCBib3R0b20gaGVhZGVyKVxuICAgICAgICAgICAgICAgIGlmIChjaGFuZ2UpIHsgLy8gQXQgbGVhdHMgb25lIGNoYW5nZSBpbiBlbGVtZW50cyBmbGFnIHN0cnVjdHVyZSBvY2N1cmVkXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDAgOyBpIDwgZWxlbWVudHMubGVuZ3RoIDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZml4RmxhZ1tpXSA9PSAxICYmIHBhcmFtcy5wYXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kKGVsZW1lbnRzW2ldKS5hZGRDbGFzcyhwYXJhbXMucGFzdCkucmVtb3ZlQ2xhc3MocGFyYW1zLmZ1dHVyZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaXhGbGFnW2ldID09IDIgJiYgcGFyYW1zLmZ1dHVyZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJChlbGVtZW50c1tpXSkuYWRkQ2xhc3MocGFyYW1zLmZ1dHVyZSkucmVtb3ZlQ2xhc3MocGFyYW1zLnBhc3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZml4RmxhZ1tpXSA9PSAzICYmIChwYXJhbXMuZnV0dXJlIHx8IHBhcmFtcy5wYXN0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJChlbGVtZW50c1tpXSkucmVtb3ZlQ2xhc3MocGFyYW1zLnBhc3QpLnJlbW92ZUNsYXNzKHBhcmFtcy5mdXR1cmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZml4RmxhZ1tpXSAhPSBmaXhGbGFnW2kgKyAxXSAmJiBmaXhGbGFnW2ldID09IDEgJiYgcGFyYW1zLmJlZm9yZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJChlbGVtZW50c1tpXSkuYWRkQ2xhc3MocGFyYW1zLmJlZm9yZSkucmVtb3ZlQ2xhc3MocGFyYW1zLmFmdGVyKTsgLy8gTGFzdCB0b3AgZml4ZWQgaGVhZGVyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGZpeEZsYWdbaV0gIT0gZml4RmxhZ1tpIC0gMV0gJiYgZml4RmxhZ1tpXSA9PSAyICYmIHBhcmFtcy5hZnRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJChlbGVtZW50c1tpXSkuYWRkQ2xhc3MocGFyYW1zLmFmdGVyKS5yZW1vdmVDbGFzcyhwYXJhbXMuYmVmb3JlKTsgLy8gRmlyc3QgYm90dG9tIGZpeGVkIGhlYWRlclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiQoZWxlbWVudHNbaV0pLnJlbW92ZUNsYXNzKHBhcmFtcy5iZWZvcmUpLnJlbW92ZUNsYXNzKHBhcmFtcy5hZnRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMub24oJ3Jlc2l6ZSB1cGQnLCBmdW5jdGlvbih1cGRQYXJhbXMpIHtcbiAgICAgICAgICAgIGluaXQuY2FsbCh0aGlzLCB1cGRQYXJhbXMgJiYgdXBkUGFyYW1zLmZpeCk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBiYXJvbi5mbi5maXggPSBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgdmFyIGkgPSAwO1xuXG4gICAgICAgIHdoaWxlICh0aGlzW2ldKSB7XG4gICAgICAgICAgICBmaXguY2FsbCh0aGlzW2ldLCBwYXJhbXMpO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbn0pKHdpbmRvdyk7XG4vKiBDb250cm9scyBwbHVnaW4gZm9yIGJhcm9uIDAuNisgKi9cbihmdW5jdGlvbih3aW5kb3csIHVuZGVmaW5lZCkge1xuICAgIHZhciBjb250cm9scyA9IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICB2YXIgZm9yd2FyZCwgYmFja3dhcmQsIHRyYWNrLCBzY3JlZW4sXG4gICAgICAgICAgICBzZWxmID0gdGhpczsgLy8gQUFBQUFBISEhISExMVxuXG4gICAgICAgIHNjcmVlbiA9IHBhcmFtcy5zY3JlZW4gfHwgMC45O1xuXG4gICAgICAgIGlmIChwYXJhbXMuZm9yd2FyZCkge1xuICAgICAgICAgICAgZm9yd2FyZCA9IHRoaXMuJChwYXJhbXMuZm9yd2FyZCwgdGhpcy5jbGlwcGVyKTtcblxuICAgICAgICAgICAgdGhpcy5ldmVudChmb3J3YXJkLCAnY2xpY2snLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgeSA9IHNlbGYucG9zKCkgLSBwYXJhbXMuZGVsdGEgfHwgMzA7XG5cbiAgICAgICAgICAgICAgICBzZWxmLnBvcyh5KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhcmFtcy5iYWNrd2FyZCkge1xuICAgICAgICAgICAgYmFja3dhcmQgPSB0aGlzLiQocGFyYW1zLmJhY2t3YXJkLCB0aGlzLmNsaXBwZXIpO1xuXG4gICAgICAgICAgICB0aGlzLmV2ZW50KGJhY2t3YXJkLCAnY2xpY2snLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgeSA9IHNlbGYucG9zKCkgKyBwYXJhbXMuZGVsdGEgfHwgMzA7XG5cbiAgICAgICAgICAgICAgICBzZWxmLnBvcyh5KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhcmFtcy50cmFjaykge1xuICAgICAgICAgICAgaWYgKHBhcmFtcy50cmFjayA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHRyYWNrID0gdGhpcy50cmFjaztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJhY2sgPSB0aGlzLiQocGFyYW1zLnRyYWNrLCB0aGlzLmNsaXBwZXIpWzBdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHJhY2spIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50KHRyYWNrLCAnbW91c2Vkb3duJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgeCA9IGVbJ29mZnNldCcgKyBzZWxmLm9yaWdpbi54XSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHhCYXIgPSBzZWxmLmJhcltzZWxmLm9yaWdpbi5vZmZzZXRQb3NdLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2lnbiA9IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHggPCB4QmFyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaWduID0gLTE7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoeCA+IHhCYXIgKyBzZWxmLmJhcltzZWxmLm9yaWdpbi5vZmZzZXRdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaWduID0gMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhciB5ID0gc2VsZi5wb3MoKSArIHNpZ24gKiBzY3JlZW4gKiBzZWxmLnNjcm9sbGVyW3NlbGYub3JpZ2luLmNsaWVudF07XG4gICAgICAgICAgICAgICAgICAgIHNlbGYucG9zKHkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgYmFyb24uZm4uY29udHJvbHMgPSBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgdmFyIGkgPSAwO1xuXG4gICAgICAgIHdoaWxlICh0aGlzW2ldKSB7XG4gICAgICAgICAgICBjb250cm9scy5jYWxsKHRoaXNbaV0sIHBhcmFtcyk7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xufSkod2luZG93KTtcbi8qIFB1bGwgdG8gbG9hZCBwbHVnaW4gZm9yIGJhcm9uIDAuNisgKi9cbihmdW5jdGlvbih3aW5kb3csIHVuZGVmaW5lZCkge1xuICAgIHZhciBwdWxsID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIHZhciBibG9jayA9IHRoaXMuJChwYXJhbXMuYmxvY2spLFxuICAgICAgICAgICAgc2l6ZSA9IHBhcmFtcy5zaXplIHx8IHRoaXMub3JpZ2luLnNpemUsXG4gICAgICAgICAgICBsaW1pdCA9IHBhcmFtcy5saW1pdCB8fCA4MCxcbiAgICAgICAgICAgIG9uRXhwYW5kID0gcGFyYW1zLm9uRXhwYW5kLFxuICAgICAgICAgICAgZWxlbWVudHMgPSBwYXJhbXMuZWxlbWVudHMgfHwgW10sXG4gICAgICAgICAgICBpblByb2dyZXNzID0gcGFyYW1zLmluUHJvZ3Jlc3MgfHwgJycsXG4gICAgICAgICAgICBzZWxmID0gdGhpcyxcbiAgICAgICAgICAgIF9pbnNpc3RlbmNlID0gMCxcbiAgICAgICAgICAgIF96ZXJvWENvdW50ID0gMCxcbiAgICAgICAgICAgIF9pbnRlcnZhbCxcbiAgICAgICAgICAgIF90aW1lcixcbiAgICAgICAgICAgIF94ID0gMCxcbiAgICAgICAgICAgIF9vbkV4cGFuZENhbGxlZCxcbiAgICAgICAgICAgIF93YWl0aW5nID0gcGFyYW1zLndhaXRpbmcgfHwgNTAwLFxuICAgICAgICAgICAgX29uO1xuXG4gICAgICAgIGZ1bmN0aW9uIGdldFNpemUoKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5zY3JvbGxlcltzZWxmLm9yaWdpbi5zY3JvbGxdICsgc2VsZi5zY3JvbGxlcltzZWxmLm9yaWdpbi5vZmZzZXRdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2Nyb2xsZXIgY29udGVudCBoZWlnaHRcbiAgICAgICAgZnVuY3Rpb24gZ2V0Q29udGVudFNpemUoKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5zY3JvbGxlcltzZWxmLm9yaWdpbi5zY3JvbGxTaXplXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNjcm9sbGVyIGhlaWdodFxuICAgICAgICBmdW5jdGlvbiBnZXRTY3JvbGxlclNpemUoKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5zY3JvbGxlcltzZWxmLm9yaWdpbi5jbGllbnRdO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gc3RlcCh4LCBmb3JjZSkge1xuICAgICAgICAgICAgdmFyIGsgPSB4ICogMC4wMDA1O1xuXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihmb3JjZSAtIGsgKiAoeCArIDU1MCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gdG9nZ2xlKG9uKSB7XG4gICAgICAgICAgICBfb24gPSBvbjtcblxuICAgICAgICAgICAgaWYgKG9uKSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlKCk7IC8vIEZpcnN0IHRpbWUgd2l0aCBubyBkZWxheVxuICAgICAgICAgICAgICAgIF9pbnRlcnZhbCA9IHNldEludGVydmFsKHVwZGF0ZSwgMjAwKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChfaW50ZXJ2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgICAgICAgICAgdmFyIHBvcyA9IHt9LFxuICAgICAgICAgICAgICAgIGhlaWdodCA9IGdldFNpemUoKSxcbiAgICAgICAgICAgICAgICBzY3JvbGxIZWlnaHQgPSBnZXRDb250ZW50U2l6ZSgpLFxuICAgICAgICAgICAgICAgIGR4LFxuICAgICAgICAgICAgICAgIG9wNCxcbiAgICAgICAgICAgICAgICBzY3JvbGxJblByb2dyZXNzID0gX2luc2lzdGVuY2UgPT0gMTtcblxuICAgICAgICAgICAgb3A0ID0gMDsgLy8g0JLQvtC30LLRgNCw0YnQsNGO0YnQsNGPINGB0LjQu9CwXG4gICAgICAgICAgICBpZiAoX2luc2lzdGVuY2UgPiAwKSB7XG4gICAgICAgICAgICAgICAgb3A0ID0gNDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL2lmIChfaW5zaXN0ZW5jZSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgZHggPSBzdGVwKF94LCBvcDQpO1xuICAgICAgICAgICAgICAgIGlmIChoZWlnaHQgPj0gc2Nyb2xsSGVpZ2h0IC0gX3ggJiYgX2luc2lzdGVuY2UgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2Nyb2xsSW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3ggKz0gZHg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBfeCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKF94IDwgMCkgX3ggPSAwO1xuXG4gICAgICAgICAgICAgICAgcG9zW3NpemVdID0gX3ggKyAncHgnO1xuICAgICAgICAgICAgICAgIGlmIChnZXRTY3JvbGxlclNpemUoKSA8PSBnZXRDb250ZW50U2l6ZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuJChibG9jaykuY3NzKHBvcyk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwIDsgaSA8IGVsZW1lbnRzLmxlbmd0aCA7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi4kKGVsZW1lbnRzW2ldLnNlbGYpLmNzcyhlbGVtZW50c1tpXS5wcm9wZXJ0eSwgTWF0aC5taW4oX3ggLyBsaW1pdCAqIDEwMCwgMTAwKSArICclJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaW5Qcm9ncmVzcyAmJiBfeCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLiQoc2VsZi5yb290KS5hZGRDbGFzcyhpblByb2dyZXNzKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoX3ggPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLm9uQ29sbGFwc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy5vbkNvbGxhcHNlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBfaW5zaXN0ZW5jZSA9IDA7XG4gICAgICAgICAgICAgICAgX3RpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgX2luc2lzdGVuY2UgPSAtMTtcbiAgICAgICAgICAgICAgICB9LCBfd2FpdGluZyk7XG4gICAgICAgICAgICAvL31cblxuICAgICAgICAgICAgaWYgKG9uRXhwYW5kICYmIF94ID4gbGltaXQgJiYgIV9vbkV4cGFuZENhbGxlZCkge1xuICAgICAgICAgICAgICAgIG9uRXhwYW5kKCk7XG4gICAgICAgICAgICAgICAgX29uRXhwYW5kQ2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKF94ID09IDApIHtcbiAgICAgICAgICAgICAgICBfemVyb1hDb3VudCsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBfemVyb1hDb3VudCA9IDA7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfemVyb1hDb3VudCA+IDEpIHtcbiAgICAgICAgICAgICAgICB0b2dnbGUoZmFsc2UpO1xuICAgICAgICAgICAgICAgIF9vbkV4cGFuZENhbGxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmIChpblByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuJChzZWxmLnJvb3QpLnJlbW92ZUNsYXNzKGluUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMub24oJ2luaXQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRvZ2dsZSh0cnVlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5vbignZGlzcG9zZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdG9nZ2xlKGZhbHNlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5ldmVudCh0aGlzLnNjcm9sbGVyLCAnbW91c2V3aGVlbCBET01Nb3VzZVNjcm9sbCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIHZhciBkb3duID0gZS53aGVlbERlbHRhIDwgMCB8fCAoZS5vcmlnaW5hbEV2ZW50ICYmIGUub3JpZ2luYWxFdmVudC53aGVlbERlbHRhIDwgMCkgfHwgZS5kZXRhaWwgPiAwO1xuXG4gICAgICAgICAgICBpZiAoZG93bikge1xuICAgICAgICAgICAgICAgIF9pbnNpc3RlbmNlID0gMTtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoX3RpbWVyKTtcbiAgICAgICAgICAgICAgICBpZiAoIV9vbiAmJiBnZXRTaXplKCkgPj0gZ2V0Q29udGVudFNpemUoKSkge1xuICAgICAgICAgICAgICAgICAgICB0b2dnbGUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gIGVsc2Uge1xuICAgICAgICAgICAgLy8gICAgIHRvZ2dsZShmYWxzZSk7XG4gICAgICAgICAgICAvLyB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBiYXJvbi5mbi5wdWxsID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIHZhciBpID0gMDtcblxuICAgICAgICB3aGlsZSAodGhpc1tpXSkge1xuICAgICAgICAgICAgcHVsbC5jYWxsKHRoaXNbaV0sIHBhcmFtcyk7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xufSkod2luZG93KTtcbiIsIi8vIDJHSVMtcmVsYXRlZCBwb3B1cCBjb250ZW50IHdyYXBwZXIgYW5kIG9mZnNldFxuKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb2Zmc2V0WCA9IERHLmNvbmZpZ1RoZW1lLmJhbGxvb25PcHRpb25zLm9mZnNldC54LFxuICAgICAgICBvZmZzZXRZID0gREcuY29uZmlnVGhlbWUuYmFsbG9vbk9wdGlvbnMub2Zmc2V0LnksXG4gICAgICAgIG9yaWdpbmFsSW5pdGlhbGl6ZSA9IERHLlBvcHVwLnByb3RvdHlwZS5pbml0aWFsaXplLFxuICAgICAgICBvcmlnaW5hbEluaXRMYXlvdXQgPSBERy5Qb3B1cC5wcm90b3R5cGUuX2luaXRMYXlvdXQsXG4gICAgICAgIG9yaWdpbmFsT25BZGQgPSBERy5Qb3B1cC5wcm90b3R5cGUub25BZGQsXG4gICAgICAgIG9yaWdpbmFsQWRqdXN0UGFuID0gREcuUG9wdXAucHJvdG90eXBlLl9hZGp1c3RQYW4sXG4gICAgICAgIGdyYWYgPSBiYXJvbi5ub0NvbmZsaWN0KCk7XG5cbiAgICB2YXIgQmFyb25Eb21IZWxwZXIgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICB0aGlzWzBdID0gZWxlbWVudDtcbiAgICAgICAgdGhpcy5sZW5ndGggPSAxO1xuICAgIH07XG4gICAgQmFyb25Eb21IZWxwZXIucHJvdG90eXBlID0ge1xuICAgICAgICBzZXRBdHRyaWJ1dGU6IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgICAgICAgICAgdGhpc1swXS5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIGdldEF0dHJpYnV0ZTogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzWzBdLmdldEF0dHJpYnV0ZShuYW1lKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlQXR0cmlidXRlOiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgdGhpc1swXS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgY3NzOiBmdW5jdGlvbiAoc3R5bGUsIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzWzBdLnN0eWxlW3N0eWxlXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gREcuRG9tVXRpbC5nZXRTdHlsZSh0aGlzWzBdLCBzdHlsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgREcuUG9wdXAucHJvdG90eXBlLm9wdGlvbnMub2Zmc2V0ID0gREcucG9pbnQob2Zmc2V0WCwgb2Zmc2V0WSk7XG5cbiAgICBERy5Qb3B1cC5tZXJnZU9wdGlvbnMoe1xuICAgICAgICBib3JkZXI6IDE2LFxuICAgICAgICBtYXBDb250cm9sc1dpZHRoOiA2MFxuICAgIH0pO1xuXG4gICAgREcuUG9wdXAuaW5jbHVkZSh7XG4gICAgICAgIF9oZWFkZXJDb250ZW50OiBudWxsLFxuICAgICAgICBfZm9vdGVyQ29udGVudDogbnVsbCxcblxuICAgICAgICAvL2Jhcm9uIGVsZW1lbnRzIHJlZmVyZW5jZXNcbiAgICAgICAgX3Njcm9sbGVyOiBudWxsLFxuICAgICAgICBfc2Nyb2xsZXJCYXI6IG51bGwsXG4gICAgICAgIF9iYXJXcmFwcGVyOiBudWxsLFxuICAgICAgICBfYmFyb246IG51bGwsXG4gICAgICAgIF9pc0Jhcm9uRXhpc3Q6IGZhbHNlLFxuXG4gICAgICAgIF9wb3B1cFNob3dDbGFzczogJ2xlYWZsZXQtcG9wdXBfc2hvd190cnVlJyxcbiAgICAgICAgX3BvcHVwSGlkZUNsYXNzOiAnbGVhZmxldC1wb3B1cF9zaG93X2ZhbHNlJyxcblxuICAgICAgICBfcG9wdXBUaXBDbGFzczogJ2xlYWZsZXQtcG9wdXAtdGlwLWNvbnRhaW5lcicsXG4gICAgICAgIF90aXBTVkdQYXRoOiAnTTAgMGMxMi42NDMgMCAyOCA3LjExNSAyOCA0NGgyYzAtMzYuODg1IDE1LjM1OC00NCAyOC00NGgtNTh6JyxcblxuICAgICAgICBfaXNBdXRvUGFuUGFkZGluZ1VzZXJEZWZpbmVkOiBmYWxzZSxcblxuICAgICAgICBpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucywgc291cmNlKSB7IC8vIChPYmplY3QsIE9iamVjdClcbiAgICAgICAgICAgIHRoaXMuX3BvcHVwU3RydWN0dXJlID0ge307XG4gICAgICAgICAgICB0aGlzLl9pc0F1dG9QYW5QYWRkaW5nVXNlckRlZmluZWQgPSBvcHRpb25zICYmIG9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ2F1dG9QYW5QYWRkaW5nJyk7XG4gICAgICAgICAgICBvcmlnaW5hbEluaXRpYWxpemUuY2FsbCh0aGlzLCBvcHRpb25zLCBzb3VyY2UpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7IC8vIChNYXApXG4gICAgICAgICAgICBtYXAub24oJ2VudHJhbmNlc2hvdycsIHRoaXMuX2Nsb3NlUG9wdXAsIHRoaXMpO1xuICAgICAgICAgICAgb3JpZ2luYWxPbkFkZC5jYWxsKHRoaXMsIG1hcCk7XG4gICAgICAgICAgICB0aGlzLl9hbmltYXRlT3BlbmluZygpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7IC8vIChNYXApXG4gICAgICAgICAgICB0aGlzLl9hbmltYXRlQ2xvc2luZygpO1xuICAgICAgICAgICAgbWFwLm9mZignZW50cmFuY2VzaG93JywgdGhpcy5fY2xvc2VQb3B1cCwgdGhpcyk7XG5cbiAgICAgICAgICAgIGlmIChERy5Eb21VdGlsLlRSQU5TSVRJT04pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmVUaW1lb3V0ID0gc2V0VGltZW91dChMLmJpbmQoTC5Eb21VdGlsLnJlbW92ZSwgTC5Eb21VdGlsLCB0aGlzLl9jb250YWluZXIpLCAyMDApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBMLkRvbVV0aWwucmVtb3ZlKHRoaXMuX2NvbnRhaW5lcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1hcC5maXJlKCdwb3B1cGNsb3NlJywge3BvcHVwOiB0aGlzfSk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9zb3VyY2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zb3VyY2UuZmlyZSgncG9wdXBjbG9zZScsIHtwb3B1cDogdGhpc30sIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHNldENvbnRlbnQ6IGZ1bmN0aW9uIChjb250ZW50KSB7IC8vIChET01FbGVtZW50IHwgT2JqZWN0IHwgSFRNTCkgLT4gUG9wdXBcbiAgICAgICAgICAgIGlmICghdGhpcy5faXNOb2RlKGNvbnRlbnQpICYmIHR5cGVvZiBjb250ZW50ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKGNvbnRlbnQpLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1snXycgKyBpdGVtICsgJ0NvbnRlbnQnXSA9IGNvbnRlbnRbaXRlbV07XG4gICAgICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2JvZHlDb250ZW50ID0gY29udGVudDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0SGVhZGVyQ29udGVudDogZnVuY3Rpb24gKGNvbnRlbnQpIHsgLy8gKEhUTUwpIC0+IFBvcHVwXG4gICAgICAgICAgICB0aGlzLl9oZWFkZXJDb250ZW50ID0gY29udGVudDtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldEZvb3RlckNvbnRlbnQ6IGZ1bmN0aW9uIChjb250ZW50KSB7IC8vIChIVE1MKSAtPiBQb3B1cFxuICAgICAgICAgICAgdGhpcy5fZm9vdGVyQ29udGVudCA9IGNvbnRlbnQ7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRDb250ZW50OiBmdW5jdGlvbigpIHsgLy8gKCkgLT4gSFRNTFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2JvZHlDb250ZW50O1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldEhlYWRlckNvbnRlbnQ6IGZ1bmN0aW9uKCkgeyAvLyAoKSAtPiBIVE1MXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faGVhZGVyQ29udGVudDtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRGb290ZXJDb250ZW50OiBmdW5jdGlvbigpIHsgLy8gKCkgLT4gSFRNTFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Zvb3RlckNvbnRlbnQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2xlYXI6IGZ1bmN0aW9uICgpIHsgLy8gKCkgLT4gUG9wdXBcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHRoaXMuX3BvcHVwU3RydWN0dXJlKS5mb3JFYWNoKHRoaXMuX2NsZWFyRWxlbWVudCwgdGhpcyk7XG5cbiAgICAgICAgICAgIC8vIHRoaW5rIGFib3V0IG1vdmUgdGhpcyBzZXQgdG8gYW5vdGhlciBwdWJsaWMgbWV0aG9kXG4gICAgICAgICAgICB0aGlzLl9pc0Jhcm9uRXhpc3QgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNsZWFySGVhZGVyOiBmdW5jdGlvbiAoKSB7IC8vICgpIC0+IFBvcHVwXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2xlYXJFbGVtZW50KCdoZWFkZXInKTtcbiAgICAgICAgfSxcblxuICAgICAgICBjbGVhckZvb3RlcjogZnVuY3Rpb24gKCkgeyAvLyAoKSAtPiBQb3B1cFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NsZWFyRWxlbWVudCgnZm9vdGVyJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluZEVsZW1lbnQ6IGZ1bmN0aW9uIChlbGVtZW50KSB7IC8vIChTdHJpbmcpIC0+IERPTUVsZW1lbnRcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb250ZW50Tm9kZS5xdWVyeVNlbGVjdG9yKGVsZW1lbnQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9hbmltYXRlT3BlbmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgREcuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9pbm5lckNvbnRhaW5lciwgdGhpcy5fcG9wdXBTaG93Q2xhc3MpO1xuICAgICAgICAgICAgREcuRG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9pbm5lckNvbnRhaW5lciwgdGhpcy5fcG9wdXBIaWRlQ2xhc3MpO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9hbmltYXRlQ2xvc2luZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgREcuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9pbm5lckNvbnRhaW5lciwgdGhpcy5fcG9wdXBIaWRlQ2xhc3MpO1xuICAgICAgICAgICAgREcuRG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9pbm5lckNvbnRhaW5lciwgdGhpcy5fcG9wdXBTaG93Q2xhc3MpO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9jbG9zZVBvcHVwOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9tYXAuY2xvc2VQb3B1cCh0aGlzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBfaXNOb2RlOiBmdW5jdGlvbiAobykgeyAvLyAoT2JqZWN0KSAtPiBCb29sZWFuXG4gICAgICAgICAgICByZXR1cm4gKG8ubm9kZU5hbWUgPyB0cnVlIDogZmFsc2UpO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9pbml0TGF5b3V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBvcmlnaW5hbEluaXRMYXlvdXQuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX2lubmVyQ29udGFpbmVyID0gREcuRG9tVXRpbC5jcmVhdGUoJ2RpdicsICdsZWFmbGV0LXBvcHVwLWlubmVyICcgKyB0aGlzLl9wb3B1cEhpZGVDbGFzcywgdGhpcy5fY29udGFpbmVyKTtcblxuICAgICAgICAgICAgLy8gUHJldmVudHMgbW91c2UgZXZlbnRzIGZyb20gbGVha2luZyB0aHJvdWdoIGNsb3NlIGJ1dHRvblxuICAgICAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS8yZ2lzL21hcHNhcGkvcHVsbC8xNTMvXG4gICAgICAgICAgICBERy5Eb21FdmVudC5kaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbih0aGlzLl9pbm5lckNvbnRhaW5lcik7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuY2xvc2VCdXR0b24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbm5lckNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLl9kZXRhY2hFbCh0aGlzLl9jbG9zZUJ1dHRvbikpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9pbm5lckNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLl9kZXRhY2hFbCh0aGlzLl93cmFwcGVyKSk7XG5cbiAgICAgICAgICAgIHZhciB0aXAgPSB0aGlzLl9kZXRhY2hFbCh0aGlzLl90aXBDb250YWluZXIpO1xuXG4gICAgICAgICAgICBpZiAoREcuQnJvd3Nlci5zdmcpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGF0aCA9IERHLlNWRy5jcmVhdGUoJ3BhdGgnKTtcbiAgICAgICAgICAgICAgICB2YXIgc3ZnQ2xhc3MgPSB0aGlzLl9wb3B1cFRpcENsYXNzICsgJyAnICsgdGhpcy5fcG9wdXBUaXBDbGFzcyArICdfc3ZnJztcblxuICAgICAgICAgICAgICAgIHBhdGguc2V0QXR0cmlidXRlKCdkJywgdGhpcy5fdGlwU1ZHUGF0aCk7XG5cbiAgICAgICAgICAgICAgICB0aXAgPSBERy5TVkcuY3JlYXRlKCdzdmcnKTtcbiAgICAgICAgICAgICAgICB0aXAuc2V0QXR0cmlidXRlKCdjbGFzcycsIHN2Z0NsYXNzKTtcblxuICAgICAgICAgICAgICAgIHRpcC5hcHBlbmRDaGlsZChwYXRoKTtcbiAgICAgICAgICAgICAgICBERy5Eb21FdmVudC5kaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbihwYXRoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgREcuRG9tVXRpbC5hZGRDbGFzcyh0aXAsIHRoaXMuX3BvcHVwVGlwQ2xhc3MgKyAnX2ltYWdlJyk7XG4gICAgICAgICAgICAgICAgREcuRG9tRXZlbnQuZGlzYWJsZUNsaWNrUHJvcGFnYXRpb24odGlwKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5faW5uZXJDb250YWluZXIuYXBwZW5kQ2hpbGQodGlwKTtcbiAgICAgICAgfSxcblxuICAgICAgICBfY2xlYXJFbGVtZW50OiBmdW5jdGlvbiAoZWxlbSkgeyAvLyAoRE9NRWxlbWVudCkgLT4gUG9wdXBcbiAgICAgICAgICAgIHRoaXNbJ18nICsgZWxlbSArICdDb250ZW50J10gPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fZGV0YWNoRWwodGhpcy5fcG9wdXBTdHJ1Y3R1cmVbZWxlbV0pO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3BvcHVwU3RydWN0dXJlW2VsZW1dO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX3VwZGF0ZVNjcm9sbFBvc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fYmFyb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9iYXJvbi51cGRhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICByZXNpemU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzY3JvbGxlZCA9IHRoaXMuX3VwZGF0ZUxheW91dCgpO1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlUG9zaXRpb24oKTtcblxuICAgICAgICAgICAgaWYgKCFzY3JvbGxlZCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pc0Jhcm9uRXhpc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2Nyb2xsZXJXcmFwcGVyLnN0eWxlLmhlaWdodCA9ICcnO1xuICAgICAgICAgICAgICAgICAgICBERy5Eb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX3Njcm9sbGVyLCAnZGctc2Nyb2xsZXInKTtcblxuICAgICAgICAgICAgICAgICAgICBERy5Eb21VdGlsLmFkZENsYXNzKHRoaXMuX3Njcm9sbGVyLCAnZGctc2Nyb2xsZXJfaGlkZGVuX3RydWUnKTtcbiAgICAgICAgICAgICAgICAgICAgREcuRG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9zY3JvbGxlciwgJ2RnLXNjcm9sbGVyJyk7XG4gICAgICAgICAgICAgICAgICAgIERHLkRvbUV2ZW50Lm9mZih0aGlzLl9zY3JvbGxlciwgJ3Njcm9sbCcsIHRoaXMuX29uU2Nyb2xsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2lzQmFyb25FeGlzdCkge1xuICAgICAgICAgICAgICAgIERHLkRvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fc2Nyb2xsZXIsICdkZy1zY3JvbGxlcl9oaWRkZW5fdHJ1ZScpO1xuICAgICAgICAgICAgICAgIERHLkRvbVV0aWwuYWRkQ2xhc3ModGhpcy5fc2Nyb2xsZXIsICdkZy1zY3JvbGxlcicpO1xuXG4gICAgICAgICAgICAgICAgdmFyIHNjcm9sbFRvcCA9IHRoaXMuX2lzQmFyb25FeGlzdCA/IHRoaXMuX3Njcm9sbGVyLnNjcm9sbFRvcCA6IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgaWYgKHNjcm9sbFRvcCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zY3JvbGxlci5zY3JvbGxUb3AgPSBzY3JvbGxUb3A7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGlubmVySGVpZ2h0ID0gdGhpcy5vcHRpb25zLm1heEhlaWdodCAtIHRoaXMub3B0aW9ucy5ib3JkZXIgKiAyIC0gdGhpcy5fZ2V0RGVsdGEoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zY3JvbGxlcldyYXBwZXIuc3R5bGUuaGVpZ2h0ID0gaW5uZXJIZWlnaHQgKyAncHgnO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlU2Nyb2xsUG9zaXRpb24oKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5pdEJhcm9uU2Nyb2xsZXIoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbml0QmFyb24oKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fYWRqdXN0UGFuKCk7XG4gICAgICAgICAgICB0aGlzLl9iaW5kQWRqdXN0UGFuT25UcmFuc2l0aW9uRW5kKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2FkanVzdFBhbjogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fbWFwKSB7IHJldHVybjsgfVxuXG4gICAgICAgICAgICBpZiAoZSkge1xuICAgICAgICAgICAgICAgIGlmIChlLnByb3BlcnR5TmFtZSA9PT0gJ21heC1oZWlnaHQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQob3JpZ2luYWxBZGp1c3RQYW4uYmluZCh0aGlzKSwgMSk7IC8vSlNBUEktMzQwOSBmaXggc2FmYXJpIGdsaWNoXG4gICAgICAgICAgICAgICAgICAgIERHLkRvbUV2ZW50Lm9mZih0aGlzLl93cmFwcGVyLCBERy5Eb21VdGlsLlRSQU5TSVRJT05fRU5ELCB0aGlzLl9hZGp1c3RQYW4pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5hdXRvUGFuKSB7IHJldHVybjsgfVxuXG4gICAgICAgICAgICB2YXIgbWFwID0gdGhpcy5fbWFwLFxuICAgICAgICAgICAgICAgIGNvbnRhaW5lckhlaWdodCA9IHRoaXMuX2NvbnRhaW5lci5vZmZzZXRIZWlnaHQsXG4gICAgICAgICAgICAgICAgY29udGFpbmVyV2lkdGggPSB0aGlzLl9jb250YWluZXJXaWR0aCxcbiAgICAgICAgICAgICAgICBsYXllclBvcyA9IG5ldyBMLlBvaW50KHRoaXMuX2NvbnRhaW5lckxlZnQsIC1jb250YWluZXJIZWlnaHQgLSB0aGlzLl9jb250YWluZXJCb3R0b20pO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XG4gICAgICAgICAgICAgICAgbGF5ZXJQb3MuX2FkZChMLkRvbVV0aWwuZ2V0UG9zaXRpb24odGhpcy5fY29udGFpbmVyKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBhdXRvUGFuUGFkZGluZyA9IFtvcHRpb25zLmF1dG9QYW5QYWRkaW5nWzBdLCBvcHRpb25zLmF1dG9QYW5QYWRkaW5nWzFdXTtcblxuICAgICAgICAgICAgLy8gaWYgd2lkdGggb2YgbWFwIGlzIG1vcmUgdGhlbiB3aWR0aCBvZiBwb3B1cCBhbmQgY29udHJvbHNcbiAgICAgICAgICAgIC8vIHNldCBkZWZhdWx0IGF1dG9QYW5QYWRkaW5nIHRvIHdpZHRoIGNvbnRyb2xzXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgIXRoaXMuX2lzQXV0b1BhblBhZGRpbmdVc2VyRGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYXAuX2NvbnRhaW5lci5vZmZzZXRXaWR0aCA+PSBvcHRpb25zLm1heFdpZHRoICsgb3B0aW9ucy5tYXBDb250cm9sc1dpZHRoICogMlxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgYXV0b1BhblBhZGRpbmdbMF0gPSBvcHRpb25zLm1hcENvbnRyb2xzV2lkdGg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBjb250YWluZXJQb3MgPSBtYXAubGF5ZXJQb2ludFRvQ29udGFpbmVyUG9pbnQobGF5ZXJQb3MpLFxuICAgICAgICAgICAgICAgIHBhZGRpbmcgPSBMLnBvaW50KGF1dG9QYW5QYWRkaW5nKSxcbiAgICAgICAgICAgICAgICBwYWRkaW5nVEwgPSBMLnBvaW50KG9wdGlvbnMuYXV0b1BhblBhZGRpbmdUb3BMZWZ0IHx8IHBhZGRpbmcpLFxuICAgICAgICAgICAgICAgIHBhZGRpbmdCUiA9IEwucG9pbnQob3B0aW9ucy5hdXRvUGFuUGFkZGluZ0JvdHRvbVJpZ2h0IHx8IHBhZGRpbmcpLFxuICAgICAgICAgICAgICAgIHNpemUgPSBtYXAuZ2V0U2l6ZSgpLFxuICAgICAgICAgICAgICAgIGR4ID0gMCxcbiAgICAgICAgICAgICAgICBkeSA9IDA7XG5cbiAgICAgICAgICAgIGlmIChjb250YWluZXJQb3MueCArIGNvbnRhaW5lcldpZHRoICsgcGFkZGluZ0JSLnggPiBzaXplLngpIHsgLy8gcmlnaHRcbiAgICAgICAgICAgICAgICBkeCA9IGNvbnRhaW5lclBvcy54ICsgY29udGFpbmVyV2lkdGggLSBzaXplLnggKyBwYWRkaW5nQlIueDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb250YWluZXJQb3MueCAtIGR4IC0gcGFkZGluZ1RMLnggPCAwKSB7IC8vIGxlZnRcbiAgICAgICAgICAgICAgICBkeCA9IGNvbnRhaW5lclBvcy54IC0gcGFkZGluZ1RMLng7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29udGFpbmVyUG9zLnkgKyBjb250YWluZXJIZWlnaHQgKyBwYWRkaW5nQlIueSA+IHNpemUueSkgeyAvLyBib3R0b21cbiAgICAgICAgICAgICAgICBkeSA9IGNvbnRhaW5lclBvcy55ICsgY29udGFpbmVySGVpZ2h0IC0gc2l6ZS55ICsgcGFkZGluZ0JSLnk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29udGFpbmVyUG9zLnkgLSBkeSAtIHBhZGRpbmdUTC55IDwgMCkgeyAvLyB0b3BcbiAgICAgICAgICAgICAgICBkeSA9IGNvbnRhaW5lclBvcy55IC0gcGFkZGluZ1RMLnk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkeCB8fCBkeSkge1xuICAgICAgICAgICAgICAgIG1hcFxuICAgICAgICAgICAgICAgICAgICAuZmlyZSgnYXV0b3BhbnN0YXJ0JylcbiAgICAgICAgICAgICAgICAgICAgLnBhbkJ5KFtkeCwgZHldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBfYmluZEFkanVzdFBhbk9uVHJhbnNpdGlvbkVuZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKERHLkRvbVV0aWwuVFJBTlNJVElPTikge1xuICAgICAgICAgICAgICAgIERHLkRvbUV2ZW50Lm9uKHRoaXMuX3dyYXBwZXIsIERHLkRvbVV0aWwuVFJBTlNJVElPTl9FTkQsIHRoaXMuX2FkanVzdFBhbiwgdGhpcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FkanVzdFBhbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIF9pc0NvbnRlbnRIZWlnaHRFbm91Z2g6IGZ1bmN0aW9uICgpIHsgLy8gKCkgLT4gQm9vbGVhblxuICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5tYXhIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHBvcHVwSGVpZ2h0ID0gdGhpcy5fcG9wdXBTdHJ1Y3R1cmUuYm9keSA/XG4gICAgICAgICAgICAgICAgdGhpcy5fcG9wdXBTdHJ1Y3R1cmUuYm9keS5vZmZzZXRIZWlnaHQgKyB0aGlzLl9nZXREZWx0YSgpIDpcbiAgICAgICAgICAgICAgICB0aGlzLl9jb250ZW50Tm9kZS5vZmZzZXRIZWlnaHQ7XG5cbiAgICAgICAgICAgIHBvcHVwSGVpZ2h0ICs9IG9wdGlvbnMuYm9yZGVyICogMjtcblxuICAgICAgICAgICAgcmV0dXJuIHBvcHVwSGVpZ2h0IDw9IG9wdGlvbnMubWF4SGVpZ2h0O1xuICAgICAgICB9LFxuXG4gICAgICAgIF9pbml0QmFyb25TY3JvbGxlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGNvbnRlbnROb2RlID0gdGhpcy5fcG9wdXBTdHJ1Y3R1cmUuYm9keS5wYXJlbnROb2RlLFxuICAgICAgICAgICAgICAgIHNjcm9sbGVyV3JhcHBlciA9IHRoaXMuX3Njcm9sbGVyV3JhcHBlciA9IERHLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCAnZGctc2Nyb2xsZXJfX3dyYXBwZXInLCBjb250ZW50Tm9kZSksXG4gICAgICAgICAgICAgICAgc2Nyb2xsZXIgPSB0aGlzLl9zY3JvbGxlciA9IERHLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCAnZGctc2Nyb2xsZXInLCBzY3JvbGxlcldyYXBwZXIpLFxuICAgICAgICAgICAgICAgIGJhcldyYXBwZXIgPSB0aGlzLl9iYXJXcmFwcGVyID0gREcuRG9tVXRpbC5jcmVhdGUoJ2RpdicsICdkZy1zY3JvbGxlcl9fYmFyLXdyYXBwZXInLCBzY3JvbGxlciksXG4gICAgICAgICAgICAgICAgaW5uZXJIZWlnaHQgPSB0aGlzLm9wdGlvbnMubWF4SGVpZ2h0IC0gdGhpcy5vcHRpb25zLmJvcmRlciAqIDI7XG5cbiAgICAgICAgICAgIHRoaXMuX3Njcm9sbGVyQmFyID0gREcuRG9tVXRpbC5jcmVhdGUoJ2RpdicsICdkZy1zY3JvbGxlcl9fYmFyJywgYmFyV3JhcHBlcik7XG4gICAgICAgICAgICBzY3JvbGxlci5hcHBlbmRDaGlsZCh0aGlzLl9kZXRhY2hFbCh0aGlzLl9wb3B1cFN0cnVjdHVyZS5ib2R5KSk7XG5cbiAgICAgICAgICAgIGlubmVySGVpZ2h0IC09IHRoaXMuX2dldERlbHRhKCk7XG4gICAgICAgICAgICBzY3JvbGxlcldyYXBwZXIuc3R5bGUuaGVpZ2h0ID0gTWF0aC5tYXgoMTgsIGlubmVySGVpZ2h0KSArICdweCc7XG4gICAgICAgICAgICBzY3JvbGxlcldyYXBwZXIuc3R5bGUud2lkdGggPSBjb250ZW50Tm9kZS5vZmZzZXRXaWR0aCArIDUgKyAncHgnOyAvL1RPRE9cblxuICAgICAgICAgICAgdGhpcy5faXNCYXJvbkV4aXN0ID0gdHJ1ZTtcblxuICAgICAgICAgICAgdGhpcy5fc3dpdGNoRXZlbnRzKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX29uU2Nyb2xsOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdGhpcy5maXJlKCdzY3JvbGwnLCB7b3JpZ2luYWxFdmVudDogZX0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9vbkNsaWNrOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgZS50YXJnZXQgPSBlLnRhcmdldCB8fCBlLnNyY0VsZW1lbnQ7XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5fbW92aW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maXJlKCdjbGljaycsIHtvcmlnaW5hbEV2ZW50OiBlfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgX29uU3RhcnQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB0aGlzLl9tb3ZlZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fbW92aW5nKSB7IHJldHVybjsgfVxuXG4gICAgICAgICAgICB2YXIgZmlyc3QgPSBlLnRvdWNoZXMgPyBlLnRvdWNoZXNbMF0gOiBlO1xuXG4gICAgICAgICAgICB0aGlzLl9zdGFydFBvaW50ID0gbmV3IERHLlBvaW50KGZpcnN0LmNsaWVudFgsIGZpcnN0LmNsaWVudFkpO1xuXG4gICAgICAgICAgICB0aGlzLl90b2dnbGVUb3VjaEV2ZW50cygpO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9vbkVuZDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3RvZ2dsZVRvdWNoRXZlbnRzKHRydWUpO1xuXG4gICAgICAgICAgICB0aGlzLl9vbkNsaWNrKGUpO1xuXG4gICAgICAgICAgICB0aGlzLl9tb3ZpbmcgPSBmYWxzZTtcbiAgICAgICAgfSxcblxuICAgICAgICBfb25Nb3ZlOiBmdW5jdGlvbiAoZSkge1xuXG4gICAgICAgICAgICBpZiAoZS50b3VjaGVzICYmIGUudG91Y2hlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbW92ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGZpcnN0ID0gKGUudG91Y2hlcyAmJiBlLnRvdWNoZXMubGVuZ3RoID09PSAxID8gZS50b3VjaGVzWzBdIDogZSksXG4gICAgICAgICAgICAgICAgbmV3UG9pbnQgPSBERy5wb2ludChmaXJzdC5jbGllbnRYLCBmaXJzdC5jbGllbnRZKSxcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBNYXRoLmFicyhuZXdQb2ludC5zdWJ0cmFjdCh0aGlzLl9zdGFydFBvaW50KS55KTtcblxuICAgICAgICAgICAgaWYgKCFvZmZzZXQgfHwgb2Zmc2V0IDwgMTApIHsgcmV0dXJuOyB9XG5cbiAgICAgICAgICAgIHRoaXMuX21vdmluZyA9IHRoaXMuX21vdmVkID0gdHJ1ZTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIF9pbml0QmFyb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjb250ZXh0ID0gdGhpcy5fc2Nyb2xsZXJXcmFwcGVyO1xuICAgICAgICAgICAgdGhpcy5fYmFyb24gPSBncmFmKHtcbiAgICAgICAgICAgICAgICBzY3JvbGxlcjogJy5kZy1zY3JvbGxlcicsXG4gICAgICAgICAgICAgICAgYmFyOiAnLmRnLXNjcm9sbGVyX19iYXInLFxuICAgICAgICAgICAgICAgIHRyYWNrOiAnLmRnLXNjcm9sbGVyX19iYXItd3JhcHBlcicsXG4gICAgICAgICAgICAgICAgJDogZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBub2RlID0ge30udG9TdHJpbmcuY2FsbChzZWxlY3RvcikgPT09ICdbb2JqZWN0IFN0cmluZ10nID9cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQucXVlcnlTZWxlY3RvcihzZWxlY3RvcikgOiBzZWxlY3RvcjtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJhcm9uRG9tSGVscGVyKG5vZGUpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZXZlbnQ6IGZ1bmN0aW9uIChlbGVtLCBldmVudCwgZnVuYywgbW9kZSkge1xuICAgICAgICAgICAgICAgICAgICBldmVudC5zcGxpdCgnICcpLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIERHLkRvbUV2ZW50W21vZGUgfHwgJ29uJ10oZWxlbSwgdHlwZSwgZnVuYyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9pbml0SGVhZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9wb3B1cFN0cnVjdHVyZS5oZWFkZXIgPSBERy5Eb21VdGlsLmNyZWF0ZSgnaGVhZGVyJywgJ2RnLXBvcHVwX19oZWFkZXInLCB0aGlzLl9jb250ZW50Tm9kZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2luaXRGb290ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX3BvcHVwU3RydWN0dXJlLmZvb3RlciA9IERHLkRvbVV0aWwuY3JlYXRlKCdmb290ZXInLCAnZGctcG9wdXBfX2Zvb3RlcicsIHRoaXMuX2NvbnRlbnROb2RlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBfaW5pdEJvZHlDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX3BvcHVwU3RydWN0dXJlLndyYXBwZXIgPSBERy5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgJ2RnLXBvcHVwX19jb250YWluZXItd3JhcHBlcicsIHRoaXMuX2NvbnRlbnROb2RlKTtcbiAgICAgICAgICAgIHRoaXMuX3BvcHVwU3RydWN0dXJlLmJvZHkgPSBERy5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgJ2RnLXBvcHVwX19jb250YWluZXInLCB0aGlzLl9wb3B1cFN0cnVjdHVyZS53cmFwcGVyKTtcbiAgICAgICAgfSxcblxuICAgICAgICB1cGRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fbWFwKSB7IHJldHVybjsgfVxuXG4gICAgICAgICAgICBpZiAoIURHLkJyb3dzZXIuaWVsdDkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb250YWluZXIuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fc3dpdGNoRXZlbnRzKHRydWUpO1xuXG4gICAgICAgICAgICB0aGlzLl9jbGVhck5vZGUodGhpcy5fY29udGVudE5vZGUpO1xuICAgICAgICAgICAgdGhpcy5faXNCYXJvbkV4aXN0ID0gZmFsc2U7XG5cbiAgICAgICAgICAgIC8vIGluaXQgcG9wdXAgY29udGVudCBkb20gc3RydWN0dXJlXG4gICAgICAgICAgICBpZiAodGhpcy5faGVhZGVyQ29udGVudCkgeyB0aGlzLl9pbml0SGVhZGVyKCk7IH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9ib2R5Q29udGVudCkgeyB0aGlzLl9pbml0Qm9keUNvbnRhaW5lcigpOyB9XG4gICAgICAgICAgICBpZiAodGhpcy5fZm9vdGVyQ29udGVudCkgeyB0aGlzLl9pbml0Rm9vdGVyKCk7IH1cblxuICAgICAgICAgICAgdGhpcy5fdXBkYXRlUG9wdXBTdHJ1Y3R1cmUoKTtcbiAgICAgICAgICAgIHRoaXMucmVzaXplKCk7XG5cbiAgICAgICAgICAgIERHLkRvbUV2ZW50Lm9uKHRoaXMuX3dyYXBwZXIsICdjbGljaycsIERHLkRvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbik7XG4gICAgICAgICAgICB0aGlzLl9zd2l0Y2hFdmVudHMoKTtcblxuICAgICAgICAgICAgaWYgKERHLkJyb3dzZXIuaWVsdDkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZWxlbSA9IHRoaXMuX3BvcHVwU3RydWN0dXJlLmZvb3RlcjtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbSkge1xuICAgICAgICAgICAgICAgICAgICBlbGVtLmNsYXNzTmFtZSArPSAnIGllOCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIURHLkJyb3dzZXIuaWVsdDkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb250YWluZXIuc3R5bGUudmlzaWJpbGl0eSA9ICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIF9nZXREZWx0YTogZnVuY3Rpb24gKCkgeyAvLyAoKSAtPiBOdW1iZXJcbiAgICAgICAgICAgIHZhciBkZWx0YSA9IDAsXG4gICAgICAgICAgICAgICAgcG9wdXAgPSB0aGlzLl9wb3B1cFN0cnVjdHVyZTtcblxuICAgICAgICAgICAgaWYgKHBvcHVwLmhlYWRlcikge1xuICAgICAgICAgICAgICAgIGRlbHRhICs9IHBvcHVwLmhlYWRlci5vZmZzZXRIZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocG9wdXAuZm9vdGVyKSB7XG4gICAgICAgICAgICAgICAgZGVsdGEgKz0gcG9wdXAuZm9vdGVyLm9mZnNldEhlaWdodDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGRlbHRhO1xuICAgICAgICB9LFxuXG4gICAgICAgIF91cGRhdGVMYXlvdXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBvcHRzID0gdGhpcy5vcHRpb25zLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSB0aGlzLl9jb250ZW50Tm9kZSwgLy8gbGVhZmxldC1wb3B1cC1jb250ZW50XG4gICAgICAgICAgICAgICAgd3JhcHBlciA9IHRoaXMuX3dyYXBwZXIsIC8vIGxlYWZsZXQtcG9wdXAtY29udGVudC13cmFwcGVyXG4gICAgICAgICAgICAgICAgc3R5bGUgPSBjb250ZW50LnN0eWxlLFxuICAgICAgICAgICAgICAgIHdyYXBwZXJTdHlsZSA9IHdyYXBwZXIuc3R5bGUsXG4gICAgICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICAgICAgc2Nyb2xsZWRDbGFzcyA9ICdsZWFmbGV0LXBvcHVwLXNjcm9sbGVkJyxcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcblxuICAgICAgICAgICAgc3R5bGUubWFyZ2luID0gb3B0cy5ib3JkZXIgKyAncHgnO1xuXG4gICAgICAgICAgICBERy5Eb21VdGlsLnJlbW92ZUNsYXNzKGNvbnRlbnQsIHNjcm9sbGVkQ2xhc3MpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5faXNDb250ZW50SGVpZ2h0RW5vdWdoKCkpIHtcbiAgICAgICAgICAgICAgICB3cmFwcGVyU3R5bGUubWF4SGVpZ2h0ID0gY29udGVudC5vZmZzZXRIZWlnaHQgKyBvcHRzLmJvcmRlciAqIDIgKyAncHgnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB3cmFwcGVyU3R5bGUubWF4SGVpZ2h0ID0gb3B0cy5tYXhIZWlnaHQgKyAncHgnO1xuICAgICAgICAgICAgICAgIERHLkRvbVV0aWwuYWRkQ2xhc3MoY29udGVudCwgc2Nyb2xsZWRDbGFzcyk7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGF2YWlsYWJsZVdpZHRoID0gb3B0cy5hdXRvUGFuUGFkZGluZ1swXSAqIDI7XG5cbiAgICAgICAgICAgIGlmIChvcHRzLnNwcmF3bGluZykge1xuICAgICAgICAgICAgICAgIHdpZHRoID0gb3B0cy5tYXhXaWR0aDtcblxuICAgICAgICAgICAgICAgIHdpZHRoID0gTWF0aC5taW4od2lkdGgsIHRoaXMuX21hcC5fY29udGFpbmVyLm9mZnNldFdpZHRoIC0gYXZhaWxhYmxlV2lkdGgpO1xuICAgICAgICAgICAgICAgIHdpZHRoID0gTWF0aC5tYXgod2lkdGgsIG9wdHMubWluV2lkdGgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB3cmFwcGVyU3R5bGUud2lkdGggPSAnJztcblxuICAgICAgICAgICAgICAgIHN0eWxlLndoaXRlU3BhY2UgPSAnbm93cmFwJztcbiAgICAgICAgICAgICAgICB3aWR0aCA9IHdyYXBwZXIub2Zmc2V0V2lkdGg7XG4gICAgICAgICAgICAgICAgc3R5bGUud2hpdGVTcGFjZSA9ICcnO1xuXG4gICAgICAgICAgICAgICAgd2lkdGggPSBNYXRoLm1pbih3aWR0aCwgdGhpcy5fbWFwLl9jb250YWluZXIub2Zmc2V0V2lkdGggLSBhdmFpbGFibGVXaWR0aCk7XG4gICAgICAgICAgICAgICAgd2lkdGggPSBNYXRoLm1pbihNYXRoLm1heCh3aWR0aCwgb3B0cy5taW5XaWR0aCksIG9wdHMubWF4V2lkdGgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB3cmFwcGVyU3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG5cbiAgICAgICAgICAgIHRoaXMuX2NvbnRhaW5lcldpZHRoID0gdGhpcy5fY29udGFpbmVyLm9mZnNldFdpZHRoO1xuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuXG4gICAgICAgIF91cGRhdGVQb3B1cFN0cnVjdHVyZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgT2JqZWN0LmtleXModGhpcy5fcG9wdXBTdHJ1Y3R1cmUpLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbnNlcnRDb250ZW50KHRoaXNbJ18nICsgaXRlbSArICdDb250ZW50J10sIHRoaXMuX3BvcHVwU3RydWN0dXJlW2l0ZW1dKTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgICAgICB0aGlzLmZpcmUoJ2NvbnRlbnR1cGRhdGUnKTtcbiAgICAgICAgfSxcblxuICAgICAgICBfaW5zZXJ0Q29udGVudDogZnVuY3Rpb24gKGNvbnRlbnQsIG5vZGUpIHsgLy8gKFN0cmluZyB8IERPTUVsZW1lbnQsIERPTUVsZW1lbnQpXG4gICAgICAgICAgICBpZiAoIWNvbnRlbnQgfHwgIW5vZGUpIHsgcmV0dXJuOyB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBub2RlLmlubmVySFRNTCA9IGNvbnRlbnQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NsZWFyTm9kZShub2RlKTtcbiAgICAgICAgICAgICAgICBub2RlLmFwcGVuZENoaWxkKGNvbnRlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIF9jbGVhck5vZGU6IGZ1bmN0aW9uIChub2RlKSB7IC8vIChET01FbGVtZW50KVxuICAgICAgICAgICAgd2hpbGUgKG5vZGUuaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5yZW1vdmVDaGlsZChub2RlLmZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIF9kZXRhY2hFbDogZnVuY3Rpb24gKGVsZW0pIHsgLy8gKERPTUVsZW1lbnQpIC0+IERPTUVsZW1lbnRcbiAgICAgICAgICAgIGlmIChlbGVtLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICBlbGVtLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWxlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZWxlbTtcbiAgICAgICAgfSxcblxuICAgICAgICBfc3dpdGNoRXZlbnRzOiBmdW5jdGlvbiAob24pIHsgLy8gKEJvb2xlYW4pXG4gICAgICAgICAgICB2YXIgc3dpdGNoZXIgPSBvbiA/ICdvZmYnIDogJ29uJztcblxuICAgICAgICAgICAgaWYgKCFERy5Ccm93c2VyLnRvdWNoKSB7XG4gICAgICAgICAgICAgICAgREcuRG9tRXZlbnRbc3dpdGNoZXJdKHRoaXMuX2NvbnRlbnROb2RlLCAnY2xpY2snLCB0aGlzLl9vbkNsaWNrLCB0aGlzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgREcuRG9tRXZlbnRbc3dpdGNoZXJdKHRoaXMuX2NvbnRlbnROb2RlLCAndG91Y2hzdGFydCBtb3VzZWRvd24gbW91c2Vtb3ZlJywgdGhpcy5fb25TdGFydCwgdGhpcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9pc0Jhcm9uRXhpc3QpIHtcbiAgICAgICAgICAgICAgICBERy5Eb21FdmVudFtzd2l0Y2hlcl0odGhpcy5fc2Nyb2xsZXIsICdzY3JvbGwnLCB0aGlzLl9vblNjcm9sbCwgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgX3RvZ2dsZVRvdWNoRXZlbnRzOiBmdW5jdGlvbiAob24pIHtcbiAgICAgICAgICAgIHZhciBzd2l0Y2hlciA9IG9uID8gJ29mZicgOiAnb24nO1xuXG4gICAgICAgICAgICBERy5Eb21FdmVudFxuICAgICAgICAgICAgICAgIFtzd2l0Y2hlcl0odGhpcy5fY29udGVudE5vZGUsICd0b3VjaG1vdmUnLCB0aGlzLl9vbk1vdmUsIHRoaXMpXG4gICAgICAgICAgICAgICAgW3N3aXRjaGVyXSh0aGlzLl9jb250ZW50Tm9kZSwgJ3RvdWNoZW5kJywgdGhpcy5fb25FbmQsIHRoaXMpO1xuICAgICAgICB9XG5cbiAgICB9KTtcbn0oKSk7XG5cblxuREcuTWFwLmluY2x1ZGUoe1xuICAgIF9tYXJrZXJDbGFzczogJ2RnLWN1c3RvbWl6YXRpb25fX21hcmtlcl90eXBlX211c2hyb29tJyxcbiAgICBfbWFya2VyU2hvd0NsYXNzOiAnZGctY3VzdG9taXphdGlvbl9fbWFya2VyX2FwcGVhcicsXG4gICAgX21hcmtlckhpZGVDbGFzczogJ2RnLWN1c3RvbWl6YXRpb25fX21hcmtlcl9kaXNhcHBlYXInLFxuICAgIF9kZ0hpZGVDbGFzczogJ2RnLXBvcHVwX2hpZGRlbl90cnVlJyxcbiAgICBvcGVuUG9wdXA6IGZ1bmN0aW9uIChwb3B1cCwgbGF0bG5nLCBvcHRpb25zKSB7IC8vIChQb3B1cCkgb3IgKFN0cmluZyB8fCBIVE1MRWxlbWVudCwgTGF0TG5nWywgT2JqZWN0XSlcbiAgICAgICAgaWYgKCEocG9wdXAgaW5zdGFuY2VvZiBMLlBvcHVwKSkge1xuICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSBwb3B1cDtcblxuICAgICAgICAgICAgcG9wdXAgPSBuZXcgTC5Qb3B1cChvcHRpb25zKS5zZXRDb250ZW50KGNvbnRlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxhdGxuZykge1xuICAgICAgICAgICAgcG9wdXAuc2V0TGF0TG5nKGxhdGxuZyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5oYXNMYXllcihwb3B1cCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jbG9zZVBvcHVwKCk7XG4gICAgICAgIHRoaXMuX3BvcHVwID0gcG9wdXA7XG5cbiAgICAgICAgaWYgKHBvcHVwLl9zb3VyY2UgJiYgcG9wdXAuX3NvdXJjZS5faWNvbikge1xuICAgICAgICAgICAgaWYgKHBvcHVwLl9zb3VyY2UuX2ljb24uY2xhc3NOYW1lLmluZGV4T2YodGhpcy5fbWFya2VyQ2xhc3MpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIERHLkRvbVV0aWwucmVtb3ZlQ2xhc3MocG9wdXAuX3NvdXJjZS5faWNvbiwgdGhpcy5fbWFya2VyU2hvd0NsYXNzKTtcbiAgICAgICAgICAgICAgICBERy5Eb21VdGlsLmFkZENsYXNzKHBvcHVwLl9zb3VyY2UuX2ljb24sIHRoaXMuX21hcmtlckhpZGVDbGFzcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIERHLkRvbVV0aWwuYWRkQ2xhc3MocG9wdXAuX3NvdXJjZS5faWNvbiwgdGhpcy5fZGdIaWRlQ2xhc3MpO1xuICAgICAgICAgICAgICAgIGlmIChwb3B1cC5fc291cmNlLl9zaGFkb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgREcuRG9tVXRpbC5hZGRDbGFzcyhwb3B1cC5fc291cmNlLl9zaGFkb3csIHRoaXMuX2RnSGlkZUNsYXNzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5hZGRMYXllcihwb3B1cCk7XG4gICAgfSxcblxuICAgIGNsb3NlUG9wdXA6IGZ1bmN0aW9uIChwb3B1cCkgeyAgLy8gKFBvcHVwKSAtPiBQb3B1cFxuICAgICAgICBpZiAoIXBvcHVwIHx8IHBvcHVwID09PSB0aGlzLl9wb3B1cCkge1xuICAgICAgICAgICAgcG9wdXAgPSB0aGlzLl9wb3B1cDtcbiAgICAgICAgICAgIHRoaXMuX3BvcHVwID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9wdXApIHtcbiAgICAgICAgICAgIGlmIChwb3B1cC5fc291cmNlICYmIHBvcHVwLl9zb3VyY2UuX2ljb24pIHtcbiAgICAgICAgICAgICAgICBpZiAocG9wdXAuX3NvdXJjZS5faWNvbi5jbGFzc05hbWUuaW5kZXhPZih0aGlzLl9tYXJrZXJDbGFzcykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIERHLkRvbVV0aWwucmVtb3ZlQ2xhc3MocG9wdXAuX3NvdXJjZS5faWNvbiwgdGhpcy5fbWFya2VySGlkZUNsYXNzKTtcbiAgICAgICAgICAgICAgICAgICAgREcuRG9tVXRpbC5hZGRDbGFzcyhwb3B1cC5fc291cmNlLl9pY29uLCB0aGlzLl9tYXJrZXJTaG93Q2xhc3MpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIERHLkRvbVV0aWwucmVtb3ZlQ2xhc3MocG9wdXAuX3NvdXJjZS5faWNvbiwgdGhpcy5fZGdIaWRlQ2xhc3MpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9wdXAuX3NvdXJjZS5fc2hhZG93KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBERy5Eb21VdGlsLnJlbW92ZUNsYXNzKHBvcHVwLl9zb3VyY2UuX3NoYWRvdywgdGhpcy5fZGdIaWRlQ2xhc3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZW1vdmVMYXllcihwb3B1cCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59KTtcbiIsIkRHLkRpY3Rpb25hcnkgPSB7fTtcblxuREcuRGljdGlvbmFyeS5ydSA9IHtcbiAgICBwbHVyYWxSdWxlczogZnVuY3Rpb24gKG4pIHsgLy8gKE51bWJlcilcbiAgICAgICAgaWYgKG4gJSAxMCA9PT0gMSAmJiBuICUgMTAwICE9PSAxMSkgeyAvLyAxLCAyMVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChuICUgMTAgPj0gMiAmJiBuICUgMTAgPD0gNCAmJiAobiAlIDEwKSAlIDEgPT09IDApICYmIChuICUgMTAwIDwgMTIgfHwgbiAlIDEwMCA+IDE0KSkgeyAvLyAyLCAzXG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgobiAlIDEwID09PSAwKSB8fCAobiAlIDEwID49IDUgJiYgbiAlIDEwIDw9IDkgJiYgKG4gJSAxMCkgJSAxID09PSAwKSB8fCAobiAlIDEwMCA+PSAxMSAmJiAobiAlIDEwMCkgPD0gMTQgJiYgKG4gJSAxMDApICUgMSA9PT0gMCkpIHsgLy8gMTMsIDE3XG4gICAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbkRHLkRpY3Rpb25hcnkuZW4gPSB7XG4gICAgcGx1cmFsUnVsZXM6IGZ1bmN0aW9uIChuKSB7IC8vIChOdW1iZXIpXG4gICAgICAgIGlmIChuID09PSAxKSB7IC8vIDFcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIDE7IC8vMCwgMiwgMywgNCAuLlxuICAgICAgICB9XG4gICAgfVxufTtcblxuREcuRGljdGlvbmFyeS5pdCA9IHtcbiAgICBwbHVyYWxSdWxlczogZnVuY3Rpb24gKG4pIHsgLy8gKE51bWJlcilcbiAgICAgICAgaWYgKG4gPT09IDEpIHsgLy8gMVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gMTsgLy8wLCAyLCAzLCA0IC4uXG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5ERy5EaWN0aW9uYXJ5LmNzID0ge1xuICAgIHBsdXJhbFJ1bGVzOiBmdW5jdGlvbiAobikgeyAvLyAoTnVtYmVyKVxuICAgICAgICByZXR1cm4gKG4gPT09IDEpID8gMCA6IChuID49IDIgJiYgbiA8PSA0KSA/IDEgOiAyO1xuICAgIH1cbn07XG5cbkRHLkRpY3Rpb25hcnkuZXMgPSB7XG4gICAgcGx1cmFsUnVsZXM6IGZ1bmN0aW9uIChuKSB7IC8vIChOdW1iZXIpXG4gICAgICAgIHJldHVybiAobiA+PSAyKSA/IDEgOiAwO1xuICAgIH1cbn07XG4iLCJERy5Mb2NhbGUgPSB7XG4gICAgdDogZnVuY3Rpb24gKG1zZywgYXJndW1lbnQpIHsgLy8gKFN0cmluZywgTnVtYmVyKSAtPiBTdHJpbmdcbiAgICAgICAgdmFyIHJlc3VsdCxcbiAgICAgICAgICAgIGxhbmcgPSB0aGlzLl9tYXAub3B0aW9ucy5jdXJyZW50TGFuZyxcbiAgICAgICAgICAgIG1zZ0lzc2V0ID0gZmFsc2UsXG4gICAgICAgICAgICBkaWN0aW9uYXJ5TXNnLFxuICAgICAgICAgICAgZXhwO1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuY29uc3RydWN0b3IuRGljdGlvbmFyeVtsYW5nXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGxhbmcgPSAncnUnO1xuICAgICAgICAgICAgdGhpcy5fbWFwLnNldExhbmcobGFuZyk7XG4gICAgICAgIH1cbiAgICAgICAgZGljdGlvbmFyeU1zZyA9IHRoaXMuY29uc3RydWN0b3IuRGljdGlvbmFyeVtsYW5nXVttc2ddO1xuICAgICAgICBtc2dJc3NldCA9IHR5cGVvZiBkaWN0aW9uYXJ5TXNnICE9PSAndW5kZWZpbmVkJztcbiAgICAgICAgaWYgKCFtc2dJc3NldCkge1xuICAgICAgICAgICAgcmV0dXJuIG1zZztcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgPSBtc2dJc3NldCA/IGRpY3Rpb25hcnlNc2cgOiBtc2c7XG5cbiAgICAgICAgaWYgKGFyZ3VtZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGFyZ3VtZW50ID0gcGFyc2VJbnQoYXJndW1lbnQsIDEwKTtcbiAgICAgICAgICAgIGFyZ3VtZW50ID0gaXNOYU4oYXJndW1lbnQpID8gMCA6IGFyZ3VtZW50O1xuICAgICAgICAgICAgZXhwID0gdGhpcy5jb25zdHJ1Y3Rvci5EaWN0aW9uYXJ5W2xhbmddLnBsdXJhbFJ1bGVzKGFyZ3VtZW50KTtcbiAgICAgICAgICAgIHJlc3VsdCA9IGRpY3Rpb25hcnlNc2dbZXhwXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdCA9IERHLlV0aWwudGVtcGxhdGUocmVzdWx0LCB7bjogYXJndW1lbnR9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCA/IHJlc3VsdCA6IG1zZztcbiAgICB9XG59O1xuXG5mdW5jdGlvbiBnZXRQYWdlTGFuZygpIHtcbiAgICB2YXIgcm9vdCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxcbiAgICAgICAgbGFuZyA9IHJvb3QubGFuZyB8fCAocm9vdC5nZXRBdHRyaWJ1dGVOUyAmJiByb290LmdldEF0dHJpYnV0ZU5TKCdodHRwOi8vd3d3LnczLm9yZy9YTUwvMTk5OC9uYW1lc3BhY2UnLCAnbGFuZycpKSB8fCAncnUnO1xuXG4gICAgcmV0dXJuIGxhbmc7XG59XG5cbkRHLk1hcC5tZXJnZU9wdGlvbnMoe1xuICAgIGN1cnJlbnRMYW5nOiBnZXRQYWdlTGFuZygpXG59KTtcblxuREcuTWFwLmluY2x1ZGUoe1xuXG4gICAgc2V0TGFuZzogZnVuY3Rpb24gKGxhbmcpIHsgLy8gKFN0cmluZylcbiAgICAgICAgaWYgKGxhbmcgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGxhbmcpID09PSAnW29iamVjdCBTdHJpbmddJykge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmN1cnJlbnRMYW5nID0gbGFuZztcbiAgICAgICAgICAgIHRoaXMuZmlyZSgnbGFuZ2NoYW5nZScsIHsnbGFuZyc6IGxhbmd9KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXRMYW5nOiBmdW5jdGlvbiAoKSB7IC8vICgpIC0+IFN0cmluZ1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmN1cnJlbnRMYW5nO1xuICAgIH1cbn0pO1xuIiwiREcuUm91bmRDb250cm9sID0gREcuQ29udHJvbC5leHRlbmQoe1xuICAgIGluY2x1ZGVzOiBERy5NaXhpbi5FdmVudHMsXG5cbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHBvc2l0aW9uOiAndG9wcmlnaHQnLFxuICAgICAgICBpY29uQ2xhc3M6ICdkZWZhdWx0J1xuICAgIH0sXG5cbiAgICBvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xuICAgICAgICB2YXIgY29udHJvbENsYXNzID0gdGhpcy5fY29udHJvbENMYXNzID0gJ2RnLWNvbnRyb2wtcm91bmQnLFxuICAgICAgICAgICAgY29udHJvbEljb25DbGFzcyA9IHRoaXMuX2NvbnRyb2xJY29uQ0xhc3MgPSB0aGlzLl9jb250cm9sQ0xhc3MgKyAnX19pY29uJyxcbiAgICAgICAgICAgIGNvbnRhaW5lciA9IERHLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCAnJyk7XG5cbiAgICAgICAgaWYgKHRoaXMuX2Rpc2FibGUpIHtcbiAgICAgICAgICAgIHJldHVybiBjb250YWluZXI7XG4gICAgICAgIH1cbiAgICAgICAgREcuRG9tVXRpbC5hZGRDbGFzcyhjb250YWluZXIsIGNvbnRyb2xDbGFzcyk7XG5cbiAgICAgICAgdmFyIGxpbmsgPSB0aGlzLl9saW5rID0gREcuRG9tVXRpbC5jcmVhdGUoXG4gICAgICAgICAgICAnYScsXG4gICAgICAgICAgICBjb250cm9sSWNvbkNsYXNzICsgJyAnICsgY29udHJvbEljb25DbGFzcyArICdfbmFtZV8nICsgdGhpcy5vcHRpb25zLmljb25DbGFzcyxcbiAgICAgICAgICAgIGNvbnRhaW5lclxuICAgICAgICApO1xuXG4gICAgICAgIGxpbmsuaHJlZiA9ICcjJztcblxuICAgICAgICB0aGlzLl9yZW5kZXJUcmFuc2xhdGlvbigpO1xuXG4gICAgICAgIHRoaXMuX21hcCA9IG1hcDtcblxuICAgICAgICBERy5Eb21FdmVudFxuICAgICAgICAgICAgLm9uKGNvbnRhaW5lciwgJ2NsaWNrJywgdGhpcy5fdG9nZ2xlQ29udHJvbCwgdGhpcylcbiAgICAgICAgICAgIC5vbihjb250YWluZXIsICdkYmxjbGljaycsIERHLkRvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbilcbiAgICAgICAgICAgIC5vbihsaW5rLCAnbW91c2Vkb3duJywgREcuRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uKTtcblxuICAgICAgICB0aGlzLmZpcmVFdmVudCgnYWRkJyk7XG5cbiAgICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgICB9LFxuXG4gICAgb25SZW1vdmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5maXJlRXZlbnQoJ3JlbW92ZScpO1xuICAgICAgICBERy5Eb21FdmVudC5vZmYodGhpcy5fbGluaywgJ2NsaWNrJywgdGhpcy5fdG9nZ2xlQ29udHJvbCk7XG4gICAgfSxcblxuICAgIHNldFN0YXRlOiBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9saW5rIHx8ICF0aGlzLl9jb250YWluZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlKSB7XG4gICAgICAgICAgICBERy5Eb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX2NvbnRhaW5lciwgdGhpcy5fY29udHJvbENMYXNzICsgJ19zdGF0ZV8nICsgdGhpcy5fc3RhdGUpO1xuICAgICAgICAgICAgREcuRG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9saW5rLCB0aGlzLl9jb250cm9sSWNvbkNMYXNzICsgJ19zdGF0ZV8nICsgdGhpcy5fc3RhdGUpO1xuXG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gc3RhdGU7XG5cbiAgICAgICAgICAgIERHLkRvbVV0aWwuYWRkQ2xhc3ModGhpcy5fY29udGFpbmVyLCB0aGlzLl9jb250cm9sQ0xhc3MgKyAnX3N0YXRlXycgKyB0aGlzLl9zdGF0ZSk7XG4gICAgICAgICAgICBERy5Eb21VdGlsLmFkZENsYXNzKHRoaXMuX2xpbmssIHRoaXMuX2NvbnRyb2xJY29uQ0xhc3MgKyAnX3N0YXRlXycgKyB0aGlzLl9zdGF0ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgX3RvZ2dsZUNvbnRyb2w6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIERHLkRvbUV2ZW50LnN0b3AoZSk7XG4gICAgICAgIHRoaXMuZmlyZUV2ZW50KCdjbGljaycpO1xuICAgIH1cbn0pO1xuXG5ERy5Sb3VuZENvbnRyb2wuaW5jbHVkZShERy5Mb2NhbGUpO1xuXG5ERy5yb3VuZENvbnRyb2wgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgREcuUm91bmRDb250cm9sKG9wdGlvbnMpO1xufTtcbiIsIkRHLlByb2plY3REZXRlY3RvciA9IERHLkhhbmRsZXIuZXh0ZW5kKHtcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbiAobWFwKSB7IC8vIChPYmplY3QpXG4gICAgICAgIHRoaXMuX21hcCA9IG1hcDtcbiAgICAgICAgdGhpcy5fb3NtVmlld3BvcnQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wcm9qZWN0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbG9hZFByb2plY3RMaXN0KCk7XG4gICAgfSxcblxuICAgIGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX21hcC5vbignbW92ZScsIHRoaXMuX3Byb2plY3RXYXRjaCwgdGhpcyk7XG4gICAgfSxcblxuICAgIHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX21hcC5vZmYoJ21vdmUnLCB0aGlzLl9wcm9qZWN0V2F0Y2gsIHRoaXMpO1xuICAgIH0sXG5cbiAgICBnZXRQcm9qZWN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5wcm9qZWN0KSB7IHJldHVybiBmYWxzZTsgfVxuXG4gICAgICAgIHJldHVybiBERy5VdGlsLmV4dGVuZCh7fSwgdGhpcy5wcm9qZWN0KTtcbiAgICB9LFxuXG4gICAgZ2V0UHJvamVjdHNMaXN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcm9qZWN0TGlzdC5zbGljZSgwKTtcbiAgICB9LFxuXG4gICAgaXNQcm9qZWN0SGVyZTogZnVuY3Rpb24gKGNvb3JkcywgcHJvamVjdCwgY2hlY2tNZXRob2QpIHtcbiAgICAgICAgaWYgKCFjb29yZHMpIHsgcmV0dXJuIG51bGw7IH1cblxuICAgICAgICBpZiAoIShjb29yZHMgaW5zdGFuY2VvZiBERy5MYXRMbmcpICYmICEoY29vcmRzIGluc3RhbmNlb2YgREcuTGF0TG5nQm91bmRzKSkge1xuICAgICAgICAgICAgY29vcmRzID0gREcubGF0TG5nKGNvb3Jkcyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb29yZHMgPSAoY29vcmRzIGluc3RhbmNlb2YgREcuTGF0TG5nQm91bmRzKSA/XG4gICAgICAgICAgICBERy5sYXRMbmdCb3VuZHMoY29vcmRzLmdldFNvdXRoV2VzdCgpLndyYXAoKSwgY29vcmRzLmdldE5vcnRoRWFzdCgpLndyYXAoKSkgOiBjb29yZHMud3JhcCgpO1xuXG4gICAgICAgIGNoZWNrTWV0aG9kID0gY2hlY2tNZXRob2QgfHwgKChjb29yZHMgaW5zdGFuY2VvZiBERy5MYXRMbmdCb3VuZHMpID8gICdpbnRlcnNlY3RzJyA6ICdjb250YWlucycpO1xuXG4gICAgICAgIGlmIChwcm9qZWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGVzdFByb2plY3QoY2hlY2tNZXRob2QsIGNvb3JkcywgcHJvamVjdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJvamVjdExpc3QuZmlsdGVyKHRoaXMuX3Rlc3RQcm9qZWN0LmJpbmQodGhpcywgY2hlY2tNZXRob2QsIGNvb3JkcykpWzBdO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9wcm9qZWN0V2F0Y2g6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX29zbVZpZXdwb3J0ID09PSAodGhpcy5wcm9qZWN0ICYmIHRoaXMuX2JvdW5kSW5Qcm9qZWN0KHRoaXMucHJvamVjdCwgJ2NvbnRhaW5zJykpKSB7XG4gICAgICAgICAgICB0aGlzLl9vc21WaWV3cG9ydCA9ICF0aGlzLl9vc21WaWV3cG9ydDtcbiAgICAgICAgICAgIHRoaXMuX21hcC5hdHRyaWJ1dGlvbkNvbnRyb2wuX3VwZGF0ZShudWxsLCB0aGlzLl9vc21WaWV3cG9ydCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5wcm9qZWN0ICYmIHRoaXMuX2JvdW5kSW5Qcm9qZWN0KHRoaXMucHJvamVjdCkgJiYgdGhpcy5fem9vbUluUHJvamVjdCh0aGlzLnByb2plY3QpKSB7IHJldHVybjsgfVxuXG4gICAgICAgIGlmICh0aGlzLnByb2plY3QpIHtcbiAgICAgICAgICAgIHRoaXMucHJvamVjdCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9tYXAuZmlyZSgncHJvamVjdGxlYXZlJyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9zZWFyY2hQcm9qZWN0KCk7XG5cbiAgICAgICAgaWYgKHRoaXMucHJvamVjdCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX29zbVZpZXdwb3J0ID09PSAodGhpcy5wcm9qZWN0ICYmIHRoaXMuX2JvdW5kSW5Qcm9qZWN0KHRoaXMucHJvamVjdCwgJ2NvbnRhaW5zJykpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb3NtVmlld3BvcnQgPSAhdGhpcy5fb3NtVmlld3BvcnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9tYXAuYXR0cmlidXRpb25Db250cm9sLl91cGRhdGUobnVsbCwgdGhpcy5fb3NtVmlld3BvcnQsIHRoaXMucHJvamVjdC5jb3VudHJ5X2NvZGUpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF93a3RUb0JuZDogZnVuY3Rpb24gKHdrdCkge1xuICAgICAgICB2YXIgYXJyLFxuICAgICAgICAgICAgcG9pbnRzQXJyLFxuICAgICAgICAgICAgYnJhY2tldHNDb250ZW50LFxuICAgICAgICAgICAgcmVnRXhwO1xuXG4gICAgICAgIHdrdCA9IHdrdC5yZXBsYWNlKC8sIC9nLCAnLCcpO1xuICAgICAgICB3a3QucmVwbGFjZSgnICgnLCAnKCcpO1xuXG4gICAgICAgIGFyciA9IC9eUE9MWUdPTlxcKCguKilcXCkvLmV4ZWMod2t0KTtcbiAgICAgICAgcmVnRXhwID0gL1xcKCguKj8pXFwpL2c7XG5cbiAgICAgICAgYnJhY2tldHNDb250ZW50ID0gKHJlZ0V4cCkuZXhlYyhhcnJbMV0pO1xuICAgICAgICBwb2ludHNBcnIgPSBicmFja2V0c0NvbnRlbnRbMV0uc3BsaXQoJywnKTtcblxuICAgICAgICAvLyBDcmVhdGUgYSBMYXRMbmcgYXJyYXkgb2YgYWxsIHBvaW50cyBpbiBXS1RcbiAgICAgICAgcG9pbnRzQXJyID0gcG9pbnRzQXJyLm1hcChmdW5jdGlvbihwb2ludFN0cmluZykge1xuICAgICAgICAgICAgdmFyIG51bWJlcnMgPSBwb2ludFN0cmluZy5zcGxpdCgnICcpO1xuXG4gICAgICAgICAgICByZXR1cm4gREcubGF0TG5nKFxuICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQobnVtYmVyc1sxXSksXG4gICAgICAgICAgICAgICAgcGFyc2VGbG9hdChudW1iZXJzWzBdKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIGJvdW5kID0gREcubGF0TG5nQm91bmRzKHBvaW50c0Fycik7XG5cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIFtib3VuZC5nZXRTb3V0aFdlc3QoKS5sYXQsIGJvdW5kLmdldFNvdXRoV2VzdCgpLmxuZ10sXG4gICAgICAgICAgICBbYm91bmQuZ2V0Tm9ydGhFYXN0KCkubGF0LCBib3VuZC5nZXROb3J0aEVhc3QoKS5sbmddXG4gICAgICAgIF07XG4gICAgfSxcblxuICAgIF9jaGVja1Byb2plY3Q6IGZ1bmN0aW9uIChwcm9qZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGNoZWNrKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwcm9qZWN0ICYmXG4gICAgICAgICAgICAgICAgcHJvamVjdC5ib3VuZHMgJiZcbiAgICAgICAgICAgICAgICBjaGVjayhwcm9qZWN0LmNvZGUpICYmXG4gICAgICAgICAgICAgICAgY2hlY2socHJvamVjdC5kb21haW4pICYmXG4gICAgICAgICAgICAgICAgY2hlY2socHJvamVjdC5jb3VudHJ5X2NvZGUpICYmXG4gICAgICAgICAgICAgICAgcHJvamVjdC56b29tX2xldmVsICYmXG4gICAgICAgICAgICAgICAgICAgIGNoZWNrKHByb2plY3Quem9vbV9sZXZlbC5taW4pICYmXG4gICAgICAgICAgICAgICAgICAgIGNoZWNrKHByb2plY3Quem9vbV9sZXZlbC5tYXgpICYmXG4gICAgICAgICAgICAgICAgcHJvamVjdC50aW1lX3pvbmUgJiZcbiAgICAgICAgICAgICAgICAgICAgY2hlY2socHJvamVjdC50aW1lX3pvbmUub2Zmc2V0KTtcbiAgICB9LFxuXG4gICAgX2xvYWRQcm9qZWN0TGlzdDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgaWYgKCFERy5wcm9qZWN0c0xpc3QpIHtcbiAgICAgICAgICAgIERHLnByb2plY3RzTGlzdCA9IERHLmZhbGxiYWNrUHJvamVjdHNMaXN0O1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSBERy5mYWxsYmFja1Byb2plY3RzTGlzdDtcblxuICAgICAgICB0aGlzLl9wcm9qZWN0TGlzdCA9IERHLnByb2plY3RzTGlzdFxuICAgICAgICAgICAgLmZpbHRlcihzZWxmLl9jaGVja1Byb2plY3QpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChwcm9qZWN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGJvdW5kID0gc2VsZi5fd2t0VG9CbmQocHJvamVjdC5ib3VuZHMpO1xuICAgICAgICAgICAgICAgIHZhciBsYXRMbmdCb3VuZHMgPSBuZXcgREcuTGF0TG5nQm91bmRzKGJvdW5kKTtcblxuICAgICAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIGNhbWVsY2FzZSAqL1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IHByb2plY3QuY29kZSxcbiAgICAgICAgICAgICAgICAgICAgbWluWm9vbTogcHJvamVjdC56b29tX2xldmVsLm1pbixcbiAgICAgICAgICAgICAgICAgICAgbWF4Wm9vbTogcHJvamVjdC56b29tX2xldmVsLm1heCxcbiAgICAgICAgICAgICAgICAgICAgdGltZU9mZnNldDogcHJvamVjdC50aW1lX3pvbmUub2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICBib3VuZDogYm91bmQsXG4gICAgICAgICAgICAgICAgICAgIGxhdExuZ0JvdW5kczogbGF0TG5nQm91bmRzLFxuICAgICAgICAgICAgICAgICAgICB0cmFmZmljOiAhIXByb2plY3QuZmxhZ3MudHJhZmZpYyxcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNwb3J0OiAhIXByb2plY3QuZmxhZ3MucHVibGljX3RyYW5zcG9ydCxcbiAgICAgICAgICAgICAgICAgICAgcm9hZHM6ICEhcHJvamVjdC5mbGFncy5yb2FkX25ldHdvcmssXG4gICAgICAgICAgICAgICAgICAgIGNvdW50cnlfY29kZTogcHJvamVjdC5jb3VudHJ5X2NvZGUsXG4gICAgICAgICAgICAgICAgICAgIGRvbWFpbjogcHJvamVjdC5kb21haW5cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8qIGVzbGludC1lbmFibGUgY2FtZWxjYXNlICovXG4gICAgICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgX3NlYXJjaFByb2plY3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fcHJvamVjdExpc3RcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKHByb2plY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXMuX2JvdW5kSW5Qcm9qZWN0KHByb2plY3QpICYmIHRoaXMuX3pvb21JblByb2plY3QocHJvamVjdCkpO1xuICAgICAgICAgICAgfSwgdGhpcylcbiAgICAgICAgICAgIC5zb21lKGZ1bmN0aW9uIChwcm9qZWN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9qZWN0ID0gcHJvamVjdDtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fbWFwLmZpcmUoJ3Byb2plY3RjaGFuZ2UnLCB7J2dldFByb2plY3QnOiBzZWxmLmdldFByb2plY3QuYmluZChzZWxmKX0pO1xuICAgICAgICAgICAgICAgIH0sIDEpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICB9LFxuXG4gICAgX2JvdW5kSW5Qcm9qZWN0OiBmdW5jdGlvbiAocHJvamVjdCwgY2hlY2tNZXRob2QpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlzUHJvamVjdEhlcmUodGhpcy5fbWFwLmdldEJvdW5kcygpLCBwcm9qZWN0LCBjaGVja01ldGhvZCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfdGVzdFByb2plY3Q6IGZ1bmN0aW9uIChtZXRob2QsIGNvb3JkcywgcHJvamVjdCkge1xuICAgICAgICByZXR1cm4gcHJvamVjdC5sYXRMbmdCb3VuZHNbbWV0aG9kXShjb29yZHMpO1xuICAgIH0sXG5cbiAgICBfem9vbUluUHJvamVjdDogZnVuY3Rpb24gKHByb2plY3QpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9tYXAuZ2V0Wm9vbSgpID49IHByb2plY3QubWluWm9vbSk7XG4gICAgfVxufSk7XG5cbkRHLk1hcC5tZXJnZU9wdGlvbnMoe1xuICAgIHByb2plY3REZXRlY3RvcjogdHJ1ZVxufSk7XG5cbkRHLk1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICdwcm9qZWN0RGV0ZWN0b3InLCBERy5Qcm9qZWN0RGV0ZWN0b3IpO1xuIiwiREcuY29uZmlnVGhlbWUgPSBERy5jb25maWdUaGVtZSB8fCB7fTtcblxuREcuY29uZmlnVGhlbWUubWFya2Vyc0RhdGEgPSB7XG4gICAgaWNvblNpemU6IFsyMiwgMzRdLFxuICAgIGNsYXNzTmFtZTogJ2RnLWN1c3RvbWl6YXRpb25fX21hcmtlciBkZy1jdXN0b21pemF0aW9uX19tYXJrZXJfdHlwZV9tdXNocm9vbScsXG4gICAgaWNvbkFuY2hvcjogWzEwLCAzMl1cbn07XG4iLCIvL0luamVjdCBvYnNlcnZpbmcgbG9jYWxpemF0aW9uIGNoYW5nZVxudmFyIGNvbnRyb2xBZGRUbyA9IERHLkNvbnRyb2wucHJvdG90eXBlLmFkZFRvO1xuXG5ERy5Db250cm9sLmluY2x1ZGUoe1xuICAgIGFkZFRvOiBmdW5jdGlvbiAobWFwKSB7XG4gICAgICAgIG1hcC5vbignbGFuZ2NoYW5nZScsIHRoaXMuX3JlbmRlclRyYW5zbGF0aW9uLCB0aGlzKTtcblxuICAgICAgICByZXR1cm4gY29udHJvbEFkZFRvLmNhbGwodGhpcywgbWFwKTtcbiAgICB9LFxuICAgIF9yZW5kZXJUcmFuc2xhdGlvbjogZnVuY3Rpb24gKCkge31cbn0pO1xuXG4vLyBBcHBsaWVzIDJHSVMgZGl2SWNvbiB0byBtYXJrZXJcbkRHLk1hcmtlci5wcm90b3R5cGUub3B0aW9ucy5pY29uID0gREcuZGl2SWNvbihERy5jb25maWdUaGVtZS5tYXJrZXJzRGF0YSk7XG5cbi8vIEFkZCBzb21lIGJyb3dzZXIgZGV0ZWN0aW9uXG5ERy5Ccm93c2VyLnNhZmFyaTUxID0gREcuQnJvd3Nlci5zYWZhcmkgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdWZXJzaW9uLzUuMScpICE9PSAtMTtcblxuLy8gRml4IGJ1ZyB3aXRoIHRpbGVMYXllciBtaW5ab29tXG4vLyBodHRwczovL2dpdGh1Yi5jb20vMmdpcy9tYXBzYXBpL3B1bGwvMTNcbkRHLkdyaWRMYXllci5pbmNsdWRlKHtcbiAgICBfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9tYXApIHsgcmV0dXJuOyB9XG5cbiAgICAgICAgdmFyIGJvdW5kcyA9IHRoaXMuX21hcC5nZXRQaXhlbEJvdW5kcygpLFxuICAgICAgICAgICAgem9vbSA9IHRoaXMuX21hcC5nZXRab29tKCksXG4gICAgICAgICAgICB0aWxlU2l6ZSA9IHRoaXMuX2dldFRpbGVTaXplKCk7XG5cbiAgICAgICAgaWYgKHpvb20gPiB0aGlzLm9wdGlvbnMubWF4Wm9vbSB8fFxuICAgICAgICAgICAgem9vbSA8IHRoaXMub3B0aW9ucy5taW5ab29tKSB7XG4gICAgICAgICAgICB0aGlzLl9jbGVhckJnQnVmZmVyKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0aWxlIGNvb3JkaW5hdGVzIHJhbmdlIGZvciB0aGUgY3VycmVudCB2aWV3XG4gICAgICAgIHZhciB0aWxlQm91bmRzID0gTC5ib3VuZHMoXG4gICAgICAgICAgICBib3VuZHMubWluLmRpdmlkZUJ5KHRpbGVTaXplKS5mbG9vcigpLFxuICAgICAgICAgICAgYm91bmRzLm1heC5kaXZpZGVCeSh0aWxlU2l6ZSkuZmxvb3IoKSk7XG5cbiAgICAgICAgdGhpcy5fYWRkVGlsZXModGlsZUJvdW5kcyk7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy51bmxvYWRJbnZpc2libGVUaWxlcykge1xuICAgICAgICAgICAgdGhpcy5fcmVtb3ZlT3RoZXJUaWxlcyh0aWxlQm91bmRzKTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG4vLyBGaXggZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS8yZ2lzL21hcHNhcGkvaXNzdWVzLzExMSAsIHJlbW92ZSBvbiB0aGUgbmV4dCBsZWFmbGV0IHZlcnNpb25cbkwuRHJhZ2dhYmxlLmluY2x1ZGUoe1xuICAgIF9vbk1vdmU6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChlLnRvdWNoZXMgJiYgZS50b3VjaGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHRoaXMuX21vdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBmaXJzdCA9IChlLnRvdWNoZXMgJiYgZS50b3VjaGVzLmxlbmd0aCA9PT0gMSA/IGUudG91Y2hlc1swXSA6IGUpLFxuICAgICAgICAgICAgbmV3UG9pbnQgPSBuZXcgTC5Qb2ludChmaXJzdC5jbGllbnRYLCBmaXJzdC5jbGllbnRZKSxcbiAgICAgICAgICAgIG9mZnNldCA9IG5ld1BvaW50LnN1YnRyYWN0KHRoaXMuX3N0YXJ0UG9pbnQpO1xuXG4gICAgICAgIGlmICghb2Zmc2V0LnggJiYgIW9mZnNldC55KSB7IHJldHVybjsgfVxuICAgICAgICBpZiAoTC5Ccm93c2VyLnRvdWNoICYmIE1hdGguYWJzKG9mZnNldC54KSArIE1hdGguYWJzKG9mZnNldC55KSA8IDMpIHsgcmV0dXJuOyB9XG5cbiAgICAgICAgTC5Eb21FdmVudC5wcmV2ZW50RGVmYXVsdChlKTtcblxuICAgICAgICBpZiAoIXRoaXMuX21vdmVkKSB7XG4gICAgICAgICAgICB0aGlzLmZpcmUoJ2RyYWdzdGFydCcpO1xuXG4gICAgICAgICAgICB0aGlzLl9tb3ZlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9zdGFydFBvcyA9IEwuRG9tVXRpbC5nZXRQb3NpdGlvbih0aGlzLl9lbGVtZW50KS5zdWJ0cmFjdChvZmZzZXQpO1xuXG4gICAgICAgICAgICBMLkRvbVV0aWwuYWRkQ2xhc3MoZG9jdW1lbnQuYm9keSwgJ2xlYWZsZXQtZHJhZ2dpbmcnKTtcblxuICAgICAgICAgICAgdGhpcy5fbGFzdFRhcmdldCA9IGUudGFyZ2V0IHx8IGUuc3JjRWxlbWVudDtcbiAgICAgICAgICAgIEwuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9sYXN0VGFyZ2V0LCAnbGVhZmxldC1kcmFnLXRhcmdldCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbmV3UG9zID0gdGhpcy5fc3RhcnRQb3MuYWRkKG9mZnNldCk7XG4gICAgICAgIHRoaXMuX21vdmluZyA9IHRydWU7XG5cbiAgICAgICAgTC5VdGlsLmNhbmNlbEFuaW1GcmFtZSh0aGlzLl9hbmltUmVxdWVzdCk7XG4gICAgICAgIHRoaXMuX2FuaW1SZXF1ZXN0ID0gTC5VdGlsLnJlcXVlc3RBbmltRnJhbWUodGhpcy5fdXBkYXRlUG9zaXRpb24sIHRoaXMsIHRydWUsIHRoaXMuX2RyYWdTdGFydFRhcmdldCk7XG4gICAgfSxcbiAgICBfb25VcDogZnVuY3Rpb24gKCkge1xuICAgICAgICBMLkRvbVV0aWwucmVtb3ZlQ2xhc3MoZG9jdW1lbnQuYm9keSwgJ2xlYWZsZXQtZHJhZ2dpbmcnKTtcblxuICAgICAgICBpZiAodGhpcy5fbGFzdFRhcmdldCkge1xuICAgICAgICAgICAgTC5Eb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX2xhc3RUYXJnZXQsICdsZWFmbGV0LWRyYWctdGFyZ2V0Jyk7XG4gICAgICAgICAgICB0aGlzLl9sYXN0VGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgaW4gTC5EcmFnZ2FibGUuTU9WRSkge1xuICAgICAgICAgICAgTC5Eb21FdmVudFxuICAgICAgICAgICAgICAgIC5vZmYoZG9jdW1lbnQsIEwuRHJhZ2dhYmxlLk1PVkVbaV0sIHRoaXMuX29uTW92ZSwgdGhpcylcbiAgICAgICAgICAgICAgICAub2ZmKGRvY3VtZW50LCBMLkRyYWdnYWJsZS5FTkRbaV0sIHRoaXMuX29uVXAsIHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgTC5Eb21VdGlsLmVuYWJsZUltYWdlRHJhZygpO1xuICAgICAgICBMLkRvbVV0aWwuZW5hYmxlVGV4dFNlbGVjdGlvbigpO1xuXG4gICAgICAgIGlmICh0aGlzLl9tb3ZlZCAmJiB0aGlzLl9tb3ZpbmcpIHtcbiAgICAgICAgICAgIC8vIGVuc3VyZSBkcmFnIGlzIG5vdCBmaXJlZCBhZnRlciBkcmFnZW5kXG4gICAgICAgICAgICBMLlV0aWwuY2FuY2VsQW5pbUZyYW1lKHRoaXMuX2FuaW1SZXF1ZXN0KTtcblxuICAgICAgICAgICAgdGhpcy5maXJlKCdkcmFnZW5kJywge1xuICAgICAgICAgICAgICAgIGRpc3RhbmNlOiB0aGlzLl9uZXdQb3MuZGlzdGFuY2VUbyh0aGlzLl9zdGFydFBvcylcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbW92aW5nID0gZmFsc2U7XG4gICAgfVxufSk7XG4iLCJ2YXIgcGFuQnkgPSBERy5NYXAucHJvdG90eXBlLnBhbkJ5LFxuICAgIGdldEJvdW5kc1pvb20gPSBERy5NYXAucHJvdG90eXBlLmdldEJvdW5kc1pvb207XG5cbi8vIFJlc3RyaWN0IHpvb20gbGV2ZWwgYWNjb3JkaW5nIHRvIDJnaXMgcHJvamVjdHMsIGluIGNhc2UgaWYgZGdUaWxlTGF5ZXIgaXMgb25seSBvbmVcbkRHLk1hcC5pbmNsdWRlKHtcblxuICAgIC8vIG51bWJlciBvZiB0aWxlTGF5ZXJzIHdpdGhvdXQgMmdpcyBsYXllcnNcbiAgICBfdGlsZUxheWVyc051bWJlcjogMCxcblxuICAgIF9tYXBNYXhab29tQ2FjaGU6IHVuZGVmaW5lZCxcblxuICAgIC8vVE9ETyB0cnkgcmVmYWN0b3IgaXQgYWZ0ZXIgdXAgb24gbmV3IGxlYWZsZXQgKD4gMC43KVxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIChpZCwgb3B0aW9ucykgeyAvLyAoSFRNTEVsZW1lbnQgb3IgU3RyaW5nLCBPYmplY3QpXG4gICAgICAgIG9wdGlvbnMgPSBMLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG5cbiAgICAgICAgdGhpcy5faW5pdENvbnRhaW5lcihpZCk7XG4gICAgICAgIHRoaXMuX2luaXRMYXlvdXQoKTtcblxuICAgICAgICAvLyBoYWNrIGZvciBodHRwczovL2dpdGh1Yi5jb20vTGVhZmxldC9MZWFmbGV0L2lzc3Vlcy8xOTgwXG4gICAgICAgIHRoaXMuX29uUmVzaXplID0gTC5iaW5kKHRoaXMuX29uUmVzaXplLCB0aGlzKTtcblxuICAgICAgICB0aGlzLl9pbml0RXZlbnRzKCk7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMubWF4Qm91bmRzKSB7XG4gICAgICAgICAgICB0aGlzLnNldE1heEJvdW5kcyhvcHRpb25zLm1heEJvdW5kcyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9oYW5kbGVycyA9IFtdO1xuXG4gICAgICAgIHRoaXMuX2xheWVycyA9IHt9O1xuICAgICAgICB0aGlzLl96b29tQm91bmRMYXllcnMgPSB7fTtcblxuICAgICAgICB0aGlzLmNhbGxJbml0SG9va3MoKTtcblxuICAgICAgICB0aGlzLl9hZGRMYXllcnMob3B0aW9ucy5sYXllcnMpO1xuXG4gICAgICAgIGlmIChvcHRpb25zLmNlbnRlciAmJiBvcHRpb25zLnpvb20gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5zZXRWaWV3KEwubGF0TG5nKG9wdGlvbnMuY2VudGVyKSwgb3B0aW9ucy56b29tLCB7cmVzZXQ6IHRydWV9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3NpemVDaGFuZ2VkID0gdHJ1ZTtcbiAgICB9LFxuXG4gICAgc2V0VmlldzogZnVuY3Rpb24gKGNlbnRlciwgem9vbSwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLl9yZXN0cmljdFpvb20oY2VudGVyKTtcblxuICAgICAgICB6b29tID0gIHRoaXMuX2xpbWl0Wm9vbSh6b29tID09PSB1bmRlZmluZWQgPyB0aGlzLl96b29tIDogem9vbSk7XG4gICAgICAgIGNlbnRlciA9IHRoaXMuX2xpbWl0Q2VudGVyKERHLmxhdExuZyhjZW50ZXIpLCB6b29tLCB0aGlzLm9wdGlvbnMubWF4Qm91bmRzKTtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuYW5pbWF0ZSkge1xuICAgICAgICAgICAgb3B0aW9ucy5hbmltYXRlID0gdGhpcy5fdGVzdEFuaW1hdGlvbihjZW50ZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX3BhbkFuaW0pIHtcbiAgICAgICAgICAgIHRoaXMuX3BhbkFuaW0uc3RvcCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2xvYWRlZCAmJiAhb3B0aW9ucy5yZXNldCAmJiBvcHRpb25zICE9PSB0cnVlKSB7XG5cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmFuaW1hdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuem9vbSA9IERHLmV4dGVuZCh7YW5pbWF0ZTogb3B0aW9ucy5hbmltYXRlfSwgb3B0aW9ucy56b29tKTtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnBhbiA9IERHLmV4dGVuZCh7YW5pbWF0ZTogb3B0aW9ucy5hbmltYXRlfSwgb3B0aW9ucy5wYW4pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB0cnkgYW5pbWF0aW5nIHBhbiBvciB6b29tXG4gICAgICAgICAgICB2YXIgYW5pbWF0ZWQgPSAodGhpcy5fem9vbSAhPT0gem9vbSkgP1xuICAgICAgICAgICAgdGhpcy5fdHJ5QW5pbWF0ZWRab29tICYmIHRoaXMuX3RyeUFuaW1hdGVkWm9vbShjZW50ZXIsIHpvb20sIG9wdGlvbnMuem9vbSkgOlxuICAgICAgICAgICAgICAgIHRoaXMuX3RyeUFuaW1hdGVkUGFuKGNlbnRlciwgb3B0aW9ucy5wYW4pO1xuXG4gICAgICAgICAgICBpZiAoYW5pbWF0ZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBwcmV2ZW50IHJlc2l6ZSBoYW5kbGVyIGNhbGwsIHRoZSB2aWV3IHdpbGwgcmVmcmVzaCBhZnRlciBhbmltYXRpb24gYW55d2F5XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3NpemVUaW1lcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhbmltYXRpb24gZGlkbid0IHN0YXJ0LCBqdXN0IHJlc2V0IHRoZSBtYXAgdmlld1xuICAgICAgICB0aGlzLl9yZXNldFZpZXcoY2VudGVyLCB6b29tKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgcGFuQnk6IGZ1bmN0aW9uIChvZmZzZXQsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIG1hcCA9IHBhbkJ5LmNhbGwodGhpcywgb2Zmc2V0LCBvcHRpb25zKTtcblxuICAgICAgICB2YXIgem9vbSA9IHRoaXMuX3Jlc3RyaWN0Wm9vbSh0aGlzLmdldENlbnRlcigpKTtcbiAgICAgICAgaWYgKHRoaXMuZ2V0Wm9vbSgpID4gem9vbSkge1xuICAgICAgICAgICAgdGhpcy5zZXRab29tKHpvb20pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1hcDtcbiAgICB9LFxuXG4gICAgZ2V0Qm91bmRzWm9vbTogZnVuY3Rpb24gKGJvdW5kcywgaW5zaWRlLCBwYWRkaW5nKSB7XG4gICAgICAgIHRoaXMuX3Jlc3RyaWN0Wm9vbShib3VuZHMpO1xuICAgICAgICByZXR1cm4gZ2V0Qm91bmRzWm9vbS5jYWxsKHRoaXMsIGJvdW5kcywgaW5zaWRlLCBwYWRkaW5nKTtcbiAgICB9LFxuXG4gICAgX3Rlc3RBbmltYXRpb246IGZ1bmN0aW9uIChjb29yZHMpIHsvL2lmIHdlIGp1bXAgdG8gb3RoZXIgcHJvamVjdCAtIGRpc2FibGUgYW5pbWF0aW9uXG4gICAgICAgIGlmICh0aGlzLnByb2plY3REZXRlY3Rvci5lbmFibGVkKCkpIHtcbiAgICAgICAgICAgIHZhciBwcm9qZWN0RnJvbSA9IHRoaXMucHJvamVjdERldGVjdG9yLmdldFByb2plY3QoKSxcbiAgICAgICAgICAgICAgICBwcm9qZWN0VG8gPSB0aGlzLnByb2plY3REZXRlY3Rvci5pc1Byb2plY3RIZXJlKGNvb3Jkcyk7XG5cbiAgICAgICAgICAgIGlmIChwcm9qZWN0RnJvbSAmJiBwcm9qZWN0VG8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvamVjdEZyb20uY29kZSA9PT0gcHJvamVjdFRvLmNvZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgX3VwZGF0ZVRpbGVMYXllcnM6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmICghKGUubGF5ZXIgaW5zdGFuY2VvZiBERy5UaWxlTGF5ZXIpIHx8IGUubGF5ZXIuX2lzRGcpIHsgcmV0dXJuOyB9XG5cbiAgICAgICAgaWYgKGUudHlwZSA9PT0gJ2xheWVyYWRkJykge1xuICAgICAgICAgICAgdGhpcy5fdGlsZUxheWVyc051bWJlcisrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fdGlsZUxheWVyc051bWJlci0tO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9yZXN0cmljdFpvb206IGZ1bmN0aW9uIChjb29yZHMpIHtcbiAgICAgICAgaWYgKHRoaXMuX2xheWVycyAmJlxuICAgICAgICAgICAgdGhpcy5wcm9qZWN0RGV0ZWN0b3IuZW5hYmxlZCgpICYmXG4gICAgICAgICAgICAodGhpcy5fdGlsZUxheWVyc051bWJlciA9PT0gMCkpIHtcblxuICAgICAgICAgICAgdmFyIG1hcE9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgaXNNYXBNYXhab29tID0gISFtYXBPcHRpb25zLm1heFpvb20sXG4gICAgICAgICAgICAgICAgZGdUaWxlTGF5ZXIgPSB0aGlzLmJhc2VMYXllcixcbiAgICAgICAgICAgICAgICBwcm9qZWN0ID0gdGhpcy5wcm9qZWN0RGV0ZWN0b3IuaXNQcm9qZWN0SGVyZShjb29yZHMpO1xuICAgICAgICAgICAgaWYgKGlzTWFwTWF4Wm9vbSkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fbWFwTWF4Wm9vbUNhY2hlKSB7IHRoaXMuX21hcE1heFpvb21DYWNoZSA9IG1hcE9wdGlvbnMubWF4Wm9vbTsgfVxuICAgICAgICAgICAgICAgIG1hcE9wdGlvbnMubWF4Wm9vbSA9ICh0aGlzLl9tYXBNYXhab29tQ2FjaGUgJiYgcHJvamVjdCkgPyB0aGlzLl9tYXBNYXhab29tQ2FjaGUgOiAgJzEzJztcbiAgICAgICAgICAgICAgICBpZiAocHJvamVjdCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYXBNYXhab29tQ2FjaGUgPSBtYXBPcHRpb25zLm1heFpvb207XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hcE9wdGlvbnMubWF4Wm9vbTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGdUaWxlTGF5ZXIub3B0aW9ucy5tYXhab29tID0gcHJvamVjdCA/IHByb2plY3QubWF4Wm9vbSA6ICcxMyc7XG4gICAgICAgICAgICAgICAgZGdUaWxlTGF5ZXIub3B0aW9ucy5tYXhOYXRpdmVab29tID0gZGdUaWxlTGF5ZXIub3B0aW9ucy5tYXhab29tO1xuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVpvb21MZXZlbHMoKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBkZ1RpbGVMYXllci5vcHRpb25zLm1heFpvb207XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gRml4IGZvciBodHRwczovL2dpdGh1Yi5jb20vMmdpcy9tYXBzYXBpL2lzc3Vlcy8zNFxuICAgIC8vIFJlbW92ZSBvbiB0aGUgbmV4dCBsZWFmbGV0IHZlcnNpb25cbiAgICAvLyBBZGQgcHJlcHJlY2xpY2sgZXZlbnQgYmVmb3JlIHByZWNsaWNrIHRoYW4gZ2VvY2xpY2tlciBjYW4gdHJhY2sgcG9wdXAgc3RhdGVcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vMmdpcy9tYXBzYXBpL3B1bGwvOTZcbiAgICBfZmlyZU1vdXNlRXZlbnQ6IGZ1bmN0aW9uIChvYmosIGUsIHR5cGUsIHByb3BhZ2F0ZSwgbGF0bG5nKSB7XG4gICAgICAgIHR5cGUgPSB0eXBlIHx8IGUudHlwZTtcblxuICAgICAgICBpZiAoTC5Eb21FdmVudC5fc2tpcHBlZChlKSkgeyByZXR1cm47IH1cblxuICAgICAgICBpZiAodHlwZSA9PT0gJ2NsaWNrJykge1xuICAgICAgICAgICAgdmFyIGRyYWdnYWJsZU9iaiA9IG9iai5vcHRpb25zLmRyYWdnYWJsZSA9PT0gdHJ1ZSA/IG9iaiA6IHRoaXM7XG4gICAgICAgICAgICBpZiAoIWUuX3NpbXVsYXRlZCAmJiAoKGRyYWdnYWJsZU9iai5kcmFnZ2luZyAmJiBkcmFnZ2FibGVPYmouZHJhZ2dpbmcubW92ZWQoKSkgfHxcbiAgICAgICAgICAgICAgICAodGhpcy5ib3hab29tICYmIHRoaXMuYm94Wm9vbS5tb3ZlZCgpKSkpIHtcbiAgICAgICAgICAgICAgICBMLkRvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbihlKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvYmouZmlyZSgncHJlcHJlY2xpY2snKTtcbiAgICAgICAgICAgIG9iai5maXJlKCdwcmVjbGljaycpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFvYmoubGlzdGVucyh0eXBlLCBwcm9wYWdhdGUpKSB7IHJldHVybjsgfVxuXG4gICAgICAgIGlmICh0eXBlID09PSAnY29udGV4dG1lbnUnKSB7XG4gICAgICAgICAgICBMLkRvbUV2ZW50LnByZXZlbnREZWZhdWx0KGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSAnY2xpY2snIHx8IHR5cGUgPT09ICdkYmxjbGljaycgfHwgdHlwZSA9PT0gJ2NvbnRleHRtZW51Jykge1xuICAgICAgICAgICAgTC5Eb21FdmVudC5zdG9wUHJvcGFnYXRpb24oZSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGUsXG4gICAgICAgICAgICBjb250YWluZXJQb2ludDogdGhpcy5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlKVxuICAgICAgICB9O1xuXG4gICAgICAgIGRhdGEubGF5ZXJQb2ludCA9IHRoaXMuY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQoZGF0YS5jb250YWluZXJQb2ludCk7XG4gICAgICAgIGRhdGEubGF0bG5nID0gbGF0bG5nIHx8IHRoaXMubGF5ZXJQb2ludFRvTGF0TG5nKGRhdGEubGF5ZXJQb2ludCk7XG5cbiAgICAgICAgb2JqLmZpcmUodHlwZSwgZGF0YSwgcHJvcGFnYXRlKTtcbiAgICB9XG59KTtcblxuREcuTWFwLmFkZEluaXRIb29rKGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLm9uKCdsYXllcmFkZCBsYXllcnJlbW92ZScsIHRoaXMuX3VwZGF0ZVRpbGVMYXllcnMpO1xufSk7XG5cbi8vIGZpeCBidWcgd2l0aCBkcmFnZ2luZyBtYXAgaW50byBuZXcgcGFyYWxsZWwgd29ybGRcbi8vIHJlbW92ZSBvbiBuZXh0IGxlYWZsZXQgdmVyc2lvblxuREcuTWFwLkRyYWcuaW5jbHVkZSh7XG4gICAgX29uRHJhZzogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fbWFwLm9wdGlvbnMuaW5lcnRpYSkge1xuICAgICAgICAgICAgdmFyIHRpbWUgPSB0aGlzLl9sYXN0VGltZSA9ICtuZXcgRGF0ZSgpLFxuICAgICAgICAgICAgICAgIHBvcyA9IHRoaXMuX2xhc3RQb3MgPSB0aGlzLl9kcmFnZ2FibGUuX2Fic1BvcyB8fCB0aGlzLl9kcmFnZ2FibGUuX25ld1BvcztcblxuICAgICAgICAgICAgdGhpcy5fcG9zaXRpb25zLnB1c2gocG9zKTtcbiAgICAgICAgICAgIHRoaXMuX3RpbWVzLnB1c2godGltZSk7XG5cbiAgICAgICAgICAgIGlmICh0aW1lIC0gdGhpcy5fdGltZXNbMF0gPiAyMDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wb3NpdGlvbnMuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl90aW1lcy5zaGlmdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbWFwXG4gICAgICAgICAgICAuZmlyZSgnbW92ZScpXG4gICAgICAgICAgICAuZmlyZSgnZHJhZycpO1xuICAgIH0sXG4gICAgX29uUHJlRHJhZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBUT0RPIHJlZmFjdG9yIHRvIGJlIGFibGUgdG8gYWRqdXN0IG1hcCBwYW5lIHBvc2l0aW9uIGFmdGVyIHpvb21cbiAgICAgICAgdmFyIHdvcmxkV2lkdGggPSB0aGlzLl93b3JsZFdpZHRoLFxuICAgICAgICAgICAgaGFsZldpZHRoID0gTWF0aC5yb3VuZCh3b3JsZFdpZHRoIC8gMiksXG4gICAgICAgICAgICBkeCA9IHRoaXMuX2luaXRpYWxXb3JsZE9mZnNldCxcbiAgICAgICAgICAgIHggPSB0aGlzLl9kcmFnZ2FibGUuX25ld1Bvcy54LFxuICAgICAgICAgICAgbmV3WDEgPSAoeCAtIGhhbGZXaWR0aCArIGR4KSAlIHdvcmxkV2lkdGggKyBoYWxmV2lkdGggLSBkeCxcbiAgICAgICAgICAgIG5ld1gyID0gKHggKyBoYWxmV2lkdGggKyBkeCkgJSB3b3JsZFdpZHRoIC0gaGFsZldpZHRoIC0gZHgsXG4gICAgICAgICAgICBuZXdYID0gTWF0aC5hYnMobmV3WDEgKyBkeCkgPCBNYXRoLmFicyhuZXdYMiArIGR4KSA/IG5ld1gxIDogbmV3WDI7XG5cbiAgICAgICAgdGhpcy5fZHJhZ2dhYmxlLl9hYnNQb3MgPSB0aGlzLl9kcmFnZ2FibGUuX25ld1Bvcy5jbG9uZSgpO1xuICAgICAgICB0aGlzLl9kcmFnZ2FibGUuX25ld1Bvcy54ID0gbmV3WDtcbiAgICB9XG59KTtcbiIsIihmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGVycm9yVXJsID0gJ2RhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBUUFBQUFFQUFRTUFBQUJtdkRvbEFBQUFBMUJNVkVYMjh0NVIwazVVQUFBQUgwbEVRVlI0WHUzQUFRa0FBQURDTVB1bk5zZGhXeHdBQUFBQUFBQUF3QUVoQUFBQmcyVVA1QUFBQUFCSlJVNUVya0pnZ2c9PSc7XG4gICAgdmFyIGVycm9yUnVVcmwgPSAnaHR0cDovLzJnaXMuZ2l0aHViLmlvL21hcHNhcGkvaW1nL25vbWFwX3J1LnBuZyc7XG5cbiAgICB2YXIgQmFzZUxheWVyID0gREcuVGlsZUxheWVyLmV4dGVuZCh7XG4gICAgICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uICh1cmwsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuX2lzRGcgPSB0cnVlO1xuICAgICAgICAgICAgREcuVGlsZUxheWVyLnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcywgdXJsLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgREcuTWFwLmFkZEluaXRIb29rKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5iYXNlTGF5ZXIgPSBuZXcgQmFzZUxheWVyKCdodHRwOi8vdGlsZXtzfS5tYXBzLjJnaXMuY29tL3RpbGVzP3g9e3h9Jnk9e3l9Jno9e3p9JnY9MScsIHtcbiAgICAgICAgICAgICAgICBzdWJkb21haW5zOiAnMDEyMycsXG4gICAgICAgICAgICAgICAgZXJyb3JUaWxlVXJsOiB0aGlzLmdldExhbmcoKSA9PT0gJ3J1JyA/IGVycm9yUnVVcmwgOiBlcnJvclVybCxcbiAgICAgICAgICAgICAgICAvKiBnbG9iYWwgdHJ1ZSAqL1xuICAgICAgICAgICAgICAgIGRldGVjdFJldGluYTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBtYXhab29tOiAxOSxcbiAgICAgICAgICAgICAgICBtYXhOYXRpdmVab29tOiAxOVxuICAgICAgICAgICAgfVxuICAgICAgICApLmFkZFRvKHRoaXMpO1xuXG4gICAgICAgIHRoaXMub24oJ2xhbmdjaGFuZ2UnLCBmdW5jdGlvbihldikge1xuICAgICAgICAgICAgaWYgKGV2LmxhbmcgPT09ICdydScpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJhc2VMYXllci5vcHRpb25zLmVycm9yVGlsZVVybCA9IGVycm9yUnVVcmw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuYmFzZUxheWVyLm9wdGlvbnMuZXJyb3JUaWxlVXJsID0gZXJyb3JVcmw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufSkoKTtcbiIsIkRHLkNvbnRyb2wuWm9vbS5pbmNsdWRlKERHLkxvY2FsZSk7XG5ERy5Db250cm9sLlpvb20uRGljdGlvbmFyeSA9IHt9O1xuXG5ERy5Db250cm9sLlpvb20uaW5jbHVkZSh7XG4gICAgLy8gVE9ETzogdGhpbmsgYWJvdXQgcHVsbCByZXF1ZXN0IHRvIGxlYWZsZXQgd2l0aCB6b29tIGNvbnRyb2wgYnV0dG9uJ3MgdGl0bGVzIGFzIG9wdGlvbnNcbiAgICBvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xuICAgICAgICB2YXIgem9vbU5hbWUgPSAnZGctem9vbScsXG4gICAgICAgICAgICBidXR0b25UZW1wbGF0ZSA9ICc8ZGl2IGNsYXNzPVwiZGctY29udHJvbC1yb3VuZF9faWNvbiAnICsgem9vbU5hbWUgKyAnX19jb250cm9sICcgKyB6b29tTmFtZSArICdfX2J1dHRvbiAnICsgem9vbU5hbWUgKyAnX19idXR0b25fdHlwZV97dHlwZX1cIj48L2Rpdj4nLFxuICAgICAgICAgICAgY29udGFpbmVyID0gREcuRG9tVXRpbC5jcmVhdGUoJ2RpdicsIHpvb21OYW1lKTtcblxuICAgICAgICB0aGlzLl9tYXAgPSBtYXA7XG5cbiAgICAgICAgdGhpcy5fem9vbUluQnV0dG9uID0gdGhpcy5fY3JlYXRlQnV0dG9uKERHLlV0aWwudGVtcGxhdGUoYnV0dG9uVGVtcGxhdGUsIHt0eXBlIDogJ2luJ30pLCB0aGlzLnQoJ3pvb21faW4nKSwgJ2RnLWNvbnRyb2wtcm91bmQgJyArIHpvb21OYW1lICsgJ19faW4nLCBjb250YWluZXIsIHRoaXMuX3pvb21JbiwgdGhpcyk7XG4gICAgICAgIHRoaXMuX3pvb21PdXRCdXR0b24gPSB0aGlzLl9jcmVhdGVCdXR0b24oREcuVXRpbC50ZW1wbGF0ZShidXR0b25UZW1wbGF0ZSwge3R5cGUgOiAnb3V0J30pLCB0aGlzLnQoJ3pvb21fb3V0JyksICdkZy1jb250cm9sLXJvdW5kICcgKyB6b29tTmFtZSArICdfX291dCcsIGNvbnRhaW5lciwgdGhpcy5fem9vbU91dCwgdGhpcyk7XG5cbiAgICAgICAgdGhpcy5fZXZlbnRMaXN0ZW5lcnMgPSB7fTtcbiAgICAgICAgdGhpcy5fZXZlbnRMaXN0ZW5lcnMuem9vbWVuZCA9IHRoaXMuX2V2ZW50TGlzdGVuZXJzLnpvb21sZXZlbHNjaGFuZ2UgPSB0aGlzLl91cGRhdGVEaXNhYmxlZDtcbiAgICAgICAgdGhpcy5fdXBkYXRlRGlzYWJsZWQoKTtcbiAgICAgICAgbWFwLm9uKHRoaXMuX2V2ZW50TGlzdGVuZXJzLCB0aGlzKTtcblxuICAgICAgICByZXR1cm4gY29udGFpbmVyO1xuICAgIH0sXG5cbiAgICBfb3JpZ2luYWxDcmVhdGVCdXR0b246IERHLkNvbnRyb2wuWm9vbS5wcm90b3R5cGUuX2NyZWF0ZUJ1dHRvbixcblxuICAgIF9jcmVhdGVCdXR0b246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICB2YXIgbGluayA9IHRoaXMuX29yaWdpbmFsQ3JlYXRlQnV0dG9uLmFwcGx5KHRoaXMsIGFyZ3MpO1xuXG4gICAgICAgIHZhciBpY29uID0gbGluay5jaGlsZHJlblswXTtcbiAgICAgICAgdmFyIGxpbmtBY3RpdmVDbGFzcyA9ICdkZy1jb250cm9sLXJvdW5kX3N0YXRlX2FjdGl2ZSc7XG4gICAgICAgIHZhciBpY29uQWN0aXZlQ2xhc3MgPSAnZGctY29udHJvbC1yb3VuZF9faWNvbl9zdGF0ZV9hY3RpdmUnO1xuXG4gICAgICAgIERHLkRvbUV2ZW50XG4gICAgICAgICAgICAub24obGluaywgJ3RvdWNoc3RhcnQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgREcuRG9tVXRpbC5hZGRDbGFzcyhsaW5rLCBsaW5rQWN0aXZlQ2xhc3MpO1xuICAgICAgICAgICAgICAgIERHLkRvbVV0aWwuYWRkQ2xhc3MoaWNvbiwgaWNvbkFjdGl2ZUNsYXNzKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAub24obGluaywgJ3RvdWNoZW5kIHRvdWNoY2FuY2VsJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIERHLkRvbVV0aWwucmVtb3ZlQ2xhc3MobGluaywgbGlua0FjdGl2ZUNsYXNzKTtcbiAgICAgICAgICAgICAgICBERy5Eb21VdGlsLnJlbW92ZUNsYXNzKGljb24sIGljb25BY3RpdmVDbGFzcyk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gbGluaztcbiAgICB9LFxuXG4gICAgb25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcbiAgICAgICAgbWFwLm9mZih0aGlzLl9ldmVudExpc3RlbmVycywgdGhpcyk7XG4gICAgfSxcblxuICAgIF9yZW5kZXJUcmFuc2xhdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl96b29tSW5CdXR0b24udGl0bGUgPSB0aGlzLnQoJ3pvb21faW4nKTtcbiAgICAgICAgdGhpcy5fem9vbU91dEJ1dHRvbi50aXRsZSA9IHRoaXMudCgnem9vbV9vdXQnKTtcbiAgICB9XG59KTtcbiIsIkRHLkNvbnRyb2wuWm9vbS5EaWN0aW9uYXJ5LnJ1ID0ge1xuICAgIHpvb21faW4gOiAn0J/RgNC40LHQu9C40LfQuNGC0YwnLFxuICAgIHpvb21fb3V0IDogJ9Ce0YLQtNCw0LvQuNGC0YwnXG59OyIsIkRHLkNvbnRyb2wuWm9vbS5EaWN0aW9uYXJ5Lml0ID0ge1xuICAgIHpvb21faW4gOiAnWm9vbSBhdmFudGknLFxuICAgIHpvb21fb3V0IDogJ1pvb20gaW5kaWV0cm8nXG59OyIsIkRHLkNvbnRyb2wuWm9vbS5EaWN0aW9uYXJ5LmNzID0ge1xuICAgIHpvb21faW4gOiAnUMWZaWJsw63Fvml0JyxcbiAgICB6b29tX291dCA6ICdPZGTDoWxpdCdcbn07IiwiREcuQ29udHJvbC5ab29tLkRpY3Rpb25hcnkuZW4gPSB7XG4gICAgem9vbV9pbiA6ICdab29tIGluJyxcbiAgICB6b29tX291dCA6ICdab29tIG91dCdcbn07IiwiREcuQ29udHJvbC5ab29tLkRpY3Rpb25hcnkuZXMgPSB7XG4gICAgem9vbV9pbiA6ICdBY2VyY2FyJyxcbiAgICB6b29tX291dCA6ICdBbGVqYXInXG59O1xuIiwiLyohIER1c3QgLSBBc3luY2hyb25vdXMgVGVtcGxhdGluZyAtIHYyLjYuMVxuKiBodHRwOi8vbGlua2VkaW4uZ2l0aHViLmlvL2R1c3Rqcy9cbiogQ29weXJpZ2h0IChjKSAyMDE1IEFsZWtzYW5kZXIgV2lsbGlhbXM7IFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZSAqL1xuKGZ1bmN0aW9uKHJvb3QpIHtcbiAgdmFyIGR1c3QgPSB7XG4gICAgICAgIFwidmVyc2lvblwiOiBcIjIuNi4xXCJcbiAgICAgIH0sXG4gICAgICBOT05FID0gJ05PTkUnLFxuICAgICAgRVJST1IgPSAnRVJST1InLFxuICAgICAgV0FSTiA9ICdXQVJOJyxcbiAgICAgIElORk8gPSAnSU5GTycsXG4gICAgICBERUJVRyA9ICdERUJVRycsXG4gICAgICBsb2dnaW5nTGV2ZWxzID0gW0RFQlVHLCBJTkZPLCBXQVJOLCBFUlJPUiwgTk9ORV0sXG4gICAgICBFTVBUWV9GVU5DID0gZnVuY3Rpb24oKSB7fSxcbiAgICAgIGxvZ2dlciA9IHt9LFxuICAgICAgb3JpZ2luYWxMb2csXG4gICAgICBsb2dnZXJDb250ZXh0O1xuXG4gIGR1c3QuZGVidWdMZXZlbCA9IE5PTkU7XG5cbiAgZHVzdC5jb25maWcgPSB7XG4gICAgd2hpdGVzcGFjZTogZmFsc2UsXG4gICAgYW1kOiBmYWxzZVxuICB9O1xuXG4gIC8vIERpcmVjdGl2ZSBhbGlhc2VzIHRvIG1pbmlmeSBjb2RlXG4gIGR1c3QuX2FsaWFzZXMgPSB7XG4gICAgXCJ3cml0ZVwiOiBcIndcIixcbiAgICBcImVuZFwiOiBcImVcIixcbiAgICBcIm1hcFwiOiBcIm1cIixcbiAgICBcInJlbmRlclwiOiBcInJcIixcbiAgICBcInJlZmVyZW5jZVwiOiBcImZcIixcbiAgICBcInNlY3Rpb25cIjogXCJzXCIsXG4gICAgXCJleGlzdHNcIjogXCJ4XCIsXG4gICAgXCJub3RleGlzdHNcIjogXCJueFwiLFxuICAgIFwiYmxvY2tcIjogXCJiXCIsXG4gICAgXCJwYXJ0aWFsXCI6IFwicFwiLFxuICAgIFwiaGVscGVyXCI6IFwiaFwiXG4gIH07XG5cbiAgLy8gVHJ5IHRvIGZpbmQgdGhlIGNvbnNvbGUgaW4gZ2xvYmFsIHNjb3BlXG4gIGlmIChyb290ICYmIHJvb3QuY29uc29sZSAmJiByb290LmNvbnNvbGUubG9nKSB7XG4gICAgbG9nZ2VyQ29udGV4dCA9IHJvb3QuY29uc29sZTtcbiAgICBvcmlnaW5hbExvZyA9IHJvb3QuY29uc29sZS5sb2c7XG4gIH1cblxuICAvLyByb2J1c3QgbG9nZ2VyIGZvciBub2RlLmpzLCBtb2Rlcm4gYnJvd3NlcnMsIGFuZCBJRSA8PSA5LlxuICBsb2dnZXIubG9nID0gbG9nZ2VyQ29udGV4dCA/IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gRG8gdGhpcyBmb3Igbm9ybWFsIGJyb3dzZXJzXG4gICAgICBpZiAodHlwZW9mIG9yaWdpbmFsTG9nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGxvZ2dlci5sb2cgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBvcmlnaW5hbExvZy5hcHBseShsb2dnZXJDb250ZXh0LCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRG8gdGhpcyBmb3IgSUUgPD0gOVxuICAgICAgICBsb2dnZXIubG9nID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIG1lc3NhZ2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkoYXJndW1lbnRzKS5qb2luKCcgJyk7XG4gICAgICAgICAgb3JpZ2luYWxMb2cobWVzc2FnZSk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBsb2dnZXIubG9nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH0gOiBmdW5jdGlvbigpIHsgLyogbm8gb3AgKi8gfTtcblxuICAvKipcbiAgICogTG9nIGR1c3QgZGVidWcgc3RhdGVtZW50cywgaW5mbyBzdGF0ZW1lbnRzLCB3YXJuaW5nIHN0YXRlbWVudHMsIGFuZCBlcnJvcnMuXG4gICAqIEZpbHRlcnMgb3V0IHRoZSBtZXNzYWdlcyBiYXNlZCBvbiB0aGUgZHVzdC5kZWJ1Z2xldmVsLlxuICAgKiBUaGlzIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gd2lsbCBwcmludCB0byB0aGUgY29uc29sZSBpZiBpdCBleGlzdHMuXG4gICAqIEBwYXJhbSB7U3RyaW5nfEVycm9yfSBtZXNzYWdlIHRoZSBtZXNzYWdlIHRvIHByaW50L3Rocm93XG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIHRoZSBzZXZlcml0eSBvZiB0aGUgbWVzc2FnZShFUlJPUiwgV0FSTiwgSU5GTywgb3IgREVCVUcpXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGR1c3QubG9nID0gZnVuY3Rpb24obWVzc2FnZSwgdHlwZSkge1xuICAgIHR5cGUgPSB0eXBlIHx8IElORk87XG4gICAgaWYgKGR1c3QuZGVidWdMZXZlbCAhPT0gTk9ORSAmJiBkdXN0LmluZGV4SW5BcnJheShsb2dnaW5nTGV2ZWxzLCB0eXBlKSA+PSBkdXN0LmluZGV4SW5BcnJheShsb2dnaW5nTGV2ZWxzLCBkdXN0LmRlYnVnTGV2ZWwpKSB7XG4gICAgICBpZighZHVzdC5sb2dRdWV1ZSkge1xuICAgICAgICBkdXN0LmxvZ1F1ZXVlID0gW107XG4gICAgICB9XG4gICAgICBkdXN0LmxvZ1F1ZXVlLnB1c2goe21lc3NhZ2U6IG1lc3NhZ2UsIHR5cGU6IHR5cGV9KTtcbiAgICAgIGxvZ2dlci5sb2coJ1tEVVNUOicgKyB0eXBlICsgJ10nLCBtZXNzYWdlKTtcbiAgICB9XG4gIH07XG5cbiAgZHVzdC5oZWxwZXJzID0ge307XG5cbiAgZHVzdC5jYWNoZSA9IHt9O1xuXG4gIGR1c3QucmVnaXN0ZXIgPSBmdW5jdGlvbihuYW1lLCB0bXBsKSB7XG4gICAgaWYgKCFuYW1lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGR1c3QuY2FjaGVbbmFtZV0gPSB0bXBsO1xuICB9O1xuXG4gIGR1c3QucmVuZGVyID0gZnVuY3Rpb24obmFtZSwgY29udGV4dCwgY2FsbGJhY2spIHtcbiAgICB2YXIgY2h1bmsgPSBuZXcgU3R1YihjYWxsYmFjaykuaGVhZDtcbiAgICB0cnkge1xuICAgICAgZHVzdC5sb2FkKG5hbWUsIGNodW5rLCBDb250ZXh0LndyYXAoY29udGV4dCwgbmFtZSkpLmVuZCgpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY2h1bmsuc2V0RXJyb3IoZXJyKTtcbiAgICB9XG4gIH07XG5cbiAgZHVzdC5zdHJlYW0gPSBmdW5jdGlvbihuYW1lLCBjb250ZXh0KSB7XG4gICAgdmFyIHN0cmVhbSA9IG5ldyBTdHJlYW0oKSxcbiAgICAgICAgY2h1bmsgPSBzdHJlYW0uaGVhZDtcbiAgICBkdXN0Lm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZHVzdC5sb2FkKG5hbWUsIHN0cmVhbS5oZWFkLCBDb250ZXh0LndyYXAoY29udGV4dCwgbmFtZSkpLmVuZCgpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNodW5rLnNldEVycm9yKGVycik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHN0cmVhbTtcbiAgfTtcblxuICBkdXN0LnJlbmRlclNvdXJjZSA9IGZ1bmN0aW9uKHNvdXJjZSwgY29udGV4dCwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gZHVzdC5jb21waWxlRm4oc291cmNlKShjb250ZXh0LCBjYWxsYmFjayk7XG4gIH07XG5cbiAgZHVzdC5jb21waWxlRm4gPSBmdW5jdGlvbihzb3VyY2UsIG5hbWUpIHtcbiAgICAvLyBuYW1lIGlzIG9wdGlvbmFsLiBXaGVuIG5hbWUgaXMgbm90IHByb3ZpZGVkIHRoZSB0ZW1wbGF0ZSBjYW4gb25seSBiZSByZW5kZXJlZCB1c2luZyB0aGUgY2FsbGFibGUgcmV0dXJuZWQgYnkgdGhpcyBmdW5jdGlvbi5cbiAgICAvLyBJZiBhIG5hbWUgaXMgcHJvdmlkZWQgdGhlIGNvbXBpbGVkIHRlbXBsYXRlIGNhbiBhbHNvIGJlIHJlbmRlcmVkIGJ5IG5hbWUuXG4gICAgbmFtZSA9IG5hbWUgfHwgbnVsbDtcbiAgICB2YXIgdG1wbCA9IGR1c3QubG9hZFNvdXJjZShkdXN0LmNvbXBpbGUoc291cmNlLCBuYW1lKSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGNvbnRleHQsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgbWFzdGVyID0gY2FsbGJhY2sgPyBuZXcgU3R1YihjYWxsYmFjaykgOiBuZXcgU3RyZWFtKCk7XG4gICAgICBkdXN0Lm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgICBpZih0eXBlb2YgdG1wbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHRtcGwobWFzdGVyLmhlYWQsIENvbnRleHQud3JhcChjb250ZXh0LCBuYW1lKSkuZW5kKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZHVzdC5sb2cobmV3IEVycm9yKCdUZW1wbGF0ZSBbJyArIG5hbWUgKyAnXSBjYW5ub3QgYmUgcmVzb2x2ZWQgdG8gYSBEdXN0IGZ1bmN0aW9uJyksIEVSUk9SKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gbWFzdGVyO1xuICAgIH07XG4gIH07XG5cbiAgZHVzdC5sb2FkID0gZnVuY3Rpb24obmFtZSwgY2h1bmssIGNvbnRleHQpIHtcbiAgICB2YXIgdG1wbCA9IGR1c3QuY2FjaGVbbmFtZV07XG4gICAgaWYgKHRtcGwpIHtcbiAgICAgIHJldHVybiB0bXBsKGNodW5rLCBjb250ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGR1c3Qub25Mb2FkKSB7XG4gICAgICAgIHJldHVybiBjaHVuay5tYXAoZnVuY3Rpb24oY2h1bmspIHtcbiAgICAgICAgICBkdXN0Lm9uTG9hZChuYW1lLCBmdW5jdGlvbihlcnIsIHNyYykge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICByZXR1cm4gY2h1bmsuc2V0RXJyb3IoZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZHVzdC5jYWNoZVtuYW1lXSkge1xuICAgICAgICAgICAgICBkdXN0LmxvYWRTb3VyY2UoZHVzdC5jb21waWxlKHNyYywgbmFtZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZHVzdC5jYWNoZVtuYW1lXShjaHVuaywgY29udGV4dCkuZW5kKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNodW5rLnNldEVycm9yKG5ldyBFcnJvcignVGVtcGxhdGUgTm90IEZvdW5kOiAnICsgbmFtZSkpO1xuICAgIH1cbiAgfTtcblxuICBkdXN0LmxvYWRTb3VyY2UgPSBmdW5jdGlvbihzb3VyY2UsIHBhdGgpIHtcbiAgICByZXR1cm4gZXZhbChzb3VyY2UpO1xuICB9O1xuXG4gIGlmIChBcnJheS5pc0FycmF5KSB7XG4gICAgZHVzdC5pc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcbiAgfSBlbHNlIHtcbiAgICBkdXN0LmlzQXJyYXkgPSBmdW5jdGlvbihhcnIpIHtcbiAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJyKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgICB9O1xuICB9XG5cbiAgLy8gaW5kZXhPZiBzaGltIGZvciBhcnJheXMgZm9yIElFIDw9IDhcbiAgLy8gc291cmNlOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9pbmRleE9mXG4gIGR1c3QuaW5kZXhJbkFycmF5ID0gZnVuY3Rpb24oYXJyLCBpdGVtLCBmcm9tSW5kZXgpIHtcbiAgICBmcm9tSW5kZXggPSArZnJvbUluZGV4IHx8IDA7XG4gICAgaWYgKEFycmF5LnByb3RvdHlwZS5pbmRleE9mKSB7XG4gICAgICByZXR1cm4gYXJyLmluZGV4T2YoaXRlbSwgZnJvbUluZGV4KTtcbiAgICB9IGVsc2Uge1xuICAgIGlmICggYXJyID09PSB1bmRlZmluZWQgfHwgYXJyID09PSBudWxsICkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvciggJ2Nhbm5vdCBjYWxsIG1ldGhvZCBcImluZGV4T2ZcIiBvZiBudWxsJyApO1xuICAgIH1cblxuICAgIHZhciBsZW5ndGggPSBhcnIubGVuZ3RoOyAvLyBIYWNrIHRvIGNvbnZlcnQgb2JqZWN0Lmxlbmd0aCB0byBhIFVJbnQzMlxuXG4gICAgaWYgKE1hdGguYWJzKGZyb21JbmRleCkgPT09IEluZmluaXR5KSB7XG4gICAgICBmcm9tSW5kZXggPSAwO1xuICAgIH1cblxuICAgIGlmIChmcm9tSW5kZXggPCAwKSB7XG4gICAgICBmcm9tSW5kZXggKz0gbGVuZ3RoO1xuICAgICAgaWYgKGZyb21JbmRleCA8IDApIHtcbiAgICAgICAgZnJvbUluZGV4ID0gMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKDtmcm9tSW5kZXggPCBsZW5ndGg7IGZyb21JbmRleCsrKSB7XG4gICAgICBpZiAoYXJyW2Zyb21JbmRleF0gPT09IGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGZyb21JbmRleDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gLTE7XG4gICAgfVxuICB9O1xuXG4gIGR1c3QubmV4dFRpY2sgPSAoZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICBzZXRUaW1lb3V0KGNhbGxiYWNrLDApO1xuICAgIH07XG4gIH0gKSgpO1xuXG4gIGR1c3QuaXNFbXB0eSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgaWYgKGR1c3QuaXNBcnJheSh2YWx1ZSkgJiYgIXZhbHVlLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gKCF2YWx1ZSk7XG4gIH07XG5cbiAgLy8gYXBwbHkgdGhlIGZpbHRlciBjaGFpbiBhbmQgcmV0dXJuIHRoZSBvdXRwdXQgc3RyaW5nXG4gIGR1c3QuZmlsdGVyID0gZnVuY3Rpb24oc3RyaW5nLCBhdXRvLCBmaWx0ZXJzKSB7XG4gICAgaWYgKGZpbHRlcnMpIHtcbiAgICAgIGZvciAodmFyIGk9MCwgbGVuPWZpbHRlcnMubGVuZ3RoOyBpPGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBuYW1lID0gZmlsdGVyc1tpXTtcbiAgICAgICAgaWYgKG5hbWUgPT09ICdzJykge1xuICAgICAgICAgIGF1dG8gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBkdXN0LmZpbHRlcnNbbmFtZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBzdHJpbmcgPSBkdXN0LmZpbHRlcnNbbmFtZV0oc3RyaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBkdXN0LmxvZygnSW52YWxpZCBmaWx0ZXIgWycgKyBuYW1lICsgJ10nLCBXQVJOKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBieSBkZWZhdWx0IGFsd2F5cyBhcHBseSB0aGUgaCBmaWx0ZXIsIHVubGVzcyBhc2tlZCB0byB1bmVzY2FwZSB3aXRoIHxzXG4gICAgaWYgKGF1dG8pIHtcbiAgICAgIHN0cmluZyA9IGR1c3QuZmlsdGVyc1thdXRvXShzdHJpbmcpO1xuICAgIH1cbiAgICByZXR1cm4gc3RyaW5nO1xuICB9O1xuXG4gIGR1c3QuZmlsdGVycyA9IHtcbiAgICBoOiBmdW5jdGlvbih2YWx1ZSkgeyByZXR1cm4gZHVzdC5lc2NhcGVIdG1sKHZhbHVlKTsgfSxcbiAgICBqOiBmdW5jdGlvbih2YWx1ZSkgeyByZXR1cm4gZHVzdC5lc2NhcGVKcyh2YWx1ZSk7IH0sXG4gICAgdTogZW5jb2RlVVJJLFxuICAgIHVjOiBlbmNvZGVVUklDb21wb25lbnQsXG4gICAganM6IGZ1bmN0aW9uKHZhbHVlKSB7IHJldHVybiBkdXN0LmVzY2FwZUpTT04odmFsdWUpOyB9LFxuICAgIGpwOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgaWYgKCFKU09OKSB7ZHVzdC5sb2coJ0pTT04gaXMgdW5kZWZpbmVkLiAgSlNPTiBwYXJzZSBoYXMgbm90IGJlZW4gdXNlZCBvbiBbJyArIHZhbHVlICsgJ10nLCBXQVJOKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UodmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBDb250ZXh0KHN0YWNrLCBnbG9iYWwsIGJsb2NrcywgdGVtcGxhdGVOYW1lKSB7XG4gICAgdGhpcy5zdGFjayAgPSBzdGFjaztcbiAgICB0aGlzLmdsb2JhbCA9IGdsb2JhbDtcbiAgICB0aGlzLmJsb2NrcyA9IGJsb2NrcztcbiAgICB0aGlzLnRlbXBsYXRlTmFtZSA9IHRlbXBsYXRlTmFtZTtcbiAgfVxuXG4gIGR1c3QubWFrZUJhc2UgPSBmdW5jdGlvbihnbG9iYWwpIHtcbiAgICByZXR1cm4gbmV3IENvbnRleHQobmV3IFN0YWNrKCksIGdsb2JhbCk7XG4gIH07XG5cbiAgQ29udGV4dC53cmFwID0gZnVuY3Rpb24oY29udGV4dCwgbmFtZSkge1xuICAgIGlmIChjb250ZXh0IGluc3RhbmNlb2YgQ29udGV4dCkge1xuICAgICAgcmV0dXJuIGNvbnRleHQ7XG4gICAgfVxuICAgIHJldHVybiBuZXcgQ29udGV4dChuZXcgU3RhY2soY29udGV4dCksIHt9LCBudWxsLCBuYW1lKTtcbiAgfTtcblxuICAvKipcbiAgICogUHVibGljIEFQSSBmb3IgZ2V0dGluZyBhIHZhbHVlIGZyb20gdGhlIGNvbnRleHQuXG4gICAqIEBtZXRob2QgZ2V0XG4gICAqIEBwYXJhbSB7c3RyaW5nfGFycmF5fSBwYXRoIFRoZSBwYXRoIHRvIHRoZSB2YWx1ZS4gU3VwcG9ydGVkIGZvcm1hdHMgYXJlOlxuICAgKiAna2V5J1xuICAgKiAncGF0aC50by5rZXknXG4gICAqICcucGF0aC50by5rZXknXG4gICAqIFsncGF0aCcsICd0bycsICdrZXknXVxuICAgKiBbJ2tleSddXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2N1cj1mYWxzZV0gQm9vbGVhbiB3aGljaCBkZXRlcm1pbmVzIGlmIHRoZSBzZWFyY2ggc2hvdWxkIGJlIGxpbWl0ZWQgdG8gdGhlXG4gICAqIGN1cnJlbnQgY29udGV4dCAodHJ1ZSksIG9yIGlmIGdldCBzaG91bGQgc2VhcmNoIGluIHBhcmVudCBjb250ZXh0cyBhcyB3ZWxsIChmYWxzZSkuXG4gICAqIEBwdWJsaWNcbiAgICogQHJldHVybnMge3N0cmluZ3xvYmplY3R9XG4gICAqL1xuICBDb250ZXh0LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihwYXRoLCBjdXIpIHtcbiAgICBpZiAodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAocGF0aFswXSA9PT0gJy4nKSB7XG4gICAgICAgIGN1ciA9IHRydWU7XG4gICAgICAgIHBhdGggPSBwYXRoLnN1YnN0cigxKTtcbiAgICAgIH1cbiAgICAgIHBhdGggPSBwYXRoLnNwbGl0KCcuJyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9nZXQoY3VyLCBwYXRoKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IGEgdmFsdWUgZnJvbSB0aGUgY29udGV4dFxuICAgKiBAbWV0aG9kIF9nZXRcbiAgICogQHBhcmFtIHtib29sZWFufSBjdXIgR2V0IG9ubHkgZnJvbSB0aGUgY3VycmVudCBjb250ZXh0XG4gICAqIEBwYXJhbSB7YXJyYXl9IGRvd24gQW4gYXJyYXkgb2YgZWFjaCBzdGVwIGluIHRoZSBwYXRoXG4gICAqIEBwcml2YXRlXG4gICAqIEByZXR1cm4ge3N0cmluZyB8IG9iamVjdH1cbiAgICovXG4gIENvbnRleHQucHJvdG90eXBlLl9nZXQgPSBmdW5jdGlvbihjdXIsIGRvd24pIHtcbiAgICB2YXIgY3R4ID0gdGhpcy5zdGFjayxcbiAgICAgICAgaSA9IDEsXG4gICAgICAgIHZhbHVlLCBmaXJzdCwgbGVuLCBjdHhUaGlzLCBmbjtcbiAgICBmaXJzdCA9IGRvd25bMF07XG4gICAgbGVuID0gZG93bi5sZW5ndGg7XG5cbiAgICBpZiAoY3VyICYmIGxlbiA9PT0gMCkge1xuICAgICAgY3R4VGhpcyA9IGN0eDtcbiAgICAgIGN0eCA9IGN0eC5oZWFkO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIWN1cikge1xuICAgICAgICAvLyBTZWFyY2ggdXAgdGhlIHN0YWNrIGZvciB0aGUgZmlyc3QgdmFsdWVcbiAgICAgICAgd2hpbGUgKGN0eCkge1xuICAgICAgICAgIGlmIChjdHguaXNPYmplY3QpIHtcbiAgICAgICAgICAgIGN0eFRoaXMgPSBjdHguaGVhZDtcbiAgICAgICAgICAgIHZhbHVlID0gY3R4LmhlYWRbZmlyc3RdO1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGN0eCA9IGN0eC50YWlsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjdHggPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdHggPSB0aGlzLmdsb2JhbCA/IHRoaXMuZ2xvYmFsW2ZpcnN0XSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjdHgpIHtcbiAgICAgICAgLy8gaWYgc2NvcGUgaXMgbGltaXRlZCBieSBhIGxlYWRpbmcgZG90LCBkb24ndCBzZWFyY2ggdXAgdGhlIHRyZWVcbiAgICAgICAgaWYoY3R4LmhlYWQpIHtcbiAgICAgICAgICBjdHggPSBjdHguaGVhZFtmaXJzdF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy9jb250ZXh0J3MgaGVhZCBpcyBlbXB0eSwgdmFsdWUgd2UgYXJlIHNlYXJjaGluZyBmb3IgaXMgbm90IGRlZmluZWRcbiAgICAgICAgICBjdHggPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgd2hpbGUgKGN0eCAmJiBpIDwgbGVuKSB7XG4gICAgICAgIGN0eFRoaXMgPSBjdHg7XG4gICAgICAgIGN0eCA9IGN0eFtkb3duW2ldXTtcbiAgICAgICAgaSsrO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJldHVybiB0aGUgY3R4IG9yIGEgZnVuY3Rpb24gd3JhcHBpbmcgdGhlIGFwcGxpY2F0aW9uIG9mIHRoZSBjb250ZXh0LlxuICAgIGlmICh0eXBlb2YgY3R4ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBmbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBjdHguYXBwbHkoY3R4VGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgZHVzdC5sb2coZXJyLCBFUlJPUik7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgZm4uX19kdXN0Qm9keSA9ICEhY3R4Ll9fZHVzdEJvZHk7XG4gICAgICByZXR1cm4gZm47XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChjdHggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkdXN0LmxvZygnQ2Fubm90IGZpbmQgdGhlIHZhbHVlIGZvciByZWZlcmVuY2UgW3snICsgZG93bi5qb2luKCcuJykgKyAnfV0gaW4gdGVtcGxhdGUgWycgKyB0aGlzLmdldFRlbXBsYXRlTmFtZSgpICsgJ10nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjdHg7XG4gICAgfVxuICB9O1xuXG4gIENvbnRleHQucHJvdG90eXBlLmdldFBhdGggPSBmdW5jdGlvbihjdXIsIGRvd24pIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0KGN1ciwgZG93bik7XG4gIH07XG5cbiAgQ29udGV4dC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uKGhlYWQsIGlkeCwgbGVuKSB7XG4gICAgcmV0dXJuIG5ldyBDb250ZXh0KG5ldyBTdGFjayhoZWFkLCB0aGlzLnN0YWNrLCBpZHgsIGxlbiksIHRoaXMuZ2xvYmFsLCB0aGlzLmJsb2NrcywgdGhpcy5nZXRUZW1wbGF0ZU5hbWUoKSk7XG4gIH07XG5cbiAgQ29udGV4dC5wcm90b3R5cGUucmViYXNlID0gZnVuY3Rpb24oaGVhZCkge1xuICAgIHJldHVybiBuZXcgQ29udGV4dChuZXcgU3RhY2soaGVhZCksIHRoaXMuZ2xvYmFsLCB0aGlzLmJsb2NrcywgdGhpcy5nZXRUZW1wbGF0ZU5hbWUoKSk7XG4gIH07XG5cbiAgQ29udGV4dC5wcm90b3R5cGUuY3VycmVudCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnN0YWNrLmhlYWQ7XG4gIH07XG5cbiAgQ29udGV4dC5wcm90b3R5cGUuZ2V0QmxvY2sgPSBmdW5jdGlvbihrZXksIGNoaywgY3R4KSB7XG4gICAgaWYgKHR5cGVvZiBrZXkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciB0ZW1wQ2hrID0gbmV3IENodW5rKCk7XG4gICAgICBrZXkgPSBrZXkodGVtcENoaywgdGhpcykuZGF0YS5qb2luKCcnKTtcbiAgICB9XG5cbiAgICB2YXIgYmxvY2tzID0gdGhpcy5ibG9ja3M7XG5cbiAgICBpZiAoIWJsb2Nrcykge1xuICAgICAgZHVzdC5sb2coJ05vIGJsb2NrcyBmb3IgY29udGV4dFt7JyArIGtleSArICd9XSBpbiB0ZW1wbGF0ZSBbJyArIHRoaXMuZ2V0VGVtcGxhdGVOYW1lKCkgKyAnXScsIERFQlVHKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGxlbiA9IGJsb2Nrcy5sZW5ndGgsIGZuO1xuICAgIHdoaWxlIChsZW4tLSkge1xuICAgICAgZm4gPSBibG9ja3NbbGVuXVtrZXldO1xuICAgICAgaWYgKGZuKSB7XG4gICAgICAgIHJldHVybiBmbjtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgQ29udGV4dC5wcm90b3R5cGUuc2hpZnRCbG9ja3MgPSBmdW5jdGlvbihsb2NhbHMpIHtcbiAgICB2YXIgYmxvY2tzID0gdGhpcy5ibG9ja3MsXG4gICAgICAgIG5ld0Jsb2NrcztcblxuICAgIGlmIChsb2NhbHMpIHtcbiAgICAgIGlmICghYmxvY2tzKSB7XG4gICAgICAgIG5ld0Jsb2NrcyA9IFtsb2NhbHNdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV3QmxvY2tzID0gYmxvY2tzLmNvbmNhdChbbG9jYWxzXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IENvbnRleHQodGhpcy5zdGFjaywgdGhpcy5nbG9iYWwsIG5ld0Jsb2NrcywgdGhpcy5nZXRUZW1wbGF0ZU5hbWUoKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIENvbnRleHQucHJvdG90eXBlLmdldFRlbXBsYXRlTmFtZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnRlbXBsYXRlTmFtZTtcbiAgfTtcblxuICBmdW5jdGlvbiBTdGFjayhoZWFkLCB0YWlsLCBpZHgsIGxlbikge1xuICAgIHRoaXMudGFpbCA9IHRhaWw7XG4gICAgdGhpcy5pc09iamVjdCA9IGhlYWQgJiYgdHlwZW9mIGhlYWQgPT09ICdvYmplY3QnO1xuICAgIHRoaXMuaGVhZCA9IGhlYWQ7XG4gICAgdGhpcy5pbmRleCA9IGlkeDtcbiAgICB0aGlzLm9mID0gbGVuO1xuICB9XG5cbiAgZnVuY3Rpb24gU3R1YihjYWxsYmFjaykge1xuICAgIHRoaXMuaGVhZCA9IG5ldyBDaHVuayh0aGlzKTtcbiAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgdGhpcy5vdXQgPSAnJztcbiAgfVxuXG4gIFN0dWIucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNodW5rID0gdGhpcy5oZWFkO1xuXG4gICAgd2hpbGUgKGNodW5rKSB7XG4gICAgICBpZiAoY2h1bmsuZmx1c2hhYmxlKSB7XG4gICAgICAgIHRoaXMub3V0ICs9IGNodW5rLmRhdGEuam9pbignJyk7IC8vaWU3IHBlcmZcbiAgICAgIH0gZWxzZSBpZiAoY2h1bmsuZXJyb3IpIHtcbiAgICAgICAgdGhpcy5jYWxsYmFjayhjaHVuay5lcnJvcik7XG4gICAgICAgIGR1c3QubG9nKCdDaHVuayBlcnJvciBbJyArIGNodW5rLmVycm9yICsgJ10gdGhyb3duLiBDZWFzaW5nIHRvIHJlbmRlciB0aGlzIHRlbXBsYXRlLicsIFdBUk4pO1xuICAgICAgICB0aGlzLmZsdXNoID0gRU1QVFlfRlVOQztcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY2h1bmsgPSBjaHVuay5uZXh0O1xuICAgICAgdGhpcy5oZWFkID0gY2h1bms7XG4gICAgfVxuICAgIHRoaXMuY2FsbGJhY2sobnVsbCwgdGhpcy5vdXQpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIFN0cmVhbSgpIHtcbiAgICB0aGlzLmhlYWQgPSBuZXcgQ2h1bmsodGhpcyk7XG4gIH1cblxuICBTdHJlYW0ucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNodW5rID0gdGhpcy5oZWFkO1xuXG4gICAgd2hpbGUoY2h1bmspIHtcbiAgICAgIGlmIChjaHVuay5mbHVzaGFibGUpIHtcbiAgICAgICAgdGhpcy5lbWl0KCdkYXRhJywgY2h1bmsuZGF0YS5qb2luKCcnKSk7IC8vaWU3IHBlcmZcbiAgICAgIH0gZWxzZSBpZiAoY2h1bmsuZXJyb3IpIHtcbiAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGNodW5rLmVycm9yKTtcbiAgICAgICAgZHVzdC5sb2coJ0NodW5rIGVycm9yIFsnICsgY2h1bmsuZXJyb3IgKyAnXSB0aHJvd24uIENlYXNpbmcgdG8gcmVuZGVyIHRoaXMgdGVtcGxhdGUuJywgV0FSTik7XG4gICAgICAgIHRoaXMuZmx1c2ggPSBFTVBUWV9GVU5DO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjaHVuayA9IGNodW5rLm5leHQ7XG4gICAgICB0aGlzLmhlYWQgPSBjaHVuaztcbiAgICB9XG4gICAgdGhpcy5lbWl0KCdlbmQnKTtcbiAgfTtcblxuICBTdHJlYW0ucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbih0eXBlLCBkYXRhKSB7XG4gICAgaWYgKCF0aGlzLmV2ZW50cykge1xuICAgICAgZHVzdC5sb2coJ05vIGV2ZW50cyB0byBlbWl0JywgSU5GTyk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciBoYW5kbGVyID0gdGhpcy5ldmVudHNbdHlwZV07XG4gICAgaWYgKCFoYW5kbGVyKSB7XG4gICAgICBkdXN0LmxvZygnRXZlbnQgdHlwZSBbJyArIHR5cGUgKyAnXSBkb2VzIG5vdCBleGlzdCcsIFdBUk4pO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGhhbmRsZXIoZGF0YSk7XG4gICAgfSBlbHNlIGlmIChkdXN0LmlzQXJyYXkoaGFuZGxlcikpIHtcbiAgICAgIHZhciBsaXN0ZW5lcnMgPSBoYW5kbGVyLnNsaWNlKDApO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGxpc3RlbmVyc1tpXShkYXRhKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZHVzdC5sb2coJ0V2ZW50IEhhbmRsZXIgWycgKyBoYW5kbGVyICsgJ10gaXMgbm90IG9mIGEgdHlwZSB0aGF0IGlzIGhhbmRsZWQgYnkgZW1pdCcsIFdBUk4pO1xuICAgIH1cbiAgfTtcblxuICBTdHJlYW0ucHJvdG90eXBlLm9uID0gZnVuY3Rpb24odHlwZSwgY2FsbGJhY2spIHtcbiAgICBpZiAoIXRoaXMuZXZlbnRzKSB7XG4gICAgICB0aGlzLmV2ZW50cyA9IHt9O1xuICAgIH1cbiAgICBpZiAoIXRoaXMuZXZlbnRzW3R5cGVdKSB7XG4gICAgICBpZihjYWxsYmFjaykge1xuICAgICAgICB0aGlzLmV2ZW50c1t0eXBlXSA9IGNhbGxiYWNrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZHVzdC5sb2coJ0NhbGxiYWNrIGZvciB0eXBlIFsnICsgdHlwZSArICddIGRvZXMgbm90IGV4aXN0LiBMaXN0ZW5lciBub3QgcmVnaXN0ZXJlZC4nLCBXQVJOKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYodHlwZW9mIHRoaXMuZXZlbnRzW3R5cGVdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLmV2ZW50c1t0eXBlXSA9IFt0aGlzLmV2ZW50c1t0eXBlXSwgY2FsbGJhY2tdO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmV2ZW50c1t0eXBlXS5wdXNoKGNhbGxiYWNrKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgU3RyZWFtLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgdGhpcy5vbignZGF0YScsIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHN0cmVhbS53cml0ZShkYXRhLCAndXRmOCcpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGR1c3QubG9nKGVyciwgRVJST1IpO1xuICAgICAgfVxuICAgIH0pLm9uKCdlbmQnLCBmdW5jdGlvbigpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBzdHJlYW0uZW5kKCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgZHVzdC5sb2coZXJyLCBFUlJPUik7XG4gICAgICB9XG4gICAgfSkub24oJ2Vycm9yJywgZnVuY3Rpb24oZXJyKSB7XG4gICAgICBzdHJlYW0uZXJyb3IoZXJyKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBmdW5jdGlvbiBDaHVuayhyb290LCBuZXh0LCB0YXBzKSB7XG4gICAgdGhpcy5yb290ID0gcm9vdDtcbiAgICB0aGlzLm5leHQgPSBuZXh0O1xuICAgIHRoaXMuZGF0YSA9IFtdOyAvL2llNyBwZXJmXG4gICAgdGhpcy5mbHVzaGFibGUgPSBmYWxzZTtcbiAgICB0aGlzLnRhcHMgPSB0YXBzO1xuICB9XG5cbiAgQ2h1bmsucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oZGF0YSkge1xuICAgIHZhciB0YXBzICA9IHRoaXMudGFwcztcblxuICAgIGlmICh0YXBzKSB7XG4gICAgICBkYXRhID0gdGFwcy5nbyhkYXRhKTtcbiAgICB9XG4gICAgdGhpcy5kYXRhLnB1c2goZGF0YSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQ2h1bmsucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICBpZiAoZGF0YSkge1xuICAgICAgdGhpcy53cml0ZShkYXRhKTtcbiAgICB9XG4gICAgdGhpcy5mbHVzaGFibGUgPSB0cnVlO1xuICAgIHRoaXMucm9vdC5mbHVzaCgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIENodW5rLnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgIHZhciBjdXJzb3IgPSBuZXcgQ2h1bmsodGhpcy5yb290LCB0aGlzLm5leHQsIHRoaXMudGFwcyksXG4gICAgICAgIGJyYW5jaCA9IG5ldyBDaHVuayh0aGlzLnJvb3QsIGN1cnNvciwgdGhpcy50YXBzKTtcblxuICAgIHRoaXMubmV4dCA9IGJyYW5jaDtcbiAgICB0aGlzLmZsdXNoYWJsZSA9IHRydWU7XG4gICAgdHJ5IHtcbiAgICAgIGNhbGxiYWNrKGJyYW5jaCk7XG4gICAgfSBjYXRjaChlKSB7XG4gICAgICBkdXN0LmxvZyhlLCBFUlJPUik7XG4gICAgICBicmFuY2guc2V0RXJyb3IoZSk7XG4gICAgfVxuICAgIHJldHVybiBjdXJzb3I7XG4gIH07XG5cbiAgQ2h1bmsucHJvdG90eXBlLnRhcCA9IGZ1bmN0aW9uKHRhcCkge1xuICAgIHZhciB0YXBzID0gdGhpcy50YXBzO1xuXG4gICAgaWYgKHRhcHMpIHtcbiAgICAgIHRoaXMudGFwcyA9IHRhcHMucHVzaCh0YXApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnRhcHMgPSBuZXcgVGFwKHRhcCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIENodW5rLnByb3RvdHlwZS51bnRhcCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMudGFwcyA9IHRoaXMudGFwcy50YWlsO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIENodW5rLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbihib2R5LCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIGJvZHkodGhpcywgY29udGV4dCk7XG4gIH07XG5cbiAgQ2h1bmsucHJvdG90eXBlLnJlZmVyZW5jZSA9IGZ1bmN0aW9uKGVsZW0sIGNvbnRleHQsIGF1dG8sIGZpbHRlcnMpIHtcbiAgICBpZiAodHlwZW9mIGVsZW0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIENoYW5nZWQgdGhlIGZ1bmN0aW9uIGNhbGxpbmcgdG8gdXNlIGFwcGx5IHdpdGggdGhlIGN1cnJlbnQgY29udGV4dCB0byBtYWtlIHN1cmVcbiAgICAgIC8vIHRoYXQgXCJ0aGlzXCIgaXMgd2F0IHdlIGV4cGVjdCBpdCB0byBiZSBpbnNpZGUgdGhlIGZ1bmN0aW9uXG4gICAgICBlbGVtID0gZWxlbS5hcHBseShjb250ZXh0LmN1cnJlbnQoKSwgW3RoaXMsIGNvbnRleHQsIG51bGwsIHthdXRvOiBhdXRvLCBmaWx0ZXJzOiBmaWx0ZXJzfV0pO1xuICAgICAgaWYgKGVsZW0gaW5zdGFuY2VvZiBDaHVuaykge1xuICAgICAgICByZXR1cm4gZWxlbTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFkdXN0LmlzRW1wdHkoZWxlbSkpIHtcbiAgICAgIHJldHVybiB0aGlzLndyaXRlKGR1c3QuZmlsdGVyKGVsZW0sIGF1dG8sIGZpbHRlcnMpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9O1xuXG4gIENodW5rLnByb3RvdHlwZS5zZWN0aW9uID0gZnVuY3Rpb24oZWxlbSwgY29udGV4dCwgYm9kaWVzLCBwYXJhbXMpIHtcbiAgICAvLyBhbm9ueW1vdXMgZnVuY3Rpb25zXG4gICAgaWYgKHR5cGVvZiBlbGVtID09PSAnZnVuY3Rpb24nICYmICFlbGVtLl9fZHVzdEJvZHkpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGVsZW0gPSBlbGVtLmFwcGx5KGNvbnRleHQuY3VycmVudCgpLCBbdGhpcywgY29udGV4dCwgYm9kaWVzLCBwYXJhbXNdKTtcbiAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICBkdXN0LmxvZyhlLCBFUlJPUik7XG4gICAgICAgIHJldHVybiB0aGlzLnNldEVycm9yKGUpO1xuICAgICAgfVxuICAgICAgLy8gZnVuY3Rpb25zIHRoYXQgcmV0dXJuIGNodW5rcyBhcmUgYXNzdW1lZCB0byBoYXZlIGhhbmRsZWQgdGhlIGJvZHkgYW5kL29yIGhhdmUgbW9kaWZpZWQgdGhlIGNodW5rXG4gICAgICAvLyB1c2UgdGhhdCByZXR1cm4gdmFsdWUgYXMgdGhlIGN1cnJlbnQgY2h1bmsgYW5kIGdvIHRvIHRoZSBuZXh0IG1ldGhvZCBpbiB0aGUgY2hhaW5cbiAgICAgIGlmIChlbGVtIGluc3RhbmNlb2YgQ2h1bmspIHtcbiAgICAgICAgcmV0dXJuIGVsZW07XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBib2R5ID0gYm9kaWVzLmJsb2NrLFxuICAgICAgICBza2lwID0gYm9kaWVzWydlbHNlJ107XG5cbiAgICAvLyBhLmsuYSBJbmxpbmUgcGFyYW1ldGVycyBpbiB0aGUgRHVzdCBkb2N1bWVudGF0aW9uc1xuICAgIGlmIChwYXJhbXMpIHtcbiAgICAgIGNvbnRleHQgPSBjb250ZXh0LnB1c2gocGFyYW1zKTtcbiAgICB9XG5cbiAgICAvKlxuICAgIER1c3QncyBkZWZhdWx0IGJlaGF2aW9yIGlzIHRvIGVudW1lcmF0ZSBvdmVyIHRoZSBhcnJheSBlbGVtLCBwYXNzaW5nIGVhY2ggb2JqZWN0IGluIHRoZSBhcnJheSB0byB0aGUgYmxvY2suXG4gICAgV2hlbiBlbGVtIHJlc29sdmVzIHRvIGEgdmFsdWUgb3Igb2JqZWN0IGluc3RlYWQgb2YgYW4gYXJyYXksIER1c3Qgc2V0cyB0aGUgY3VycmVudCBjb250ZXh0IHRvIHRoZSB2YWx1ZVxuICAgIGFuZCByZW5kZXJzIHRoZSBibG9jayBvbmUgdGltZS5cbiAgICAqL1xuICAgIC8vbm9uIGVtcHR5IGFycmF5IGlzIHRydXRoeSwgZW1wdHkgYXJyYXkgaXMgZmFsc3lcbiAgICBpZiAoZHVzdC5pc0FycmF5KGVsZW0pKSB7XG4gICAgICBpZiAoYm9keSkge1xuICAgICAgICB2YXIgbGVuID0gZWxlbS5sZW5ndGgsIGNodW5rID0gdGhpcztcbiAgICAgICAgaWYgKGxlbiA+IDApIHtcbiAgICAgICAgICAvLyBhbnkgY3VzdG9tIGhlbHBlciBjYW4gYmxvdyB1cCB0aGUgc3RhY2tcbiAgICAgICAgICAvLyBhbmQgc3RvcmUgYSBmbGF0dGVuZWQgY29udGV4dCwgZ3VhcmQgZGVmZW5zaXZlbHlcbiAgICAgICAgICBpZihjb250ZXh0LnN0YWNrLmhlYWQpIHtcbiAgICAgICAgICAgIGNvbnRleHQuc3RhY2suaGVhZFsnJGxlbiddID0gbGVuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8bGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmKGNvbnRleHQuc3RhY2suaGVhZCkge1xuICAgICAgICAgICAgICBjb250ZXh0LnN0YWNrLmhlYWRbJyRpZHgnXSA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaHVuayA9IGJvZHkoY2h1bmssIGNvbnRleHQucHVzaChlbGVtW2ldLCBpLCBsZW4pKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYoY29udGV4dC5zdGFjay5oZWFkKSB7XG4gICAgICAgICAgICBjb250ZXh0LnN0YWNrLmhlYWRbJyRpZHgnXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNvbnRleHQuc3RhY2suaGVhZFsnJGxlbiddID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gY2h1bms7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2tpcCkge1xuICAgICAgICAgIHJldHVybiBza2lwKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlbGVtICA9PT0gdHJ1ZSkge1xuICAgICAvLyB0cnVlIGlzIHRydXRoeSBidXQgZG9lcyBub3QgY2hhbmdlIGNvbnRleHRcbiAgICAgIGlmIChib2R5KSB7XG4gICAgICAgIHJldHVybiBib2R5KHRoaXMsIGNvbnRleHQpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZWxlbSB8fCBlbGVtID09PSAwKSB7XG4gICAgICAgLy8gZXZlcnl0aGluZyB0aGF0IGV2YWx1YXRlcyB0byB0cnVlIGFyZSB0cnV0aHkgKCBlLmcuIE5vbi1lbXB0eSBzdHJpbmdzIGFuZCBFbXB0eSBvYmplY3RzIGFyZSB0cnV0aHkuIClcbiAgICAgICAvLyB6ZXJvIGlzIHRydXRoeVxuICAgICAgIC8vIGZvciBhbm9ueW1vdXMgZnVuY3Rpb25zIHRoYXQgZGlkIG5vdCByZXR1cm5zIGEgY2h1bmssIHRydXRoaW5lc3MgaXMgZXZhbHVhdGVkIGJhc2VkIG9uIHRoZSByZXR1cm4gdmFsdWVcbiAgICAgIGlmIChib2R5KSB7XG4gICAgICAgIHJldHVybiBib2R5KHRoaXMsIGNvbnRleHQucHVzaChlbGVtKSk7XG4gICAgICB9XG4gICAgIC8vIG5vbmV4aXN0ZW50LCBzY2FsYXIgZmFsc2UgdmFsdWUsIHNjYWxhciBlbXB0eSBzdHJpbmcsIG51bGwsXG4gICAgIC8vIHVuZGVmaW5lZCBhcmUgYWxsIGZhbHN5XG4gICAgfSBlbHNlIGlmIChza2lwKSB7XG4gICAgICByZXR1cm4gc2tpcCh0aGlzLCBjb250ZXh0KTtcbiAgICB9XG4gICAgZHVzdC5sb2coJ05vdCByZW5kZXJpbmcgc2VjdGlvbiAoIykgYmxvY2sgaW4gdGVtcGxhdGUgWycgKyBjb250ZXh0LmdldFRlbXBsYXRlTmFtZSgpICsgJ10sIGJlY2F1c2UgYWJvdmUga2V5IHdhcyBub3QgZm91bmQnLCBERUJVRyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQ2h1bmsucHJvdG90eXBlLmV4aXN0cyA9IGZ1bmN0aW9uKGVsZW0sIGNvbnRleHQsIGJvZGllcykge1xuICAgIHZhciBib2R5ID0gYm9kaWVzLmJsb2NrLFxuICAgICAgICBza2lwID0gYm9kaWVzWydlbHNlJ107XG5cbiAgICBpZiAoIWR1c3QuaXNFbXB0eShlbGVtKSkge1xuICAgICAgaWYgKGJvZHkpIHtcbiAgICAgICAgcmV0dXJuIGJvZHkodGhpcywgY29udGV4dCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChza2lwKSB7XG4gICAgICByZXR1cm4gc2tpcCh0aGlzLCBjb250ZXh0KTtcbiAgICB9XG4gICAgZHVzdC5sb2coJ05vdCByZW5kZXJpbmcgZXhpc3RzICg/KSBibG9jayBpbiB0ZW1wbGF0ZSBbJyArIGNvbnRleHQuZ2V0VGVtcGxhdGVOYW1lKCkgKyAnXSwgYmVjYXVzZSBhYm92ZSBrZXkgd2FzIG5vdCBmb3VuZCcsIERFQlVHKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBDaHVuay5wcm90b3R5cGUubm90ZXhpc3RzID0gZnVuY3Rpb24oZWxlbSwgY29udGV4dCwgYm9kaWVzKSB7XG4gICAgdmFyIGJvZHkgPSBib2RpZXMuYmxvY2ssXG4gICAgICAgIHNraXAgPSBib2RpZXNbJ2Vsc2UnXTtcblxuICAgIGlmIChkdXN0LmlzRW1wdHkoZWxlbSkpIHtcbiAgICAgIGlmIChib2R5KSB7XG4gICAgICAgIHJldHVybiBib2R5KHRoaXMsIGNvbnRleHQpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc2tpcCkge1xuICAgICAgcmV0dXJuIHNraXAodGhpcywgY29udGV4dCk7XG4gICAgfVxuICAgIGR1c3QubG9nKCdOb3QgcmVuZGVyaW5nIG5vdCBleGlzdHMgKF4pIGJsb2NrIGNoZWNrIGluIHRlbXBsYXRlIFsnICsgY29udGV4dC5nZXRUZW1wbGF0ZU5hbWUoKSArICddLCBiZWNhdXNlIGFib3ZlIGtleSB3YXMgZm91bmQnLCBERUJVRyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQ2h1bmsucHJvdG90eXBlLmJsb2NrID0gZnVuY3Rpb24oZWxlbSwgY29udGV4dCwgYm9kaWVzKSB7XG4gICAgdmFyIGJvZHkgPSBib2RpZXMuYmxvY2s7XG5cbiAgICBpZiAoZWxlbSkge1xuICAgICAgYm9keSA9IGVsZW07XG4gICAgfVxuXG4gICAgaWYgKGJvZHkpIHtcbiAgICAgIHJldHVybiBib2R5KHRoaXMsIGNvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBDaHVuay5wcm90b3R5cGUucGFydGlhbCA9IGZ1bmN0aW9uKGVsZW0sIGNvbnRleHQsIHBhcmFtcykge1xuICAgIHZhciBwYXJ0aWFsQ29udGV4dDtcbiAgICAvL3B1dCB0aGUgcGFyYW1zIGNvbnRleHQgc2Vjb25kIHRvIG1hdGNoIHdoYXQgc2VjdGlvbiBkb2VzLiB7Ln0gbWF0Y2hlcyB0aGUgY3VycmVudCBjb250ZXh0IHdpdGhvdXQgcGFyYW1ldGVyc1xuICAgIC8vIHN0YXJ0IHdpdGggYW4gZW1wdHkgY29udGV4dFxuICAgIHBhcnRpYWxDb250ZXh0ID0gZHVzdC5tYWtlQmFzZShjb250ZXh0Lmdsb2JhbCk7XG4gICAgcGFydGlhbENvbnRleHQuYmxvY2tzID0gY29udGV4dC5ibG9ja3M7XG4gICAgaWYgKGNvbnRleHQuc3RhY2sgJiYgY29udGV4dC5zdGFjay50YWlsKXtcbiAgICAgIC8vIGdyYWIgdGhlIHN0YWNrKHRhaWwpIG9mZiBvZiB0aGUgcHJldmlvdXMgY29udGV4dCBpZiB3ZSBoYXZlIGl0XG4gICAgICBwYXJ0aWFsQ29udGV4dC5zdGFjayA9IGNvbnRleHQuc3RhY2sudGFpbDtcbiAgICB9XG4gICAgaWYgKHBhcmFtcyl7XG4gICAgICAvL3B1dCBwYXJhbXMgb25cbiAgICAgIHBhcnRpYWxDb250ZXh0ID0gcGFydGlhbENvbnRleHQucHVzaChwYXJhbXMpO1xuICAgIH1cblxuICAgIGlmKHR5cGVvZiBlbGVtID09PSAnc3RyaW5nJykge1xuICAgICAgcGFydGlhbENvbnRleHQudGVtcGxhdGVOYW1lID0gZWxlbTtcbiAgICB9XG5cbiAgICAvL3JlYXR0YWNoIHRoZSBoZWFkXG4gICAgcGFydGlhbENvbnRleHQgPSBwYXJ0aWFsQ29udGV4dC5wdXNoKGNvbnRleHQuc3RhY2suaGVhZCk7XG5cbiAgICB2YXIgcGFydGlhbENodW5rO1xuICAgIGlmICh0eXBlb2YgZWxlbSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcGFydGlhbENodW5rID0gdGhpcy5jYXB0dXJlKGVsZW0sIHBhcnRpYWxDb250ZXh0LCBmdW5jdGlvbihuYW1lLCBjaHVuaykge1xuICAgICAgICBwYXJ0aWFsQ29udGV4dC50ZW1wbGF0ZU5hbWUgPSBwYXJ0aWFsQ29udGV4dC50ZW1wbGF0ZU5hbWUgfHwgbmFtZTtcbiAgICAgICAgZHVzdC5sb2FkKG5hbWUsIGNodW5rLCBwYXJ0aWFsQ29udGV4dCkuZW5kKCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFydGlhbENodW5rID0gZHVzdC5sb2FkKGVsZW0sIHRoaXMsIHBhcnRpYWxDb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnRpYWxDaHVuaztcbiAgfTtcblxuICBDaHVuay5wcm90b3R5cGUuaGVscGVyID0gZnVuY3Rpb24obmFtZSwgY29udGV4dCwgYm9kaWVzLCBwYXJhbXMpIHtcbiAgICB2YXIgY2h1bmsgPSB0aGlzO1xuICAgIC8vIGhhbmRsZSBpbnZhbGlkIGhlbHBlcnMsIHNpbWlsYXIgdG8gaW52YWxpZCBmaWx0ZXJzXG4gICAgaWYoZHVzdC5oZWxwZXJzW25hbWVdKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gZHVzdC5oZWxwZXJzW25hbWVdKGNodW5rLCBjb250ZXh0LCBib2RpZXMsIHBhcmFtcyk7XG4gICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgZHVzdC5sb2coJ0Vycm9yIGluICcgKyBuYW1lICsgJyBoZWxwZXI6ICcgKyBlLCBFUlJPUik7XG4gICAgICAgIHJldHVybiBjaHVuay5zZXRFcnJvcihlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZHVzdC5sb2coJ0ludmFsaWQgaGVscGVyIFsnICsgbmFtZSArICddJywgV0FSTik7XG4gICAgICByZXR1cm4gY2h1bms7XG4gICAgfVxuICB9O1xuXG4gIENodW5rLnByb3RvdHlwZS5jYXB0dXJlID0gZnVuY3Rpb24oYm9keSwgY29udGV4dCwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24oY2h1bmspIHtcbiAgICAgIHZhciBzdHViID0gbmV3IFN0dWIoZnVuY3Rpb24oZXJyLCBvdXQpIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIGNodW5rLnNldEVycm9yKGVycik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FsbGJhY2sob3V0LCBjaHVuayk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgYm9keShzdHViLmhlYWQsIGNvbnRleHQpLmVuZCgpO1xuICAgIH0pO1xuICB9O1xuXG4gIENodW5rLnByb3RvdHlwZS5zZXRFcnJvciA9IGZ1bmN0aW9uKGVycikge1xuICAgIHRoaXMuZXJyb3IgPSBlcnI7XG4gICAgdGhpcy5yb290LmZsdXNoKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gQ2h1bmsgYWxpYXNlc1xuICBmb3IodmFyIGYgaW4gQ2h1bmsucHJvdG90eXBlKSB7XG4gICAgaWYoZHVzdC5fYWxpYXNlc1tmXSkge1xuICAgICAgQ2h1bmsucHJvdG90eXBlW2R1c3QuX2FsaWFzZXNbZl1dID0gQ2h1bmsucHJvdG90eXBlW2ZdO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIFRhcChoZWFkLCB0YWlsKSB7XG4gICAgdGhpcy5oZWFkID0gaGVhZDtcbiAgICB0aGlzLnRhaWwgPSB0YWlsO1xuICB9XG5cbiAgVGFwLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24odGFwKSB7XG4gICAgcmV0dXJuIG5ldyBUYXAodGFwLCB0aGlzKTtcbiAgfTtcblxuICBUYXAucHJvdG90eXBlLmdvID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YXIgdGFwID0gdGhpcztcblxuICAgIHdoaWxlKHRhcCkge1xuICAgICAgdmFsdWUgPSB0YXAuaGVhZCh2YWx1ZSk7XG4gICAgICB0YXAgPSB0YXAudGFpbDtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xuXG4gIHZhciBIQ0hBUlMgPSAvWyY8PlwiJ10vLFxuICAgICAgQU1QICAgID0gLyYvZyxcbiAgICAgIExUICAgICA9IC88L2csXG4gICAgICBHVCAgICAgPSAvPi9nLFxuICAgICAgUVVPVCAgID0gL1xcXCIvZyxcbiAgICAgIFNRVU9UICA9IC9cXCcvZztcblxuICBkdXN0LmVzY2FwZUh0bWwgPSBmdW5jdGlvbihzKSB7XG4gICAgaWYgKHR5cGVvZiBzID09PSBcInN0cmluZ1wiIHx8IChzICYmIHR5cGVvZiBzLnRvU3RyaW5nID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgICBpZiAodHlwZW9mIHMgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcyA9IHMudG9TdHJpbmcoKTtcbiAgICAgIH1cbiAgICAgIGlmICghSENIQVJTLnRlc3QocykpIHtcbiAgICAgICAgcmV0dXJuIHM7XG4gICAgICB9XG4gICAgICByZXR1cm4gcy5yZXBsYWNlKEFNUCwnJmFtcDsnKS5yZXBsYWNlKExULCcmbHQ7JykucmVwbGFjZShHVCwnJmd0OycpLnJlcGxhY2UoUVVPVCwnJnF1b3Q7JykucmVwbGFjZShTUVVPVCwgJyYjMzk7Jyk7XG4gICAgfVxuICAgIHJldHVybiBzO1xuICB9O1xuXG4gIHZhciBCUyA9IC9cXFxcL2csXG4gICAgICBGUyA9IC9cXC8vZyxcbiAgICAgIENSID0gL1xcci9nLFxuICAgICAgTFMgPSAvXFx1MjAyOC9nLFxuICAgICAgUFMgPSAvXFx1MjAyOS9nLFxuICAgICAgTkwgPSAvXFxuL2csXG4gICAgICBMRiA9IC9cXGYvZyxcbiAgICAgIFNRID0gLycvZyxcbiAgICAgIERRID0gL1wiL2csXG4gICAgICBUQiA9IC9cXHQvZztcblxuICBkdXN0LmVzY2FwZUpzID0gZnVuY3Rpb24ocykge1xuICAgIGlmICh0eXBlb2YgcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBzXG4gICAgICAgIC5yZXBsYWNlKEJTLCAnXFxcXFxcXFwnKVxuICAgICAgICAucmVwbGFjZShGUywgJ1xcXFwvJylcbiAgICAgICAgLnJlcGxhY2UoRFEsICdcXFxcXCInKVxuICAgICAgICAucmVwbGFjZShTUSwgJ1xcXFxcXCcnKVxuICAgICAgICAucmVwbGFjZShDUiwgJ1xcXFxyJylcbiAgICAgICAgLnJlcGxhY2UoTFMsICdcXFxcdTIwMjgnKVxuICAgICAgICAucmVwbGFjZShQUywgJ1xcXFx1MjAyOScpXG4gICAgICAgIC5yZXBsYWNlKE5MLCAnXFxcXG4nKVxuICAgICAgICAucmVwbGFjZShMRiwgJ1xcXFxmJylcbiAgICAgICAgLnJlcGxhY2UoVEIsICdcXFxcdCcpO1xuICAgIH1cbiAgICByZXR1cm4gcztcbiAgfTtcblxuICBkdXN0LmVzY2FwZUpTT04gPSBmdW5jdGlvbihvKSB7XG4gICAgaWYgKCFKU09OKSB7XG4gICAgICBkdXN0LmxvZygnSlNPTiBpcyB1bmRlZmluZWQuICBKU09OIHN0cmluZ2lmeSBoYXMgbm90IGJlZW4gdXNlZCBvbiBbJyArIG8gKyAnXScsIFdBUk4pO1xuICAgICAgcmV0dXJuIG87XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShvKVxuICAgICAgICAucmVwbGFjZShMUywgJ1xcXFx1MjAyOCcpXG4gICAgICAgIC5yZXBsYWNlKFBTLCAnXFxcXHUyMDI5JylcbiAgICAgICAgLnJlcGxhY2UoTFQsICdcXFxcdTAwM2MnKTtcbiAgICB9XG4gIH07XG5cbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kICYmIGRlZmluZS5hbWQuZHVzdCA9PT0gdHJ1ZSkge1xuICAgIGRlZmluZShcImR1c3QuY29yZVwiLCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBkdXN0O1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZHVzdDtcbiAgfSBlbHNlIHtcbiAgICByb290LmR1c3QgPSBkdXN0O1xuICB9XG5cbn0pKChmdW5jdGlvbigpe3JldHVybiB0aGlzO30pKCkpO1xuXG5pZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQgJiYgZGVmaW5lLmFtZC5kdXN0ID09PSB0cnVlKSB7XG4gICAgZGVmaW5lKFtcInJlcXVpcmVcIiwgXCJkdXN0LmNvcmVcIl0sIGZ1bmN0aW9uKHJlcXVpcmUsIGR1c3QpIHtcbiAgICAgICAgZHVzdC5vbkxvYWQgPSBmdW5jdGlvbihuYW1lLCBjYikge1xuICAgICAgICAgICAgcmVxdWlyZShbbmFtZV0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGNiKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGR1c3Q7XG4gICAgfSk7XG59XG4iLCIvKiEgZHVzdGpzLWhlbHBlcnMgLSB2MS42LjFcbiogaHR0cHM6Ly9naXRodWIuY29tL2xpbmtlZGluL2R1c3Rqcy1oZWxwZXJzXG4qIENvcHlyaWdodCAoYykgMjAxNSBBbGVrc2FuZGVyIFdpbGxpYW1zOyBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UgKi9cbihmdW5jdGlvbihyb290LCBmYWN0b3J5KSB7XG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgJiYgZGVmaW5lLmFtZC5kdXN0ID09PSB0cnVlKSB7XG4gICAgZGVmaW5lKFsnZHVzdC5jb3JlJ10sIGZhY3RvcnkpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKCdkdXN0anMtbGlua2VkaW4nKSk7XG4gIH0gZWxzZSB7XG4gICAgZmFjdG9yeShyb290LmR1c3QpO1xuICB9XG59KHRoaXMsIGZ1bmN0aW9uKGR1c3QpIHtcblxuLy8gVXNlIGR1c3QncyBidWlsdC1pbiBsb2dnaW5nIHdoZW4gYXZhaWxhYmxlXG52YXIgX2xvZyA9IGR1c3QubG9nID8gZnVuY3Rpb24obXNnLCBsZXZlbCkge1xuICBsZXZlbCA9IGxldmVsIHx8IFwiSU5GT1wiO1xuICBkdXN0LmxvZyhtc2csIGxldmVsKTtcbn0gOiBmdW5jdGlvbigpIHt9O1xuXG52YXIgX2RlcHJlY2F0ZWRDYWNoZSA9IHt9O1xuZnVuY3Rpb24gX2RlcHJlY2F0ZWQodGFyZ2V0KSB7XG4gIGlmKF9kZXByZWNhdGVkQ2FjaGVbdGFyZ2V0XSkgeyByZXR1cm47IH1cbiAgX2xvZyhcIkRlcHJlY2F0aW9uIHdhcm5pbmc6IFwiICsgdGFyZ2V0ICsgXCIgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHZlcnNpb24gb2YgZHVzdGpzLWhlbHBlcnNcIiwgXCJXQVJOXCIpO1xuICBfbG9nKFwiRm9yIGhlbHAgYW5kIGEgZGVwcmVjYXRpb24gdGltZWxpbmUsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vbGlua2VkaW4vZHVzdGpzLWhlbHBlcnMvd2lraS9EZXByZWNhdGVkLUZlYXR1cmVzI1wiICsgdGFyZ2V0LnJlcGxhY2UoL1xcVysvZywgXCJcIiksIFwiV0FSTlwiKTtcbiAgX2RlcHJlY2F0ZWRDYWNoZVt0YXJnZXRdID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaXNTZWxlY3QoY29udGV4dCkge1xuICByZXR1cm4gY29udGV4dC5zdGFjay50YWlsICYmXG4gICAgICAgICB0eXBlb2YgY29udGV4dC5zdGFjay50YWlsLmhlYWQuX19zZWxlY3RfXyAhPT0gXCJ1bmRlZmluZWRcIjtcbn1cblxuZnVuY3Rpb24gZ2V0U2VsZWN0U3RhdGUoY29udGV4dCkge1xuICByZXR1cm4gY29udGV4dC5nZXQoJ19fc2VsZWN0X18nKTtcbn1cblxuZnVuY3Rpb24gYWRkU2VsZWN0U3RhdGUoY29udGV4dCwga2V5KSB7XG4gIHZhciBoZWFkID0gY29udGV4dC5zdGFjay5oZWFkLFxuICAgICAgbmV3Q29udGV4dCA9IGNvbnRleHQucmViYXNlKCk7XG5cbiAgaWYoY29udGV4dC5zdGFjayAmJiBjb250ZXh0LnN0YWNrLnRhaWwpIHtcbiAgICBuZXdDb250ZXh0LnN0YWNrID0gY29udGV4dC5zdGFjay50YWlsO1xuICB9XG5cbiAgcmV0dXJuIG5ld0NvbnRleHRcbiAgLnB1c2goeyBcIl9fc2VsZWN0X19cIjoge1xuICAgICAgaXNSZXNvbHZlZDogZmFsc2UsXG4gICAgICBpc0RlZmF1bHRlZDogZmFsc2UsXG4gICAgICBpc0RlZmVycmVkQ29tcGxldGU6IGZhbHNlLFxuICAgICAgZGVmZXJyZWRzOiBbXSxcbiAgICAgIGtleToga2V5XG4gICAgfVxuICB9KVxuICAucHVzaChoZWFkLCBjb250ZXh0LnN0YWNrLmluZGV4LCBjb250ZXh0LnN0YWNrLm9mKTtcbn1cblxuLy8gVXRpbGl0eSBtZXRob2QgOiB0b1N0cmluZygpIGVxdWl2YWxlbnQgZm9yIGZ1bmN0aW9uc1xuZnVuY3Rpb24ganNvbkZpbHRlcihrZXksIHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIC8vdG8gbWFrZSBzdXJlIGFsbCBlbnZpcm9ubWVudHMgZm9ybWF0IGZ1bmN0aW9ucyB0aGUgc2FtZSB3YXlcbiAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKVxuICAgICAgLy9yZW1vdmUgYWxsIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2VcbiAgICAgIC5yZXBsYWNlKC8oXlxccyt8XFxzKyQpL21nLCAnJylcbiAgICAgIC8vcmVtb3ZlIG5ldyBsaW5lIGNoYXJhY3RlcnNcbiAgICAgIC5yZXBsYWNlKC9cXG4vbWcsICcnKVxuICAgICAgLy9yZXBsYWNlICwgYW5kIDAgb3IgbW9yZSBzcGFjZXMgd2l0aCBcIiwgXCJcbiAgICAgIC5yZXBsYWNlKC8sXFxzKi9tZywgJywgJylcbiAgICAgIC8vaW5zZXJ0IHNwYWNlIGJldHdlZW4gKXtcbiAgICAgIC5yZXBsYWNlKC9cXClcXHsvbWcsICcpIHsnKVxuICAgIDtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbi8vIFV0aWxpdHkgbWV0aG9kOiB0byBpbnZva2UgdGhlIGdpdmVuIGZpbHRlciBvcGVyYXRpb24gc3VjaCBhcyBlcS9ndCBldGNcbmZ1bmN0aW9uIGZpbHRlcihjaHVuaywgY29udGV4dCwgYm9kaWVzLCBwYXJhbXMsIGZpbHRlck9wKSB7XG4gIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgdmFyIGJvZHkgPSBib2RpZXMuYmxvY2ssXG4gICAgICBhY3R1YWxLZXksXG4gICAgICBleHBlY3RlZFZhbHVlLFxuICAgICAgc2VsZWN0U3RhdGUsXG4gICAgICBmaWx0ZXJPcFR5cGUgPSBwYXJhbXMuZmlsdGVyT3BUeXBlIHx8ICcnO1xuXG4gIC8vIEN1cnJlbnRseSB3ZSBmaXJzdCBjaGVjayBmb3IgYSBrZXkgb24gdGhlIGhlbHBlciBpdHNlbGYsIHRoZW4gZmFsbCBiYWNrIHRvXG4gIC8vIGxvb2tpbmcgZm9yIGEga2V5IG9uIHRoZSB7QHNlbGVjdH0gdGhhdCBjb250YWlucyBpdC4gVGhpcyBpcyB1bmRvY3VtZW50ZWRcbiAgLy8gYmVoYXZpb3IgdGhhdCB3ZSBtYXkgb3IgbWF5IG5vdCBzdXBwb3J0IGluIHRoZSBmdXR1cmUuIChJZiB3ZSBzdG9wIHN1cHBvcnRpbmdcbiAgLy8gaXQsIGp1c3Qgc3dpdGNoIHRoZSBvcmRlciBvZiB0aGUgdGVzdCBiZWxvdyB0byBjaGVjayB0aGUge0BzZWxlY3R9IGZpcnN0LilcbiAgaWYgKHBhcmFtcy5oYXNPd25Qcm9wZXJ0eShcImtleVwiKSkge1xuICAgIGFjdHVhbEtleSA9IGR1c3QuaGVscGVycy50YXAocGFyYW1zLmtleSwgY2h1bmssIGNvbnRleHQpO1xuICB9IGVsc2UgaWYgKGlzU2VsZWN0KGNvbnRleHQpKSB7XG4gICAgc2VsZWN0U3RhdGUgPSBnZXRTZWxlY3RTdGF0ZShjb250ZXh0KTtcbiAgICBhY3R1YWxLZXkgPSBzZWxlY3RTdGF0ZS5rZXk7XG4gICAgLy8gT25jZSBvbmUgdHJ1dGggdGVzdCBpbiBhIHNlbGVjdCBwYXNzZXMsIHNob3J0LWNpcmN1aXQgdGhlIHJlc3Qgb2YgdGhlIHRlc3RzXG4gICAgaWYgKHNlbGVjdFN0YXRlLmlzUmVzb2x2ZWQpIHtcbiAgICAgIGZpbHRlck9wID0gZnVuY3Rpb24oKSB7IHJldHVybiBmYWxzZTsgfTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgX2xvZyhcIk5vIGtleSBzcGVjaWZpZWQgZm9yIGZpbHRlciBpbiB7QFwiICsgZmlsdGVyT3BUeXBlICsgXCJ9XCIpO1xuICAgIHJldHVybiBjaHVuaztcbiAgfVxuICBleHBlY3RlZFZhbHVlID0gZHVzdC5oZWxwZXJzLnRhcChwYXJhbXMudmFsdWUsIGNodW5rLCBjb250ZXh0KTtcbiAgLy8gY29lcmNlIGJvdGggdGhlIGFjdHVhbEtleSBhbmQgZXhwZWN0ZWRWYWx1ZSB0byB0aGUgc2FtZSB0eXBlIGZvciBlcXVhbGl0eSBhbmQgbm9uLWVxdWFsaXR5IGNvbXBhcmVzXG4gIGlmIChmaWx0ZXJPcChjb2VyY2UoZXhwZWN0ZWRWYWx1ZSwgcGFyYW1zLnR5cGUsIGNvbnRleHQpLCBjb2VyY2UoYWN0dWFsS2V5LCBwYXJhbXMudHlwZSwgY29udGV4dCkpKSB7XG4gICAgaWYgKGlzU2VsZWN0KGNvbnRleHQpKSB7XG4gICAgICBpZihmaWx0ZXJPcFR5cGUgPT09ICdkZWZhdWx0Jykge1xuICAgICAgICBzZWxlY3RTdGF0ZS5pc0RlZmF1bHRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBzZWxlY3RTdGF0ZS5pc1Jlc29sdmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgLy8gSGVscGVycyB3aXRob3V0IGJvZGllcyBhcmUgdmFsaWQgZHVlIHRvIHRoZSB1c2Ugb2Yge0Bhbnl9IGJsb2Nrc1xuICAgIGlmKGJvZHkpIHtcbiAgICAgIHJldHVybiBjaHVuay5yZW5kZXIoYm9keSwgY29udGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjaHVuaztcbiAgICB9XG4gIH0gZWxzZSBpZiAoYm9kaWVzWydlbHNlJ10pIHtcbiAgICByZXR1cm4gY2h1bmsucmVuZGVyKGJvZGllc1snZWxzZSddLCBjb250ZXh0KTtcbiAgfVxuICByZXR1cm4gY2h1bms7XG59XG5cbmZ1bmN0aW9uIGNvZXJjZSh2YWx1ZSwgdHlwZSwgY29udGV4dCkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgc3dpdGNoICh0eXBlIHx8IHR5cGVvZiB2YWx1ZSkge1xuICAgICAgY2FzZSAnbnVtYmVyJzogcmV0dXJuICt2YWx1ZTtcbiAgICAgIGNhc2UgJ3N0cmluZyc6IHJldHVybiBTdHJpbmcodmFsdWUpO1xuICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgIHZhbHVlID0gKHZhbHVlID09PSAnZmFsc2UnID8gZmFsc2UgOiB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBCb29sZWFuKHZhbHVlKTtcbiAgICAgIGNhc2UgJ2RhdGUnOiByZXR1cm4gbmV3IERhdGUodmFsdWUpO1xuICAgICAgY2FzZSAnY29udGV4dCc6IHJldHVybiBjb250ZXh0LmdldCh2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG52YXIgaGVscGVycyA9IHtcblxuICAvLyBVdGlsaXR5IGhlbHBpbmcgdG8gcmVzb2x2ZSBkdXN0IHJlZmVyZW5jZXMgaW4gdGhlIGdpdmVuIGNodW5rXG4gIC8vIHVzZXMgdGhlIENodW5rLnJlbmRlciBtZXRob2QgdG8gcmVzb2x2ZSB2YWx1ZVxuICAvKlxuICAgUmVmZXJlbmNlIHJlc29sdXRpb24gcnVsZXM6XG4gICBpZiB2YWx1ZSBleGlzdHMgaW4gSlNPTjpcbiAgICBcIlwiIG9yICcnIHdpbGwgZXZhbHVhdGUgdG8gZmFsc2UsIGJvb2xlYW4gZmFsc2UsIG51bGwsIG9yIHVuZGVmaW5lZCB3aWxsIGV2YWx1YXRlIHRvIGZhbHNlLFxuICAgIG51bWVyaWMgMCBldmFsdWF0ZXMgdG8gdHJ1ZSwgc28gZG9lcywgc3RyaW5nIFwiMFwiLCBzdHJpbmcgXCJudWxsXCIsIHN0cmluZyBcInVuZGVmaW5lZFwiIGFuZCBzdHJpbmcgXCJmYWxzZVwiLlxuICAgIEFsc28gbm90ZSB0aGF0IGVtcHR5IGFycmF5IC0+IFtdIGlzIGV2YWx1YXRlZCB0byBmYWxzZSBhbmQgZW1wdHkgb2JqZWN0IC0+IHt9IGFuZCBub24tZW1wdHkgb2JqZWN0IGFyZSBldmFsdWF0ZWQgdG8gdHJ1ZVxuICAgIFRoZSB0eXBlIG9mIHRoZSByZXR1cm4gdmFsdWUgaXMgc3RyaW5nICggc2luY2Ugd2UgY29uY2F0ZW5hdGUgdG8gc3VwcG9ydCBpbnRlcnBvbGF0ZWQgcmVmZXJlbmNlc1xuXG4gICBpZiB2YWx1ZSBkb2VzIG5vdCBleGlzdCBpbiBKU09OIGFuZCB0aGUgaW5wdXQgaXMgYSBzaW5nbGUgcmVmZXJlbmNlOiB7eH1cbiAgICAgZHVzdCByZW5kZXIgZW1pdHMgZW1wdHkgc3RyaW5nLCBhbmQgd2UgdGhlbiByZXR1cm4gZmFsc2VcblxuICAgaWYgdmFsdWVzIGRvZXMgbm90IGV4aXN0IGluIEpTT04gYW5kIHRoZSBpbnB1dCBpcyBpbnRlcnBvbGF0ZWQgcmVmZXJlbmNlcyA6IHt4fSA8IHt5fVxuICAgICBkdXN0IHJlbmRlciBlbWl0cyA8ICBhbmQgd2UgcmV0dXJuIHRoZSBwYXJ0aWFsIG91dHB1dFxuXG4gICovXG4gIFwidGFwXCI6IGZ1bmN0aW9uKGlucHV0LCBjaHVuaywgY29udGV4dCkge1xuICAgIC8vIHJldHVybiBnaXZlbiBpbnB1dCBpZiB0aGVyZSBpcyBubyBkdXN0IHJlZmVyZW5jZSB0byByZXNvbHZlXG4gICAgLy8gZHVzdCBjb21waWxlcyBhIHN0cmluZy9yZWZlcmVuY2Ugc3VjaCBhcyB7Zm9vfSB0byBhIGZ1bmN0aW9uXG4gICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICByZXR1cm4gaW5wdXQ7XG4gICAgfVxuXG4gICAgdmFyIGR1c3RCb2R5T3V0cHV0ID0gJycsXG4gICAgICByZXR1cm5WYWx1ZTtcblxuICAgIC8vdXNlIGNodW5rIHJlbmRlciB0byBldmFsdWF0ZSBvdXRwdXQuIEZvciBzaW1wbGUgZnVuY3Rpb25zIHJlc3VsdCB3aWxsIGJlIHJldHVybmVkIGZyb20gcmVuZGVyIGNhbGwsXG4gICAgLy9mb3IgZHVzdCBib2R5IGZ1bmN0aW9ucyByZXN1bHQgd2lsbCBiZSBvdXRwdXQgdmlhIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAgcmV0dXJuVmFsdWUgPSBjaHVuay50YXAoZnVuY3Rpb24oZGF0YSkge1xuICAgICAgZHVzdEJvZHlPdXRwdXQgKz0gZGF0YTtcbiAgICAgIHJldHVybiAnJztcbiAgICB9KS5yZW5kZXIoaW5wdXQsIGNvbnRleHQpO1xuXG4gICAgY2h1bmsudW50YXAoKTtcblxuICAgIC8vYXNzdW1lIGl0J3MgYSBzaW1wbGUgZnVuY3Rpb24gY2FsbCBpZiByZXR1cm4gcmVzdWx0IGlzIG5vdCBhIGNodW5rXG4gICAgaWYgKHJldHVyblZhbHVlLmNvbnN0cnVjdG9yICE9PSBjaHVuay5jb25zdHJ1Y3Rvcikge1xuICAgICAgLy91c2UgcmV0dXJuVmFsdWUgYXMgYSByZXN1bHQgb2YgdGFwXG4gICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgfSBlbHNlIGlmIChkdXN0Qm9keU91dHB1dCA9PT0gJycpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGR1c3RCb2R5T3V0cHV0O1xuICAgIH1cbiAgfSxcblxuICBcInNlcFwiOiBmdW5jdGlvbihjaHVuaywgY29udGV4dCwgYm9kaWVzKSB7XG4gICAgdmFyIGJvZHkgPSBib2RpZXMuYmxvY2s7XG4gICAgaWYgKGNvbnRleHQuc3RhY2suaW5kZXggPT09IGNvbnRleHQuc3RhY2sub2YgLSAxKSB7XG4gICAgICByZXR1cm4gY2h1bms7XG4gICAgfVxuICAgIGlmIChib2R5KSB7XG4gICAgICByZXR1cm4gYm9keShjaHVuaywgY29udGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjaHVuaztcbiAgICB9XG4gIH0sXG5cbiAgXCJmaXJzdFwiOiBmdW5jdGlvbihjaHVuaywgY29udGV4dCwgYm9kaWVzKSB7XG4gICAgaWYgKGNvbnRleHQuc3RhY2suaW5kZXggPT09IDApIHtcbiAgICAgIHJldHVybiBib2RpZXMuYmxvY2soY2h1bmssIGNvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gY2h1bms7XG4gIH0sXG5cbiAgXCJsYXN0XCI6IGZ1bmN0aW9uKGNodW5rLCBjb250ZXh0LCBib2RpZXMpIHtcbiAgICBpZiAoY29udGV4dC5zdGFjay5pbmRleCA9PT0gY29udGV4dC5zdGFjay5vZiAtIDEpIHtcbiAgICAgIHJldHVybiBib2RpZXMuYmxvY2soY2h1bmssIGNvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gY2h1bms7XG4gIH0sXG5cbiAgLyoqXG4gICAqIGNvbnRleHREdW1wIGhlbHBlclxuICAgKiBAcGFyYW0ga2V5IHNwZWNpZmllcyBob3cgbXVjaCB0byBkdW1wLlxuICAgKiBcImN1cnJlbnRcIiBkdW1wcyBjdXJyZW50IGNvbnRleHQuIFwiZnVsbFwiIGR1bXBzIHRoZSBmdWxsIGNvbnRleHQgc3RhY2suXG4gICAqIEBwYXJhbSB0byBzcGVjaWZpZXMgd2hlcmUgdG8gd3JpdGUgZHVtcCBvdXRwdXQuXG4gICAqIFZhbHVlcyBjYW4gYmUgXCJjb25zb2xlXCIgb3IgXCJvdXRwdXRcIi4gRGVmYXVsdCBpcyBvdXRwdXQuXG4gICAqL1xuICBcImNvbnRleHREdW1wXCI6IGZ1bmN0aW9uKGNodW5rLCBjb250ZXh0LCBib2RpZXMsIHBhcmFtcykge1xuICAgIHZhciBwID0gcGFyYW1zIHx8IHt9LFxuICAgICAgdG8gPSBwLnRvIHx8ICdvdXRwdXQnLFxuICAgICAga2V5ID0gcC5rZXkgfHwgJ2N1cnJlbnQnLFxuICAgICAgZHVtcDtcbiAgICB0byA9IGR1c3QuaGVscGVycy50YXAodG8sIGNodW5rLCBjb250ZXh0KTtcbiAgICBrZXkgPSBkdXN0LmhlbHBlcnMudGFwKGtleSwgY2h1bmssIGNvbnRleHQpO1xuICAgIGlmIChrZXkgPT09ICdmdWxsJykge1xuICAgICAgZHVtcCA9IEpTT04uc3RyaW5naWZ5KGNvbnRleHQuc3RhY2ssIGpzb25GaWx0ZXIsIDIpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGR1bXAgPSBKU09OLnN0cmluZ2lmeShjb250ZXh0LnN0YWNrLmhlYWQsIGpzb25GaWx0ZXIsIDIpO1xuICAgIH1cbiAgICBpZiAodG8gPT09ICdjb25zb2xlJykge1xuICAgICAgX2xvZyhkdW1wKTtcbiAgICAgIHJldHVybiBjaHVuaztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvLyBlbmNvZGUgb3BlbmluZyBicmFja2V0cyB3aGVuIG91dHB1dHRpbmcgdG8gaHRtbFxuICAgICAgZHVtcCA9IGR1bXAucmVwbGFjZSgvPC9nLCAnXFxcXHUwMDNjJyk7XG5cbiAgICAgIHJldHVybiBjaHVuay53cml0ZShkdW1wKTtcbiAgICB9XG4gIH0sXG4gIC8qKlxuICAgaWYgaGVscGVyIGZvciBjb21wbGV4IGV2YWx1YXRpb24gY29tcGxleCBsb2dpYyBleHByZXNzaW9ucy5cbiAgIE5vdGUgOiAjMSBpZiBoZWxwZXIgZmFpbHMgZ3JhY2VmdWxseSB3aGVuIHRoZXJlIGlzIG5vIGJvZHkgYmxvY2sgbm9yIGVsc2UgYmxvY2tcbiAgICAgICAgICAjMiBVbmRlZmluZWQgdmFsdWVzIGFuZCBmYWxzZSB2YWx1ZXMgaW4gdGhlIEpTT04gbmVlZCB0byBiZSBoYW5kbGVkIHNwZWNpYWxseSB3aXRoIC5sZW5ndGggY2hlY2tcbiAgICAgICAgICAgICBmb3IgZS5nIEBpZiBjb25kPVwiICd7YX0nLmxlbmd0aCAmJiAne2J9Jy5sZW5ndGhcIiBpcyBhZHZpc2VkIHdoZW4gdGhlcmUgYXJlIGNoYW5jZXMgb2YgdGhlIGEgYW5kIGIgYmVlblxuICAgICAgICAgICAgIHVuZGVmaW5lZCBvciBmYWxzZSBpbiB0aGUgY29udGV4dFxuICAgICAgICAgICMzIFVzZSBvbmx5IHdoZW4gdGhlIGRlZmF1bHQgPyBhbmQgXiBkdXN0IG9wZXJhdG9ycyBhbmQgdGhlIHNlbGVjdCBmYWxsIHNob3J0IGluIGFkZHJlc3NpbmcgdGhlIGdpdmVuIGxvZ2ljLFxuICAgICAgICAgICAgIHNpbmNlIGV2YWwgZXhlY3V0ZXMgaW4gdGhlIGdsb2JhbCBzY29wZVxuICAgICAgICAgICM0IEFsbCBkdXN0IHJlZmVyZW5jZXMgYXJlIGRlZmF1bHQgZXNjYXBlZCBhcyB0aGV5IGFyZSByZXNvbHZlZCwgaGVuY2UgZXZhbCB3aWxsIGJsb2NrIG1hbGljaW91cyBzY3JpcHRzIGluIHRoZSBjb250ZXh0XG4gICAgICAgICAgICAgQmUgbWluZGZ1bCBvZiBldmFsdWF0aW5nIGEgZXhwcmVzc2lvbiB0aGF0IGlzIHBhc3NlZCB0aHJvdWdoIHRoZSB1bmVzY2FwZSBmaWx0ZXIgLT4gfHNcbiAgIEBwYXJhbSBjb25kLCBlaXRoZXIgYSBzdHJpbmcgbGl0ZXJhbCB2YWx1ZSBvciBhIGR1c3QgcmVmZXJlbmNlXG4gICAgICAgICAgICAgICAgYSBzdHJpbmcgbGl0ZXJhbCB2YWx1ZSwgaXMgZW5jbG9zZWQgaW4gZG91YmxlIHF1b3RlcywgZS5nLiBjb25kPVwiMj4zXCJcbiAgICAgICAgICAgICAgICBhIGR1c3QgcmVmZXJlbmNlIGlzIGFsc28gZW5jbG9zZWQgaW4gZG91YmxlIHF1b3RlcywgZS5nLiBjb25kPVwiJ3t2YWx9JycgPiAzXCJcbiAgICBjb25kIGFyZ3VtZW50IHNob3VsZCBldmFsdWF0ZSB0byBhIHZhbGlkIGphdmFzY3JpcHQgZXhwcmVzc2lvblxuICAgKiovXG5cbiAgLyoqXG4gICAqIG1hdGggaGVscGVyXG4gICAqIEBwYXJhbSBrZXkgaXMgdGhlIHZhbHVlIHRvIHBlcmZvcm0gbWF0aCBhZ2FpbnN0XG4gICAqIEBwYXJhbSBtZXRob2QgaXMgdGhlIG1hdGggbWV0aG9kLCAgaXMgYSB2YWxpZCBzdHJpbmcgc3VwcG9ydGVkIGJ5IG1hdGggaGVscGVyIGxpa2UgbW9kLCBhZGQsIHN1YnRyYWN0XG4gICAqIEBwYXJhbSBvcGVyYW5kIGlzIHRoZSBzZWNvbmQgdmFsdWUgbmVlZGVkIGZvciBvcGVyYXRpb25zIGxpa2UgbW9kLCBhZGQsIHN1YnRyYWN0LCBldGMuXG4gICAqIEBwYXJhbSByb3VuZCBpcyBhIGZsYWcgdG8gYXNzdXJlIHRoYXQgYW4gaW50ZWdlciBpcyByZXR1cm5lZFxuICAgKi9cbiAgXCJtYXRoXCI6IGZ1bmN0aW9uICggY2h1bmssIGNvbnRleHQsIGJvZGllcywgcGFyYW1zICkge1xuICAgIC8va2V5IGFuZCBtZXRob2QgYXJlIHJlcXVpcmVkIGZvciBmdXJ0aGVyIHByb2Nlc3NpbmdcbiAgICBpZiggcGFyYW1zICYmIHR5cGVvZiBwYXJhbXMua2V5ICE9PSBcInVuZGVmaW5lZFwiICYmIHBhcmFtcy5tZXRob2QgKXtcbiAgICAgIHZhciBrZXkgID0gcGFyYW1zLmtleSxcbiAgICAgICAgICBtZXRob2QgPSBwYXJhbXMubWV0aG9kLFxuICAgICAgICAgIC8vIG9wZXJhbmQgY2FuIGJlIG51bGwgZm9yIFwiYWJzXCIsIGNlaWwgYW5kIGZsb29yXG4gICAgICAgICAgb3BlcmFuZCA9IHBhcmFtcy5vcGVyYW5kLFxuICAgICAgICAgIHJvdW5kID0gcGFyYW1zLnJvdW5kLFxuICAgICAgICAgIG1hdGhPdXQgPSBudWxsO1xuXG4gICAgICBrZXkgPSBwYXJzZUZsb2F0KGR1c3QuaGVscGVycy50YXAoa2V5LCBjaHVuaywgY29udGV4dCkpO1xuICAgICAgb3BlcmFuZCA9IHBhcnNlRmxvYXQoZHVzdC5oZWxwZXJzLnRhcChvcGVyYW5kLCBjaHVuaywgY29udGV4dCkpO1xuICAgICAgLy8gIFRPRE86IGhhbmRsZSAgYW5kIHRlc3RzIGZvciBuZWdhdGl2ZXMgYW5kIGZsb2F0cyBpbiBhbGwgbWF0aCBvcGVyYXRpb25zXG4gICAgICBzd2l0Y2gobWV0aG9kKSB7XG4gICAgICAgIGNhc2UgXCJtb2RcIjpcbiAgICAgICAgICBpZihvcGVyYW5kID09PSAwIHx8IG9wZXJhbmQgPT09IC0wKSB7XG4gICAgICAgICAgICBfbG9nKFwiRGl2aXNpb24gYnkgMCBpbiB7QG1hdGh9IGhlbHBlclwiLCBcIldBUk5cIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIG1hdGhPdXQgPSBrZXkgJSBvcGVyYW5kO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiYWRkXCI6XG4gICAgICAgICAgbWF0aE91dCA9IGtleSArIG9wZXJhbmQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJzdWJ0cmFjdFwiOlxuICAgICAgICAgIG1hdGhPdXQgPSBrZXkgLSBvcGVyYW5kO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibXVsdGlwbHlcIjpcbiAgICAgICAgICBtYXRoT3V0ID0ga2V5ICogb3BlcmFuZDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImRpdmlkZVwiOlxuICAgICAgICAgIGlmKG9wZXJhbmQgPT09IDAgfHwgb3BlcmFuZCA9PT0gLTApIHtcbiAgICAgICAgICAgIF9sb2coXCJEaXZpc2lvbiBieSAwIGluIHtAbWF0aH0gaGVscGVyXCIsIFwiV0FSTlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbWF0aE91dCA9IGtleSAvIG9wZXJhbmQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJjZWlsXCI6XG4gICAgICAgICAgbWF0aE91dCA9IE1hdGguY2VpbChrZXkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZmxvb3JcIjpcbiAgICAgICAgICBtYXRoT3V0ID0gTWF0aC5mbG9vcihrZXkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwicm91bmRcIjpcbiAgICAgICAgICBtYXRoT3V0ID0gTWF0aC5yb3VuZChrZXkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiYWJzXCI6XG4gICAgICAgICAgbWF0aE91dCA9IE1hdGguYWJzKGtleSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ0b2ludFwiOlxuICAgICAgICAgIG1hdGhPdXQgPSBwYXJzZUludChrZXksIDEwKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBfbG9nKFwie0BtYXRofTogbWV0aG9kIFwiICsgbWV0aG9kICsgXCIgbm90IHN1cHBvcnRlZFwiKTtcbiAgICAgfVxuXG4gICAgICBpZiAobWF0aE91dCAhPT0gbnVsbCl7XG4gICAgICAgIGlmIChyb3VuZCkge1xuICAgICAgICAgIG1hdGhPdXQgPSBNYXRoLnJvdW5kKG1hdGhPdXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChib2RpZXMgJiYgYm9kaWVzLmJsb2NrKSB7XG4gICAgICAgICAgLy8gd2l0aCBib2RpZXMgYWN0IGxpa2UgdGhlIHNlbGVjdCBoZWxwZXIgd2l0aCBtYXRoT3V0IGFzIHRoZSBrZXlcbiAgICAgICAgICAvLyBsaWtlIHRoZSBzZWxlY3QgaGVscGVyIGJvZGllc1snZWxzZSddIGlzIG1lYW5pbmdsZXNzIGFuZCBpcyBpZ25vcmVkXG4gICAgICAgICAgY29udGV4dCA9IGFkZFNlbGVjdFN0YXRlKGNvbnRleHQsIG1hdGhPdXQpO1xuICAgICAgICAgIHJldHVybiBjaHVuay5yZW5kZXIoYm9kaWVzLmJsb2NrLCBjb250ZXh0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBzZWxmIGNsb3NpbmcgbWF0aCBoZWxwZXIgd2lsbCByZXR1cm4gdGhlIGNhbGN1bGF0ZWQgb3V0cHV0XG4gICAgICAgICAgcmV0dXJuIGNodW5rLndyaXRlKG1hdGhPdXQpO1xuICAgICAgICB9XG4gICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNodW5rO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBubyBrZXkgcGFyYW1ldGVyIGFuZCBubyBtZXRob2RcbiAgICBlbHNlIHtcbiAgICAgIF9sb2coXCJLZXkgaXMgYSByZXF1aXJlZCBwYXJhbWV0ZXIgZm9yIG1hdGggaGVscGVyIGFsb25nIHdpdGggbWV0aG9kL29wZXJhbmQhXCIpO1xuICAgIH1cbiAgICByZXR1cm4gY2h1bms7XG4gIH0sXG4gICAvKipcbiAgIHNlbGVjdCBoZWxwZXIgd29ya3Mgd2l0aCBvbmUgb2YgdGhlIGVxL25lL2d0L2d0ZS9sdC9sdGUvZGVmYXVsdCBwcm92aWRpbmcgdGhlIGZ1bmN0aW9uYWxpdHlcbiAgIG9mIGJyYW5jaGluZyBjb25kaXRpb25zXG4gICBAcGFyYW0ga2V5LCAgKCByZXF1aXJlZCApIGVpdGhlciBhIHN0cmluZyBsaXRlcmFsIHZhbHVlIG9yIGEgZHVzdCByZWZlcmVuY2VcbiAgICAgICAgICAgICAgICBhIHN0cmluZyBsaXRlcmFsIHZhbHVlLCBpcyBlbmNsb3NlZCBpbiBkb3VibGUgcXVvdGVzLCBlLmcuIGtleT1cImZvb1wiXG4gICAgICAgICAgICAgICAgYSBkdXN0IHJlZmVyZW5jZSBtYXkgb3IgbWF5IG5vdCBiZSBlbmNsb3NlZCBpbiBkb3VibGUgcXVvdGVzLCBlLmcuIGtleT1cInt2YWx9XCIgYW5kIGtleT12YWwgYXJlIGJvdGggdmFsaWRcbiAgIEBwYXJhbSB0eXBlIChvcHRpb25hbCksIHN1cHBvcnRlZCB0eXBlcyBhcmUgIG51bWJlciwgYm9vbGVhbiwgc3RyaW5nLCBkYXRlLCBjb250ZXh0LCBkZWZhdWx0cyB0byBzdHJpbmdcbiAgICoqL1xuICBcInNlbGVjdFwiOiBmdW5jdGlvbihjaHVuaywgY29udGV4dCwgYm9kaWVzLCBwYXJhbXMpIHtcbiAgICB2YXIgYm9keSA9IGJvZGllcy5ibG9jayxcbiAgICAgICAgc3RhdGUsIGtleSwgbGVuLCB4O1xuXG4gICAgaWYgKHBhcmFtcy5oYXNPd25Qcm9wZXJ0eShcImtleVwiKSkge1xuICAgICAga2V5ID0gZHVzdC5oZWxwZXJzLnRhcChwYXJhbXMua2V5LCBjaHVuaywgY29udGV4dCk7XG4gICAgICAvLyBib2RpZXNbJ2Vsc2UnXSBpcyBtZWFuaW5nbGVzcyBhbmQgaXMgaWdub3JlZFxuICAgICAgaWYgKGJvZHkpIHtcbiAgICAgICAgY29udGV4dCA9IGFkZFNlbGVjdFN0YXRlKGNvbnRleHQsIGtleSk7XG4gICAgICAgIHN0YXRlID0gZ2V0U2VsZWN0U3RhdGUoY29udGV4dCk7XG4gICAgICAgIGNodW5rID0gY2h1bmsucmVuZGVyKGJvZHksIGNvbnRleHQpO1xuICAgICAgICAvLyBSZXNvbHZlIGFueSBkZWZlcnJlZCBibG9ja3MgKGN1cnJlbnRseSBqdXN0IHtAYW55fSBibG9ja3MpXG4gICAgICAgIGlmKHN0YXRlLmRlZmVycmVkcy5sZW5ndGgpIHtcbiAgICAgICAgICBzdGF0ZS5pc0RlZmVycmVkQ29tcGxldGUgPSB0cnVlO1xuICAgICAgICAgIGZvcih4PTAsIGxlbj1zdGF0ZS5kZWZlcnJlZHMubGVuZ3RoOyB4PGxlbjsgeCsrKSB7XG4gICAgICAgICAgICBzdGF0ZS5kZWZlcnJlZHNbeF0oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9sb2coXCJNaXNzaW5nIGJvZHkgYmxvY2sgaW4ge0BzZWxlY3R9XCIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBfbG9nKFwiTm8ga2V5IHByb3ZpZGVkIGZvciB7QHNlbGVjdH1cIiwgXCJXQVJOXCIpO1xuICAgIH1cbiAgICByZXR1cm4gY2h1bms7XG4gIH0sXG5cbiAgLyoqXG4gICBlcSBoZWxwZXIgY29tcGFyZXMgdGhlIGdpdmVuIGtleSBpcyBzYW1lIGFzIHRoZSBleHBlY3RlZCB2YWx1ZVxuICAgSXQgY2FuIGJlIHVzZWQgc3RhbmRhbG9uZSBvciBpbiBjb25qdW5jdGlvbiB3aXRoIHNlbGVjdCBmb3IgbXVsdGlwbGUgYnJhbmNoaW5nXG4gICBAcGFyYW0ga2V5LCAgVGhlIGFjdHVhbCBrZXkgdG8gYmUgY29tcGFyZWQgKCBvcHRpb25hbCB3aGVuIGhlbHBlciB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggc2VsZWN0KVxuICAgICAgICAgICAgICAgIGVpdGhlciBhIHN0cmluZyBsaXRlcmFsIHZhbHVlIG9yIGEgZHVzdCByZWZlcmVuY2VcbiAgICAgICAgICAgICAgICBhIHN0cmluZyBsaXRlcmFsIHZhbHVlLCBpcyBlbmNsb3NlZCBpbiBkb3VibGUgcXVvdGVzLCBlLmcuIGtleT1cImZvb1wiXG4gICAgICAgICAgICAgICAgYSBkdXN0IHJlZmVyZW5jZSBtYXkgb3IgbWF5IG5vdCBiZSBlbmNsb3NlZCBpbiBkb3VibGUgcXVvdGVzLCBlLmcuIGtleT1cInt2YWx9XCIgYW5kIGtleT12YWwgYXJlIGJvdGggdmFsaWRcbiAgIEBwYXJhbSB2YWx1ZSwgVGhlIGV4cGVjdGVkIHZhbHVlIHRvIGNvbXBhcmUgdG8sIHdoZW4gaGVscGVyIGlzIHVzZWQgc3RhbmRhbG9uZSBvciBpbiBjb25qdW5jdGlvbiB3aXRoIHNlbGVjdFxuICAgQHBhcmFtIHR5cGUgKG9wdGlvbmFsKSwgc3VwcG9ydGVkIHR5cGVzIGFyZSAgbnVtYmVyLCBib29sZWFuLCBzdHJpbmcsIGRhdGUsIGNvbnRleHQsIGRlZmF1bHRzIHRvIHN0cmluZ1xuICAgTm90ZSA6IHVzZSB0eXBlPVwibnVtYmVyXCIgd2hlbiBjb21wYXJpbmcgbnVtZXJpY1xuICAgKiovXG4gIFwiZXFcIjogZnVuY3Rpb24oY2h1bmssIGNvbnRleHQsIGJvZGllcywgcGFyYW1zKSB7XG4gICAgcGFyYW1zLmZpbHRlck9wVHlwZSA9IFwiZXFcIjtcbiAgICByZXR1cm4gZmlsdGVyKGNodW5rLCBjb250ZXh0LCBib2RpZXMsIHBhcmFtcywgZnVuY3Rpb24oZXhwZWN0ZWQsIGFjdHVhbCkgeyByZXR1cm4gYWN0dWFsID09PSBleHBlY3RlZDsgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICBuZSBoZWxwZXIgY29tcGFyZXMgdGhlIGdpdmVuIGtleSBpcyBub3QgdGhlIHNhbWUgYXMgdGhlIGV4cGVjdGVkIHZhbHVlXG4gICBJdCBjYW4gYmUgdXNlZCBzdGFuZGFsb25lIG9yIGluIGNvbmp1bmN0aW9uIHdpdGggc2VsZWN0IGZvciBtdWx0aXBsZSBicmFuY2hpbmdcbiAgIEBwYXJhbSBrZXksICBUaGUgYWN0dWFsIGtleSB0byBiZSBjb21wYXJlZCAoIG9wdGlvbmFsIHdoZW4gaGVscGVyIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCBzZWxlY3QpXG4gICAgICAgICAgICAgICAgZWl0aGVyIGEgc3RyaW5nIGxpdGVyYWwgdmFsdWUgb3IgYSBkdXN0IHJlZmVyZW5jZVxuICAgICAgICAgICAgICAgIGEgc3RyaW5nIGxpdGVyYWwgdmFsdWUsIGlzIGVuY2xvc2VkIGluIGRvdWJsZSBxdW90ZXMsIGUuZy4ga2V5PVwiZm9vXCJcbiAgICAgICAgICAgICAgICBhIGR1c3QgcmVmZXJlbmNlIG1heSBvciBtYXkgbm90IGJlIGVuY2xvc2VkIGluIGRvdWJsZSBxdW90ZXMsIGUuZy4ga2V5PVwie3ZhbH1cIiBhbmQga2V5PXZhbCBhcmUgYm90aCB2YWxpZFxuICAgQHBhcmFtIHZhbHVlLCBUaGUgZXhwZWN0ZWQgdmFsdWUgdG8gY29tcGFyZSB0bywgd2hlbiBoZWxwZXIgaXMgdXNlZCBzdGFuZGFsb25lIG9yIGluIGNvbmp1bmN0aW9uIHdpdGggc2VsZWN0XG4gICBAcGFyYW0gdHlwZSAob3B0aW9uYWwpLCBzdXBwb3J0ZWQgdHlwZXMgYXJlICBudW1iZXIsIGJvb2xlYW4sIHN0cmluZywgZGF0ZSwgY29udGV4dCwgZGVmYXVsdHMgdG8gc3RyaW5nXG4gICBOb3RlIDogdXNlIHR5cGU9XCJudW1iZXJcIiB3aGVuIGNvbXBhcmluZyBudW1lcmljXG4gICAqKi9cbiAgXCJuZVwiOiBmdW5jdGlvbihjaHVuaywgY29udGV4dCwgYm9kaWVzLCBwYXJhbXMpIHtcbiAgICBwYXJhbXMuZmlsdGVyT3BUeXBlID0gXCJuZVwiO1xuICAgIHJldHVybiBmaWx0ZXIoY2h1bmssIGNvbnRleHQsIGJvZGllcywgcGFyYW1zLCBmdW5jdGlvbihleHBlY3RlZCwgYWN0dWFsKSB7IHJldHVybiBhY3R1YWwgIT09IGV4cGVjdGVkOyB9KTtcbiAgfSxcblxuICAvKipcbiAgIGx0IGhlbHBlciBjb21wYXJlcyB0aGUgZ2l2ZW4ga2V5IGlzIGxlc3MgdGhhbiB0aGUgZXhwZWN0ZWQgdmFsdWVcbiAgIEl0IGNhbiBiZSB1c2VkIHN0YW5kYWxvbmUgb3IgaW4gY29uanVuY3Rpb24gd2l0aCBzZWxlY3QgZm9yIG11bHRpcGxlIGJyYW5jaGluZ1xuICAgQHBhcmFtIGtleSwgIFRoZSBhY3R1YWwga2V5IHRvIGJlIGNvbXBhcmVkICggb3B0aW9uYWwgd2hlbiBoZWxwZXIgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIHNlbGVjdClcbiAgICAgICAgICAgICAgICBlaXRoZXIgYSBzdHJpbmcgbGl0ZXJhbCB2YWx1ZSBvciBhIGR1c3QgcmVmZXJlbmNlXG4gICAgICAgICAgICAgICAgYSBzdHJpbmcgbGl0ZXJhbCB2YWx1ZSwgaXMgZW5jbG9zZWQgaW4gZG91YmxlIHF1b3RlcywgZS5nLiBrZXk9XCJmb29cIlxuICAgICAgICAgICAgICAgIGEgZHVzdCByZWZlcmVuY2UgbWF5IG9yIG1heSBub3QgYmUgZW5jbG9zZWQgaW4gZG91YmxlIHF1b3RlcywgZS5nLiBrZXk9XCJ7dmFsfVwiIGFuZCBrZXk9dmFsIGFyZSBib3RoIHZhbGlkXG4gICBAcGFyYW0gdmFsdWUsIFRoZSBleHBlY3RlZCB2YWx1ZSB0byBjb21wYXJlIHRvLCB3aGVuIGhlbHBlciBpcyB1c2VkIHN0YW5kYWxvbmUgIG9yIGluIGNvbmp1bmN0aW9uIHdpdGggc2VsZWN0XG4gICBAcGFyYW0gdHlwZSAob3B0aW9uYWwpLCBzdXBwb3J0ZWQgdHlwZXMgYXJlICBudW1iZXIsIGJvb2xlYW4sIHN0cmluZywgZGF0ZSwgY29udGV4dCwgZGVmYXVsdHMgdG8gc3RyaW5nXG4gICBOb3RlIDogdXNlIHR5cGU9XCJudW1iZXJcIiB3aGVuIGNvbXBhcmluZyBudW1lcmljXG4gICAqKi9cbiAgXCJsdFwiOiBmdW5jdGlvbihjaHVuaywgY29udGV4dCwgYm9kaWVzLCBwYXJhbXMpIHtcbiAgICBwYXJhbXMuZmlsdGVyT3BUeXBlID0gXCJsdFwiO1xuICAgIHJldHVybiBmaWx0ZXIoY2h1bmssIGNvbnRleHQsIGJvZGllcywgcGFyYW1zLCBmdW5jdGlvbihleHBlY3RlZCwgYWN0dWFsKSB7IHJldHVybiBhY3R1YWwgPCBleHBlY3RlZDsgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICBsdGUgaGVscGVyIGNvbXBhcmVzIHRoZSBnaXZlbiBrZXkgaXMgbGVzcyBvciBlcXVhbCB0byB0aGUgZXhwZWN0ZWQgdmFsdWVcbiAgIEl0IGNhbiBiZSB1c2VkIHN0YW5kYWxvbmUgb3IgaW4gY29uanVuY3Rpb24gd2l0aCBzZWxlY3QgZm9yIG11bHRpcGxlIGJyYW5jaGluZ1xuICAgQHBhcmFtIGtleSwgIFRoZSBhY3R1YWwga2V5IHRvIGJlIGNvbXBhcmVkICggb3B0aW9uYWwgd2hlbiBoZWxwZXIgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIHNlbGVjdClcbiAgICAgICAgICAgICAgICBlaXRoZXIgYSBzdHJpbmcgbGl0ZXJhbCB2YWx1ZSBvciBhIGR1c3QgcmVmZXJlbmNlXG4gICAgICAgICAgICAgICAgYSBzdHJpbmcgbGl0ZXJhbCB2YWx1ZSwgaXMgZW5jbG9zZWQgaW4gZG91YmxlIHF1b3RlcywgZS5nLiBrZXk9XCJmb29cIlxuICAgICAgICAgICAgICAgIGEgZHVzdCByZWZlcmVuY2UgbWF5IG9yIG1heSBub3QgYmUgZW5jbG9zZWQgaW4gZG91YmxlIHF1b3RlcywgZS5nLiBrZXk9XCJ7dmFsfVwiIGFuZCBrZXk9dmFsIGFyZSBib3RoIHZhbGlkXG4gICBAcGFyYW0gdmFsdWUsIFRoZSBleHBlY3RlZCB2YWx1ZSB0byBjb21wYXJlIHRvLCB3aGVuIGhlbHBlciBpcyB1c2VkIHN0YW5kYWxvbmUgb3IgaW4gY29uanVuY3Rpb24gd2l0aCBzZWxlY3RcbiAgIEBwYXJhbSB0eXBlIChvcHRpb25hbCksIHN1cHBvcnRlZCB0eXBlcyBhcmUgIG51bWJlciwgYm9vbGVhbiwgc3RyaW5nLCBkYXRlLCBjb250ZXh0LCBkZWZhdWx0cyB0byBzdHJpbmdcbiAgIE5vdGUgOiB1c2UgdHlwZT1cIm51bWJlclwiIHdoZW4gY29tcGFyaW5nIG51bWVyaWNcbiAgKiovXG4gIFwibHRlXCI6IGZ1bmN0aW9uKGNodW5rLCBjb250ZXh0LCBib2RpZXMsIHBhcmFtcykge1xuICAgIHBhcmFtcy5maWx0ZXJPcFR5cGUgPSBcImx0ZVwiO1xuICAgIHJldHVybiBmaWx0ZXIoY2h1bmssIGNvbnRleHQsIGJvZGllcywgcGFyYW1zLCBmdW5jdGlvbihleHBlY3RlZCwgYWN0dWFsKSB7IHJldHVybiBhY3R1YWwgPD0gZXhwZWN0ZWQ7IH0pO1xuICB9LFxuXG4gIC8qKlxuICAgZ3QgaGVscGVyIGNvbXBhcmVzIHRoZSBnaXZlbiBrZXkgaXMgZ3JlYXRlciB0aGFuIHRoZSBleHBlY3RlZCB2YWx1ZVxuICAgSXQgY2FuIGJlIHVzZWQgc3RhbmRhbG9uZSBvciBpbiBjb25qdW5jdGlvbiB3aXRoIHNlbGVjdCBmb3IgbXVsdGlwbGUgYnJhbmNoaW5nXG4gICBAcGFyYW0ga2V5LCAgVGhlIGFjdHVhbCBrZXkgdG8gYmUgY29tcGFyZWQgKCBvcHRpb25hbCB3aGVuIGhlbHBlciB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggc2VsZWN0KVxuICAgICAgICAgICAgICAgIGVpdGhlciBhIHN0cmluZyBsaXRlcmFsIHZhbHVlIG9yIGEgZHVzdCByZWZlcmVuY2VcbiAgICAgICAgICAgICAgICBhIHN0cmluZyBsaXRlcmFsIHZhbHVlLCBpcyBlbmNsb3NlZCBpbiBkb3VibGUgcXVvdGVzLCBlLmcuIGtleT1cImZvb1wiXG4gICAgICAgICAgICAgICAgYSBkdXN0IHJlZmVyZW5jZSBtYXkgb3IgbWF5IG5vdCBiZSBlbmNsb3NlZCBpbiBkb3VibGUgcXVvdGVzLCBlLmcuIGtleT1cInt2YWx9XCIgYW5kIGtleT12YWwgYXJlIGJvdGggdmFsaWRcbiAgIEBwYXJhbSB2YWx1ZSwgVGhlIGV4cGVjdGVkIHZhbHVlIHRvIGNvbXBhcmUgdG8sIHdoZW4gaGVscGVyIGlzIHVzZWQgc3RhbmRhbG9uZSAgb3IgaW4gY29uanVuY3Rpb24gd2l0aCBzZWxlY3RcbiAgIEBwYXJhbSB0eXBlIChvcHRpb25hbCksIHN1cHBvcnRlZCB0eXBlcyBhcmUgIG51bWJlciwgYm9vbGVhbiwgc3RyaW5nLCBkYXRlLCBjb250ZXh0LCBkZWZhdWx0cyB0byBzdHJpbmdcbiAgIE5vdGUgOiB1c2UgdHlwZT1cIm51bWJlclwiIHdoZW4gY29tcGFyaW5nIG51bWVyaWNcbiAgICoqL1xuICBcImd0XCI6IGZ1bmN0aW9uKGNodW5rLCBjb250ZXh0LCBib2RpZXMsIHBhcmFtcykge1xuICAgIHBhcmFtcy5maWx0ZXJPcFR5cGUgPSBcImd0XCI7XG4gICAgcmV0dXJuIGZpbHRlcihjaHVuaywgY29udGV4dCwgYm9kaWVzLCBwYXJhbXMsIGZ1bmN0aW9uKGV4cGVjdGVkLCBhY3R1YWwpIHsgcmV0dXJuIGFjdHVhbCA+IGV4cGVjdGVkOyB9KTtcbiAgfSxcblxuIC8qKlxuICAgZ3RlIGhlbHBlciwgY29tcGFyZXMgdGhlIGdpdmVuIGtleSBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gdGhlIGV4cGVjdGVkIHZhbHVlXG4gICBJdCBjYW4gYmUgdXNlZCBzdGFuZGFsb25lIG9yIGluIGNvbmp1bmN0aW9uIHdpdGggc2VsZWN0IGZvciBtdWx0aXBsZSBicmFuY2hpbmdcbiAgIEBwYXJhbSBrZXksICBUaGUgYWN0dWFsIGtleSB0byBiZSBjb21wYXJlZCAoIG9wdGlvbmFsIHdoZW4gaGVscGVyIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCBzZWxlY3QpXG4gICAgICAgICAgICAgICAgZWl0aGVyIGEgc3RyaW5nIGxpdGVyYWwgdmFsdWUgb3IgYSBkdXN0IHJlZmVyZW5jZVxuICAgICAgICAgICAgICAgIGEgc3RyaW5nIGxpdGVyYWwgdmFsdWUsIGlzIGVuY2xvc2VkIGluIGRvdWJsZSBxdW90ZXMsIGUuZy4ga2V5PVwiZm9vXCJcbiAgICAgICAgICAgICAgICBhIGR1c3QgcmVmZXJlbmNlIG1heSBvciBtYXkgbm90IGJlIGVuY2xvc2VkIGluIGRvdWJsZSBxdW90ZXMsIGUuZy4ga2V5PVwie3ZhbH1cIiBhbmQga2V5PXZhbCBhcmUgYm90aCB2YWxpZFxuICAgQHBhcmFtIHZhbHVlLCBUaGUgZXhwZWN0ZWQgdmFsdWUgdG8gY29tcGFyZSB0bywgd2hlbiBoZWxwZXIgaXMgdXNlZCBzdGFuZGFsb25lIG9yIGluIGNvbmp1bmN0aW9uIHdpdGggc2VsZWN0XG4gICBAcGFyYW0gdHlwZSAob3B0aW9uYWwpLCBzdXBwb3J0ZWQgdHlwZXMgYXJlICBudW1iZXIsIGJvb2xlYW4sIHN0cmluZywgZGF0ZSwgY29udGV4dCwgZGVmYXVsdHMgdG8gc3RyaW5nXG4gICBOb3RlIDogdXNlIHR5cGU9XCJudW1iZXJcIiB3aGVuIGNvbXBhcmluZyBudW1lcmljXG4gICoqL1xuICBcImd0ZVwiOiBmdW5jdGlvbihjaHVuaywgY29udGV4dCwgYm9kaWVzLCBwYXJhbXMpIHtcbiAgICBwYXJhbXMuZmlsdGVyT3BUeXBlID0gXCJndGVcIjtcbiAgICByZXR1cm4gZmlsdGVyKGNodW5rLCBjb250ZXh0LCBib2RpZXMsIHBhcmFtcywgZnVuY3Rpb24oZXhwZWN0ZWQsIGFjdHVhbCkgeyByZXR1cm4gYWN0dWFsID49IGV4cGVjdGVkOyB9KTtcbiAgfSxcblxuICAvKipcbiAgICoge0Bhbnl9XG4gICAqIE91dHB1dHMgYXMgbG9uZyBhcyBhdCBsZWFzdCBvbmUgdHJ1dGggdGVzdCBpbnNpZGUgYSB7QHNlbGVjdH0gaGFzIHBhc3NlZC5cbiAgICogTXVzdCBiZSBjb250YWluZWQgaW5zaWRlIGEge0BzZWxlY3R9IGJsb2NrLlxuICAgKiBUaGUgcGFzc2luZyB0cnV0aCB0ZXN0IGNhbiBiZSBiZWZvcmUgb3IgYWZ0ZXIgdGhlIHtAYW55fSBibG9jay5cbiAgICovXG4gIFwiYW55XCI6IGZ1bmN0aW9uKGNodW5rLCBjb250ZXh0LCBib2RpZXMsIHBhcmFtcykge1xuICAgIHZhciBzZWxlY3RTdGF0ZTtcblxuICAgIGlmKCFpc1NlbGVjdChjb250ZXh0KSkge1xuICAgICAgX2xvZyhcIntAYW55fSB1c2VkIG91dHNpZGUgb2YgYSB7QHNlbGVjdH0gYmxvY2tcIiwgXCJXQVJOXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWxlY3RTdGF0ZSA9IGdldFNlbGVjdFN0YXRlKGNvbnRleHQpO1xuICAgICAgaWYoc2VsZWN0U3RhdGUuaXNEZWZlcnJlZENvbXBsZXRlKSB7XG4gICAgICAgIF9sb2coXCJ7QGFueX0gbmVzdGVkIGluc2lkZSB7QGFueX0gb3Ige0Bub25lfSBibG9jay4gSXQgbmVlZHMgaXRzIG93biB7QHNlbGVjdH0gYmxvY2tcIiwgXCJXQVJOXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2h1bmsgPSBjaHVuay5tYXAoZnVuY3Rpb24oY2h1bmspIHtcbiAgICAgICAgICBzZWxlY3RTdGF0ZS5kZWZlcnJlZHMucHVzaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmKHNlbGVjdFN0YXRlLmlzUmVzb2x2ZWQgJiYgIXNlbGVjdFN0YXRlLmlzRGVmYXVsdGVkKSB7XG4gICAgICAgICAgICAgIGNodW5rID0gY2h1bmsucmVuZGVyKGJvZGllcy5ibG9jaywgY29udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaHVuay5lbmQoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjaHVuaztcbiAgfSxcblxuICAvKipcbiAgICoge0Bub25lfVxuICAgKiBPdXRwdXRzIGlmIG5vIHRydXRoIHRlc3RzIGluc2lkZSBhIHtAc2VsZWN0fSBwYXNzLlxuICAgKiBNdXN0IGJlIGNvbnRhaW5lZCBpbnNpZGUgYSB7QHNlbGVjdH0gYmxvY2suXG4gICAqIFRoZSBwb3NpdGlvbiBvZiB0aGUgaGVscGVyIGRvZXMgbm90IG1hdHRlci5cbiAgICovXG4gIFwibm9uZVwiOiBmdW5jdGlvbihjaHVuaywgY29udGV4dCwgYm9kaWVzLCBwYXJhbXMpIHtcbiAgICB2YXIgc2VsZWN0U3RhdGU7XG5cbiAgICBpZighaXNTZWxlY3QoY29udGV4dCkpIHtcbiAgICAgIF9sb2coXCJ7QG5vbmV9IHVzZWQgb3V0c2lkZSBvZiBhIHtAc2VsZWN0fSBibG9ja1wiLCBcIldBUk5cIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGVjdFN0YXRlID0gZ2V0U2VsZWN0U3RhdGUoY29udGV4dCk7XG4gICAgICBpZihzZWxlY3RTdGF0ZS5pc0RlZmVycmVkQ29tcGxldGUpIHtcbiAgICAgICAgX2xvZyhcIntAbm9uZX0gbmVzdGVkIGluc2lkZSB7QGFueX0gb3Ige0Bub25lfSBibG9jay4gSXQgbmVlZHMgaXRzIG93biB7QHNlbGVjdH0gYmxvY2tcIiwgXCJXQVJOXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2h1bmsgPSBjaHVuay5tYXAoZnVuY3Rpb24oY2h1bmspIHtcbiAgICAgICAgICBzZWxlY3RTdGF0ZS5kZWZlcnJlZHMucHVzaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmKCFzZWxlY3RTdGF0ZS5pc1Jlc29sdmVkKSB7XG4gICAgICAgICAgICAgIGNodW5rID0gY2h1bmsucmVuZGVyKGJvZGllcy5ibG9jaywgY29udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaHVuay5lbmQoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjaHVuaztcbiAgfSxcblxuICAvKipcbiAgICoge0BkZWZhdWx0fVxuICAgKiBPdXRwdXRzIGlmIG5vIHRydXRoIHRlc3QgaW5zaWRlIGEge0BzZWxlY3R9IGhhcyBwYXNzZWQuXG4gICAqIE11c3QgYmUgY29udGFpbmVkIGluc2lkZSBhIHtAc2VsZWN0fSBibG9jay5cbiAgICovXG4gIFwiZGVmYXVsdFwiOiBmdW5jdGlvbihjaHVuaywgY29udGV4dCwgYm9kaWVzLCBwYXJhbXMpIHtcbiAgICBwYXJhbXMuZmlsdGVyT3BUeXBlID0gXCJkZWZhdWx0XCI7XG4gICAgLy8gRGVwcmVjYXRlZCBmb3IgcmVtb3ZhbCBpbiAxLjdcbiAgICBfZGVwcmVjYXRlZChcIntAZGVmYXVsdH1cIik7XG4gICAgaWYoIWlzU2VsZWN0KGNvbnRleHQpKSB7XG4gICAgICBfbG9nKFwie0BkZWZhdWx0fSB1c2VkIG91dHNpZGUgb2YgYSB7QHNlbGVjdH0gYmxvY2tcIiwgXCJXQVJOXCIpO1xuICAgICAgcmV0dXJuIGNodW5rO1xuICAgIH1cbiAgICByZXR1cm4gZmlsdGVyKGNodW5rLCBjb250ZXh0LCBib2RpZXMsIHBhcmFtcywgZnVuY3Rpb24oKSB7IHJldHVybiB0cnVlOyB9KTtcbiAgfSxcblxuICAvKipcbiAgKiBzaXplIGhlbHBlciBwcmludHMgdGhlIHNpemUgb2YgdGhlIGdpdmVuIGtleVxuICAqIE5vdGUgOiBzaXplIGhlbHBlciBpcyBzZWxmIGNsb3NpbmcgYW5kIGRvZXMgbm90IHN1cHBvcnQgYm9kaWVzXG4gICogQHBhcmFtIGtleSwgdGhlIGVsZW1lbnQgd2hvc2Ugc2l6ZSBpcyByZXR1cm5lZFxuICAqL1xuICBcInNpemVcIjogZnVuY3Rpb24oIGNodW5rLCBjb250ZXh0LCBib2RpZXMsIHBhcmFtcyApIHtcbiAgICB2YXIga2V5LCB2YWx1ZT0wLCBuciwgaztcbiAgICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG4gICAga2V5ID0gcGFyYW1zLmtleTtcbiAgICBpZiAoIWtleSB8fCBrZXkgPT09IHRydWUpIHsgLy91bmRlZmluZWQsIG51bGwsIFwiXCIsIDBcbiAgICAgIHZhbHVlID0gMDtcbiAgICB9XG4gICAgZWxzZSBpZihkdXN0LmlzQXJyYXkoa2V5KSkgeyAvL2FycmF5XG4gICAgICB2YWx1ZSA9IGtleS5sZW5ndGg7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFpc05hTihwYXJzZUZsb2F0KGtleSkpICYmIGlzRmluaXRlKGtleSkpIHsgLy9udW1lcmljIHZhbHVlc1xuICAgICAgdmFsdWUgPSBrZXk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBrZXkgID09PSBcIm9iamVjdFwiKSB7IC8vb2JqZWN0IHRlc3RcbiAgICAgIC8vb2JqZWN0cywgbnVsbCBhbmQgYXJyYXkgYWxsIGhhdmUgdHlwZW9mIG9qYmVjdC4uLlxuICAgICAgLy9udWxsIGFuZCBhcnJheSBhcmUgYWxyZWFkeSB0ZXN0ZWQgc28gdHlwZW9mIGlzIHN1ZmZpY2llbnQgaHR0cDovL2pzcGVyZi5jb20vaXNvYmplY3QtdGVzdHNcbiAgICAgIG5yID0gMDtcbiAgICAgIGZvcihrIGluIGtleSl7XG4gICAgICAgIGlmKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGtleSxrKSl7XG4gICAgICAgICAgbnIrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFsdWUgPSBucjtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgPSAoa2V5ICsgJycpLmxlbmd0aDsgLy9hbnkgb3RoZXIgdmFsdWUgKHN0cmluZ3MgZXRjLilcbiAgICB9XG4gICAgcmV0dXJuIGNodW5rLndyaXRlKHZhbHVlKTtcbiAgfVxuXG5cbn07XG5cbiAgZm9yKHZhciBrZXkgaW4gaGVscGVycykge1xuICAgIGR1c3QuaGVscGVyc1trZXldID0gaGVscGVyc1trZXldO1xuICB9XG5cbiAgcmV0dXJuIGR1c3Q7XG5cbn0pKTtcbiIsIkRHLmR1c3QgPSBmdW5jdGlvbiAodG1wbCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAobmFtZSwgZGF0YSkge1xuICAgICAgICBpZiAoIWR1c3QuY2FjaGVbbmFtZV0pIHtcbiAgICAgICAgICAgIGR1c3QubG9hZFNvdXJjZSh0bXBsW25hbWVdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgICAgZHVzdC5yZW5kZXIobmFtZSwgZGF0YSwgZnVuY3Rpb24gKGVyciwgaHRtbCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gaHRtbDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xufTtcblxuaWYgKERHLmRlYnVnKSB7IGR1c3QuZGVidWdMZXZlbCA9ICdFUlJPUic7IH1cbiIsIkRHLkNvbnRyb2wuQXR0cmlidXRpb24uaW5jbHVkZShERy5Mb2NhbGUpO1xuREcuQ29udHJvbC5BdHRyaWJ1dGlvbi5EaWN0aW9uYXJ5ID0ge307XG5ERy5Db250cm9sLkF0dHJpYnV0aW9uLmluY2x1ZGUoe1xuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgcG9zaXRpb246ICdib3R0b21yaWdodCdcbiAgICB9LFxuXG4gICAgX2dldExpbms6IGZ1bmN0aW9uIChsaW5rVHlwZSkge1xuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBjYW1lbGNhc2UgKi9cbiAgICAgICAgdmFyIGRpY3Rpb25hcnkgPSB7XG4gICAgICAgICAgICBydToge1xuICAgICAgICAgICAgICAgIGNvcHlyaWdodF9sb2dvOiAnaHR0cDovL2luZm8uMmdpcy5ydS8/dXRtX3NvdXJjZT1jb3B5cmlnaHQmdXRtX21lZGl1bT1tYXAmdXRtX2NhbXBhaWduPXBhcnRuZXJzJyxcbiAgICAgICAgICAgICAgICBjb3B5cmlnaHRfYXBpbGluazogJ2h0dHA6Ly9hcGkuMmdpcy5ydS8/dXRtX3NvdXJjZT1jb3B5cmlnaHQmdXRtX21lZGl1bT1tYXAmdXRtX2NhbXBhaWduPXBhcnRuZXJzJyxcbiAgICAgICAgICAgICAgICBjb3B5cmlnaHRfbGljZW5zZTogJ2h0dHA6Ly9oZWxwLjJnaXMucnUvbGljZW5zaW5nLWFncmVlbWVudC8nXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBpdDoge1xuICAgICAgICAgICAgICAgIGNvcHlyaWdodF9sb2dvOiAnaHR0cDovLzJnaXMuaXQvP3V0bV9zb3VyY2U9Y29weXJpZ2h0JnV0bV9tZWRpdW09bWFwJnV0bV9jYW1wYWlnbj1wYXJ0bmVycycsXG4gICAgICAgICAgICAgICAgY29weXJpZ2h0X2FwaWxpbms6ICdodHRwOi8vMmdpcy5pdC8/dXRtX3NvdXJjZT1jb3B5cmlnaHQmdXRtX21lZGl1bT1tYXAmdXRtX2NhbXBhaWduPXBhcnRuZXJzJyxcbiAgICAgICAgICAgICAgICBjb3B5cmlnaHRfbGljZW5zZTogJ2h0dHA6Ly8yZ2lzLml0LydcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGN6OiB7XG4gICAgICAgICAgICAgICAgY29weXJpZ2h0X2xvZ286ICdodHRwOi8vcHJhaGEuMmdpcy5jei8/dXRtX3NvdXJjZT1jb3B5cmlnaHQmdXRtX21lZGl1bT1tYXAmdXRtX2NhbXBhaWduPXBhcnRuZXJzJyxcbiAgICAgICAgICAgICAgICBjb3B5cmlnaHRfYXBpbGluazogJ2h0dHA6Ly9wcmFoYS4yZ2lzLmN6Lz91dG1fc291cmNlPWNvcHlyaWdodCZ1dG1fbWVkaXVtPW1hcCZ1dG1fY2FtcGFpZ249cGFydG5lcnMnLFxuICAgICAgICAgICAgICAgIGNvcHlyaWdodF9saWNlbnNlOiAnaHR0cDovL2xhdy4yZ2lzLmN6L2xpY2Vuc2luZy1hZ3JlZW1lbnQvJ1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgY2w6IHtcbiAgICAgICAgICAgICAgICBjb3B5cmlnaHRfbG9nbzogJ2h0dHA6Ly9zYW50aWFnby4yZ2lzLmNsLz91dG1fc291cmNlPWNvcHlyaWdodCZ1dG1fbWVkaXVtPW1hcCZ1dG1fY2FtcGFpZ249cGFydG5lcnMnLFxuICAgICAgICAgICAgICAgIGNvcHlyaWdodF9hcGlsaW5rOiAnaHR0cDovL3NhbnRpYWdvLjJnaXMuY2wvP3V0bV9zb3VyY2U9Y29weXJpZ2h0JnV0bV9tZWRpdW09bWFwJnV0bV9jYW1wYWlnbj1wYXJ0bmVycycsXG4gICAgICAgICAgICAgICAgY29weXJpZ2h0X2xpY2Vuc2U6ICdodHRwOi8vbGF3LjJnaXMuY2wvbGljZW5zaW5nLWFncmVlbWVudC8nXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBjeToge1xuICAgICAgICAgICAgICAgIGNvcHlyaWdodF9sb2dvOiAnaHR0cDovL2luZm8uMmdpcy5jb20uY3kvbGVtZXNvcz91dG1fc291cmNlPWNvcHlyaWdodCZ1dG1fbWVkaXVtPW1hcCZ1dG1fY2FtcGFpZ249cGFydG5lcnMnLFxuICAgICAgICAgICAgICAgIGNvcHlyaWdodF9hcGlsaW5rOiAnaHR0cDovL2luZm8uMmdpcy5jb20uY3kvbGVtZXNvcz91dG1fc291cmNlPWNvcHlyaWdodCZ1dG1fbWVkaXVtPW1hcCZ1dG1fY2FtcGFpZ249cGFydG5lcnMnLFxuICAgICAgICAgICAgICAgIGNvcHlyaWdodF9saWNlbnNlOiAnaHR0cDovL2xhdy4yZ2lzLmNvbS5jeS9saWNlbnNpbmctYWdyZWVtZW50LydcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGFlOiB7XG4gICAgICAgICAgICAgICAgY29weXJpZ2h0X2xvZ286ICdodHRwOi8vaW5mby4yZ2lzLmFlL2R1YmFpP3V0bV9zb3VyY2U9Y29weXJpZ2h0JnV0bV9tZWRpdW09bWFwJnV0bV9jYW1wYWlnbj1wYXJ0bmVycycsXG4gICAgICAgICAgICAgICAgY29weXJpZ2h0X2FwaWxpbms6ICdodHRwOi8vaW5mby4yZ2lzLmFlL2R1YmFpP3V0bV9zb3VyY2U9Y29weXJpZ2h0JnV0bV9tZWRpdW09bWFwJnV0bV9jYW1wYWlnbj1wYXJ0bmVycycsXG4gICAgICAgICAgICAgICAgY29weXJpZ2h0X2xpY2Vuc2U6ICdodHRwOi8vbGF3LjJnaXMuYWUvbGljZW5zaW5nLWFncmVlbWVudC8nXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qIGVzbGludC1lbmFibGUgY2FtZWxjYXNlICovXG5cbiAgICAgICAgdmFyIGNvdW50cnlDb2RlID0gKHRoaXMuX2NvdW50cnlDb2RlIGluIGRpY3Rpb25hcnkpID8gdGhpcy5fY291bnRyeUNvZGUgOiAncnUnO1xuXG4gICAgICAgIHJldHVybiBkaWN0aW9uYXJ5W2NvdW50cnlDb2RlXVtsaW5rVHlwZV07XG4gICAgfSxcblxuICAgIG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XG4gICAgICAgIGlmICghbWFwLl9jb3B5cmlnaHQpIHtcbiAgICAgICAgICAgIG1hcC5fY29weXJpZ2h0ID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2ZpcnN0ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2NvbnRhaW5lciA9IERHLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCAnZGctYXR0cmlidXRpb24nKTtcbiAgICAgICAgREcuRG9tRXZlbnQuZGlzYWJsZUNsaWNrUHJvcGFnYXRpb24odGhpcy5fY29udGFpbmVyKTtcblxuICAgICAgICBmb3IgKHZhciBpIGluIG1hcC5fbGF5ZXJzKSB7XG4gICAgICAgICAgICBpZiAobWFwLl9sYXllcnNbaV0uZ2V0QXR0cmlidXRpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEF0dHJpYnV0aW9uKG1hcC5fbGF5ZXJzW2ldLmdldEF0dHJpYnV0aW9uKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fdXBkYXRlKCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcbiAgICB9LFxuXG4gICAgX3VwZGF0ZTogZnVuY3Rpb24gKGxhbmcsIG9zbSwgY291bnRyeUNvZGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9tYXApIHsgcmV0dXJuOyB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBvc20gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aGlzLl9vc20gPSBvc207XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNvdW50cnlDb2RlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhpcy5fY291bnRyeUNvZGUgPSBjb3VudHJ5Q29kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhdHRyaWJzID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgaSBpbiB0aGlzLl9hdHRyaWJ1dGlvbnMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9hdHRyaWJ1dGlvbnNbaV0pIHtcbiAgICAgICAgICAgICAgICBhdHRyaWJzLnB1c2goaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcHJlZml4QW5kQXR0cmlicyA9IFtdLFxuICAgICAgICAgICAgY29weXJpZ2h0ID0gJyc7XG5cbiAgICAgICAgaWYgKHRoaXMuX2ZpcnN0KSB7XG4gICAgICAgICAgICBjb3B5cmlnaHQgPSB0aGlzLl9nZXRBdHRyaWJ1dGlvbkhUTUwobGFuZyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnByZWZpeCkge1xuICAgICAgICAgICAgcHJlZml4QW5kQXR0cmlicy5wdXNoKHRoaXMub3B0aW9ucy5wcmVmaXgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhdHRyaWJzLmxlbmd0aCkge1xuICAgICAgICAgICAgcHJlZml4QW5kQXR0cmlicy5wdXNoKGF0dHJpYnMuam9pbignLCAnKSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9jb250YWluZXIuaW5uZXJIVE1MID0gY29weXJpZ2h0ICsgcHJlZml4QW5kQXR0cmlicy5qb2luKCcgfCAnKTtcbiAgICB9LFxuICAgIC8qIGdsb2JhbCBfX0RHQXR0cmlidXRpb25fVE1QTF9fICovXG4gICAgX3RtcGw6IERHLmR1c3Qoe1wiY29weXJpZ2h0XCI6XCIoZnVuY3Rpb24oKXtkdXN0LnJlZ2lzdGVyKFxcXCJjb3B5cmlnaHRcXFwiLGJvZHlfMCk7ZnVuY3Rpb24gYm9keV8wKGNoayxjdHgpe3JldHVybiBjaGsud3JpdGUoXFxcIjxkaXYgY2xhc3M9XFxcXFxcXCJkZy1hdHRyaWJ1dGlvbl9fY29weXJpZ2h0XFxcXFxcXCI+PHVsIGNsYXNzPVxcXFxcXFwiZGctYXR0cmlidXRpb25fX2xpbmtzXFxcXFxcXCI+PGxpIGNsYXNzPVxcXFxcXFwiZGctYXR0cmlidXRpb25fX2xpbmstaXRlbVxcXFxcXFwiPlxcXCIpLmV4aXN0cyhjdHguZ2V0KFtcXFwib3NtXFxcIl0sIGZhbHNlKSxjdHgse1xcXCJibG9ja1xcXCI6Ym9keV8xfSxudWxsKS53cml0ZShcXFwiPGEgaHJlZj1cXFxcXFxcIlxcXCIpLnJlZmVyZW5jZShjdHguZ2V0KFtcXFwiY29weXJpZ2h0X2FwaWxpbmtcXFwiXSwgZmFsc2UpLGN0eCxcXFwiaFxcXCIpLndyaXRlKFxcXCJcXFxcXFxcIiB0YXJnZXQ9XFxcXFxcXCJfYmxhbmtcXFxcXFxcIiBjbGFzcz1cXFxcXFxcImRnLWF0dHJpYnV0aW9uX19saW5rXFxcXFxcXCI+XFxcIikubm90ZXhpc3RzKGN0eC5nZXQoW1xcXCJvc21cXFwiXSwgZmFsc2UpLGN0eCx7XFxcImJsb2NrXFxcIjpib2R5XzJ9LG51bGwpLnJlZmVyZW5jZShjdHguZ2V0KFtcXFwiQVBJXzJHSVNcXFwiXSwgZmFsc2UpLGN0eCxcXFwiaFxcXCIpLndyaXRlKFxcXCI8L2E+PC9saT48bGkgY2xhc3M9XFxcXFxcXCJkZy1hdHRyaWJ1dGlvbl9fbGluay1pdGVtXFxcXFxcXCI+PGEgaHJlZj1cXFxcXFxcIlxcXCIpLnJlZmVyZW5jZShjdHguZ2V0KFtcXFwiY29weXJpZ2h0X2xpY2Vuc2VcXFwiXSwgZmFsc2UpLGN0eCxcXFwiaFxcXCIpLndyaXRlKFxcXCJcXFxcXFxcIiB0YXJnZXQ9XFxcXFxcXCJfYmxhbmtcXFxcXFxcIiBjbGFzcz1cXFxcXFxcImRnLWF0dHJpYnV0aW9uX19saW5rXFxcXFxcXCI+XFxcIikucmVmZXJlbmNlKGN0eC5nZXQoW1xcXCJsaWNlbnNlX2FncmVlbWVudFxcXCJdLCBmYWxzZSksY3R4LFxcXCJoXFxcIikud3JpdGUoXFxcIjwvYT48L2xpPjwvdWw+PGEgaHJlZj1cXFxcXFxcIlxcXCIpLnJlZmVyZW5jZShjdHguZ2V0KFtcXFwiY29weXJpZ2h0X2xvZ29cXFwiXSwgZmFsc2UpLGN0eCxcXFwiaFxcXCIpLndyaXRlKFxcXCJcXFxcXFxcIiB0YXJnZXQ9XFxcXFxcXCJfYmxhbmtcXFxcXFxcIiBjbGFzcz1cXFxcXFxcImRnLWF0dHJpYnV0aW9uX19sb2dvLXVybFxcXFxcXFwiPjwvYT48L2Rpdj5cXFwiKTt9ZnVuY3Rpb24gYm9keV8xKGNoayxjdHgpe3JldHVybiBjaGsud3JpdGUoXFxcIsKpIDxhIGhyZWY9XFxcXFxcXCJodHRwOi8vd3d3Lm9wZW5zdHJlZXRtYXAub3JnL2NvcHlyaWdodFxcXFxcXFwiIHRhcmdldD1cXFxcXFxcIl9ibGFua1xcXFxcXFwiIGNsYXNzPVxcXFxcXFwiZGctYXR0cmlidXRpb25fX2xpbmtcXFxcXFxcIj5PcGVuU3RyZWV0TWFwIGNvbnRyaWJ1dG9yczwvYT4sIFxcXCIpO31mdW5jdGlvbiBib2R5XzIoY2hrLGN0eCl7cmV0dXJuIGNoay5yZWZlcmVuY2UoY3R4LmdldChbXFxcIndvcmtfb25cXFwiXSwgZmFsc2UpLGN0eCxcXFwiaFxcXCIpLndyaXRlKFxcXCIgXFxcIik7fXJldHVybiBib2R5XzA7fSkoKTtcIn0pLFxuICAgIF9nZXREYXRhOiBmdW5jdGlvbiAobGFuZykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ29zbSc6IHRoaXMuX29zbSxcbiAgICAgICAgICAgICd3b3JrX29uJzogdGhpcy50KCd3b3JrX29uJyksXG4gICAgICAgICAgICAnbGFuZyc6IGxhbmcgfHwgdGhpcy5fbWFwLmdldExhbmcoKSxcbiAgICAgICAgICAgICdjb3B5cmlnaHRfYXBpbGluayc6IHRoaXMuX2dldExpbmsoJ2NvcHlyaWdodF9hcGlsaW5rJyksXG4gICAgICAgICAgICAnY29weXJpZ2h0X2xpY2Vuc2UnOiB0aGlzLl9nZXRMaW5rKCdjb3B5cmlnaHRfbGljZW5zZScpLFxuICAgICAgICAgICAgJ2NvcHlyaWdodF9sb2dvJzogdGhpcy5fZ2V0TGluaygnY29weXJpZ2h0X2xvZ28nKSxcbiAgICAgICAgICAgICdsaWNlbnNlX2FncmVlbWVudCc6IHRoaXMudCgnbGljZW5zZV9hZ3JlZW1lbnQnKSxcbiAgICAgICAgICAgICdBUElfMkdJUyc6IHRoaXMudCgnQVBJXzJHSVMnKVxuICAgICAgICB9O1xuICAgIH0sXG4gICAgX2dldEF0dHJpYnV0aW9uSFRNTDogZnVuY3Rpb24gKGxhbmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RtcGwoJ2NvcHlyaWdodCcsIHRoaXMuX2dldERhdGEobGFuZykpO1xuICAgIH0sXG4gICAgX3JlbmRlclRyYW5zbGF0aW9uOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICB0aGlzLl91cGRhdGUoZS5sYW5nKTtcbiAgICB9XG59KTtcblxuREcuTWFwLmFkZEluaXRIb29rKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuX2NvcHlyaWdodCkge1xuICAgICAgICBERy5jb250cm9sLmF0dHJpYnV0aW9uKCkuYWRkVG8odGhpcyk7XG4gICAgfVxufSk7XG4iLCJERy5Db250cm9sLkF0dHJpYnV0aW9uLkRpY3Rpb25hcnkucnUgPSB7XG4gICAgbGljZW5zZV9hZ3JlZW1lbnQ6ICfQm9C40YbQtdC90LfQuNC+0L3QvdC+0LUg0YHQvtCz0LvQsNGI0LXQvdC40LUnLFxuICAgIHdvcmtfb246ICfQoNCw0LHQvtGC0LDQtdGCINC90LAnLFxuICAgIEFQSV8yR0lTOiAnQVBJIDLQk9CY0KEnXG59O1xuIiwiREcuQ29udHJvbC5BdHRyaWJ1dGlvbi5EaWN0aW9uYXJ5Lml0ID0ge1xuXHRsaWNlbnNlX2FncmVlbWVudCA6ICdBY2NvcmRvIGRpIGxpY2VuemEnLFxuICAgIHdvcmtfb246ICcgJyxcblx0QVBJXzJHSVM6ICcyR0lTIEFQSSdcbn07XG4iLCJERy5Db250cm9sLkF0dHJpYnV0aW9uLkRpY3Rpb25hcnkuY3MgPSB7XG5cdGxpY2Vuc2VfYWdyZWVtZW50OiAnTGljZW7EjW7DrSBzbWxvdXZhJyxcblx0d29ya19vbjogJ1ByYWN1amUgbmEnLFxuICAgIEFQSV8yR0lTOiAnQVBJIDJHSVMnXG59O1xuIiwiREcuQ29udHJvbC5BdHRyaWJ1dGlvbi5EaWN0aW9uYXJ5LmVuID0ge1xuICAgIGxpY2Vuc2VfYWdyZWVtZW50OiAnTGljZW5zZSBhZ3JlZW1lbnQnLFxuICAgIHdvcmtfb246ICdVc2VzJyxcbiAgICBBUElfMkdJUzogJzJHSVMgQVBJJ1xufTtcbiIsIkRHLkNvbnRyb2wuQXR0cmlidXRpb24uRGljdGlvbmFyeS5lcyA9IHtcblx0bGljZW5zZV9hZ3JlZW1lbnQgOiAnQWN1ZXJkbyBkZSBsaWNlbmNpYScsXG4gICAgd29ya19vbjogJyAnLFxuXHRBUElfMkdJUzogJzJHSVMgQVBJJ1xufTtcbiIsIkRHLkNvbnRyb2wuTG9jYXRpb24gPSBERy5Sb3VuZENvbnRyb2wuZXh0ZW5kKHtcblxuICAgIHN0YXRpY3M6IHtcbiAgICAgICAgRGljdGlvbmFyeToge31cbiAgICB9LFxuXG4gICAgb3B0aW9uczoge1xuICAgICAgICBpY29uQ2xhc3M6ICdsb2NhdGUnLFxuICAgICAgICBwb3NpdGlvbjogREcuQnJvd3Nlci50b3VjaCA/ICdib3R0b21yaWdodCcgOiAndG9wbGVmdCcsXG4gICAgICAgIGRyYXdDaXJjbGU6IHRydWUsXG4gICAgICAgIGZvbGxvdzogdHJ1ZSwgIC8vIGZvbGxvdyB3aXRoIHpvb20gYW5kIHBhbiB0aGUgdXNlcidzIGxvY2F0aW9uXG4gICAgICAgIHN0b3BGb2xsb3dpbmdPbkRyYWc6IGZhbHNlLCAvLyBpZiBmb2xsb3cgaXMgdHJ1ZSwgc3RvcCBmb2xsb3dpbmcgd2hlbiBtYXAgaXMgZHJhZ2dlZFxuICAgICAgICBtZXRyaWM6IHRydWUsXG4gICAgICAgIG9uTG9jYXRpb25FcnJvcjogZnVuY3Rpb24gKC8qZXJyKi8pIHtcbiAgICAgICAgICAgIC8vIHRoaXMgZXZlbnQgaXMgY2FsbGVkIGluIGNhc2Ugb2YgYW55IGxvY2F0aW9uIGVycm9yXG4gICAgICAgICAgICAvLyB0aGF0IGlzIG5vdCBhIHRpbWUgb3V0IGVycm9yLlxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coZXJyLm1lc3NhZ2UpO1xuICAgICAgICB9LFxuICAgICAgICBvbkxvY2F0aW9uT3V0c2lkZU1hcEJvdW5kczogZnVuY3Rpb24gKC8qY29udGV4dCovKSB7XG4gICAgICAgICAgICAvLyB0aGlzIGV2ZW50IGlzIHJlcGVhdGVkbHkgY2FsbGVkIHdoZW4gdGhlIGxvY2F0aW9uIGNoYW5nZXNcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGNvbnRleHQudCgnb3V0c2lkZU1hcEJvdW5kc01zZycpKTtcbiAgICAgICAgfSxcbiAgICAgICAgbG9jYXRlT3B0aW9uczoge31cbiAgICB9LFxuXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgREcuVXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuXG4gICAgICAgIGlmICghbmF2aWdhdG9yLmdlb2xvY2F0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLl9kaXNhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2V2ZW50ID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIHRoaXMuX2xvY2F0ZU9wdGlvbnMgPSB7XG4gICAgICAgICAgICB3YXRjaDogdHJ1ZSwgIC8vIGlmIHlvdSBvdmVyd3JpdGUgdGhpcywgdmlzdWFsaXphdGlvbiBjYW5ub3QgYmUgdXBkYXRlZFxuICAgICAgICAgICAgc2V0VmlldzogZmFsc2UsXG4gICAgICAgICAgICBtYXhpbXVtQWdlOiBJbmZpbml0eVxuICAgICAgICB9O1xuICAgICAgICBERy5leHRlbmQodGhpcy5fbG9jYXRlT3B0aW9ucywgdGhpcy5vcHRpb25zLmxvY2F0ZU9wdGlvbnMpO1xuXG4gICAgICAgIHRoaXMuX3Jlc2V0VmFyaWFibGVzKCk7XG5cbiAgICAgICAgdGhpcy5vbih7XG4gICAgICAgICAgICAnY2xpY2snOiB0aGlzLl9oYW5kbGVMb2NhdGUsXG4gICAgICAgICAgICAnYWRkJzogdGhpcy5faW5pdExvY2F0ZVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgX2luaXRMb2NhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fbGF5ZXIgPSBuZXcgREcuTGF5ZXJHcm91cCgpO1xuICAgICAgICB0aGlzLl9sYXllci5hZGRUbyh0aGlzLl9tYXApO1xuXG4gICAgICAgIC8vIGV2ZW50IGhvb2tzXG4gICAgICAgIHRoaXMuX21hcC5vbih7XG4gICAgICAgICAgICAnbG9jYXRpb25mb3VuZCc6IHRoaXMuX29uTG9jYXRpb25Gb3VuZCxcbiAgICAgICAgICAgICdsb2NhdGlvbmVycm9yJzogdGhpcy5fb25Mb2NhdGlvbkVycm9yXG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH0sXG5cbiAgICBfaGFuZGxlTG9jYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9hY3RpdmUgJiYgKCF0aGlzLl9ldmVudCB8fFxuICAgICAgICAgICAgKHRoaXMuX21hcC5nZXRCb3VuZHMoKS5jb250YWlucyh0aGlzLl9ldmVudC5sYXRsbmcpIHx8XG4gICAgICAgICAgICB0aGlzLl9pc091dHNpZGVNYXBCb3VuZHMoKSkpKSB7XG4gICAgICAgICAgICB0aGlzLl9zdG9wTG9jYXRlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9sb2NhdGVPbk5leHRMb2NhdGlvbkZvdW5kID0gdHJ1ZTtcblxuICAgICAgICAgICAgaWYgKCF0aGlzLl9hY3RpdmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXAubG9jYXRlKHRoaXMuX2xvY2F0ZU9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9hY3RpdmUgPSB0cnVlO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmZvbGxvdykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0Rm9sbG93aW5nKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX2NsZWFyRXJyb3IoKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX2V2ZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdmlzdWFsaXplTG9jYXRpb24oKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSgncmVxdWVzdGluZycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9vbkxvY2F0aW9uRm91bmQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIC8vIG5vIG5lZWQgdG8gZG8gYW55dGhpbmcgaWYgdGhlIGxvY2F0aW9uIGhhcyBub3QgY2hhbmdlZFxuICAgICAgICBpZiAodGhpcy5fZXZlbnQgJiZcbiAgICAgICAgICAgICh0aGlzLl9ldmVudC5sYXRsbmcubGF0ID09PSBlLmxhdGxuZy5sYXQgJiZcbiAgICAgICAgICAgICB0aGlzLl9ldmVudC5sYXRsbmcubG5nID09PSBlLmxhdGxuZy5sbmcgJiZcbiAgICAgICAgICAgICB0aGlzLl9ldmVudC5hY2N1cmFjeSA9PT0gZS5hY2N1cmFjeSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5fYWN0aXZlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9ldmVudCA9IGU7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5mb2xsb3cgJiYgdGhpcy5fZm9sbG93aW5nKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2NhdGVPbk5leHRMb2NhdGlvbkZvdW5kID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3Zpc3VhbGl6ZUxvY2F0aW9uKCk7XG4gICAgfSxcblxuICAgIF9zdGFydEZvbGxvd2luZzogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9mb2xsb3dpbmcgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnN0b3BGb2xsb3dpbmdPbkRyYWcpIHtcbiAgICAgICAgICAgIHRoaXMuX21hcC5vbignZHJhZ3N0YXJ0JywgdGhpcy5fc3RvcEZvbGxvd2luZyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX3N0b3BGb2xsb3dpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fZm9sbG93aW5nID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3RvcEZvbGxvd2luZ09uRHJhZykge1xuICAgICAgICAgICAgdGhpcy5fbWFwLm9mZignZHJhZ3N0YXJ0JywgdGhpcy5fc3RvcEZvbGxvd2luZyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdmlzdWFsaXplTG9jYXRpb24oKTtcbiAgICB9LFxuXG4gICAgX2lzT3V0c2lkZU1hcEJvdW5kczogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fZXZlbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXAub3B0aW9ucy5tYXhCb3VuZHMgJiZcbiAgICAgICAgICAgICF0aGlzLl9tYXAub3B0aW9ucy5tYXhCb3VuZHMuY29udGFpbnModGhpcy5fZXZlbnQubGF0bG5nKTtcbiAgICB9LFxuXG4gICAgX3Zpc3VhbGl6ZUxvY2F0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9ldmVudC5hY2N1cmFjeSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl9ldmVudC5hY2N1cmFjeSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmFkaXVzID0gdGhpcy5fZXZlbnQuYWNjdXJhY3k7XG5cbiAgICAgICAgaWYgKHRoaXMuX2xvY2F0ZU9uTmV4dExvY2F0aW9uRm91bmQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc091dHNpZGVNYXBCb3VuZHMoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5vbkxvY2F0aW9uT3V0c2lkZU1hcEJvdW5kcyh0aGlzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLyogZ2xvYmFsIDEzOmZhbHNlKi9cbiAgICAgICAgICAgICAgICB2YXIgem9vbSA9IHRoaXMuX21hcC5wcm9qZWN0RGV0ZWN0b3IuZ2V0UHJvamVjdCgpLm1heFpvb20gfHwgMTM7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWFwLnNldFZpZXcodGhpcy5fZXZlbnQubGF0bG5nLCB6b29tKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2xvY2F0ZU9uTmV4dExvY2F0aW9uRm91bmQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNpcmNsZSB3aXRoIHRoZSByYWRpdXMgb2YgdGhlIGxvY2F0aW9uJ3MgYWNjdXJhY3lcbiAgICAgICAgdmFyIHN0eWxlID0ge1xuICAgICAgICAgICAgY2xpY2thYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGNvbG9yOiAnI0ZGRicsXG4gICAgICAgICAgICBmaWxsQ29sb3I6ICcjRkZGJyxcbiAgICAgICAgICAgIGZpbGxPcGFjaXR5OiAwLjQsXG4gICAgICAgICAgICB3ZWlnaHQ6IDAsXG4gICAgICAgICAgICBvcGFjaXR5OiAwLjNcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5kcmF3Q2lyY2xlKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2NpcmNsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NpcmNsZSA9IERHLmNpcmNsZSh0aGlzLl9ldmVudC5sYXRsbmcsIHJhZGl1cywgc3R5bGUpXG4gICAgICAgICAgICAgICAgICAgIC5hZGRUbyh0aGlzLl9sYXllcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NpcmNsZS5zZXRMYXRMbmcodGhpcy5fZXZlbnQubGF0bG5nKS5zZXRSYWRpdXMocmFkaXVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtYXJrZXJDbGFzcyA9ICdkZy1sb2NhdGlvbl9fcGluJztcblxuICAgICAgICBtYXJrZXJDbGFzcyArPSB0aGlzLl9mb2xsb3dpbmcgPyAoJyAnICsgbWFya2VyQ2xhc3MgKyAnc3RhdGVfZm9sbG93aW5nJykgOiAnJztcbiAgICAgICAgLy8gc21hbGwgaW5uZXIgbWFya2VyXG4gICAgICAgIHZhciBtID0ge1xuICAgICAgICAgICAgaWNvbjogREcuZGl2SWNvbih7XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBtYXJrZXJDbGFzcyxcbiAgICAgICAgICAgICAgICBpY29uU2l6ZTogWzIwLCAyMF1cbiAgICAgICAgICAgIH0pXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKCF0aGlzLl9tYXJrZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX21hcmtlciA9IERHLm1hcmtlcih0aGlzLl9ldmVudC5sYXRsbmcsIG0pXG4gICAgICAgICAgICAgICAgLmJpbmRMYWJlbCh0aGlzLnQoJ3lvdV9hcmVfaGVyZScpKVxuICAgICAgICAgICAgICAgIC5hZGRUbyh0aGlzLl9sYXllcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9tYXJrZXIuc2V0TGF0TG5nKHRoaXMuX2V2ZW50LmxhdGxuZyk7XG4gICAgICAgIH1cblxuICAgICAgICBERy5Eb21FdmVudC5vbih0aGlzLl9tYXJrZXIsICdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX21hcC5maXJlRXZlbnQoJ2RnTG9jYXRlQ2xpY2snKTtcbiAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9jb250YWluZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2V0U3RhdGUoJ2FjdGl2ZScpO1xuICAgIH0sXG5cbiAgICBfcmVzZXRWYXJpYWJsZXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2ZvbGxvd2luZyA9IGZhbHNlO1xuICAgIH0sXG5cblxuICAgIF9zdG9wTG9jYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX21hcC5zdG9wTG9jYXRlKCk7XG4gICAgICAgIHRoaXMuX21hcC5vZmYoJ2RyYWdzdGFydCcsIHRoaXMuX3N0b3BGb2xsb3dpbmcpO1xuXG4gICAgICAgIHRoaXMuc2V0U3RhdGUoKTtcbiAgICAgICAgdGhpcy5fcmVzZXRWYXJpYWJsZXMoKTtcblxuICAgICAgICB0aGlzLl9sYXllci5jbGVhckxheWVycygpO1xuICAgICAgICB0aGlzLl9tYXJrZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX2NpcmNsZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fZXZlbnQgPSB1bmRlZmluZWQ7XG4gICAgfSxcblxuICAgIF9vbkxvY2F0aW9uRXJyb3I6IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgLy8gaWdub3JlIHRpbWUgb3V0IGVycm9yIGlmIHRoZSBsb2NhdGlvbiBpcyB3YXRjaGVkXG4gICAgICAgIGlmIChlcnIuY29kZSA9PT0gMyAmJiB0aGlzLl9sb2NhdGVPcHRpb25zLndhdGNoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9zdG9wTG9jYXRlKCk7XG4gICAgICAgIHRoaXMuX2Vycm9yID0gREcuRG9tVXRpbC5jcmVhdGUoJ2RpdicsICdkZy1sYWJlbCBkZy1sYWJlbF9uYW1lX2xvY2F0aW9uLWVycm9yJywgdGhpcy5fY29udGFpbmVyKTtcbiAgICAgICAgdGhpcy5fZXJyb3JUZXh0ID0gREcuRG9tVXRpbC5jcmVhdGUoJ2RpdicsICdkZy1sYWJlbF9fY29udGVudCcsIHRoaXMuX2Vycm9yKTtcbiAgICAgICAgdGhpcy5fZXJyb3JUZXh0LmlubmVySFRNTCA9IHRoaXMudCgnY2FudF9maW5kJyk7XG5cbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHNlbGYuX2NsZWFyRXJyb3IoKTtcbiAgICAgICAgfSwgMzAwMCk7XG5cbiAgICAgICAgLy9zaG93IGxvY2F0aW9uIGVycm9yXG4gICAgICAgIHRoaXMub3B0aW9ucy5vbkxvY2F0aW9uRXJyb3IoZXJyKTtcbiAgICB9LFxuXG4gICAgX2NsZWFyRXJyb3I6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2Vycm9yKSB7XG4gICAgICAgICAgICB0aGlzLl9jb250YWluZXIucmVtb3ZlQ2hpbGQodGhpcy5fZXJyb3IpO1xuICAgICAgICAgICAgdGhpcy5fZXJyb3IgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLl9lcnJvclRleHQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX3JlbmRlclRyYW5zbGF0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9saW5rKSB7XG4gICAgICAgICAgICB0aGlzLl9saW5rLnRpdGxlID0gdGhpcy50KCdidXR0b25fdGl0bGUnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fbWFya2VyKSB7XG4gICAgICAgICAgICB0aGlzLl9tYXJrZXIuYmluZExhYmVsKHRoaXMudCgneW91X2FyZV9oZXJlJykpO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbkRHLmNvbnRyb2wubG9jYXRpb24gPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgREcuQ29udHJvbC5Mb2NhdGlvbihvcHRpb25zKTtcbn07XG5cbkRHLk1hcC5hZGRJbml0SG9vayhmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5sb2NhdGlvbkNvbnRyb2wpIHtcbiAgICAgICAgdGhpcy5sb2NhdGlvbkNvbnRyb2wgPSBERy5jb250cm9sLmxvY2F0aW9uKHRoaXMub3B0aW9ucy5sb2NhdGlvbkNvbnRyb2wpO1xuICAgICAgICB0aGlzLmFkZENvbnRyb2wodGhpcy5sb2NhdGlvbkNvbnRyb2wpO1xuICAgIH1cbn0pO1xuIiwiREcuQ29udHJvbC5Mb2NhdGlvbi5EaWN0aW9uYXJ5LnJ1ID0ge1xuXHQgY2FudF9maW5kIDogJ9Cc0Ysg0L3QtSDRgdC80L7Qs9C70Lgg0JLQsNGBINC90LDQudGC0LgnLFxuXHQgeW91X2FyZV9oZXJlIDogJ9CS0Ysg0LfQtNC10YHRjCcsXG5cdCBidXR0b25fdGl0bGUgOiAn0J3QsNC50YLQuCDQktCw0YEg0L3QsCDQutCw0YDRgtC1J1xufTsiLCJERy5Db250cm9sLkxvY2F0aW9uLkRpY3Rpb25hcnkuaXQgPSB7XG5cdCBjYW50X2ZpbmQgOiAnTm9uIHNpYW1vIHJpdXNjaXRpIGEgbG9jYWxpenphcnRpJyxcblx0IHlvdV9hcmVfaGVyZSA6ICdWb2kgc2lldGUgcXVpJyxcblx0IGJ1dHRvbl90aXRsZSA6ICdUcm92YSBsYSB0dWEgcG9zaXppb25lIHN1bGxhIG1hcHBhJ1xufTsiLCJERy5Db250cm9sLkxvY2F0aW9uLkRpY3Rpb25hcnkuY3MgPSB7XG5cdCBjYW50X2ZpbmQgOiAnTmVwb2RhxZlpbG8gc2UgbsOhbSB1csSNaXQgVmHFoWkgcG9sb2h1Jyxcblx0IHlvdV9hcmVfaGVyZSA6ICdKc3RlIHRhZHknLFxuXHQgYnV0dG9uX3RpdGxlIDogJ1VyxI1pdCBWYcWhaSBwb2xvaHUgbmEgbWFwxJsnXG59OyIsIkRHLkNvbnRyb2wuTG9jYXRpb24uRGljdGlvbmFyeS5lbiA9IHtcblx0IGNhbnRfZmluZCA6ICdXZSBjYW5cXCd0IGZpbmQgeW91Jyxcblx0IHlvdV9hcmVfaGVyZSA6ICdZb3UgYXJlIGhlcmUnLFxuXHQgYnV0dG9uX3RpdGxlIDogJ1Nob3cgeW91ciBsb2NhdGlvbidcbn07IiwiREcuQ29udHJvbC5Mb2NhdGlvbi5EaWN0aW9uYXJ5LmVzID0ge1xuXHQgY2FudF9maW5kIDogJ05vIHB1ZGltb3MgZW5jb250cmFydGUnLFxuXHQgeW91X2FyZV9oZXJlIDogJ1TDuiBlc3TDoXMgYXF1w60nLFxuXHQgYnV0dG9uX3RpdGxlIDogJ0VuY29udHJhcnRlIGVuIGVsIG1hcGEnXG59OyIsIi8vIEluc3BpcmVkIGJ5IFNpbmRyZSBTb3JodXMgc2NyZWVuZnVsbFxuLypnbG9iYWwgRWxlbWVudCAqL1xuREcuU2NyZWVuZnVsbCA9IERHLkNsYXNzLmV4dGVuZCh7XG4gICAgX2FwaU1hcDogW1xuICAgICAgICBbXG4gICAgICAgICAgICAncmVxdWVzdEZ1bGxzY3JlZW4nLFxuICAgICAgICAgICAgJ2V4aXRGdWxsc2NyZWVuJyxcbiAgICAgICAgICAgICdmdWxsc2NyZWVuRWxlbWVudCcsXG4gICAgICAgICAgICAnZnVsbHNjcmVlbkVuYWJsZWQnLFxuICAgICAgICAgICAgJ2Z1bGxzY3JlZW5jaGFuZ2UnLFxuICAgICAgICAgICAgJ2Z1bGxzY3JlZW5lcnJvcidcbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgICAgJ3dlYmtpdFJlcXVlc3RGdWxsc2NyZWVuJyxcbiAgICAgICAgICAgICd3ZWJraXRFeGl0RnVsbHNjcmVlbicsXG4gICAgICAgICAgICAnd2Via2l0RnVsbHNjcmVlbkVsZW1lbnQnLFxuICAgICAgICAgICAgJ3dlYmtpdEZ1bGxzY3JlZW5FbmFibGVkJyxcbiAgICAgICAgICAgICd3ZWJraXRmdWxsc2NyZWVuY2hhbmdlJyxcbiAgICAgICAgICAgICd3ZWJraXRmdWxsc2NyZWVuZXJyb3InXG5cbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgICAgJ21velJlcXVlc3RGdWxsU2NyZWVuJyxcbiAgICAgICAgICAgICdtb3pDYW5jZWxGdWxsU2NyZWVuJyxcbiAgICAgICAgICAgICdtb3pGdWxsU2NyZWVuRWxlbWVudCcsXG4gICAgICAgICAgICAnbW96RnVsbFNjcmVlbkVuYWJsZWQnLFxuICAgICAgICAgICAgJ21vemZ1bGxzY3JlZW5jaGFuZ2UnLFxuICAgICAgICAgICAgJ21vemZ1bGxzY3JlZW5lcnJvcidcbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgICAgJ21zUmVxdWVzdEZ1bGxzY3JlZW4nLFxuICAgICAgICAgICAgJ21zRXhpdEZ1bGxzY3JlZW4nLFxuICAgICAgICAgICAgJ21zRnVsbHNjcmVlbkVsZW1lbnQnLFxuICAgICAgICAgICAgJ21zRnVsbHNjcmVlbkVuYWJsZWQnLFxuICAgICAgICAgICAgJ01TRnVsbHNjcmVlbkNoYW5nZScsXG4gICAgICAgICAgICAnTVNGdWxsc2NyZWVuRXJyb3InXG4gICAgICAgIF1cbiAgICBdLFxuXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmFwaSA9IHRoaXMuX2FwaSgpO1xuICAgIH0sXG5cbiAgICByZXF1ZXN0OiBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICB2YXIgcmVxdWVzdCA9IHRoaXMuYXBpLnJlcXVlc3RGdWxsc2NyZWVuO1xuXG4gICAgICAgIGVsZW0gPSBlbGVtIHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgZWxlbVtyZXF1ZXN0XShFbGVtZW50LkFMTE9XX0tFWUJPQVJEX0lOUFVUKTtcbiAgICB9LFxuXG4gICAgZXhpdDogZnVuY3Rpb24gKCkge1xuICAgICAgICBkb2N1bWVudFt0aGlzLmFwaS5leGl0RnVsbHNjcmVlbl0oKTtcbiAgICB9LFxuXG4gICAgaXNGdWxsc2NyZWVuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAhIWRvY3VtZW50W3RoaXMuYXBpLmZ1bGxzY3JlZW5FbGVtZW50XTtcbiAgICB9LFxuXG4gICAgaXNBdmFpbGFibGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4odGhpcy5hcGkpO1xuICAgIH0sXG5cbiAgICBfYXBpOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcGkgPSB7fSxcbiAgICAgICAgICAgIGFwaU1hcCA9IHRoaXMuX2FwaU1hcDtcblxuICAgICAgICBhcGlNYXAuZm9yRWFjaChmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICBpZiAodmFsICYmIHZhbFsxXSBpbiBkb2N1bWVudCkge1xuICAgICAgICAgICAgICAgIHZhbC5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgYXBpW2FwaU1hcFswXVtpXV0gPSBtZXRob2Q7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBhcGkucmVxdWVzdEZ1bGxzY3JlZW4gPyBhcGkgOiBmYWxzZTtcbiAgICB9XG59KTtcblxuREcuc2NyZWVuZnVsbCA9IG5ldyBERy5TY3JlZW5mdWxsKCk7XG4iLCJERy5Db250cm9sLkZ1bGxzY3JlZW4gPSBERy5Sb3VuZENvbnRyb2wuZXh0ZW5kKHtcblxuICAgIHN0YXRpY3M6IHtcbiAgICAgICAgRGljdGlvbmFyeToge31cbiAgICB9LFxuXG4gICAgb3B0aW9uczoge1xuICAgICAgICBwb3NpdGlvbjogJ3RvcHJpZ2h0JyxcbiAgICAgICAgaWNvbkNsYXNzOiAnZnVsbHNjcmVlbidcbiAgICB9LFxuXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgREcuVXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLl9pc0Z1bGxzY3JlZW4gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vbignY2xpY2snLCB0aGlzLl90b2dnbGVGdWxsc2NyZWVuKTtcbiAgICB9LFxuXG4gICAgX3RvZ2dsZUZ1bGxzY3JlZW46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9pc0Z1bGxzY3JlZW4pIHtcbiAgICAgICAgICAgIHRoaXMuX3RvZ2dsZSh0cnVlLCAncmVxdWVzdCcsICdvbicsICdyZXF1ZXN0ZnVsbHNjcmVlbicpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fdG9nZ2xlKGZhbHNlLCAnZXhpdCcsICdvbicsICdjYW5jZWxmdWxsc2NyZWVuJyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9yZW5kZXJUcmFuc2xhdGlvbigpO1xuICAgICAgICB0aGlzLl9tYXAuaW52YWxpZGF0ZVNpemUoKTtcbiAgICB9LFxuXG4gICAgX3JlbmRlclRyYW5zbGF0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2xpbmsudGl0bGUgPSB0aGlzLnQodGhpcy5faXNGdWxsc2NyZWVuID8gJ3RpdGxlX21pbicgOiAndGl0bGVfbWF4Jyk7XG4gICAgfSxcblxuICAgIF90b2dnbGU6IGZ1bmN0aW9uIChpc0VuYWJsZWQsIG1ldGhvZCwgbGlzdCwgZXZlbnQpIHtcbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IHRoaXMuX21hcC5fY29udGFpbmVyO1xuXG4gICAgICAgIHRoaXMuX2lzRnVsbHNjcmVlbiA9IGlzRW5hYmxlZDtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZShpc0VuYWJsZWQgPyAnYWN0aXZlJyA6ICcnKTtcblxuICAgICAgICBERy5zY3JlZW5mdWxsW21ldGhvZF0oY29udGFpbmVyKTtcbiAgICAgICAgREcuRG9tRXZlbnRbbGlzdF0oZG9jdW1lbnQsIERHLnNjcmVlbmZ1bGwuYXBpLmZ1bGxzY3JlZW5jaGFuZ2UsIHRoaXMuX29uRnVsbFNjcmVlblN0YXRlQ2hhbmdlLCB0aGlzKTtcbiAgICAgICAgdGhpcy5fbWFwLmZpcmUoZXZlbnQpO1xuICAgIH0sXG5cbiAgICBfb25GdWxsU2NyZWVuU3RhdGVDaGFuZ2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFERy5zY3JlZW5mdWxsLmlzRnVsbHNjcmVlbigpKSB7XG4gICAgICAgICAgICB0aGlzLl90b2dnbGUoZmFsc2UsICdleGl0JywgJ29uJywgJ2NhbmNlbGZ1bGxzY3JlZW4nKTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5ERy5jb250cm9sLmZ1bGxzY3JlZW4gPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgREcuQ29udHJvbC5GdWxsc2NyZWVuKG9wdGlvbnMpO1xufTtcblxuREcuTWFwLm1lcmdlT3B0aW9ucyh7XG4gICAgZnVsbHNjcmVlbkNvbnRyb2w6IHRydWVcbn0pO1xuXG5ERy5NYXAuYWRkSW5pdEhvb2soZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZnVsbHNjcmVlbkNvbnRyb2wpIHtcbiAgICAgICAgdGhpcy5mdWxsc2NyZWVuQ29udHJvbCA9IERHLmNvbnRyb2wuZnVsbHNjcmVlbih0aGlzLm9wdGlvbnMuZnVsbHNjcmVlbkNvbnRyb2wpO1xuXG4gICAgICAgIGlmIChERy5zY3JlZW5mdWxsLmlzQXZhaWxhYmxlKCkpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkQ29udHJvbCh0aGlzLmZ1bGxzY3JlZW5Db250cm9sKTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuIiwiREcuQ29udHJvbC5GdWxsc2NyZWVuLkRpY3Rpb25hcnkucnUgPSB7XG4gICAgdGl0bGVfbWF4IDogJ9Cg0LDQt9Cy0LXRgNC90YPRgtGMJyxcbiAgICB0aXRsZV9taW4gOiAn0JLQvtGB0YHRgtCw0L3QvtCy0LjRgtGMJ1xufTtcbiIsIkRHLkNvbnRyb2wuRnVsbHNjcmVlbi5EaWN0aW9uYXJ5Lml0ID0ge1xuICAgIHRpdGxlX21heCA6ICdFc3BhbmRpJyxcbiAgICB0aXRsZV9taW4gOiAnUmlwcmlzdGluYSdcbn07XG4iLCJERy5Db250cm9sLkZ1bGxzY3JlZW4uRGljdGlvbmFyeS5jcyA9IHtcbiAgICAgdGl0bGVfbWF4IDogJ1JvemJhbGl0JyxcbiAgICAgdGl0bGVfbWluIDogJ09ibm92aXQnXG59O1xuIiwiREcuQ29udHJvbC5GdWxsc2NyZWVuLkRpY3Rpb25hcnkuZW4gPSB7XG4gICAgdGl0bGVfbWF4IDogJ0V4cGFuZCcsXG4gICAgdGl0bGVfbWluIDogJ1Jlc3RvcmUnXG59O1xuIiwiREcuQ29udHJvbC5GdWxsc2NyZWVuLkRpY3Rpb25hcnkuZXMgPSB7XG4gICAgdGl0bGVfbWF4IDogJ01heGltaXphcicsXG4gICAgdGl0bGVfbWluIDogJ1Jlc3RhdXJhcidcbn07XG4iLCJERy5NZXRhID0ge307XG5cbkRHLk1ldGEuTGF5ZXIgPSBERy5MYXllci5leHRlbmQoe1xuXG4gICAgb3B0aW9uczoge1xuICAgICAgICB0aWxlU2l6ZTogMjU2LFxuXG4gICAgICAgIG1pblpvb206IDAsXG4gICAgICAgIG1heFpvb206IDE5LFxuICAgICAgICB6b29tT2Zmc2V0OiAwLFxuICAgICAgICBldmVudEJ1YmJsaW5nOiAndHJhbnNwYXJlbnQnXG4gICAgICAgIC8vIG1heE5hdGl2ZVpvb206IDxOdW1iZXI+LFxuICAgICAgICAvLyBkZXRlY3RSZXRpbmE6IDxOdW1iZXI+LFxuICAgICAgICAvLyB6b29tUmV2ZXJzZTogPE51bWJlcj5cbiAgICAgICAgLy8gYXR0cmlidXRpb246IDxTdHJpbmc+LFxuICAgICAgICAvLyB6SW5kZXg6IDxOdW1iZXI+LFxuICAgICAgICAvLyBib3VuZHM6IDxMYXRMbmdCb3VuZHM+XG4gICAgfSxcblxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIChzb3VyY2UsIG9wdGlvbnMpIHsgLy8gKFN0cmluZywgT2JqZWN0KVxuICAgICAgICBERy5UaWxlTGF5ZXIucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzLCBudWxsLCBvcHRpb25zKTtcbiAgICAgICAgZGVsZXRlIHRoaXMuX3VybDtcblxuICAgICAgICB0aGlzLl9jdXJyZW50VGlsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9jdXJyZW50VGlsZURhdGEgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faG92ZXJlZE9iamVjdCA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5fb3JpZ2luID0gREcuTWV0YS5vcmlnaW4oc291cmNlLCB7XG4gICAgICAgICAgICBkYXRhRmlsdGVyOiB0aGlzLm9wdGlvbnMuZGF0YUZpbHRlclxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgZ2V0T3JpZ2luOiBmdW5jdGlvbiAoKSB7IC8vICgpIC0+IE9iamVjdFxuICAgICAgICByZXR1cm4gdGhpcy5fb3JpZ2luO1xuICAgIH0sXG5cbiAgICBvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xuICAgICAgICB0aGlzLl9yZXNldCgpO1xuICAgICAgICB0aGlzLl9hZGREb21FdmVudHMoKTtcblxuICAgICAgICBtYXAub24oJ3J1bGVyc3RhcnQnLCB0aGlzLl9yZW1vdmVEb21FdmVudHMsIHRoaXMpO1xuICAgICAgICBtYXAub24oJ3J1bGVyZW5kJywgdGhpcy5fYWRkRG9tRXZlbnRzLCB0aGlzKTtcbiAgICB9LFxuXG4gICAgb25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcbiAgICAgICAgdGhpcy5fcmVtb3ZlRG9tRXZlbnRzKCk7XG5cbiAgICAgICAgbWFwLm9mZigncnVsZXJzdGFydCcsIHRoaXMuX3JlbW92ZURvbUV2ZW50cywgdGhpcyk7XG4gICAgICAgIG1hcC5vZmYoJ3J1bGVyZW5kJywgdGhpcy5fYWRkRG9tRXZlbnRzLCB0aGlzKTtcbiAgICB9LFxuXG4gICAgZ2V0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBldmVudHMgPSB7XG4gICAgICAgICAgICB2aWV3cmVzZXQ6IHRoaXMuX3Jlc2V0XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIGV2ZW50cztcbiAgICB9LFxuXG4gICAgX2FkZERvbUV2ZW50czogZnVuY3Rpb24gKCkge1xuICAgICAgICBERy5Eb21FdmVudC5vbih0aGlzLl9tYXAuZ2V0UGFuZSgndGlsZVBhbmUnKSwgdGhpcy5fZG9tRXZlbnRzLCB0aGlzKTtcbiAgICB9LFxuXG4gICAgX3JlbW92ZURvbUV2ZW50czogZnVuY3Rpb24gKCkge1xuICAgICAgICBERy5Eb21FdmVudC5vZmYodGhpcy5fbWFwLmdldFBhbmUoJ3RpbGVQYW5lJyksIHRoaXMuX2RvbUV2ZW50cywgdGhpcyk7XG4gICAgfSxcblxuICAgIF9nZXRab29tRm9yVXJsOiBERy5UaWxlTGF5ZXIucHJvdG90eXBlLl9nZXRab29tRm9yVXJsLFxuICAgIF9nZXRUaWxlU2l6ZTogREcuVGlsZUxheWVyLnByb3RvdHlwZS5fZ2V0VGlsZVNpemUsXG4gICAgX2dldFRpbGVOdW1Cb3VuZHM6IERHLkdyaWRMYXllci5wcm90b3R5cGUuX2dldFRpbGVOdW1Cb3VuZHMsXG4gICAgX2lzVmFsaWRUaWxlOiBERy5HcmlkTGF5ZXIucHJvdG90eXBlLl9pc1ZhbGlkVGlsZSxcbiAgICBfd3JhcENvb3JkczogREcuR3JpZExheWVyLnByb3RvdHlwZS5fd3JhcENvb3JkcyxcbiAgICBfcmVzZXRXcmFwOiBERy5HcmlkTGF5ZXIucHJvdG90eXBlLl9yZXNldFdyYXAsXG5cbiAgICBfZG9tRXZlbnRzOiB7XG4gICAgICAgIG1vdXNlbW92ZTogZnVuY3Rpb24gKGV2ZW50KSB7IC8vIChNb3VzZUV2ZW50KVxuICAgICAgICAgICAgdmFyIHRpbGVTaXplID0gdGhpcy5fZ2V0VGlsZVNpemUoKSxcbiAgICAgICAgICAgICAgICBsYXllclBvaW50ID0gdGhpcy5fbWFwLm1vdXNlRXZlbnRUb0xheWVyUG9pbnQoZXZlbnQpLFxuICAgICAgICAgICAgICAgIHRpbGVPcmlnaW5Qb2ludCA9IHRoaXMuX21hcC5nZXRQaXhlbE9yaWdpbigpLmFkZChsYXllclBvaW50KSxcbiAgICAgICAgICAgICAgICB0aWxlQ29vcmQgPSB0aWxlT3JpZ2luUG9pbnQuZGl2aWRlQnkodGlsZVNpemUpLmZsb29yKCksXG4gICAgICAgICAgICAgICAgbW91c2VUaWxlT2Zmc2V0LFxuICAgICAgICAgICAgICAgIHRpbGVLZXksXG4gICAgICAgICAgICAgICAgaG92ZXJlZE9iamVjdCxcbiAgICAgICAgICAgICAgICB6b29tID0gdGhpcy5fbWFwLmdldFpvb20oKTtcblxuICAgICAgICAgICAgaWYgKHpvb20gPiAodGhpcy5vcHRpb25zLm1heFpvb20gKyB0aGlzLm9wdGlvbnMuem9vbU9mZnNldCkgfHxcbiAgICAgICAgICAgICAgICB6b29tIDwgKHRoaXMub3B0aW9ucy5taW5ab29tIC0gdGhpcy5vcHRpb25zLnpvb21PZmZzZXQpIHx8XG4gICAgICAgICAgICAgICAgIXRoaXMuX2lzVmFsaWRUaWxlKHRpbGVDb29yZCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX3dyYXBDb29yZHModGlsZUNvb3JkKTtcblxuICAgICAgICAgICAgdGlsZUNvb3JkLnogPSB0aGlzLl9nZXRab29tRm9yVXJsKCk7XG4gICAgICAgICAgICB0aWxlQ29vcmQua2V5ID0gdGlsZVNpemU7XG4gICAgICAgICAgICB0aWxlS2V5ID0gdGhpcy5fb3JpZ2luLmdldFRpbGVLZXkodGlsZUNvb3JkKTtcblxuICAgICAgICAgICAgaWYgKHRpbGVLZXkgIT09IHRoaXMuX2N1cnJlbnRUaWxlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudFRpbGUgPSB0aWxlS2V5O1xuICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRUaWxlRGF0YSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5fY3VycmVudFRpbGVEYXRhID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRUaWxlRGF0YSA9IHRoaXMuX29yaWdpbi5nZXRUaWxlRGF0YSh0aWxlQ29vcmQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtb3VzZVRpbGVPZmZzZXQgPSBERy5wb2ludCh0aWxlT3JpZ2luUG9pbnQueCAlIHRpbGVTaXplLCB0aWxlT3JpZ2luUG9pbnQueSAlIHRpbGVTaXplKTtcbiAgICAgICAgICAgICAgICBob3ZlcmVkT2JqZWN0ID0gdGhpcy5fZ2V0SG92ZXJlZE9iamVjdCh0aWxlQ29vcmQsIG1vdXNlVGlsZU9mZnNldCk7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faG92ZXJlZEVudGl0eSAhPT0gaG92ZXJlZE9iamVjdCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9maXJlTW91c2VFdmVudCgnbW91c2VvdXQnLCBldmVudCk7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faG92ZXJlZEVudGl0eSA9IGhvdmVyZWRPYmplY3Q7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2ZpcmVNb3VzZUV2ZW50KCdtb3VzZW92ZXInLCBldmVudCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5fZmlyZU1vdXNlRXZlbnQoJ21vdXNlbW92ZScsIGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbW91c2VvdXQ6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgdGhpcy5fZmlyZU1vdXNlRXZlbnQoJ21vdXNlb3V0JywgZXZlbnQpO1xuICAgICAgICAgICAgdGhpcy5faG92ZXJlZEVudGl0eSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50VGlsZSA9IGZhbHNlO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNsaWNrOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZpcmVNb3VzZUV2ZW50KCdjbGljaycsIGV2ZW50KTtcbiAgICAgICAgfSxcblxuICAgICAgICBkYmxjbGljazogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLl9maXJlTW91c2VFdmVudCgnZGJsY2xpY2snLCBldmVudCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgbW91c2Vkb3duOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZpcmVNb3VzZUV2ZW50KCdtb3VzZWRvd24nLCBldmVudCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY29udGV4dG1lbnU6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgdGhpcy5fZmlyZU1vdXNlRXZlbnQoJ2NvbnRleHRtZW51JywgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9maXJlTW91c2VFdmVudDogZnVuY3Rpb24gKHR5cGUsIG1vdXNlRXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2hvdmVyZWRFbnRpdHkpIHtcbiAgICAgICAgICAgIHRoaXMuZmlyZSh0eXBlLCB7XG4gICAgICAgICAgICAgICAgbWV0YTogdGhpcy5faG92ZXJlZEVudGl0eSxcbiAgICAgICAgICAgICAgICBsYXRsbmc6IHRoaXMuX21hcC5tb3VzZUV2ZW50VG9MYXRMbmcobW91c2VFdmVudClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5ldmVudEJ1YmJsaW5nID09PSAnbGF5ZXInKSB7XG4gICAgICAgICAgICAgICAgREcuRG9tRXZlbnQuc3RvcChtb3VzZUV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfZ2V0SG92ZXJlZE9iamVjdDogZnVuY3Rpb24gKGNvb3JkcywgbW91c2VUaWxlT2Zmc2V0KSB7XG4gICAgICAgIGZvciAodmFyIGkgPSB0aGlzLl9jdXJyZW50VGlsZURhdGEubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGlmIChERy5Qb2x5VXRpbC5jb250YWlucyhtb3VzZVRpbGVPZmZzZXQsIHRoaXMuX2N1cnJlbnRUaWxlRGF0YVtpXS5nZW9tZXRyeS5jb29yZGluYXRlc1swXSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY3VycmVudFRpbGVEYXRhW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuICAgIF9yZXNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl90aWxlTnVtQm91bmRzID0gdGhpcy5fZ2V0VGlsZU51bUJvdW5kcygpO1xuICAgICAgICB0aGlzLl9yZXNldFdyYXAodGhpcy5fdGlsZU51bUJvdW5kcyk7XG4gICAgfVxuXG59KTtcblxuREcuTWV0YS5sYXllciA9IGZ1bmN0aW9uIChzb3VyY2UsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IERHLk1ldGEuTGF5ZXIoc291cmNlLCBvcHRpb25zKTtcbn07XG4iLCJERy5NZXRhLk9yaWdpbiA9IERHLkNsYXNzLmV4dGVuZCh7XG5cbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHN1YmRvbWFpbnM6ICcwMTIzJyxcbiAgICAgICAgZGF0YUZpbHRlcjogbnVsbFxuICAgIH0sXG5cbiAgICBfdXJsOiBmYWxzZSxcblxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uICh1cmwsIG9wdGlvbnMpIHsgLy8gKFN0cmluZywgT2JqZWN0KVxuICAgICAgICB0aGlzLl91cmwgPSB1cmw7XG4gICAgICAgIHRoaXMuX3JlcXVlc3RzID0ge307XG5cbiAgICAgICAgdGhpcy5fdGlsZVN0b3JhZ2UgPSB7fTtcbiAgICAgICAgdGhpcy5fZGF0YVN0b3JhZ2UgPSB7fTtcblxuICAgICAgICBvcHRpb25zID0gREcuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcblxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuc3ViZG9tYWlucyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuc3ViZG9tYWlucyA9IG9wdGlvbnMuc3ViZG9tYWlucy5zcGxpdCgnJyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0VGlsZURhdGE6IGZ1bmN0aW9uIChjb29yZCkgeyAvLyAoT2JqZWN0KSAtPiBPYmplY3RcbiAgICAgICAgdmFyIHRpbGVLZXkgPSB0aGlzLmdldFRpbGVLZXkoY29vcmQpLFxuICAgICAgICAgICAgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLl90aWxlU3RvcmFnZVt0aWxlS2V5XSA9PT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHRoaXMuX3JlcXVlc3RzW3RpbGVLZXldID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhpcy5fdGlsZVN0b3JhZ2VbdGlsZUtleV0gPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX3JlcXVlc3RzW3RpbGVLZXldID0gdGhpcy5fcmVxdWVzdERhdGEoY29vcmQpLnRoZW4oZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnNldFRpbGVEYXRhKHRpbGVLZXksIHNlbGYub3B0aW9ucy5kYXRhRmlsdGVyID8gc2VsZi5vcHRpb25zLmRhdGFGaWx0ZXIoZGF0YSwgY29vcmQpIDogZGF0YSk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHNlbGYuX3JlcXVlc3RzW3RpbGVLZXldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fdGlsZVN0b3JhZ2VbdGlsZUtleV0uY29uc3RydWN0b3IgPT09IE9iamVjdCkge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX3RpbGVTdG9yYWdlW3RpbGVLZXldKS5tYXAoZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIERHLmV4dGVuZCh7Z2VvbWV0cnk6IHRoaXMuX3RpbGVTdG9yYWdlW3RpbGVLZXldW2lkXX0sIHRoaXMuX2RhdGFTdG9yYWdlW2lkXSk7XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl90aWxlU3RvcmFnZVt0aWxlS2V5XTtcbiAgICB9LFxuXG4gICAgc2V0VGlsZURhdGE6IGZ1bmN0aW9uIChrZXksIGRhdGEpIHsgLy8gKE9iamVjdC9TdHJpbmcsIE9iamVjdCkgLT4gT2JqZWN0XG4gICAgICAgIGlmICh0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAga2V5ID0gdGhpcy5nZXRUaWxlS2V5KGtleSk7XG4gICAgICAgIH1cblxuICAgICAgICBkYXRhLmZvckVhY2goZnVuY3Rpb24gKGVudGl0eSkge1xuICAgICAgICAgICAgaWYgKGVudGl0eS5nZW9tZXRyeS5jb25zdHJ1Y3RvciAhPT0gT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgZW50aXR5Lmdlb21ldHJ5ID0gREcuV2t0LnRvR2VvSlNPTihlbnRpdHkuZ2VvbWV0cnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLl90aWxlU3RvcmFnZVtrZXldKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGlsZVN0b3JhZ2Vba2V5XSA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fdGlsZVN0b3JhZ2Vba2V5XVtlbnRpdHkuaWRdID0gZW50aXR5Lmdlb21ldHJ5O1xuICAgICAgICAgICAgZGVsZXRlIGVudGl0eS5nZW9tZXRyeTtcbiAgICAgICAgICAgIHRoaXMuX2RhdGFTdG9yYWdlW2VudGl0eS5pZF0gPSBlbnRpdHk7XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBmbHVzaDogZnVuY3Rpb24gKCkgeyAvLyAoKSAtPiBPYmplY3RcbiAgICAgICAgdGhpcy5fdGlsZVN0b3JhZ2UgPSB7fTtcbiAgICAgICAgdGhpcy5fZGF0YVN0b3JhZ2UgPSB7fTtcbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5fcmVxdWVzdHMpLmZvckVhY2goZnVuY3Rpb24gKHRpbGVLZXkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzW3RpbGVLZXldLmFib3J0KSB7XG4gICAgICAgICAgICAgICAgdGhpc1t0aWxlS2V5XS5hYm9ydCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzLl9yZXF1ZXN0cyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHNldFVSTDogZnVuY3Rpb24gKHVybCwgZmx1c2gpIHsgLy8gKFN0cmluZywgQm9vbGVhbikgLT4gT2JqZWN0XG4gICAgICAgIHRoaXMuX3VybCA9IHVybDtcbiAgICAgICAgaWYgKGZsdXNoKSB7XG4gICAgICAgICAgICB0aGlzLmZsdXNoKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgZ2V0VGlsZUtleTogZnVuY3Rpb24gKGNvb3JkKSB7IC8vIChPYmplY3QpLT4gU3RyaW5nXG4gICAgICAgIHJldHVybiBbY29vcmQueCwgY29vcmQueSwgY29vcmQueiwgY29vcmQua2V5XS5qb2luKCc6Jyk7XG4gICAgfSxcblxuICAgIF9yZXF1ZXN0RGF0YTogZnVuY3Rpb24gKGtleSkgeyAvLyAoU3RyaW5nKVxuICAgICAgICBpZiAodGhpcy5fdXJsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcGVyZm9ybVJlcXVlc3Qoa2V5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoW10pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9wZXJmb3JtUmVxdWVzdDogZnVuY3Rpb24gKGNvb3JkcykgeyAvLyAoT2JqZWN0KSAtPiBQcm9taXNlXG4gICAgICAgIHJldHVybiBERy5hamF4KHRoaXMuX3ByZXBhcmVVUkwoY29vcmRzKSwge1xuICAgICAgICAgICAgdHlwZTogJ2dldCcsXG4gICAgICAgICAgICBkYXRhVHlwZTogJ2pzb24nXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBfcHJlcGFyZVVSTDogZnVuY3Rpb24gKGNvb3JkcykgeyAvLyAoT2JqZWN0KSAtPiBTdHJpbmdcbiAgICAgICAgcmV0dXJuIERHLlV0aWwudGVtcGxhdGUodGhpcy5fdXJsLCB7XG4gICAgICAgICAgICB4OiBjb29yZHMueCxcbiAgICAgICAgICAgIHk6IGNvb3Jkcy55LFxuICAgICAgICAgICAgejogY29vcmRzLnosXG4gICAgICAgICAgICBzOiB0aGlzLl9nZXRTdWJkb21haW4oY29vcmRzKVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgX2dldFN1YmRvbWFpbjogREcuVGlsZUxheWVyLnByb3RvdHlwZS5fZ2V0U3ViZG9tYWluXG5cbn0pO1xuXG5ERy5NZXRhLm9yaWdpbiA9IGZ1bmN0aW9uIChzb3VyY2UsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IERHLk1ldGEuT3JpZ2luKHNvdXJjZSwgb3B0aW9ucyk7XG59O1xuIiwiLy8gcmF5IHRyYWNpbmcgbWV0aG9kOiBodHRwOi8vYWxnb2xpc3QucnUvbWF0aHMvZ2VvbS9iZWxvbmcvcG9seTJkLnBocFxuXG5ERy5Qb2x5VXRpbC5jb250YWlucyA9IGZ1bmN0aW9uIChwb2ludCwgZ2VvbWV0cnkpIHsgLy8gKERHLkxhdExuZywgQXJyYXkpIC0+IEJvb2xlYW5cbiAgICB2YXIgZWRnZXMsIGksIGxlbixcbiAgICAgICAgcGFyaXR5ID0gMCxcbiAgICAgICAgdmVydGljZXMgPSBbXTtcblxuICAgIGZvciAoaSA9IDAsIGxlbiA9IGdlb21ldHJ5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZlcnRpY2VzLnB1c2goREcucG9pbnQoZ2VvbWV0cnlbaV0pKTtcbiAgICB9XG5cbiAgICBlZGdlcyA9IHRoaXMuX2dldEVkZ2VzKHZlcnRpY2VzKTtcbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBlZGdlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBzd2l0Y2ggKHRoaXMuX2dldEVkZ2VUeXBlKGVkZ2VzW2ldLCBwb2ludCkpIHtcbiAgICAgICAgICAgIGNhc2UgJ1RPVUNISU5HJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGNhc2UgJ0NST1NTSU5HJzpcbiAgICAgICAgICAgICAgICBwYXJpdHkgPSAxIC0gcGFyaXR5O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYXJpdHkgPyB0cnVlIDogZmFsc2U7XG59O1xuXG4vLyByZXR1cm5zIGFycmF5IHdpdGggZWRnZSBvYmplY3RzXG5ERy5Qb2x5VXRpbC5fZ2V0RWRnZXMgPSBmdW5jdGlvbiAodmVydGljZXMpIHsgLy8gKEFycmF5KSAtPiBBcnJheVxuICAgIHZhciBlZGdlcyA9IFtdO1xuICAgIHZhciBlZGdlO1xuICAgIHZhciBzdGFydFBvaW50O1xuICAgIHZhciBlbmRQb2ludDtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB2ZXJ0aWNlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBzdGFydFBvaW50ID0gdmVydGljZXNbaV07XG4gICAgICAgIGVuZFBvaW50ID0gKGkgIT09IGxlbiAtIDEpID8gdmVydGljZXNbaSArIDFdIDogdmVydGljZXNbMF07XG4gICAgICAgIGVkZ2UgPSB7XG4gICAgICAgICAgICBzdGFydFBvaW50OiBzdGFydFBvaW50LFxuICAgICAgICAgICAgZW5kUG9pbnQ6IGVuZFBvaW50XG4gICAgICAgIH07XG4gICAgICAgIGVkZ2VzLnB1c2goZWRnZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVkZ2VzO1xufTtcblxuLy8gcmVzdWx0IHNob3VsZCBiZTogJ0NST1NTSU5HJywgJ0lORVNTRU5USUFMJyBvciAnVE9VQ0hJTkcnXG5ERy5Qb2x5VXRpbC5fZ2V0RWRnZVR5cGUgPSBmdW5jdGlvbiAoZWRnZSwgcG9pbnQpIHsgLy8gKE9iamVjdCwgREcuUG9pbnQpIC0+IFN0cmluZ1xuICAgIHZhciBwb2ludFBvc2l0aW9uID0gdGhpcy5fY2xhc3NpZnkoZWRnZSwgcG9pbnQpO1xuICAgIHN3aXRjaCAocG9pbnRQb3NpdGlvbikge1xuICAgICAgICBjYXNlICdMRUZUJzpcbiAgICAgICAgICAgIHJldHVybiAoKGVkZ2Uuc3RhcnRQb2ludC55IDwgcG9pbnQueSkgJiYgKHBvaW50LnkgPD0gZWRnZS5lbmRQb2ludC55KSkgPyAnQ1JPU1NJTkcnIDogJ0lORVNTRU5USUFMJztcbiAgICAgICAgY2FzZSAnUklHSFQnOlxuICAgICAgICAgICAgcmV0dXJuICgoZWRnZS5lbmRQb2ludC55IDwgcG9pbnQueSkgJiYgKHBvaW50LnkgPD0gZWRnZS5zdGFydFBvaW50LnkpKSA/ICdDUk9TU0lORycgOiAnSU5FU1NFTlRJQUwnO1xuICAgICAgICBjYXNlICdCRVRXRUVOJzpcbiAgICAgICAgY2FzZSAnT1JJR0lOJzpcbiAgICAgICAgY2FzZSAnREVTVElOQVRJT04nOlxuICAgICAgICAgICAgcmV0dXJuICdUT1VDSElORyc7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gJ0lORVNTRU5USUFMJztcbiAgICB9XG59O1xuXG4vLyBkZXRlcm1pbmVzIHRoZSBwb3NpdGlvbiBvZiBhIHBvaW50IHJlbGF0aXZlIHRvIHRoZSBlZGdlXG4vLyByZXN1bHQgc2hvdWxkIGJlOiAnTEVGVCcsICdSSUdIVCcsICdCRUhJTkQnLCAnQkVZT05EJywgJ09SSUdJTicsICdERVNUSU5BVElPTicsICdCRVRXRUVOJ1xuREcuUG9seVV0aWwuX2NsYXNzaWZ5ID0gZnVuY3Rpb24gKGVkZ2UsIHBvaW50KSB7IC8vIChPYmplY3QsIERHLlBvaW50KSAtPiBTdHJpbmdcbiAgICB2YXIgYTtcbiAgICB2YXIgYjtcbiAgICB2YXIgc2E7XG5cbiAgICBhID0ge1xuICAgICAgICB4OiBlZGdlLmVuZFBvaW50LnggLSBlZGdlLnN0YXJ0UG9pbnQueCxcbiAgICAgICAgeTogZWRnZS5lbmRQb2ludC55IC0gZWRnZS5zdGFydFBvaW50LnlcbiAgICB9O1xuICAgIGIgPSB7XG4gICAgICAgIHg6IHBvaW50LnggLSBlZGdlLnN0YXJ0UG9pbnQueCxcbiAgICAgICAgeTogcG9pbnQueSAtIGVkZ2Uuc3RhcnRQb2ludC55XG4gICAgfTtcblxuICAgIHNhID0gYS54ICogYi55IC0gYi54ICogYS55O1xuICAgIGlmIChzYSA+IDApIHtcbiAgICAgICAgcmV0dXJuICdMRUZUJztcbiAgICB9XG4gICAgaWYgKHNhIDwgMCkge1xuICAgICAgICByZXR1cm4gJ1JJR0hUJztcbiAgICB9XG4gICAgaWYgKChhLnggKiBiLnggPCAwKSB8fCAoYS55ICogYi55IDwgMCkpIHtcbiAgICAgICAgcmV0dXJuICdCRUhJTkQnO1xuICAgIH1cbiAgICBpZiAodGhpcy5fZ2V0TGVuZ3RoU3F1YXJlZChhKSA8IHRoaXMuX2dldExlbmd0aFNxdWFyZWQoYikpIHtcbiAgICAgICAgcmV0dXJuICdCRVlPTkQnO1xuICAgIH1cbiAgICBpZiAoREcuUG9seVV0aWwuX2FyZUVxdWFscyhlZGdlLnN0YXJ0UG9pbnQsIHBvaW50KSkge1xuICAgICAgICByZXR1cm4gJ09SSUdJTic7XG4gICAgfVxuICAgIGlmIChERy5Qb2x5VXRpbC5fYXJlRXF1YWxzKGVkZ2UuZW5kUG9pbnQsIHBvaW50KSkge1xuICAgICAgICByZXR1cm4gJ0RFU1RJTkFUSU9OJztcbiAgICB9XG4gICAgcmV0dXJuICdCRVRXRUVOJztcbn07XG5cbkRHLlBvbHlVdGlsLl9nZXRMZW5ndGhTcXVhcmVkID0gZnVuY3Rpb24gKHBvaW50KSB7IC8vIChERy5Qb2ludCkgLT4gTnVtYmVyXG4gICAgcmV0dXJuIE1hdGgucG93KHBvaW50LngsIDIpICsgTWF0aC5wb3cocG9pbnQueSwgMik7XG59O1xuXG5ERy5Qb2x5VXRpbC5fYXJlRXF1YWxzID0gZnVuY3Rpb24gKHBvaW50MSwgcG9pbnQyKSB7IC8vIChERy5Qb2ludCwgREcuUG9pbnQpIC0+IEJvb2xlYW5cbiAgICByZXR1cm4gcG9pbnQxLnggPT09IHBvaW50Mi54ICYmIHBvaW50MS55ID09PSBwb2ludDIueTtcbn07XG4iLCIvKiBnbG9iYWwgMTUsdHJ1ZSAqL1xuXG5ERy5NYXAubWVyZ2VPcHRpb25zKHtcbiAgICBwb2k6ICFERy5Ccm93c2VyLnRvdWNoXG59KTtcblxuREcuUG9pID0gREcuSGFuZGxlci5leHRlbmQoe1xuXG4gICAgb3B0aW9uczoge1xuICAgICAgICBkaXNhYmxlTGFiZWw6IGZhbHNlXG4gICAgfSxcblxuICAgIHN0YXRpY3M6IHtcbiAgICAgICAgbWV0YVVSTDogJ2h0dHA6Ly90aWxle3N9Lm1hcHMuMmdpcy5jb20vP3g9e3h9Jnk9e3l9Jno9e3p9JnY9MSZ0eXBlPXBvaSdcbiAgICB9LFxuXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKG1hcCwgb3B0aW9ucykgeyAvLyAoT2JqZWN0KVxuICAgICAgICB0aGlzLl9tYXAgPSBtYXA7XG4gICAgICAgIERHLlV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5fbWV0YUxheWVyID0gREcuTWV0YS5sYXllcihERy5Qb2kubWV0YVVSTCwge1xuICAgICAgICAgICAgbWluWm9vbTogMTUsXG4gICAgICAgICAgICBtYXhOYXRpdmVab29tOiAxOSxcbiAgICAgICAgICAgIGRldGVjdFJldGluYTogdHJ1ZSxcbiAgICAgICAgICAgIGV2ZW50QnViYmxpbmc6ICdsYXllcicsXG4gICAgICAgICAgICBkYXRhRmlsdGVyOiBERy5iaW5kKHRoaXMuX3Byb2Nlc3NEYXRhLCB0aGlzKVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgYWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fbWFwLmFkZExheWVyKHRoaXMuX21ldGFMYXllcik7XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLmRpc2FibGVMYWJlbCkge1xuICAgICAgICAgICAgdGhpcy5fbGFiZWxIZWxwZXIgPSBERy5sYWJlbCgpO1xuICAgICAgICAgICAgdGhpcy5fbWV0YUxheWVyLm9uKHRoaXMuX2xheWVyRXZlbnRzTGlzdGVuZXJzLCB0aGlzKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICByZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9tYXAucmVtb3ZlTGF5ZXIodGhpcy5fbWV0YUxheWVyKTtcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuZGlzYWJsZUxhYmVsKSB7XG4gICAgICAgICAgICB0aGlzLl9tZXRhTGF5ZXIub2ZmKHRoaXMuX2xheWVyRXZlbnRzTGlzdGVuZXJzLCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX21hcC5yZW1vdmVMYXllcih0aGlzLl9sYWJlbEhlbHBlcik7XG4gICAgICAgICAgICB0aGlzLl9sYWJlbEhlbHBlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0TWV0YUxheWVyIDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWV0YUxheWVyO1xuICAgIH0sXG5cbiAgICBfcHJvY2Vzc0RhdGEgOiBmdW5jdGlvbiAoZGF0YSwgY29vcmQpIHtcbiAgICAgICAgdmFyIG1hcCA9IHRoaXMuX21hcCxcbiAgICAgICAgICAgIHRpbGVPcmlnaW5Qb2ludCA9IGNvb3JkLm11bHRpcGx5QnkodGhpcy5fbWV0YUxheWVyLl9nZXRUaWxlU2l6ZSgpKTtcblxuICAgICAgICBpZiAoZGF0YS5yZXNwb25zZVRleHQgPT09ICcnKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGF0YS5yZXN1bHQucG9pLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgdmFyIGdlb0pzb24gPSBERy5Xa3QudG9HZW9KU09OKGl0ZW0uaG92ZXIpO1xuXG4gICAgICAgICAgICBnZW9Kc29uLmNvb3JkaW5hdGVzWzBdID0gZ2VvSnNvbi5jb29yZGluYXRlc1swXS5tYXAoZnVuY3Rpb24gKHJldmVydGVkTGF0bG5nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hcFxuICAgICAgICAgICAgICAgICAgICAgICAgLnByb2plY3QoW3JldmVydGVkTGF0bG5nWzFdLCByZXZlcnRlZExhdGxuZ1swXV0pLnJvdW5kKClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zdWJ0cmFjdCh0aWxlT3JpZ2luUG9pbnQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGlkOiBpdGVtLmlkLFxuICAgICAgICAgICAgICAgIGhpbnQ6IGl0ZW0ubGlua3NbMF0ubmFtZSxcbiAgICAgICAgICAgICAgICBsaW5rZWQ6IGl0ZW0ubGlua3NbMF0sXG4gICAgICAgICAgICAgICAgZ2VvbWV0cnk6IGdlb0pzb25cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBfbGF5ZXJFdmVudHNMaXN0ZW5lcnMgOiB7XG4gICAgICAgIG1vdXNlb3ZlcjogZnVuY3Rpb24gKGUpIHsgLy8gKE9iamVjdClcbiAgICAgICAgICAgIHRoaXMuX3NldEN1cnNvcigncG9pbnRlcicpO1xuICAgICAgICAgICAgdGhpcy5fbGFiZWxIZWxwZXJcbiAgICAgICAgICAgICAgICAuc2V0UG9zaXRpb24oZS5sYXRsbmcpXG4gICAgICAgICAgICAgICAgLnNldENvbnRlbnQoZS5tZXRhLmhpbnQpO1xuICAgICAgICAgICAgdGhpcy5fbWFwLmFkZExheWVyKHRoaXMuX2xhYmVsSGVscGVyKTtcbiAgICAgICAgfSxcblxuICAgICAgICBtb3VzZW91dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fc2V0Q3Vyc29yKCcnKTtcbiAgICAgICAgICAgIHRoaXMuX21hcC5yZW1vdmVMYXllcih0aGlzLl9sYWJlbEhlbHBlcik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgbW91c2Vtb3ZlOiBmdW5jdGlvbiAoZSkgeyAvLyAoT2JqZWN0KVxuICAgICAgICAgICAgdGhpcy5fbGFiZWxIZWxwZXIuc2V0UG9zaXRpb24oZS5sYXRsbmcpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9zZXRDdXJzb3I6IGZ1bmN0aW9uIChjdXJzb3IpIHsgLy8gKFN0cmluZylcbiAgICAgICAgdGhpcy5fbWFwLmdldENvbnRhaW5lcigpLnN0eWxlLmN1cnNvciA9IGN1cnNvcjtcbiAgICB9XG5cbn0pO1xuXG5ERy5NYXAuYWRkSW5pdEhvb2soJ2FkZEhhbmRsZXInLCAncG9pJywgREcuUG9pKTtcbiIsIkRHLkVudHJhbmNlID0gREcuTGF5ZXIuZXh0ZW5kKHtcblxuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgdmVjdG9yczogW11cbiAgICB9LFxuXG4gICAgc3RhdGljczoge1xuICAgICAgICBTSE9XX0ZST01fWk9PTTogREcuQnJvd3Nlci5zdmcgPyAxNiA6IDE3XG4gICAgfSxcblxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7IC8vIChPYmplY3QpXG4gICAgICAgIERHLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG4gICAgfSxcblxuICAgIG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7IC8vIChERy5NYXApXG4gICAgICAgIHRoaXMuX21hcCA9IG1hcDtcbiAgICAgICAgdGhpcy5faW5pdEFycm93cygpLmFkZFRvKG1hcCk7XG4gICAgICAgIHRoaXMuX2V2ZW50SGFuZGxlciA9IG5ldyBERy5FbnRyYW5jZS5FdmVudEhhbmRsZXIobWFwLCB0aGlzKTtcbiAgICAgICAgdGhpcy5fZXZlbnRIYW5kbGVyLmVuYWJsZSgpO1xuXG4gICAgICAgIC8vIGhpZGUgd2l0aG91dCBldmVudCBieSBkZWZhdWx0XG4gICAgICAgIHRoaXMuX2Fycm93cy5lYWNoTGF5ZXIoZnVuY3Rpb24gKGFycm93KSB7XG4gICAgICAgICAgICBhcnJvdy5zZXRTdHlsZSh7dmlzaWJpbGl0eTogJ2hpZGRlbid9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2lzU2hvd24gPSBmYWxzZTtcbiAgICB9LFxuXG4gICAgYWRkVG86IGZ1bmN0aW9uIChtYXApIHsgLy8gKERHLk1hcCkgLT4gREcuRW50cmFuY2VcbiAgICAgICAgbWFwLmFkZExheWVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgb25SZW1vdmU6IGZ1bmN0aW9uICgpIHsgLy8gKERHLk1hcClcbiAgICAgICAgdGhpcy5faXNTaG93biA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9yZW1vdmVBcnJvd3MoKTtcbiAgICAgICAgdGhpcy5fbWFwID0gbnVsbDtcbiAgICAgICAgdGhpcy5fZXZlbnRIYW5kbGVyLmRpc2FibGUoKTtcbiAgICAgICAgdGhpcy5fZXZlbnRIYW5kbGVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5fYXJyb3dzID0gbnVsbDtcbiAgICB9LFxuXG4gICAgcmVtb3ZlRnJvbTogZnVuY3Rpb24gKG1hcCkgeyAvLyAoREcuTWFwKSAtPiBERy5FbnRyYW5jZVxuICAgICAgICBtYXAucmVtb3ZlTGF5ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzaG93OiBmdW5jdGlvbiAoZml0Qm91bmRzKSB7IC8vICgpIC0+IERHLkVudHJhbmNlXG4gICAgICAgIGlmICghdGhpcy5fYXJyb3dzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZml0Qm91bmRzICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhpcy5fZml0Qm91bmRzKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2lzQWxsb3dlZFpvb20oKSkge1xuICAgICAgICAgICAgdGhpcy5fYXJyb3dzLmVhY2hMYXllcihmdW5jdGlvbiAoYXJyb3cpIHtcbiAgICAgICAgICAgICAgICBhcnJvdy5zZXRTdHlsZSh7dmlzaWJpbGl0eTogJ3Zpc2libGUnfSk7XG4gICAgICAgICAgICAgICAgaWYgKERHLlBhdGguQU5JTUFUSU9OX0FWQUlMQUJMRSkge1xuICAgICAgICAgICAgICAgICAgICBhcnJvdy5ydW5BbmltYXRpb24oJ2FuaW1hdGVBcnJvd1BhdGhHZW9tJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2lzU2hvd24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXAuZmlyZSgnZW50cmFuY2VzaG93Jyk7XG4gICAgICAgICAgICAgICAgdGhpcy5faXNTaG93biA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgaGlkZTogZnVuY3Rpb24gKCkgeyAvLyAoKSAtPiBERy5FbnRyYW5jZVxuXG4gICAgICAgIGlmICh0aGlzLmlzU2hvd24oKSAmJiB0aGlzLl9hcnJvd3MpIHtcbiAgICAgICAgICAgIHRoaXMuX2Fycm93cy5lYWNoTGF5ZXIoZnVuY3Rpb24gKGFycm93KSB7XG4gICAgICAgICAgICAgICAgYXJyb3cuc2V0U3R5bGUoe3Zpc2liaWxpdHk6ICdoaWRkZW4nfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuX2lzU2hvd24gPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX21hcC5maXJlKCdlbnRyYW5jZWhpZGUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBpc1Nob3duOiBmdW5jdGlvbiAoKSB7IC8vICgpIC0+IEJvb2xlYW5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzU2hvd247XG4gICAgfSxcblxuICAgIGdldEJvdW5kczogZnVuY3Rpb24gKCkgeyAvLyAoKSAtPiBERy5MYXRMbmdCb3VuZHNcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Fycm93cy5nZXRCb3VuZHMoKTtcbiAgICB9LFxuXG4gICAgX2luaXRBcnJvd3M6IGZ1bmN0aW9uICgpIHsgLy8gKCkgLT4gREcuRmVhdHVyZUdyb3VwXG4gICAgICAgIHRoaXMuX2Fycm93cyA9IERHLmZlYXR1cmVHcm91cCgpO1xuXG4gICAgICAgIHRoaXMub3B0aW9ucy52ZWN0b3JzXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uICh2ZWN0b3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gREcuV2t0LnRvTGF0TG5ncyh2ZWN0b3IpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChsYXRsbmdzKSB7XG4gICAgICAgICAgICAgICAgLy8gc3Ryb2tlXG4gICAgICAgICAgICAgICAgdGhpcy5fYXJyb3dzLmFkZExheWVyKERHLkVudHJhbmNlLmFycm93KGxhdGxuZ3MsIHRoaXMuX2dldEFycm93U3Ryb2tlT3B0aW9ucygpKSk7XG4gICAgICAgICAgICAgICAgLy8gYmFzaXNcbiAgICAgICAgICAgICAgICB0aGlzLl9hcnJvd3MuYWRkTGF5ZXIoREcuRW50cmFuY2UuYXJyb3cobGF0bG5ncywgdGhpcy5fZ2V0QXJyb3dPcHRpb25zKCkpKTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9hcnJvd3M7XG4gICAgfSxcblxuICAgIF9yZW1vdmVBcnJvd3M6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fbWFwLnJlbW92ZUxheWVyKHRoaXMuX2Fycm93cy5jbGVhckxheWVycygpKTtcbiAgICB9LFxuXG4gICAgX2dldEZpdFpvb206IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcC5wcm9qZWN0RGV0ZWN0b3IuZ2V0UHJvamVjdCgpLm1heFpvb20gfHwgREcuRW50cmFuY2UuU0hPV19GUk9NX1pPT007XG4gICAgfSxcblxuICAgIF9maXRCb3VuZHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG1hcCA9IHRoaXMuX21hcCxcbiAgICAgICAgICAgIGZpdFpvb20sXG4gICAgICAgICAgICBib3VuZHMgPSB0aGlzLmdldEJvdW5kcygpO1xuXG4gICAgICAgIGlmICghbWFwLmdldEJvdW5kcygpLmNvbnRhaW5zKGJvdW5kcykgfHwgIXRoaXMuX2lzQWxsb3dlZFpvb20oKSkge1xuICAgICAgICAgICAgZml0Wm9vbSA9IHRoaXMuX2dldEZpdFpvb20oKTtcbiAgICAgICAgICAgIGlmICghbWFwLnByb2plY3REZXRlY3Rvci5nZXRQcm9qZWN0KCkpIHtcbiAgICAgICAgICAgICAgICBtYXAub25jZSgnbW92ZWVuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFwLnNldFpvb20odGhpcy5fZ2V0Rml0Wm9vbSgpKTtcbiAgICAgICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1hcC5zZXRWaWV3KGJvdW5kcy5nZXRDZW50ZXIoKSwgZml0Wm9vbSwge1xuICAgICAgICAgICAgICAgIGFuaW1hdGUgOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfaXNBbGxvd2VkWm9vbTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFwLmdldFpvb20oKSA+PSBERy5FbnRyYW5jZS5TSE9XX0ZST01fWk9PTTtcbiAgICB9LFxuXG4gICAgX2dldEFycm93U3Ryb2tlT3B0aW9uczogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2xpY2thYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGNvbG9yOiAnI2ZmZicsXG4gICAgICAgICAgICB3ZWlnaHQ6IDYsXG4gICAgICAgICAgICBieVpvb206IHtcbiAgICAgICAgICAgICAgICAxNjoge1xuICAgICAgICAgICAgICAgICAgICBtYXJrZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdCb3g6ICcwIDAgMjQgMjQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVmWDogMTIsXG4gICAgICAgICAgICAgICAgICAgICAgICByZWZZOiAxMixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcmtlckhlaWdodDogMjQsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXJrZXJXaWR0aDogMjQsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZDogICdNOS4zMTMsMTguOTg0YzIuMjQ2LTEuNDY4LDcuMTAxLTUuNTYyLCcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnNy4xMDEtNS41NjJjMC43ODEtMC43ODEsMC43ODEtMi4wNDcsMC0nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJzIuODI4YzAsMC01LjI0Mi00LjAyMy03LjEwMS01LjEwMkM5Ljc0JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcsNS4zNTQsOC41ODMsNS45Myw4LjEyNSw2LjVDNy45MDIsNi43NycgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnNyw5LDExLjYxNCw5LDExLjYxNHYwLjc4OWMwLDAtMC44NzksNC4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJzIzNy0wLjkwNSw1LjI4NUM4LjA5LDE3Ljg5MSw5LjEwOCwxOS4xJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcxOCw5LjMxMywxOC45ODR6J1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBsYXN0UG9pbnRPZmZzZXQ6IDIsXG4gICAgICAgICAgICAgICAgICAgIHZtbEVuZEFycm93OiAnbm9uZScsXG4gICAgICAgICAgICAgICAgICAgIHdlaWdodDogNixcbiAgICAgICAgICAgICAgICAgICAgaWNvbldpZHRoOiA0XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAxNzoge1xuICAgICAgICAgICAgICAgICAgICBtYXJrZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdCb3g6ICcwIDAgMjQgMjQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVmWDogMTIsXG4gICAgICAgICAgICAgICAgICAgICAgICByZWZZOiAxMixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcmtlckhlaWdodDogMjQsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXJrZXJXaWR0aDogMjQsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZDogICdNNy45MTIsMjEuNDk4YzMuMTA2LTIuMDI5LDkuODU5LTcuODczLCcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnOS44NTktNy44NzNjMi4wNTktMS44MDcsMi4xNDItMS41NDIsMC4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJzE0Ni0zLjIwOGMwLDAtNy40MzQtNi4wODQtMTAuMDA1LTcuNTc2JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdDNy41ODMsMi42NDksNi45MDMsMy40NDYsNi4yNzEsNC4yMzNjLScgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnMC4zMDgsMC4zODQsMi4yMDksNi4wNTEsMi4yMDksNi4wNTF2My4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJzM4OGMwLDAtMi4yMTUsNC41ODMtMi4yNSw2LjAzQzYuMjIyLDE5JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcuOTg2LDcuNjI5LDIxLjY4NCw3LjkxMiwyMS40OTh6J1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBsYXN0UG9pbnRPZmZzZXQ6IDAsXG4gICAgICAgICAgICAgICAgICAgIHZtbEVuZEFycm93OiAnbm9uZScsXG4gICAgICAgICAgICAgICAgICAgIHdlaWdodDogNyxcbiAgICAgICAgICAgICAgICAgICAgaWNvbldpZHRoOiA2XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAxODoge1xuICAgICAgICAgICAgICAgICAgICBtYXJrZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdCb3g6ICcwIDAgMjQgMjQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVmWDogMTIsXG4gICAgICAgICAgICAgICAgICAgICAgICByZWZZOiAxMixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcmtlckhlaWdodDogMjQsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXJrZXJXaWR0aDogMjQsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZDogICdNNy42MSwyMi42ODhjNC4wNDUtMi42NDIsMTEuMzEyLTguOTA2LCcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnMTEuMzEyLTguOTA2YzEuOTItMS43ODEsMS45MzgtMi0wLjEyNC0nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJzMuNzgxYzAsMC04LjE1MS02LjMzNC0xMS41LTguMjc2QzYuODcsJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcxLjQ3NSw1LjUxNiwyLjYyLDUuNzMyLDMuMDkzYzIuMTQ2LDQuNicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnOTQsMi4wNjMsNC43NDEsMi42MTIsNy40NjlsMC4wMTYsMi43NWMnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJzAsMC0xLjU3Myw1LjQ1OC0yLjYxOSw3Ljk1OEM1LjU5OSwyMS42JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcxMSw3LjI0MSwyMi45Myw3LjYxLDIyLjY4OHonXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGxhc3RQb2ludE9mZnNldDogIURHLkJyb3dzZXIudm1sID8gLTUgOiAtMixcbiAgICAgICAgICAgICAgICAgICAgdm1sRW5kQXJyb3c6ICdub25lJyxcbiAgICAgICAgICAgICAgICAgICAgd2VpZ2h0OiA4LFxuICAgICAgICAgICAgICAgICAgICBpY29uV2lkdGg6IDhcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIDE5OiB7XG4gICAgICAgICAgICAgICAgICAgIG1hcmtlcjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmlld0JveDogJzAgMCAyNCAyNCcsXG4gICAgICAgICAgICAgICAgICAgICAgICByZWZYOiAxMixcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZlk6IDEyLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWFya2VySGVpZ2h0OiAyNyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcmtlcldpZHRoOiAyNyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkOiAgJ002LjI1NDQ3MiwyMy44NDc1YzQuNTYwMzU1LC0yLjk3MjI4MSAxJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcyLjc0NzUzOCwtMTAuMDMyNzg1IDEyLjc0NzUzOCwtMTAuMDMyNycgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnODVjMi4xNjc1MjEsLTIuMDA2NTU2IDIuMTc4MjQyLC0yLjI1MzMnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJzUzIC0wLjEzOTQ5LC00LjI1OTkxYzAsMCAtOS4xODUxMDEsLTcuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcxMzU2MiAtMTIuOTYyMTQ4LC05LjMyNDU5NGMtMC40ODI4NjEsLScgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnMC4yNzg5ODUgLTIuMDA2NTU4LDEuMDA4NjQ1IC0xLjc1OTc2MSwnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJzEuNTM0NDI4YzIuNDE0MzA2LDUuMjkwMDE1IDIuNDE0MzA2LDUuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcyOTAwMTUgMy4yNzI3MjQsOC4yOTQ0ODZsMCwzLjQzMzY4MWMwLCcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnMCAtMi4wODE2NjUsNS45MzM4MjkgLTMuMjYxOTk3LDguNzU1ODgnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJzljLTAuMTYwOTUxLDAuMzg2Mjg4IDEuNjg0NjUyLDEuODY3MDYyJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcgMi4xMDMxMzQsMS41OTg4MDR6J1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBsYXN0UG9pbnRPZmZzZXQ6ICFERy5Ccm93c2VyLnZtbCA/IC01IDogLTIsXG4gICAgICAgICAgICAgICAgICAgIHZtbEVuZEFycm93OiAnbm9uZScsXG4gICAgICAgICAgICAgICAgICAgIHdlaWdodDogMTAsXG4gICAgICAgICAgICAgICAgICAgIGljb25XaWR0aDogMTJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIF9nZXRBcnJvd09wdGlvbnM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNsaWNrYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBjb2xvcjogJyMwMDg1YTAnLFxuICAgICAgICAgICAgd2VpZ2h0OiAzLFxuICAgICAgICAgICAgYnlab29tOiB7XG4gICAgICAgICAgICAgICAgMTY6IHtcbiAgICAgICAgICAgICAgICAgICAgbWFya2VyOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWZYOiAxMixcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZlk6IDEyLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWFya2VySGVpZ2h0OiAyNCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcmtlcldpZHRoOiAyNCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkOiAgJ00xMS4wNjgsMTMuMDExTDkuNSwxNy4yODVsNi4zNzktNS4xNjlMOScgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnLjMxMyw3LjE5bDEuNzE3LDMuODI0J1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBsYXN0UG9pbnRPZmZzZXQ6IDIsXG4gICAgICAgICAgICAgICAgICAgIHdlaWdodDogMixcbiAgICAgICAgICAgICAgICAgICAgaWNvbldpZHRoOiA0XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAxNzoge1xuICAgICAgICAgICAgICAgICAgICBtYXJrZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZlg6IDEyLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVmWTogMTIsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXJrZXJIZWlnaHQ6IDI0LFxuICAgICAgICAgICAgICAgICAgICAgICAgbWFya2VyV2lkdGg6IDI0LFxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQ6ICAnTTEwLjM1NCwxMy45NjlsLTIuMTg0LDUuMThMMTYuOTkzLDEyTDcuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICc5MTIsNS4xODhsMi4zOCw0Ljc4MSdcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgbGFzdFBvaW50T2Zmc2V0OiAwLFxuICAgICAgICAgICAgICAgICAgICB3ZWlnaHQ6IDMsXG4gICAgICAgICAgICAgICAgICAgIGljb25XaWR0aDogNlxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgMTg6IHtcbiAgICAgICAgICAgICAgICAgICAgbWFya2VyOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWZYOiAxMixcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZlk6IDEyLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWFya2VySGVpZ2h0OiAyNCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcmtlcldpZHRoOiAyNCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkOiAgJ00xMC4yODEsMTMuNzgxTDcuNDIsMjEuMjcxbDExLjQ4OC05LjMwOCcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnTDcuMDgzLDMuMDkzTDEwLjIxOSwxMCdcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgbGFzdFBvaW50T2Zmc2V0OiAhREcuQnJvd3Nlci52bWwgPyAtNSA6IDAsXG4gICAgICAgICAgICAgICAgICAgIHdlaWdodDogNCxcbiAgICAgICAgICAgICAgICAgICAgaWNvbldpZHRoOiA4XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAxOToge1xuICAgICAgICAgICAgICAgICAgICBtYXJrZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZlg6IDEyLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVmWTogMTIsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXJrZXJIZWlnaHQ6IDI3LFxuICAgICAgICAgICAgICAgICAgICAgICAgbWFya2VyV2lkdGg6IDI3LFxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQ6ICAnTTkuMzQ0NzgzLDEzLjgxNDcxNGwtMy4zMjYzNzUsOC40NzY5MDInICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2wxMi45ODM2MDMsLTEwLjUxNTY1bC0xMy4zMDU1MTMsLTkuOTc5JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcxMzdsMy42NDgyODYsNy45NDAzODknXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGxhc3RQb2ludE9mZnNldDogIURHLkJyb3dzZXIudm1sID8gLTUgOiAwLFxuICAgICAgICAgICAgICAgICAgICB3ZWlnaHQ6IDUsXG4gICAgICAgICAgICAgICAgICAgIGljb25XaWR0aDogMTJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxufSk7XG4iLCJERy5QYXRoLkFOSU1BVElPTl9BVkFJTEFCTEUgPVxuICAgIERHLkJyb3dzZXIuc3ZnICYmXG4gICAgIURHLkJyb3dzZXIubW9iaWxlV2Via2l0ICYmXG4gICAgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ3ByZXN0bycpID09PSAtMSAmJlxuICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChcbiAgICAgICAgREcuU1ZHLmNyZWF0ZSgnYW5pbWF0ZScpLmJlZ2luRWxlbWVudCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG5cblxuREcuUGF0aC5pbmNsdWRlKCFERy5QYXRoLkFOSU1BVElPTl9BVkFJTEFCTEUgPyB7fSA6IHtcblxuICAgIHJ1bkFuaW1hdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYW5pbWF0aW9uRWwgPSB0aGlzLl9hbmltYXRpb25FbCA9IHRoaXMuX2FkZEFuaW1hdGlvbigpO1xuXG4gICAgICAgIGlmIChhbmltYXRpb25FbCkge1xuICAgICAgICAgICAgYW5pbWF0aW9uRWwuYmVnaW5FbGVtZW50KCk7XG4gICAgICAgICAgICB0aGlzLl9yZW1vdmVBbmltYXRpb24oYW5pbWF0aW9uRWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHN0b3BBbmltYXRpb246IGZ1bmN0aW9uIChuYW1lKSB7IC8vIChTdHJpbmcpIC0+IERHLlBhdGhcbiAgICAgICAgaWYgKHRoaXMuYW5pbWF0aW9uc1tuYW1lXSkge1xuICAgICAgICAgICAgdGhpcy5hbmltYXRpb25zW25hbWVdLmVuZEVsZW1lbnQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgX2FkZEFuaW1hdGlvbjogZnVuY3Rpb24gKCkgeyAvLyAoKSAtPiBTVkdBbmltYXRlRWxlbWVudHxudWxsXG4gICAgICAgIHZhciBhbmltT3B0aW9ucyA9IHRoaXMub3B0aW9ucy5hbmltYXRpb24sXG4gICAgICAgICAgICBwb2ludHMgPSB0aGlzLl9yaW5nc1swXSxcbiAgICAgICAgICAgIGFuaW1hdGlvbkVsID0gbnVsbDtcblxuICAgICAgICBpZiAoYW5pbU9wdGlvbnMgJiYgcG9pbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGFuaW1hdGlvbkVsID0gREcuU1ZHLmNyZWF0ZSgnYW5pbWF0ZScpO1xuXG4gICAgICAgICAgICAvLyBjYWxjdWxhdGUgdmFsdWVzIGlmIGF0dHJpYnV0ZU5hbWU6ICdkJyB3YXMgdXNlZCB0byBhbmltYXRlXG4gICAgICAgICAgICBpZiAoYW5pbU9wdGlvbnMuZ2V0VmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgYW5pbU9wdGlvbnMudmFsdWVzID0gYW5pbU9wdGlvbnMuZ2V0VmFsdWVzKHBvaW50cyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGFuaW1PcHRpb25zKVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHt9LnRvU3RyaW5nLmNhbGwoYW5pbU9wdGlvbnNbbmFtZV0pICE9PSAnW29iamVjdCBGdW5jdGlvbl0nO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uRWwuc2V0QXR0cmlidXRlKG5hbWUsIGFuaW1PcHRpb25zW25hbWVdKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhpcy5fcGF0aC5hcHBlbmRDaGlsZChhbmltYXRpb25FbCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYW5pbWF0aW9uRWw7XG4gICAgfSxcblxuICAgIF9yZW1vdmVBbmltYXRpb246IGZ1bmN0aW9uIChhbmltYXRpb25FbCkge1xuICAgICAgICB0aGlzLl9tYXAub25jZSgnem9vbXN0YXJ0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGFuaW1hdGlvbkVsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGF0aC5yZW1vdmVDaGlsZChhbmltYXRpb25FbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9hbmltYXRpb25FbCA9IG51bGw7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH1cbn0pO1xuIiwiREcuRW50cmFuY2UuQXJyb3cgPSBERy5Qb2x5bGluZS5leHRlbmQoe1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIChsYXRsbmdzLCBvcHRpb25zKSB7IC8vIChBcnJheSwgT2JqZWN0KVxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgICB0aGlzLl9zZXRMYXRMbmdzKGxhdGxuZ3MpO1xuXG4gICAgICAgIGlmIChERy5QYXRoLkFOSU1BVElPTl9BVkFJTEFCTEUpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuYW5pbWF0aW9uID0gdGhpcy5nZXRBcnJvd0FuaW1hdGlvbih0aGlzLl9jb252ZXJ0TGF0TG5ncyhsYXRsbmdzKSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9tYXJrZXJzID0gW107XG5cbiAgICAgICAgTC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICBvbkFkZDogZnVuY3Rpb24gKG1hcCkgeyAvLyAoREcuTWFwKVxuICAgICAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLl9yZW5kZXJlciA9IG1hcC5nZXRBcnJvd1JlbmRlcmVyKCk7XG4gICAgICAgIHJlbmRlcmVyLl9pbml0UGF0aCh0aGlzKTtcblxuICAgICAgICAvLyBkZWZpbmVkIGluIGNoaWxkcmVuIGNsYXNzZXNcbiAgICAgICAgdGhpcy5fcHJvamVjdCgpO1xuICAgICAgICB0aGlzLl91cGRhdGUoKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlU3R5bGVCeVpvb20oKTtcblxuICAgICAgICByZW5kZXJlci5fYWRkUGF0aCh0aGlzKTtcbiAgICAgICAgcmVuZGVyZXIuX2luaXRNYXJrZXJzKHRoaXMpO1xuICAgIH0sXG5cbiAgICBvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkgeyAvLyAoREcuTWFwKVxuICAgICAgICBERy5Qb2x5bGluZS5wcm90b3R5cGUub25SZW1vdmUuY2FsbCh0aGlzLCBtYXApO1xuXG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLl9yZW1vdmVNYXJrZXJzKHRoaXMpO1xuICAgIH0sXG5cbiAgICBnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZpZXdyZXNldDogdGhpcy5fcHJvamVjdCxcbiAgICAgICAgICAgIG1vdmU6IHRoaXMuX3VwZGF0ZSxcbiAgICAgICAgICAgIHpvb21lbmQ6IHRoaXMuX3VwZGF0ZVN0eWxlQnlab29tXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIF9wcm9qZWN0TGF0bG5nczogZnVuY3Rpb24gKGxhdGxuZ3MsIHJlc3VsdCkge1xuICAgICAgICBERy5Qb2x5bGluZS5wcm90b3R5cGUuX3Byb2plY3RMYXRsbmdzLmNhbGwodGhpcywgbGF0bG5ncywgcmVzdWx0KTtcbiAgICAgICAgdGhpcy5fb2Zmc2V0TGFzdFBhdGhQb2ludCgpO1xuICAgIH0sXG5cbiAgICBfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIERHLlBvbHlsaW5lLnByb3RvdHlwZS5fdXBkYXRlLmNhbGwodGhpcyk7XG5cbiAgICAgICAgdGhpcy5fcmVuZGVyZXIuX3VwZGF0ZU1hcmtlcih0aGlzKTtcbiAgICB9LFxuXG4gICAgX3VwZGF0ZVN0eWxlQnlab29tOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvcHRpb25zQnlab29tID0gdGhpcy5vcHRpb25zLmJ5Wm9vbSxcbiAgICAgICAgICAgIHpvb20gPSB0aGlzLl9tYXAuZ2V0Wm9vbSgpO1xuXG4gICAgICAgIHRoaXMuc2V0U3R5bGUob3B0aW9uc0J5Wm9vbVt6b29tXSk7XG4gICAgfSxcblxuICAgIF9vZmZzZXRMYXN0UGF0aFBvaW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvcmlnUG9pbnRzID0gdGhpcy5fcmluZ3NbMF0sXG4gICAgICAgICAgICBzdHlsZSA9IHRoaXMub3B0aW9ucy5ieVpvb21bdGhpcy5fbWFwLmdldFpvb20oKV0sXG4gICAgICAgICAgICBwb2ludHNMZW4gPSBvcmlnUG9pbnRzLmxlbmd0aCxcbiAgICAgICAgICAgIGxhc3RTZWdtZW50TGVuID0gb3JpZ1BvaW50c1twb2ludHNMZW4gLSAxXS5kaXN0YW5jZVRvKG9yaWdQb2ludHNbcG9pbnRzTGVuIC0gMl0pLFxuICAgICAgICAgICAgbGFzdFNlZ21lbnRJblBlcmNlbnRzLFxuICAgICAgICAgICAgb2Zmc2V0VmVjdG9yLFxuICAgICAgICAgICAgb2Zmc2V0VG87XG5cbiAgICAgICAgaWYgKHN0eWxlKSB7XG4gICAgICAgICAgICBvZmZzZXRWZWN0b3IgPSB7XG4gICAgICAgICAgICAgICAgeDogb3JpZ1BvaW50c1twb2ludHNMZW4gLSAxXS54IC0gb3JpZ1BvaW50c1twb2ludHNMZW4gLSAyXS54LFxuICAgICAgICAgICAgICAgIHk6IG9yaWdQb2ludHNbcG9pbnRzTGVuIC0gMV0ueSAtIG9yaWdQb2ludHNbcG9pbnRzTGVuIC0gMl0ueVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8g0YHRgNCw0LLQvdC10L3QuNC1INC00LvQuNC90Ysg0L/QvtGB0LvQtdC00L3QtdCz0L4g0YHQtdCz0LzQtdC90YLQsCDQv9GD0YLQuCDRgSDRgNCw0LfQvNC10YDQvtC8INC40LrQvtC90LrQuCDRgdGC0YDQtdC70LrQuFxuICAgICAgICAgICAgaWYgKGxhc3RTZWdtZW50TGVuID4gc3R5bGUuaWNvbldpZHRoKSB7XG4gICAgICAgICAgICAgICAgbGFzdFNlZ21lbnRJblBlcmNlbnRzID0gTWF0aC5hYnMoc3R5bGUubGFzdFBvaW50T2Zmc2V0IC8gbGFzdFNlZ21lbnRMZW4pO1xuXG4gICAgICAgICAgICAgICAgb2Zmc2V0VG8gPSB7XG4gICAgICAgICAgICAgICAgICAgIHg6IG9mZnNldFZlY3Rvci54ICogbGFzdFNlZ21lbnRJblBlcmNlbnRzLFxuICAgICAgICAgICAgICAgICAgICB5OiBvZmZzZXRWZWN0b3IueSAqIGxhc3RTZWdtZW50SW5QZXJjZW50c1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAvLyBtb3ZlIGxhc3QgcG9pbnQgZm9yd2FyZC9iYWNrIGJ5IG9mZnNldFZlY3RvciBkaXJlY3Rpb25cbiAgICAgICAgICAgICAgICBpZiAoc3R5bGUubGFzdFBvaW50T2Zmc2V0ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBvcmlnUG9pbnRzW3BvaW50c0xlbiAtIDFdLnggKz0gb2Zmc2V0VG8ueDtcbiAgICAgICAgICAgICAgICAgICAgb3JpZ1BvaW50c1twb2ludHNMZW4gLSAxXS55ICs9IG9mZnNldFRvLnk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb3JpZ1BvaW50c1twb2ludHNMZW4gLSAxXS54IC09IG9mZnNldFRvLng7XG4gICAgICAgICAgICAgICAgICAgIG9yaWdQb2ludHNbcG9pbnRzTGVuIC0gMV0ueSAtPSBvZmZzZXRUby55O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8g0YPQtNC70LjQvdGP0LXQvCDQv9C+0YHQu9C10LTQvdC40Lkg0YPRh9Cw0YHRgtC+0LosINC10YHQu9C4INC+0L0g0LzQtdC90YzRiNC1INGB0YLRgNC10LvQutC4XG4gICAgICAgICAgICAgICAgbGFzdFNlZ21lbnRJblBlcmNlbnRzID0gbGFzdFNlZ21lbnRMZW4gLyBzdHlsZS5pY29uV2lkdGg7XG5cbiAgICAgICAgICAgICAgICBpZiAob2Zmc2V0VmVjdG9yLnggIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgb3JpZ1BvaW50c1twb2ludHNMZW4gLSAxXS54ID0gb3JpZ1BvaW50c1twb2ludHNMZW4gLSAyXS54ICsgb2Zmc2V0VmVjdG9yLnggLyBsYXN0U2VnbWVudEluUGVyY2VudHM7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKG9mZnNldFZlY3Rvci55ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG9yaWdQb2ludHNbcG9pbnRzTGVuIC0gMV0ueSA9IG9yaWdQb2ludHNbcG9pbnRzTGVuIC0gMl0ueSArIG9mZnNldFZlY3Rvci55IC8gbGFzdFNlZ21lbnRJblBlcmNlbnRzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxufSk7XG5cbkRHLkVudHJhbmNlLmFycm93ID0gZnVuY3Rpb24gKGxhdGxuZ3MsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IERHLkVudHJhbmNlLkFycm93KGxhdGxuZ3MsIG9wdGlvbnMpO1xufTtcbiIsIkRHLkVudHJhbmNlLkFycm93LlNWRyA9IERHLlNWRy5leHRlbmQoe1xuXG4gICAgZ2V0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBldmVudHMgPSB7XG4gICAgICAgICAgICBtb3ZlOiB0aGlzLl91cGRhdGVcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xuICAgICAgICAgICAgZXZlbnRzLnpvb21hbmltID0gdGhpcy5fYW5pbWF0ZVpvb207XG4gICAgICAgIH1cbiAgICAgICAgaWYgKERHLkJyb3dzZXIuaWUpIHtcbiAgICAgICAgICAgIGV2ZW50cy5tb3ZlZW5kID0gZXZlbnRzLm1vdXNlbW92ZSA9IGV2ZW50cy56b29tZW5kID0gdGhpcy5fcmVmcmVzaDsgLy9KU0FQSS0zMzc5XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV2ZW50cztcbiAgICB9LFxuXG4gICAgX2luaXRNYXJrZXJzOiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAgICAgdmFyIG1hcmtlciwgbWFya2VyU3R5bGUsXG4gICAgICAgICAgICBvcHRpb25zQnlab29tID0gIGxheWVyLm9wdGlvbnMuYnlab29tLFxuICAgICAgICAgICAgaWQgPSBsYXllci5fbWFya2VySWQgPSAnYXJyb3ctbWFya2VyLScgKyBERy5VdGlsLnN0YW1wKGxheWVyKTtcblxuICAgICAgICBPYmplY3Qua2V5cyhvcHRpb25zQnlab29tKS5tYXAoZnVuY3Rpb24gKHpvb20pIHtcbiAgICAgICAgICAgIG1hcmtlciA9IERHLlNWRy5jcmVhdGUoJ21hcmtlcicpO1xuICAgICAgICAgICAgbWFya2VyU3R5bGUgPSBvcHRpb25zQnlab29tW3pvb21dLm1hcmtlcjtcblxuICAgICAgICAgICAgT2JqZWN0LmtleXMobWFya2VyU3R5bGUpXG4gICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBrZXkgIT09ICdwb2x5Z29uJyAmJiBrZXkgIT09ICdwYXRoJztcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFya2VyLnNldEF0dHJpYnV0ZShrZXksIG1hcmtlclN0eWxlW2tleV0pO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBtYXJrZXIuaWQgPSBpZCArICctJyArIHpvb207XG4gICAgICAgICAgICBtYXJrZXIuc2V0QXR0cmlidXRlKCdvcmllbnQnLCAnYXV0bycpO1xuICAgICAgICAgICAgbWFya2VyLnNldEF0dHJpYnV0ZSgnbWFya2VyVW5pdHMnLCAndXNlclNwYWNlT25Vc2UnKTtcbiAgICAgICAgICAgIG1hcmtlci5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS13aWR0aCcsICcwJyk7XG5cbiAgICAgICAgICAgIGlmIChtYXJrZXJTdHlsZS5wYXRoKSB7XG4gICAgICAgICAgICAgICAgbWFya2VyLmFwcGVuZENoaWxkKHRoaXMuX2dldE1hcmtlckNoaWxkKCdwYXRoJywgbWFya2VyU3R5bGUucGF0aCwgbGF5ZXIpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG1hcmtlclN0eWxlLnBvbHlnb24pIHtcbiAgICAgICAgICAgICAgICBtYXJrZXIuYXBwZW5kQ2hpbGQodGhpcy5fZ2V0TWFya2VyQ2hpbGQoJ3BvbHlnb24nLCBtYXJrZXJTdHlsZS5wb2x5Z29uLCBsYXllcikpO1xuICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgIGxheWVyLl9tYXJrZXJzLnB1c2gobWFya2VyKTtcbiAgICAgICAgICAgIHRoaXMuX2dldERlZnMoKS5hcHBlbmRDaGlsZChtYXJrZXIpO1xuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICB0aGlzLl91cGRhdGVNYXJrZXIobGF5ZXIpO1xuICAgIH0sXG5cbiAgICBfZ2V0TWFya2VyQ2hpbGQ6IGZ1bmN0aW9uICh0eXBlLCBvcHRpb25zLCBsYXllcikge1xuICAgICAgICB2YXIgbWFya2VyUGF0aCA9IERHLlNWRy5jcmVhdGUoJ3BhdGgnKSxcbiAgICAgICAgICAgIHZlY3RvciA9ICh0eXBlID09PSAncGF0aCcpID8gJ2QnIDogJ3BvaW50cyc7XG5cbiAgICAgICAgbWFya2VyUGF0aC5zZXRBdHRyaWJ1dGUodmVjdG9yLCBvcHRpb25zW3ZlY3Rvcl0pO1xuXG4gICAgICAgIG1hcmtlclBhdGguc2V0QXR0cmlidXRlKCdmaWxsJywgb3B0aW9ucy5jb2xvciA/IG9wdGlvbnMuY29sb3IgOiBsYXllci5vcHRpb25zLmNvbG9yKTtcblxuICAgICAgICByZXR1cm4gbWFya2VyUGF0aDtcbiAgICB9LFxuXG4gICAgX2dldERlZnM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fZGVmcyA9IHRoaXMuX2RlZnMgfHwgREcuU1ZHLmNyZWF0ZSgnZGVmcycpO1xuICAgICAgICBpZiAoIXRoaXMuX2RlZnMucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgdGhpcy5fY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuX2RlZnMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWZzO1xuICAgIH0sXG5cbiAgICBfdXBkYXRlTWFya2VyOiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAgICAgdmFyIHpvb20gPSBsYXllci5fbWFwLmdldFpvb20oKSxcbiAgICAgICAgICAgIGJvdW5kID0gbGF5ZXIuX21hcC5nZXRCb3VuZHMoKSxcbiAgICAgICAgICAgIGxhc3RQb2ludCA9IGxheWVyLl9sYXRsbmdzW2xheWVyLl9sYXRsbmdzLmxlbmd0aCAtIDFdLFxuICAgICAgICAgICAgdXJsID0gKHpvb20gPj0gREcuRW50cmFuY2UuU0hPV19GUk9NX1pPT00gJiYgYm91bmQuY29udGFpbnMobGFzdFBvaW50KSkgPyBsYXllci5fbWFya2VySWQgKyAnLScgKyB6b29tIDogJyc7XG5cbiAgICAgICAgbGF5ZXIuX3BhdGguc2V0QXR0cmlidXRlKCdtYXJrZXItZW5kJywgJ3VybCgjJyArIHVybCArICcpJyk7XG4gICAgfSxcblxuICAgIF9yZW1vdmVNYXJrZXJzOiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAgICAgdmFyIGRlZnMgPSB0aGlzLl9nZXREZWZzKCksXG4gICAgICAgICAgICBtYXJrZXJzID0gbGF5ZXIuX21hcmtlcnM7XG5cbiAgICAgICAgaWYgKCFkZWZzICYmICFtYXJrZXJzKSB7IHJldHVybjsgfVxuXG4gICAgICAgIG1hcmtlcnMuZm9yRWFjaChmdW5jdGlvbiAobWFya2VyKSB7XG4gICAgICAgICAgICBkZWZzLnJlbW92ZUNoaWxkKG1hcmtlcik7XG4gICAgICAgIH0pO1xuICAgICAgICBtYXJrZXJzLmxlbmd0aCA9IDA7XG4gICAgfSxcblxuICAgIF9yZWZyZXNoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2NvbnRhaW5lci5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLl9jb250YWluZXIsIHRoaXMuX2NvbnRhaW5lcik7XG4gICAgfSxcblxuICAgIF91cGRhdGVTdHlsZTogZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgICAgIHZhciBwYXRoID0gbGF5ZXIuX3BhdGgsXG4gICAgICAgICAgICBvcHRpb25zID0gbGF5ZXIub3B0aW9ucztcblxuICAgICAgICBERy5TVkcucHJvdG90eXBlLl91cGRhdGVTdHlsZS5jYWxsKHRoaXMsIGxheWVyKTtcblxuICAgICAgICBwYXRoLnNldEF0dHJpYnV0ZSgndmlzaWJpbGl0eScsIG9wdGlvbnMudmlzaWJpbGl0eSk7XG5cbiAgICAgICAgbGF5ZXIuX21hcmtlcnMuZm9yRWFjaChmdW5jdGlvbiAobWFya2VyKSB7XG4gICAgICAgICAgICBtYXJrZXIuc2V0QXR0cmlidXRlKCdmaWxsLW9wYWNpdHknLCBvcHRpb25zLm9wYWNpdHkpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLl91cGRhdGVNYXJrZXIobGF5ZXIpO1xuICAgIH1cbn0pO1xuXG5cbkwuTWFwLmluY2x1ZGUoe1xuICAgIGdldEFycm93UmVuZGVyZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlbmRlcmVyID0gdGhpcy5fYXJyb3dSZW5kZXJlcjtcblxuICAgICAgICBpZiAoIXJlbmRlcmVyKSB7XG4gICAgICAgICAgICByZW5kZXJlciA9IHRoaXMuX2Fycm93UmVuZGVyZXIgPSBuZXcgREcuRW50cmFuY2UuQXJyb3cuU1ZHKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuaGFzTGF5ZXIocmVuZGVyZXIpKSB7XG4gICAgICAgICAgICB0aGlzLmFkZExheWVyKHJlbmRlcmVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZW5kZXJlcjtcbiAgICB9XG59KTtcbiIsIi8vIHJlZGVmaW5lIHNvbWUgU1ZHIG1ldGhvZHMgdG8gaGFuZGxlIFZNTCBzeW50YXggd2hpY2ggaXMgc2ltaWxhciBidXQgd2l0aCBzb21lIGRpZmZlcmVuY2VzXG5ERy5FbnRyYW5jZS5BcnJvdy5TVkcuaW5jbHVkZSghTC5Ccm93c2VyLnZtbCA/IHt9IDoge1xuXG4gICAgX2luaXRNYXJrZXJzOiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAgICAgbGF5ZXIuX21hcmtlcnMgPSBMLlNWRy5jcmVhdGUoJ3N0cm9rZScpO1xuICAgICAgICB0aGlzLl91cGRhdGVNYXJrZXIobGF5ZXIpO1xuICAgICAgICBsYXllci5fY29udGFpbmVyLmFwcGVuZENoaWxkKGxheWVyLl9tYXJrZXJzKTtcbiAgICB9LFxuXG4gICAgX3VwZGF0ZU1hcmtlcjogZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgICAgIHZhciBzdHlsZSA9IGxheWVyLm9wdGlvbnMuYnlab29tW2xheWVyLl9tYXAuZ2V0Wm9vbSgpXTtcblxuICAgICAgICBsYXllci5fbWFya2Vycy5lbmRhcnJvdyA9XG4gICAgICAgICAgICAoc3R5bGUgJiYgc3R5bGUudm1sRW5kQXJyb3cpID8gc3R5bGUudm1sRW5kQXJyb3cgOiAnY2xhc3NpYyc7XG4gICAgfSxcblxuICAgIF9yZW1vdmVNYXJrZXJzOiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAgICAgbGF5ZXIuX2NvbnRhaW5lci5yZW1vdmVDaGlsZChsYXllci5fbWFya2Vycyk7XG4gICAgfSxcblxuICAgIF91cGRhdGVTdHlsZTogZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gbGF5ZXIub3B0aW9ucyxcbiAgICAgICAgICAgIGNvbnRhaW5lciA9IGxheWVyLl9jb250YWluZXI7XG5cbiAgICAgICAgREcuU1ZHLnByb3RvdHlwZS5fdXBkYXRlU3R5bGUuY2FsbCh0aGlzLCBsYXllcik7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMudmlzaWJpbGl0eSkge1xuICAgICAgICAgICAgY29udGFpbmVyLnN0eWxlLnZpc2liaWxpdHkgPSBvcHRpb25zLnZpc2liaWxpdHk7XG4gICAgICAgIH1cbiAgICB9XG59KTtcbiIsIi8vIEV4dGVuZHMgREcuRW50cmFuY2UuQXJyb3cgd2l0aCBTVkctc3BlY2lmaWMgYW5pbWF0aW9uIG9wdGlvbnNcbmlmIChERy5Ccm93c2VyLnN2Zykge1xuXG4gICAgREcuRW50cmFuY2UuQXJyb3cuaW5jbHVkZSh7XG5cbiAgICAgICAgZ2V0QXJyb3dBbmltYXRpb246IGZ1bmN0aW9uICh2ZXJ0aWNlcykgeyAvLyAoTnVtYmVyKSAtPiBPYmplY3RcbiAgICAgICAgICAgIHZhciBhbmltYXRlQXJyb3cgPSB7XG4gICAgICAgICAgICAgICAgaWQ6ICdhbmltYXRlQXJyb3dQYXRoR2VvbScsXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlTmFtZTogJ2QnLFxuICAgICAgICAgICAgICAgIGZpbGw6ICdmcmVlemUnLFxuICAgICAgICAgICAgICAgIGJlZ2luOiAnaW5kZWZpbml0ZSdcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGFuaW1hdGVBcnJvdy5nZXRWYWx1ZXMgPSB0aGlzLl9nZXRBbmltYXRpb25WYWx1ZXModmVydGljZXMubGVuZ3RoKTtcbiAgICAgICAgICAgIGFuaW1hdGVBcnJvdy5rZXlUaW1lcyA9IHRoaXMuX2dldEFuaW1hdGVUaW1pbmcodmVydGljZXMpO1xuICAgICAgICAgICAgYW5pbWF0ZUFycm93LmR1ciA9IHRoaXMuX2dldEFuaW1hdGlvblRpbWUodmVydGljZXMubGVuZ3RoKTtcblxuICAgICAgICAgICAgcmV0dXJuIGFuaW1hdGVBcnJvdztcbiAgICAgICAgfSxcblxuICAgICAgICBfZ2V0QW5pbWF0aW9uVmFsdWVzOiBmdW5jdGlvbiAodmVydGljZXNDb3VudCkge1xuICAgICAgICAgICAgcmV0dXJuICh2ZXJ0aWNlc0NvdW50ID09PSAyKSA/IHRoaXMuX2dldFNoYWtlQW5pbWF0aW9uVmFsdWVzIDogdGhpcy5fZ2V0U2xpZGVBbmltYXRpb25WYWx1ZXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2dldFNsaWRlQW5pbWF0aW9uVmFsdWVzOiBmdW5jdGlvbiAocG9pbnRzKSB7IC8vIChBcnJheSkgLT4gU3RyaW5nXG4gICAgICAgICAgICB2YXIgZCA9ICcnLFxuICAgICAgICAgICAgICAgIHByZXZQb2ludCA9ICcnLFxuICAgICAgICAgICAgICAgIGN1clBvaW50ID0gJycsXG4gICAgICAgICAgICAgICAgTSA9ICdNICcgKyBwb2ludHNbMF0ueCArICcgJyArIHBvaW50c1swXS55LFxuICAgICAgICAgICAgICAgIGwgPSAnbCAtMSAwJztcblxuICAgICAgICAgICAgZCA9IE0gKyAnICcgKyBsICsgJzsgJztcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY3VyUG9pbnQgKz0gKHBvaW50c1tpXS54IC0gcG9pbnRzW2kgLSAxXS54KSArICcgJyArIChwb2ludHNbaV0ueSAtIHBvaW50c1tpIC0gMV0ueSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gcG9pbnRzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VyUG9pbnQgPSAocG9pbnRzW2ldLnggLSBwb2ludHNbaSAtIDFdLngpICsgJyAnICsgKHBvaW50c1tpXS55IC0gcG9pbnRzW2kgLSAxXS55KTtcbiAgICAgICAgICAgICAgICAgICAgZCArPSBNICsgJyBsICcgKyBwcmV2UG9pbnQgICsgY3VyUG9pbnQgKyAnOyc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGQgKz0gTSArICcgbCAnICsgY3VyUG9pbnQgKyAnOyAnO1xuICAgICAgICAgICAgICAgIGQgKz0gTSArICcgbCAnICsgY3VyUG9pbnQgKyAnICcgKyBsICsgJzsgJztcbiAgICAgICAgICAgICAgICBjdXJQb2ludCArPSAnIGwgJztcbiAgICAgICAgICAgICAgICBwcmV2UG9pbnQgKz0gKHBvaW50c1tpXS54IC0gcG9pbnRzW2kgLSAxXS54KSArICcgJyArIChwb2ludHNbaV0ueSAtIHBvaW50c1tpIC0gMV0ueSkgKyAnIGwgJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2dldFNoYWtlQW5pbWF0aW9uVmFsdWVzOiBmdW5jdGlvbiAocG9pbnRzKSB7IC8vIChBcnJheSkgLT4gU3RyaW5nXG4gICAgICAgICAgICB2YXIgcHgwLCBweTAsXG4gICAgICAgICAgICAgICAgLy8gY29uZmlnIGNvZWZmaWNpZW50IHZhbHVlcyBmb3IgYXJyb3cgYW5pbWF0aW9uXG4gICAgICAgICAgICAgICAgcmVsRGlmZiA9IFsxLCAwLjQsIDEsIDAuODQsIDEsIDAuOTQsIDFdLFxuICAgICAgICAgICAgICAgIGR4ID0gcG9pbnRzWzFdLnggLSBwb2ludHNbMF0ueCxcbiAgICAgICAgICAgICAgICBkeSA9IHBvaW50c1sxXS55IC0gcG9pbnRzWzBdLnksXG4gICAgICAgICAgICAgICAgbCA9ICcgbCAnICsgZHggKyAnICcgKyBkeTtcblxuICAgICAgICAgICAgcHgwID0gcG9pbnRzWzBdLnggLSBkeDtcbiAgICAgICAgICAgIHB5MCA9IHBvaW50c1swXS55IC0gZHk7XG5cbiAgICAgICAgICAgIHJldHVybiByZWxEaWZmLnJlZHVjZShcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoZCwgc3RlcCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZCArICcgTSAnICsgKHB4MCArIGR4ICogc3RlcCkgKyAnICcgKyAocHkwICsgZHkgKiBzdGVwKSArIGwgKyAnOyc7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnTSAnICsgcHgwICsgJyAnICsgcHkwICsgbCArICc7ICdcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2dldFBvbHlsaW5lTGVuZ3RoOiBmdW5jdGlvbiAobGF0bG5ncykge1xuICAgICAgICAgICAgdmFyIGxlbiA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGxhdGxuZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZW4gKz0gbGF0bG5nc1tpIC0gMV0uZGlzdGFuY2VUbyhsYXRsbmdzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBsZW47XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2dldEFuaW1hdGVUaW1pbmc6IGZ1bmN0aW9uIChsYXRsbmdzKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0QXJyID0gWzBdLFxuICAgICAgICAgICAgICAgIHBvbHlMZW4gPSB0aGlzLl9nZXRQb2x5bGluZUxlbmd0aChsYXRsbmdzKSxcbiAgICAgICAgICAgICAgICByZXN1bHQsXG4gICAgICAgICAgICAgICAgc2VnbWVudFJhdGlvLFxuICAgICAgICAgICAgICAgIHNlZ21lbnRMZW5ndGg7XG5cbiAgICAgICAgICAgIGlmIChsYXRsbmdzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9ICcwOyAwLjMzOyAwLjQ5NTsgMC42NjsgMC43NzsgMC44ODsgMC45MzU7IDEnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobGF0bG5ncy5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSAnMDsgMC4zMzsgMC4zNDsgMSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChsYXRsbmdzLmxlbmd0aCA9PT0gNCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9ICcwOyAwLjI1OyAwLjI2OyAwLjU7IDAuNTE7IDEnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBsYXRsbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlZ21lbnRMZW5ndGggPSBsYXRsbmdzW2kgLSAxXS5kaXN0YW5jZVRvKGxhdGxuZ3NbaV0pO1xuICAgICAgICAgICAgICAgICAgICBzZWdtZW50UmF0aW8gPSBzZWdtZW50TGVuZ3RoIC8gcG9seUxlbjtcblxuICAgICAgICAgICAgICAgICAgICByZXN1bHRBcnIucHVzaChyZXN1bHRBcnJbcmVzdWx0QXJyLmxlbmd0aCAtIDFdICsgc2VnbWVudFJhdGlvKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoaSA8IGxhdGxuZ3MubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gMiBwb2ludHMgZm9yIGVhY2ggdmVydGljZSAoYnV0IG5vdCBmb3IgZmlyc3QgYW5kIGxhc3QpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRBcnIucHVzaChyZXN1bHRBcnJbcmVzdWx0QXJyLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxhc3QgcG9pbnQgc2hvdWxkIGJlIDEsIGJ1dCBzb21lIHRpbWVzIGl0IGxvb2tzIGxpa2UgMC45OTk5Li4uXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRBcnJbcmVzdWx0QXJyLmxlbmd0aCAtIDFdID0gMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdEFyci5qb2luKCc7ICcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuXG4gICAgICAgIF9nZXRBbmltYXRpb25UaW1lOiBmdW5jdGlvbiAodmVydGljZXNDb3VudCkge1xuICAgICAgICAgICAgaWYgKHZlcnRpY2VzQ291bnQgPT09IDIpIHsgcmV0dXJuICcwLjdzJzsgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmVydGljZXNDb3VudCA9PT0gMyB8fCB2ZXJ0aWNlc0NvdW50ID09PSA0KSB7IHJldHVybiAnMC41cyc7IH1cbiAgICAgICAgICAgIGVsc2UgeyByZXR1cm4gJzAuN3MnOyB9XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbiIsIkRHLkVudHJhbmNlLkV2ZW50SGFuZGxlciA9IERHLkhhbmRsZXIuZXh0ZW5kKHtcblxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIChtYXAsIGVudHJhbmNlKSB7IC8vIChERy5NYXAsIERHLkVudHJhbmNlKVxuICAgICAgICB0aGlzLl9tYXAgPSBtYXA7XG4gICAgICAgIHRoaXMuX2VudHJhbmNlID0gZW50cmFuY2U7XG4gICAgfSxcblxuICAgIGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX21hcC5vbih0aGlzLl9ldmVudHMoKSwgdGhpcyk7XG4gICAgfSxcblxuICAgIHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX21hcC5vZmYodGhpcy5fZXZlbnRzKCksIHRoaXMpO1xuICAgIH0sXG5cbiAgICBfZXZlbnRzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnbGF5ZXJhZGQnOiB0aGlzLl9yZW1vdmVFbnRyYW5jZSxcbiAgICAgICAgICAgICd6b29tZW5kJzogdGhpcy5fc2hvd09ySGlkZUVudHJhbmNlLFxuICAgICAgICAgICAgJ3Byb2plY3RsZWF2ZSc6IHRoaXMuX3Nob3dPckhpZGVFbnRyYW5jZVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBfc2hvd09ySGlkZUVudHJhbmNlOiBmdW5jdGlvbiAoKSB7IC8vIChERy5FdmVudClcbiAgICAgICAgaWYgKHRoaXMuX21hcC5nZXRab29tKCkgPj0gREcuRW50cmFuY2UuU0hPV19GUk9NX1pPT00pIHtcbiAgICAgICAgICAgIHRoaXMuX2VudHJhbmNlLnNob3coZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fZW50cmFuY2UuaGlkZSgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9yZW1vdmVFbnRyYW5jZTogZnVuY3Rpb24gKGUpIHsgLy8gKERHLkxheWVyRXZlbnQpXG4gICAgICAgIGlmIChlLmxheWVyIGluc3RhbmNlb2YgREcuUG9wdXAgfHxcbiAgICAgICAgICAgIChlLmxheWVyIGluc3RhbmNlb2YgREcuRW50cmFuY2UgJiYgZS5sYXllciAhPT0gdGhpcy5fZW50cmFuY2UpKSB7XG5cbiAgICAgICAgICAgIHRoaXMuX2VudHJhbmNlLnJlbW92ZUZyb20odGhpcy5fbWFwKTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuIiwiREcuTWFwLm1lcmdlT3B0aW9ucyh7XG4gICAgZ2VvY2xpY2tlcjogZmFsc2Vcbn0pO1xuXG5ERy5HZW9jbGlja2VyID0gREcuSGFuZGxlci5leHRlbmQoe1xuICAgIGNsaWNrQ291bnQ6IDAsXG4gICAgcGVuZGluZ0NsaWNrOiAwLFxuICAgIHRpbWVvdXQ6IDI1MCwgLy8gc2hvdWxkIGJlIGVxdWFsIHRvICdkZWxheScgdmFsdWUgaW4gRG91YmxlVGFwIGV2ZW50XG5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbiAobWFwLCBvcHRpb25zKSB7IC8vIChPYmplY3QpXG4gICAgICAgIHRoaXMuX21hcCA9IG1hcDtcbiAgICAgICAgdGhpcy5fY29udHJvbGxlciA9IG5ldyBERy5HZW9jbGlja2VyLkNvbnRyb2xsZXIobWFwLCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgYWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fdG9nZ2xlRXZlbnRzKHRydWUpO1xuXG4gICAgICAgIHRoaXMuX21hcFxuICAgICAgICAgICAgLm9uKCdydWxlcnN0YXJ0JywgdGhpcy5fcGF1c2UsIHRoaXMpXG4gICAgICAgICAgICAub24oJ3J1bGVyZW5kJywgdGhpcy5fdW5wYXVzZSwgdGhpcyk7XG4gICAgfSxcblxuICAgIHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3RvZ2dsZUV2ZW50cygpO1xuXG4gICAgICAgIHRoaXMuX21hcFxuICAgICAgICAgICAgLm9mZigncnVsZXJzdGFydCcsIHRoaXMuX3BhdXNlLCB0aGlzKVxuICAgICAgICAgICAgLm9mZigncnVsZXJlbmQnLCB0aGlzLl91bnBhdXNlLCB0aGlzKTtcbiAgICB9LFxuXG4gICAgX3BhdXNlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3RvZ2dsZUV2ZW50cygpO1xuICAgIH0sXG5cbiAgICBfdW5wYXVzZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBSZWVuYWJsZSBldmVudCBoYW5kbGluZyBvbmx5IGluIGNhc2UgZ2VvY2xpY2tlciBpcyBlbmFibGVkXG4gICAgICAgIGlmICh0aGlzLmVuYWJsZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5fdG9nZ2xlRXZlbnRzKHRydWUpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF90b2dnbGVFdmVudHM6IGZ1bmN0aW9uIChmbGFnKSB7XG4gICAgICAgIHRoaXMuX21hcFtmbGFnID8gJ29uJyA6ICdvZmYnXSh0aGlzLl9tYXBFdmVudHNMaXN0ZW5lcnMsIHRoaXMpO1xuICAgICAgICBpZiAodGhpcy5fbWFwLnBvaSkge1xuICAgICAgICAgICAgdGhpcy5fbWFwLnBvaS5nZXRNZXRhTGF5ZXIoKVtmbGFnID8gJ29uJyA6ICdvZmYnXSgnY2xpY2snLCB0aGlzLl9tYXBFdmVudHNMaXN0ZW5lcnMuY2xpY2ssIHRoaXMpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGdldENvbnRyb2xsZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRyb2xsZXI7XG4gICAgfSxcblxuICAgIF9jaGVja09wZW5Qb3B1cDogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoREcuQnJvd3Nlci5tb2JpbGUgJiYgdGhpcy5fbWFwLl9wb3B1cCAmJlxuICAgICAgICAgICAgKHRoaXMuX21hcC5fcG9wdXAub3B0aW9ucy5jbG9zZU9uQ2xpY2sgfHxcbiAgICAgICAgICAgIHRoaXMuX21hcC5vcHRpb25zLmNsb3NlUG9wdXBPbkNsaWNrKSkge1xuICAgICAgICAgICAgdGhpcy5wb3B1cFdhc09wZW4gPSB0cnVlO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9tYXBFdmVudHNMaXN0ZW5lcnM6IHtcbiAgICAgICAgbGFuZ2NoYW5nZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fY29udHJvbGxlci5yZWludm9rZUhhbmRsZXIoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBwb3B1cGNsb3NlOiBmdW5jdGlvbiAoZSkgeyAvLyAoT2JqZWN0KVxuICAgICAgICAgICAgdGhpcy5fY29udHJvbGxlci5oYW5kbGVQb3B1cENsb3NlKGUucG9wdXApO1xuICAgICAgICB9LFxuXG4gICAgICAgIHByZXByZWNsaWNrOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9jaGVja09wZW5Qb3B1cCgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNsaWNrOiBmdW5jdGlvbiAoZSkgeyAvLyAoT2JqZWN0KVxuICAgICAgICAgICAgaWYgKHRoaXMuY2xpY2tDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xpY2tDb3VudCA9IDE7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2luZ2xlQ2xpY2soZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xpY2tDb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucGVuZGluZ0NsaWNrKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcHVwV2FzT3BlbiA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9zaW5nbGVDbGljazogZnVuY3Rpb24gKGUpIHsgLy8gKE9iamVjdClcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnBlbmRpbmdDbGljayk7XG5cbiAgICAgICAgdGhpcy5wZW5kaW5nQ2xpY2sgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIHByZXByZWNsaWNrIGV2ZW50IG5vdCBhdmFpbGFibGUgaW4gbWV0YSBsYXllclxuICAgICAgICAgICAgaWYgKGUubWV0YSkge1xuICAgICAgICAgICAgICAgIHNlbGYuX2NoZWNrT3BlblBvcHVwKCk7XG4gICAgICAgICAgICAgICAgc2VsZi5fbWFwLmNsb3NlUG9wdXAoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFzZWxmLnBvcHVwV2FzT3Blbikge1xuICAgICAgICAgICAgICAgIHZhciB6b29tID0gc2VsZi5fbWFwLmdldFpvb20oKTtcbiAgICAgICAgICAgICAgICBzZWxmLl9jb250cm9sbGVyLmhhbmRsZUNsaWNrKGUubGF0bG5nLCB6b29tLCBlLm1ldGEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZWxmLmNsaWNrQ291bnQgPSAwO1xuICAgICAgICAgICAgc2VsZi5wb3B1cFdhc09wZW4gPSBmYWxzZTtcbiAgICAgICAgfSwgdGhpcy50aW1lb3V0KTtcbiAgICB9XG59KTtcblxuREcuTWFwLmFkZEluaXRIb29rKCdhZGRIYW5kbGVyJywgJ2dlb2NsaWNrZXInLCBERy5HZW9jbGlja2VyKTtcbiIsIkRHLkdlb2NsaWNrZXIuY2xhbXBIZWxwZXIgPSBmdW5jdGlvbiAoZWwsIGxpbmVDbGFtcCkge1xuICAgIHZhciBtZWFzdXJlLCB0ZXh0LCBsaW5lV2lkdGgsXG4gICAgICAgIGxpbmVTdGFydCwgbGluZUNvdW50LCB3b3JkU3RhcnQsXG4gICAgICAgIGxpbmUsIGxpbmVUZXh0LCB3YXNOZXdMaW5lLFxuICAgICAgICBjZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQuYmluZChkb2N1bWVudCksXG4gICAgICAgIGN0biA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlLmJpbmQoZG9jdW1lbnQpO1xuXG4gICAgLy8gbWVhc3VyZW1lbnQgZWxlbWVudCBpcyBtYWRlIGEgY2hpbGQgb2YgdGhlIGNsYW1wZWQgZWxlbWVudCB0byBnZXQgaXQncyBzdHlsZVxuICAgIG1lYXN1cmUgPSBjZSgnc3BhbicpO1xuXG4gICAgKGZ1bmN0aW9uIChzKSB7XG4gICAgICAgIHMucG9zaXRpb24gPSAnYWJzb2x1dGUnOyAvLyBwcmV2ZW50IHBhZ2UgcmVmbG93XG4gICAgICAgIHMud2hpdGVTcGFjZSA9ICdwcmUnOyAvLyBjcm9zcy1icm93c2VyIHdpZHRoIHJlc3VsdHNcbiAgICAgICAgcy52aXNpYmlsaXR5ID0gJ2hpZGRlbic7IC8vIHByZXZlbnQgZHJhd2luZ1xuICAgICAgICBzLm1hcmdpbiA9ICcwIDE4cHggOHB4IDAnO1xuICAgIH0pKG1lYXN1cmUuc3R5bGUpO1xuXG4gICAgLy8gbWFrZSBzdXJlIHRoZSBlbGVtZW50IGJlbG9uZ3MgdG8gdGhlIGRvY3VtZW50XG4gICAgaWYgKCFlbC5vd25lckRvY3VtZW50IHx8IGVsLm93bmVyRG9jdW1lbnQgIT09IGRvY3VtZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gcmVzZXQgdG8gc2FmZSBzdGFydGluZyB2YWx1ZXNcbiAgICBsaW5lU3RhcnQgPSB3b3JkU3RhcnQgPSAwO1xuICAgIGxpbmVDb3VudCA9IDE7XG4gICAgd2FzTmV3TGluZSA9IGZhbHNlO1xuICAgIGxpbmVXaWR0aCA9IGVsLmNsaWVudFdpZHRoO1xuICAgIC8vIGdldCBhbGwgdGhlIHRleHQsIHJlbW92ZSBhbnkgbGluZSBjaGFuZ2VzXG4gICAgdGV4dCA9IChlbC50ZXh0Q29udGVudCB8fCBlbC5pbm5lclRleHQpLnJlcGxhY2UoL1xcbi9nLCAnICcpO1xuICAgIC8vIHJlbW92ZSBhbGwgY29udGVudFxuICAgIHdoaWxlIChlbC5maXJzdENoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIGVsLnJlbW92ZUNoaWxkKGVsLmZpcnN0Q2hpbGQpO1xuICAgIH1cbiAgICAvLyBhZGQgbWVhc3VyZW1lbnQgZWxlbWVudCB3aXRoaW4gc28gaXQgaW5oZXJpdHMgc3R5bGVzXG4gICAgZWwuYXBwZW5kQ2hpbGQobWVhc3VyZSk7XG4gICAgLy8gaHR0cDovL2Vqb2huLm9yZy9ibG9nL3NlYXJjaC1hbmQtZG9udC1yZXBsYWNlL1xuICAgIHRleHQucmVwbGFjZSgvIHwtL2csIGZ1bmN0aW9uIChtLCBwb3MpIHtcbiAgICAgICAgLy8gaWdub3JlIGFueSBmdXJ0aGVyIHByb2Nlc3NpbmcgaWYgd2UgaGF2ZSB0b3RhbCBsaW5lc1xuICAgICAgICBpZiAobGluZUNvdW50ID09PSBsaW5lQ2xhbXApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBjcmVhdGUgYSB0ZXh0IG5vZGUgYW5kIHBsYWNlIGl0IGluIHRoZSBtZWFzdXJlbWVudCBlbGVtZW50XG4gICAgICAgIG1lYXN1cmUuYXBwZW5kQ2hpbGQoY3RuKHRleHQuc3Vic3RyKGxpbmVTdGFydCwgcG9zIC0gbGluZVN0YXJ0KSkpO1xuICAgICAgICAvLyBoYXZlIHdlIGV4Y2VlZGVkIGFsbG93ZWQgbGluZSB3aWR0aD9cbiAgICAgICAgaWYgKGxpbmVXaWR0aCA8IG1lYXN1cmUuY2xpZW50V2lkdGgpIHtcbiAgICAgICAgICAgIGlmICh3YXNOZXdMaW5lKSB7XG4gICAgICAgICAgICAgICAgLy8gd2UgaGF2ZSBhIGxvbmcgd29yZCBzbyBpdCBnZXRzIGEgbGluZSBvZiBpdCdzIG93blxuICAgICAgICAgICAgICAgIGxpbmVUZXh0ID0gdGV4dC5zdWJzdHIobGluZVN0YXJ0LCBwb3MgKyAxIC0gbGluZVN0YXJ0KTtcbiAgICAgICAgICAgICAgICAvLyBuZXh0IGxpbmUgc3RhcnQgcG9zaXRpb25cbiAgICAgICAgICAgICAgICBsaW5lU3RhcnQgPSBwb3MgKyAxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBncmFiIHRoZSB0ZXh0IHVudGlsIHRoaXMgd29yZFxuICAgICAgICAgICAgICAgIGxpbmVUZXh0ID0gdGV4dC5zdWJzdHIobGluZVN0YXJ0LCB3b3JkU3RhcnQgLSBsaW5lU3RhcnQpO1xuICAgICAgICAgICAgICAgIC8vIG5leHQgbGluZSBzdGFydCBwb3NpdGlvblxuICAgICAgICAgICAgICAgIGxpbmVTdGFydCA9IHdvcmRTdGFydDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNyZWF0ZSBhIGxpbmUgZWxlbWVudFxuICAgICAgICAgICAgbGluZSA9IGNlKCdzcGFuJyk7XG4gICAgICAgICAgICAvLyBhZGQgdGV4dCB0byB0aGUgbGluZSBlbGVtZW50XG4gICAgICAgICAgICBsaW5lLmFwcGVuZENoaWxkKGN0bihsaW5lVGV4dCkpO1xuICAgICAgICAgICAgLy8gYWRkIHRoZSBsaW5lIGVsZW1lbnQgdG8gdGhlIGNvbnRhaW5lclxuICAgICAgICAgICAgZWwuYXBwZW5kQ2hpbGQobGluZSk7XG4gICAgICAgICAgICBsaW5lLmNsYXNzTmFtZSA9ICdkZy1tYXAtZ2VvY2xpY2tlcl9fY2xhbXBlZC1saW5lJztcbiAgICAgICAgICAgIC8vIHllcywgd2UgY3JlYXRlZCBhIG5ldyBsaW5lXG4gICAgICAgICAgICB3YXNOZXdMaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgIGxpbmVDb3VudCsrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gZGlkIG5vdCBjcmVhdGUgYSBuZXcgbGluZVxuICAgICAgICAgICAgd2FzTmV3TGluZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlbWVtYmVyIGxhc3Qgd29yZCBzdGFydCBwb3NpdGlvblxuICAgICAgICB3b3JkU3RhcnQgPSBwb3MgKyAxO1xuICAgICAgICAvLyBjbGVhciBtZWFzdXJlbWVudCBlbGVtZW50XG4gICAgICAgIG1lYXN1cmUucmVtb3ZlQ2hpbGQobWVhc3VyZS5maXJzdENoaWxkKTtcbiAgICB9KTtcbiAgICAvLyByZW1vdmUgdGhlIG1lYXN1cmVtZW50IGVsZW1lbnQgZnJvbSB0aGUgY29udGFpbmVyXG4gICAgZWwucmVtb3ZlQ2hpbGQobWVhc3VyZSk7XG4gICAgLy8gY3JlYXRlIHRoZSBsYXN0IGxpbmUgZWxlbWVudFxuICAgIGxpbmUgPSBjZSgnc3BhbicpO1xuICAgIC8vIGdpdmUgc3R5bGVzIHJlcXVpcmVkIGZvciB0ZXh0LW92ZXJmbG93IHRvIGtpY2sgaW5cbiAgICBsaW5lLmNsYXNzTmFtZSA9ICdkZy1tYXAtZ2VvY2xpY2tlcl9fY2xhbXBlZC1saW5lIGRnLW1hcC1nZW9jbGlja2VyX19jbGFtcGVkLWxpbmVfbGFzdCc7XG4gICAgLy8gYWRkIGFsbCByZW1haW5pbmcgdGV4dCB0byB0aGUgbGluZSBlbGVtZW50XG4gICAgbGluZS5hcHBlbmRDaGlsZChjdG4odGV4dC5zdWJzdHIobGluZVN0YXJ0KSkpO1xuICAgIC8vIGFkZCB0aGUgbGluZSBlbGVtZW50IHRvIHRoZSBjb250YWluZXJcbiAgICBlbC5hcHBlbmRDaGlsZChsaW5lKTtcbn07XG4iLCJERy5HZW9jbGlja2VyLlByb3ZpZGVyID0ge307XG4iLCJERy5HZW9jbGlja2VyLlByb3ZpZGVyLkNhdGFsb2dBcGkgPSBERy5DbGFzcy5leHRlbmQoe1xuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgdXJsR2VvU2VhcmNoOiAnaHR0cDovL2NhdGFsb2cuYXBpLjJnaXMucnUvMi4wL2dlby9zZWFyY2gnLFxuICAgICAgICB1cmxHZW9HZXQ6ICdodHRwOi8vY2F0YWxvZy5hcGkuMmdpcy5ydS8yLjAvZ2VvL2dldCcsXG4gICAgICAgIHVybERldGFpbHM6ICdodHRwOi8vY2F0YWxvZy5hcGkuMmdpcy5ydS8yLjAvY2F0YWxvZy9icmFuY2gvZ2V0JyxcbiAgICAgICAgdXJsRmlybXNJbkhvdXNlOiAnaHR0cDovL2NhdGFsb2cuYXBpLjJnaXMucnUvMi4wL2NhdGFsb2cvYnJhbmNoL2xpc3QnLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICBrZXk6ICdydXhsaWgwNzE4J1xuICAgICAgICB9LFxuICAgICAgICBnZW9GaWVsZHM6ICdpdGVtcy5nZW9tZXRyeS5zZWxlY3Rpb24saXRlbXMubGlua3MsaXRlbXMuYWRtX2RpdixpdGVtcy5hZGRyZXNzLGl0ZW1zLmZsb29ycyxpdGVtcy5kZXNjcmlwdGlvbicsXG4gICAgICAgIGZpcm1JbmZvRmllbGRzOiAnaXRlbXMucmV2aWV3cyxpdGVtcy5waG90b3MsaXRlbXMubGlua3MsaXRlbXMuZXh0ZXJuYWxfY29udGVudCcsXG5cbiAgICAgICAgdGltZW91dE1zOiA1MDAwXG4gICAgfSxcblxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIChtYXApIHsgLy8gKE9iamVjdClcbiAgICAgICAgdGhpcy5fbWFwID0gbWFwO1xuICAgIH0sXG5cbiAgICBnZXRMb2NhdGlvbnM6IGZ1bmN0aW9uIChvcHRpb25zKSB7IC8vIChPYmplY3QpXG4gICAgICAgIC8vIENhbGxiYWNrIHdpbGwgcmVjZWl2ZSBhcnJheSBvZiBmb3VuZCByZXN1bHRzIG9yIHZvaWQgaWYgZXJyb3JzIG9jY3VycmVkIG9yIG5vdGhpbmcgd2FzIGZvdW5kLlxuICAgICAgICB2YXIgem9vbSA9IG9wdGlvbnMuem9vbSxcbiAgICAgICAgICAgIGxhdGxuZyA9IG9wdGlvbnMubGF0bG5nLFxuICAgICAgICAgICAgYmVmb3JlUmVxdWVzdCA9IG9wdGlvbnMuYmVmb3JlUmVxdWVzdCB8fCBmdW5jdGlvbiAoKSB7fSxcbiAgICAgICAgICAgIHR5cGVzID0gdGhpcy5nZXRUeXBlc0J5Wm9vbSh6b29tKSxcbiAgICAgICAgICAgIHEgPSBsYXRsbmcubG5nICsgJywnICsgbGF0bG5nLmxhdDtcblxuICAgICAgICBpZiAoIXR5cGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ25vIHR5cGUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJlZm9yZVJlcXVlc3QoKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5nZW9TZWFyY2gocSwgdHlwZXMsIHpvb20pLnRoZW4oREcuYmluZChmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZmlsdGVyUmVzcG9uc2UocmVzdWx0LCB0eXBlcyk7XG4gICAgICAgIH0sIHRoaXMpKTtcbiAgICB9LFxuXG4gICAgZmlybXNJbkhvdXNlOiBmdW5jdGlvbiAoaG91c2VJZCwgcGFyYW1ldGVycykgeyAvLyAoU3RyaW5nLCBGdW5jdGlvbiwgTnVtYmVyKVxuICAgICAgICBwYXJhbWV0ZXJzID0gcGFyYW1ldGVycyB8fCB7fTtcblxuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBjYW1lbGNhc2UgKi9cbiAgICAgICAgdmFyIHBhcmFtcyA9IERHLmV4dGVuZCh0aGlzLm9wdGlvbnMuZGF0YSwge1xuICAgICAgICAgICAgYnVpbGRpbmdfaWQ6IGhvdXNlSWQsXG4gICAgICAgICAgICBwYWdlOiBwYXJhbWV0ZXJzLnBhZ2UgfHwgMVxuICAgICAgICB9KTtcbiAgICAgICAgLyogZXNsaW50LWVuYWJsZSBjYW1lbGNhc2UgKi9cblxuICAgICAgICByZXR1cm4gdGhpcy5fcGVyZm9ybVJlcXVlc3QocGFyYW1zLCB0aGlzLm9wdGlvbnMudXJsRmlybXNJbkhvdXNlKTtcbiAgICB9LFxuXG4gICAgZ2V0RmlybUluZm86IGZ1bmN0aW9uIChmaXJtSWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BlcmZvcm1SZXF1ZXN0KHtcbiAgICAgICAgICAgIHR5cGU6ICdmaWxpYWwnLFxuICAgICAgICAgICAgaWQ6IGZpcm1JZCxcbiAgICAgICAgICAgIGZpZWxkczogdGhpcy5vcHRpb25zLmZpcm1JbmZvRmllbGRzXG4gICAgICAgIH0sIHRoaXMub3B0aW9ucy51cmxEZXRhaWxzKTtcbiAgICB9LFxuXG4gICAgZ2VvU2VhcmNoOiBmdW5jdGlvbiAocSwgdHlwZXMsIHpvb21sZXZlbCkgeyAvLyAoU3RyaW5nLCBTdHJpbmcsIE51bWJlcilcbiAgICAgICAgLyogZXNsaW50LWRpc2FibGUgY2FtZWxjYXNlICovXG4gICAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgICAgICBwb2ludDogcSxcbiAgICAgICAgICAgIHR5cGU6IHR5cGVzLFxuICAgICAgICAgICAgem9vbV9sZXZlbDogem9vbWxldmVsLFxuICAgICAgICAgICAgZmllbGRzOiB0aGlzLm9wdGlvbnMuZ2VvRmllbGRzXG4gICAgICAgIH07XG4gICAgICAgIC8qIGVzbGludC1lbmFibGUgY2FtZWxjYXNlICovXG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3BlcmZvcm1SZXF1ZXN0KHBhcmFtcywgdGhpcy5vcHRpb25zLnVybEdlb1NlYXJjaCk7XG4gICAgfSxcblxuICAgIGdlb0dldDogZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICBmaWVsZHM6IHRoaXMub3B0aW9ucy5nZW9GaWVsZHNcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fcGVyZm9ybVJlcXVlc3QocGFyYW1zLCB0aGlzLm9wdGlvbnMudXJsR2VvR2V0KTtcbiAgICB9LFxuXG4gICAgY2FuY2VsTGFzdFJlcXVlc3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2xhc3RSZXF1ZXN0KSB7XG4gICAgICAgICAgICB0aGlzLl9sYXN0UmVxdWVzdC5hYm9ydCgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGdldFR5cGVzQnlab29tOiBmdW5jdGlvbiAoem9vbSkgeyAvLyAoTnVtYmVyKSAtPiBTdHJpbmd8TnVsbFxuICAgICAgICB2YXIgdHlwZXMgPSB7XG4gICAgICAgICAgICAnYWRtX2Rpdi5zZXR0bGVtZW50JzogICA4LFxuICAgICAgICAgICAgJ2FkbV9kaXYuY2l0eSc6ICAgICAgICAgOCxcbiAgICAgICAgICAgICdhZG1fZGl2LmRpdmlzaW9uJzogICAgIDExLFxuICAgICAgICAgICAgJ2FkbV9kaXYuZGlzdHJpY3QnOiAgICAgMTIsXG4gICAgICAgICAgICAnc3RyZWV0JzogICAgICAgICAgICAgICAxNCxcbiAgICAgICAgICAgICdidWlsZGluZyc6ICAgICAgICAgICAgIDE0LFxuICAgICAgICAgICAgJ2FkbV9kaXYucGxhY2UnOiAgICAgICAgMTUsXG4gICAgICAgICAgICAncG9pJzogICAgICAgICAgICAgICAgICAxNSxcbiAgICAgICAgICAgICdhdHRyYWN0aW9uJzogICAgICAgICAgIDE3XG4gICAgICAgIH0sXG4gICAgICAgIHNlbGVjdGVkVHlwZXMgPSBbXTtcblxuICAgICAgICBPYmplY3Qua2V5cyh0eXBlcykuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICAgICAgaWYgKHpvb20gPj0gdHlwZXNbdHlwZV0pIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZFR5cGVzLnB1c2godHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChzZWxlY3RlZFR5cGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHNlbGVjdGVkVHlwZXMuam9pbignLCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX3BlcmZvcm1SZXF1ZXN0OiBmdW5jdGlvbiAocGFyYW1zLCB1cmwpIHsgLy8gKE9iamVjdCwgU3RyaW5nLCBGdW5jdGlvbiwgRnVuY3Rpb24pXG4gICAgICAgIHZhciBzb3VyY2UgPSB0aGlzLm9wdGlvbnMuZGF0YSxcbiAgICAgICAgICAgIGRhdGEgPSBERy5leHRlbmQoeyAvLyBUT0RPIGNsb25lIGZ1bmN0aW9uIHNob3VsZCBiZSB1c2VkIGluc3RlYWQgb2YgbWFudWFsbHkgY29weWluZ1xuICAgICAgICAgICAgICAgIGtleTogc291cmNlLmtleVxuICAgICAgICAgICAgfSwgcGFyYW1zKSxcbiAgICAgICAgICAgIHR5cGUgPSAnZ2V0JztcblxuICAgICAgICB0aGlzLmNhbmNlbExhc3RSZXF1ZXN0KCk7XG5cbiAgICAgICAgaWYgKCFERy5hamF4LmNvcnNTdXBwb3J0KSB7XG4gICAgICAgICAgICB0eXBlID0gZGF0YS5mb3JtYXQgPSAnanNvbnAnO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbGFzdFJlcXVlc3QgPSBERy5hamF4KHVybCwge1xuICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgICB0aW1lb3V0OiB0aGlzLm9wdGlvbnMudGltZW91dE1zXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9sYXN0UmVxdWVzdDtcbiAgICB9LFxuXG4gICAgX2ZpbHRlclJlc3BvbnNlOiBmdW5jdGlvbiAocmVzcG9uc2UsIGFsbG93ZWRUeXBlcykgeyAvLyAoT2JqZWN0LCBBcnJheSkgLT4gQm9vbGVhbnxPYmplY3RcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9LCBpLCBpdGVtLCBmb3VuZCwgZGF0YSwgdHlwZTtcblxuICAgICAgICBpZiAodGhpcy5faXNOb3RGb3VuZChyZXNwb25zZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRhdGEgPSByZXNwb25zZS5yZXN1bHQuaXRlbXM7XG5cbiAgICAgICAgZm9yIChpID0gZGF0YS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgaXRlbSA9IGRhdGFbaV07XG5cbiAgICAgICAgICAgIHR5cGUgPSBpdGVtLnR5cGU7XG4gICAgICAgICAgICBpZiAoaXRlbS5zdWJ0eXBlKSB7XG4gICAgICAgICAgICAgICAgdHlwZSArPSAnLicgKyBpdGVtLnN1YnR5cGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChhbGxvd2VkVHlwZXMgJiYgYWxsb3dlZFR5cGVzLmluZGV4T2YodHlwZSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlc3VsdFt0eXBlXSA9IGl0ZW07XG4gICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZm91bmQpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX2lzTm90Rm91bmQ6IGZ1bmN0aW9uIChyZXNwb25zZSkgeyAvLyAoT2JqZWN0KSAtPiBCb29sZWFuXG4gICAgICAgIHJldHVybiAhcmVzcG9uc2UgfHxcbiAgICAgICAgICAgICAgICEhcmVzcG9uc2UubWV0YSAmJiAhIXJlc3BvbnNlLm1ldGEuZXJyb3IgfHxcbiAgICAgICAgICAgICAgICFyZXNwb25zZS5yZXN1bHQgfHxcbiAgICAgICAgICAgICAgICFyZXNwb25zZS5yZXN1bHQuaXRlbXMgfHxcbiAgICAgICAgICAgICAgICFyZXNwb25zZS5yZXN1bHQuaXRlbXMubGVuZ3RoO1xuICAgIH1cblxufSk7XG4iLCJERy5HZW9jbGlja2VyLkhhbmRsZXIgPSB7fTtcbiIsIkRHLkdlb2NsaWNrZXIuSGFuZGxlci5EZWZhdWx0ID0gREcuQ2xhc3MuZXh0ZW5kKHtcblxuICAgIGluY2x1ZGVzOiBERy5Mb2NhbGUsXG5cbiAgICBzdGF0aWNzOiB7XG4gICAgICAgIERpY3Rpb25hcnk6IHt9XG4gICAgfSxcblxuICAgIF9ldmVudEhhbmRsZXJzOiB7fSxcblxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIChjb250cm9sbGVyLCB2aWV3LCBtYXApIHsgLy8gKE9iamVjdCwgT2JqZWN0LCBPYmplY3QpXG4gICAgICAgIHRoaXMuX2NvbnRyb2xsZXIgPSBjb250cm9sbGVyO1xuICAgICAgICB0aGlzLl92aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy5fbWFwID0gbWFwO1xuICAgIH0sXG5cbiAgICBoYW5kbGU6IGZ1bmN0aW9uICgpIHsgLy8gKCkgLT4gUHJvbWlzZVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgICAgIHRtcGw6ICdwb3B1cEhlYWRlcicsXG4gICAgICAgICAgICBkYXRhOiB7J3RpdGxlJzogdGhpcy50KCd3ZV9oYXZlX25vdCcpfVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgYWRkQ2xpY2tFdmVudDogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl92aWV3Ll9wb3B1cC5vbignY2xpY2snLCB0aGlzLl9ydW5FdmVudEhhbmRsZXJzLCB0aGlzKTtcbiAgICAgICAgdGhpcy5fbWFwLm9uY2UoJ3BvcHVwY2xvc2UnLCB0aGlzLl9yZW1vdmVDbGlja0V2ZW50LCB0aGlzKTtcbiAgICB9LFxuXG4gICAgX3JlbW92ZUNsaWNrRXZlbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fdmlldy5fcG9wdXAub2ZmKCdjbGljaycsIHRoaXMuX3J1bkV2ZW50SGFuZGxlcnMsIHRoaXMpO1xuICAgIH0sXG5cbiAgICBfYWRkRXZlbnRIYW5kbGVyOiBmdW5jdGlvbiAoZWwsIGhhbmRsZXIpIHsgLy8gKFN0cmluZywgRnVuY3Rpb24pXG4gICAgICAgIHRoaXMuX2V2ZW50SGFuZGxlcnNbZWxdID0gaGFuZGxlcjtcbiAgICB9LFxuXG4gICAgX3J1bkV2ZW50SGFuZGxlcnM6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdmFyIHRhcmdldCA9IGUub3JpZ2luYWxFdmVudC50YXJnZXQ7XG5cbiAgICAgICAgZm9yICh2YXIgZXZlbnRDbGFzcyBpbiB0aGlzLl9ldmVudEhhbmRsZXJzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fZXZlbnRIYW5kbGVycy5oYXNPd25Qcm9wZXJ0eShldmVudENsYXNzKSAmJiB0YXJnZXQuY2xhc3NOYW1lLmluZGV4T2YoZXZlbnRDbGFzcykgPiAtMSkge1xuICAgICAgICAgICAgICAgIERHLkRvbUV2ZW50LnByZXZlbnREZWZhdWx0KGUub3JpZ2luYWxFdmVudCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRIYW5kbGVyc1tldmVudENsYXNzXS5jYWxsKHRoaXMsIHRhcmdldCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9jbGVhckV2ZW50SGFuZGxlcnM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fZXZlbnRIYW5kbGVycyA9IHt9O1xuICAgIH0sXG5cbiAgICBfZ2V0RGlyZWN0aW9uc1VybDogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIERHLlV0aWwudGVtcGxhdGUoJ2h0dHA6Ly8yZ2lzLntkb21haW59L3twcm9qZWN0Q29kZX0vY2VudGVyL3tjZW50ZXJ9L3pvb20ve3pvb219L3JvdXRlVGFiL3JzVHlwZS97cnNUeXBlfS90by97cG9pbnR94pWOe25hbWV9Jywge1xuICAgICAgICAgICAgJ2RvbWFpbic6IHRoaXMuX21hcC5wcm9qZWN0RGV0ZWN0b3IuZ2V0UHJvamVjdCgpLmRvbWFpbixcbiAgICAgICAgICAgICdwcm9qZWN0Q29kZSc6IHRoaXMuX21hcC5wcm9qZWN0RGV0ZWN0b3IuZ2V0UHJvamVjdCgpLmNvZGUsXG4gICAgICAgICAgICAnY2VudGVyJzogdGhpcy5fbWFwLmdldENlbnRlcigpLmxuZyArICcsJyArIHRoaXMuX21hcC5nZXRDZW50ZXIoKS5sYXQsXG4gICAgICAgICAgICAnem9vbSc6IHRoaXMuX21hcC5nZXRab29tKCksXG4gICAgICAgICAgICAnbmFtZSc6IGVuY29kZVVSSUNvbXBvbmVudChuYW1lKSxcbiAgICAgICAgICAgICdyc1R5cGUnOiB0aGlzLl9tYXAucHJvamVjdERldGVjdG9yLmdldFByb2plY3QoKS50cmFuc3BvcnQgPyAnYnVzJyA6ICdjYXInLFxuICAgICAgICAgICAgJ3BvaW50JzogdGhpcy5fcG9wdXAuX2xhdGxuZy5sbmcgKyAnLCcgKyB0aGlzLl9wb3B1cC5fbGF0bG5nLmxhdFxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgX2dldERyaWxsZG93bjogZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgICB2YXIgYWRtRGl2cyA9IFtdLFxuICAgICAgICAgICAgcmVzdWx0O1xuXG4gICAgICAgIGlmIChvYmplY3QuYWRtX2Rpdikge1xuICAgICAgICAgICAgYWRtRGl2cyA9IG9iamVjdC5hZG1fZGl2XG4gICAgICAgICAgICAgICAgLnJlZHVjZShmdW5jdGlvbihhZG1EaXZzLCBhZG1EaXYpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFkbURpdi5uYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZG1EaXZzLnB1c2goYWRtRGl2Lm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFkbURpdnM7XG4gICAgICAgICAgICAgICAgfSwgW10pXG4gICAgICAgICAgICAgICAgLnJldmVyc2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhZG1EaXZzLmxlbmd0aCAmJiBvYmplY3QuYWRkcmVzcyAmJiBvYmplY3QuYWRkcmVzcy5wb3N0Y29kZSkge1xuICAgICAgICAgICAgYWRtRGl2cy5wdXNoKG9iamVjdC5hZGRyZXNzLnBvc3Rjb2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdCA9IGFkbURpdnMuam9pbignLCAnKTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxufSk7XG5cblxuREcuR2VvY2xpY2tlci5IYW5kbGVyLkhhbmRsZXJFeGFtcGxlID0gREcuR2VvY2xpY2tlci5IYW5kbGVyLkRlZmF1bHQuZXh0ZW5kKHtcblxuICAgIGhhbmRsZTogZnVuY3Rpb24gKHJlc3VsdHMsIHR5cGUpIHsgLy8gKE9iamVjdCwgU3RyaW5nKSAtPiBQcm9taXNlXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICAgICAgdG1wbDogdHlwZSArICc6PGJyLz4nICsgcmVzdWx0c1t0eXBlXS5pZFxuICAgICAgICB9KTtcbiAgICB9XG59KTtcbiIsIkRHLkdlb2NsaWNrZXIuSGFuZGxlci5BcGlFcnJvciA9IERHLkdlb2NsaWNrZXIuSGFuZGxlci5EZWZhdWx0LmV4dGVuZCh7XG4gICAgaGFuZGxlOiBmdW5jdGlvbiAoKSB7IC8vICgpIC0+IFByb21pc2VcbiAgICAgICAgdmFyIGhlYWRlciA9IHRoaXMuX3ZpZXcucmVuZGVyKHtcbiAgICAgICAgICAgIHRtcGw6ICdwb3B1cEhlYWRlcicsXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgdGl0bGU6IHRoaXMudCgnYXBpRXJyb3JUaXRsZScpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICAgICAgaGVhZGVyOiBoZWFkZXIsXG4gICAgICAgICAgICB0bXBsOiB0aGlzLnQoJ2FwaUVycm9yQm9keScpXG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuIiwiREcuR2VvY2xpY2tlci5IYW5kbGVyLkNpdHlBcmVhID0gREcuR2VvY2xpY2tlci5IYW5kbGVyLkRlZmF1bHQuZXh0ZW5kKHtcblxuICAgIF9wb2x5bGluZVN0eWxlRGVmYXVsdCA6IHtcbiAgICAgICAgZmlsbENvbG9yOiAnI2ZmOTM4NycsXG4gICAgICAgIGNvbG9yOiAnI2ZmOTM4NycsXG4gICAgICAgIGNsaWNrYWJsZTogZmFsc2UsXG4gICAgICAgIG5vQ2xpcDogdHJ1ZSxcbiAgICAgICAgb3BhY2l0eTogMVxuICAgIH0sXG5cbiAgICBfcG9seWxpbmVTdHlsZXMgOiB7XG4gICAgICAgIDExIDoge1xuICAgICAgICAgICAgZmlsbE9wYWNpdHk6IDAuMTgsXG4gICAgICAgICAgICB3ZWlnaHQ6IDFcbiAgICAgICAgfSxcbiAgICAgICAgMTIgOiB7XG4gICAgICAgICAgICBmaWxsT3BhY2l0eTogMC4xMixcbiAgICAgICAgICAgIHdlaWdodDogMVxuICAgICAgICB9LFxuICAgICAgICAxMyA6IHtcbiAgICAgICAgICAgIGZpbGxPcGFjaXR5OiAwLjA4LFxuICAgICAgICAgICAgd2VpZ2h0OiAyXG4gICAgICAgIH0sXG4gICAgICAgIDE4IDoge1xuICAgICAgICAgICAgZmlsbE9wYWNpdHk6IDAsXG4gICAgICAgICAgICB3ZWlnaHQ6IDNcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBoYW5kbGU6IGZ1bmN0aW9uIChyZXN1bHRzLCB0eXBlKSB7IC8vIChPYmplY3QsIFN0cmluZykgLT4gUHJvbWlzZVxuICAgICAgICBpZiAoIXJlc3VsdHNbdHlwZV0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5fc3R5bGVzSW5pdGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9pbml0U3R5bGVzKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9wb3B1cCA9IHRoaXMuX3ZpZXcuZ2V0UG9wdXAoKTtcblxuICAgICAgICB0aGlzLl9nZW9tZXRyeVpvb21TdHlsZSA9IHRoaXMuX2dldFBvbHlTdHlsZU51bSgpO1xuICAgICAgICB0aGlzLl9nZW9tZXRyeSA9IERHLldrdC5nZW9Kc29uTGF5ZXIocmVzdWx0c1t0eXBlXS5nZW9tZXRyeS5zZWxlY3Rpb24sIHtcbiAgICAgICAgICAgIHN0eWxlOiB0aGlzLl9wb2x5bGluZVN0eWxlc1t0aGlzLl9nZW9tZXRyeVpvb21TdHlsZV1cbiAgICAgICAgfSkuYWRkVG8odGhpcy5fbWFwKTtcblxuICAgICAgICB0aGlzLl9tYXBcbiAgICAgICAgICAgIC5vbignem9vbWVuZCcsIHRoaXMuX3VwZGF0ZUdlb21ldHJ5LCB0aGlzKVxuICAgICAgICAgICAgLm9uY2UoJ3BvcHVwY2xvc2UnLCB0aGlzLl9jbGVhclBvcHVwLCB0aGlzKTtcblxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2ZpbGxDaXR5QXJlYU9iamVjdChyZXN1bHRzLCB0eXBlKSk7XG4gICAgfSxcblxuICAgIF9maWxsQ2l0eUFyZWFPYmplY3Q6IGZ1bmN0aW9uIChyZXN1bHRzLCB0eXBlKSB7XG4gICAgICAgIHZhciBkYXRhID0ge1xuICAgICAgICAgICAgbmFtZTogdGhpcy50KCdub25hbWUnKSxcbiAgICAgICAgICAgIGRyaWxsZG93bjogJycsXG4gICAgICAgICAgICBwdXJwb3NlOiB0aGlzLnQodHlwZSksXG4gICAgICAgICAgICB0eXBlOiB0eXBlLnNwbGl0KCcuJykuam9pbignXycpXG4gICAgICAgIH07XG5cbiAgICAgICAgZGF0YS5kcmlsbGRvd24gPSB0aGlzLl9nZXREcmlsbGRvd24ocmVzdWx0c1t0eXBlXSk7XG5cbiAgICAgICAgaWYgKHJlc3VsdHNbdHlwZV0ubmFtZSkge1xuICAgICAgICAgICAgZGF0YS5uYW1lID0gcmVzdWx0c1t0eXBlXS5uYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRtcGw6ICdjaXR5YXJlYScsXG4gICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgaGVhZGVyOiB0aGlzLl92aWV3LnJlbmRlcih7XG4gICAgICAgICAgICAgICAgdG1wbDogJ3BvcHVwSGVhZGVyJyxcbiAgICAgICAgICAgICAgICBkYXRhOiB7J3RpdGxlJzogZGF0YS5uYW1lfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgX2luaXRTdHlsZXMgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3N0eWxlc0luaXRlZCA9IHRydWU7XG5cbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5fcG9seWxpbmVTdHlsZXMpLmZvckVhY2goZnVuY3Rpb24gKHpvb20pIHtcbiAgICAgICAgICAgIERHLmV4dGVuZCh0aGlzLl9wb2x5bGluZVN0eWxlc1t6b29tXSwgdGhpcy5fcG9seWxpbmVTdHlsZURlZmF1bHQpO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICB9LFxuXG4gICAgX2dldFBvbHlTdHlsZU51bTogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbWFwWm9vbSA9IHRoaXMuX21hcC5nZXRab29tKCk7XG5cbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX3BvbHlsaW5lU3R5bGVzKS5maWx0ZXIoZnVuY3Rpb24gKHpvb20pIHtcbiAgICAgICAgICAgIHJldHVybiBtYXBab29tIDw9IHpvb207XG4gICAgICAgIH0pWzBdIHx8IGZhbHNlO1xuICAgIH0sXG5cbiAgICBfdXBkYXRlR2VvbWV0cnk6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5ld1N0eWxlID0gdGhpcy5fZ2V0UG9seVN0eWxlTnVtKCk7XG5cbiAgICAgICAgaWYgKG5ld1N0eWxlICYmIG5ld1N0eWxlICE9PSB0aGlzLl9nZW9tZXRyeVpvb21TdHlsZSkge1xuICAgICAgICAgICAgdGhpcy5fZ2VvbWV0cnlab29tU3R5bGUgPSBuZXdTdHlsZTtcbiAgICAgICAgICAgIHRoaXMuX2dlb21ldHJ5LnNldFN0eWxlKHRoaXMuX3BvbHlsaW5lU3R5bGVzW25ld1N0eWxlXSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX2NsZWFyUG9wdXA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fbWFwXG4gICAgICAgICAgICAgICAgLnJlbW92ZUxheWVyKHRoaXMuX2dlb21ldHJ5KVxuICAgICAgICAgICAgICAgIC5vZmYoJ3pvb21lbmQnLCB0aGlzLl91cGRhdGVHZW9tZXRyeSwgdGhpcyk7XG4gICAgfVxuXG59KTtcbiIsIi8qZ2xvYmFsIEZpcm1DYXJkICovXG5ERy5HZW9jbGlja2VyLkhhbmRsZXIuSG91c2UgPSBERy5HZW9jbGlja2VyLkhhbmRsZXIuRGVmYXVsdC5leHRlbmQoe1xuXG4gICAgX2Zpcm1zT25QYWdlOiAyMCxcbiAgICBfc2Nyb2xsVGhyb3R0bGVJbnRlcnZhbDogNDAwLFxuICAgIF9zY3JvbGxIZWlnaHRSZXNlcnZlOiA2MCxcblxuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgJ3Nob3dCb29rbGV0JzogdHJ1ZSxcbiAgICAgICAgJ3Nob3dQaG90b3MnOiB0cnVlLFxuICAgICAgICAnc2hvd1JvdXRlU2VhcmNoJzogdHJ1ZVxuICAgIH0sXG5cbiAgICBoYW5kbGU6IGZ1bmN0aW9uIChyZXN1bHRzKSB7IC8vIChPYmplY3QpIC0+IFByb21pc2VcbiAgICAgICAgaWYgKCFyZXN1bHRzLmJ1aWxkaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpbml0aWFsaXphdGlvbiBzZXR1cFxuICAgICAgICB0aGlzLmZpcm1DYXJkID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcGFnZSA9IDE7XG4gICAgICAgIHRoaXMuX2hvdXNlT2JqZWN0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fZmlybUxpc3QgPSBudWxsO1xuICAgICAgICB0aGlzLl9maXJtTGlzdE9iamVjdCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2Zpcm1DYXJkT2JqZWN0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fb25TY3JvbGwgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faXNGaXJtbGlzdE9wZW4gPSBmYWxzZTtcblxuICAgICAgICB0aGlzLl9pZCA9IHJlc3VsdHMuYnVpbGRpbmcuaWQ7XG4gICAgICAgIHRoaXMuX3RvdGFsUGFnZXMgPSAxO1xuICAgICAgICB0aGlzLl9hcGkgPSB0aGlzLl9jb250cm9sbGVyLmdldENhdGFsb2dBcGkoKTtcbiAgICAgICAgdGhpcy5fcG9wdXAgPSB0aGlzLl92aWV3LmdldFBvcHVwKCk7XG4gICAgICAgIHRoaXMuX2luaXRlZFBvcHVwQ2xvc2UgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZGlyZWN0aW9uc1VybCA9IHRoaXMuX2dldERpcmVjdGlvbnNVcmwocmVzdWx0cy5idWlsZGluZy5uYW1lKTtcbiAgICAgICAgdGhpcy5fZmlybUxpc3RMb2FkZXIgPSB0aGlzLl92aWV3LmluaXRMb2FkZXIodHJ1ZSk7XG5cbiAgICAgICAgdGhpcy5faG91c2VPYmplY3QgPSB0aGlzLl9maWxsSG91c2VPYmplY3QocmVzdWx0cy5idWlsZGluZyk7XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLl9ob3VzZU9iamVjdCk7XG4gICAgfSxcblxuICAgIF9pc1JvdXRlU2VhcmNoQWxsb3dlZDogZnVuY3Rpb24oKSB7IC8vKCkgLT4gQm9vbGVhblxuICAgICAgICB2YXIgcHJvamVjdCA9IHRoaXMuX2NvbnRyb2xsZXIuZ2V0TWFwKCkucHJvamVjdERldGVjdG9yLmdldFByb2plY3QoKTtcbiAgICAgICAgcmV0dXJuIHByb2plY3QudHJhbnNwb3J0IHx8IHByb2plY3Qucm9hZHM7XG4gICAgfSxcblxuICAgIF9maXJtQ2FyZFNldHVwOiBmdW5jdGlvbiAoKSB7IC8vKCkgLT4gT2JqZWN0XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZW5kZXI6IHRoaXMuX3ZpZXcuX3RlbXBsYXRlcyxcbiAgICAgICAgICAgIGxhbmc6IHRoaXMuX21hcC5nZXRMYW5nKCksXG4gICAgICAgICAgICBkb21haW46IHRoaXMuX2NvbnRyb2xsZXIuZ2V0TWFwKCkucHJvamVjdERldGVjdG9yLmdldFByb2plY3QoKS5kb21haW4sXG4gICAgICAgICAgICBhamF4OiBERy5iaW5kKHRoaXMuX2FwaS5nZXRGaXJtSW5mbywgdGhpcy5fYXBpKSxcbiAgICAgICAgICAgIHRpbWV6b25lT2Zmc2V0OiB0aGlzLl9jb250cm9sbGVyLmdldE1hcCgpLnByb2plY3REZXRlY3Rvci5nZXRQcm9qZWN0KCkudGltZU9mZnNldCxcbiAgICAgICAgICAgIG1hcDogdGhpcy5fbWFwLFxuICAgICAgICAgICAgcG9wdXA6IHRoaXMuX3BvcHVwLFxuICAgICAgICAgICAgaXNNb2JpbGU6IERHLkJyb3dzZXIubW9iaWxlLFxuICAgICAgICAgICAgc2hvd0VudHJhbmNlOiBERy5FbnRyYW5jZSxcbiAgICAgICAgICAgIGdvdG9Vcmw6IHRoaXMuX2RpcmVjdGlvbnNVcmwsXG4gICAgICAgICAgICBvbkZpcm1SZWFkeTogREcuYmluZCh0aGlzLl9vbkZpcm1SZWFkeSwgdGhpcyksXG4gICAgICAgICAgICBvblRvZ2dsZTogREcuYmluZCh0aGlzLl9wb3B1cC5yZXNpemUsIHRoaXMuX3BvcHVwKSxcbiAgICAgICAgICAgIHNob3dCb29rbGV0OiB0aGlzLm9wdGlvbnMuc2hvd0Jvb2tsZXQsXG4gICAgICAgICAgICBzaG93UGhvdG9zOiB0aGlzLm9wdGlvbnMuc2hvd1Bob3RvcyxcbiAgICAgICAgICAgIHNob3dSb3V0ZVNlYXJjaDogdGhpcy5vcHRpb25zLnNob3dSb3V0ZVNlYXJjaCAmJiB0aGlzLl9pc1JvdXRlU2VhcmNoQWxsb3dlZCgpLFxuICAgICAgICAgICAgdDogREcuYmluZCh0aGlzLnQsIHRoaXMpXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8vIGluaXQgc2luZ2xlIGZpcm0gY2FyZCBpbiBjYXNlIG9mIHBvaVxuICAgIF9maWxsRmlybUNhcmRPYmplY3Q6IGZ1bmN0aW9uIChmaXJtSWQpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLl9maXJtQ2FyZFNldHVwKCk7XG5cbiAgICAgICAgdGhpcy5maXJtQ2FyZCA9IG5ldyBGaXJtQ2FyZChmaXJtSWQsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLl9pbml0UG9wdXBDbG9zZSgpO1xuICAgICAgICByZXR1cm4gdGhpcy5maXJtQ2FyZC5nZXRDb250YWluZXIoKTtcbiAgICB9LFxuXG4gICAgX2Zpcm1MaXN0U2V0dXA6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMuX2Zpcm1DYXJkU2V0dXAoKTtcblxuICAgICAgICBERy5leHRlbmQob3B0aW9ucywge1xuICAgICAgICAgICAgYmFja0J0bjogREcuYmluZCh0aGlzLl9zaG93SG91c2VQb3B1cCwgdGhpcyksXG4gICAgICAgICAgICBvbkZpcm1DbGljazogREcuYmluZCh0aGlzLl9vbkZpcm1MaXN0Q2xpY2ssIHRoaXMpLFxuICAgICAgICAgICAgb25TaG93TGVzczogREcuYmluZCh0aGlzLl9zaG93SG91c2VQb3B1cCwgdGhpcyksXG4gICAgICAgICAgICBwYXN0ZUxvYWRlcjogREcuYmluZCh0aGlzLl9wYXN0ZUxvYWRlciwgdGhpcylcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZpcm1DYXJkOiBvcHRpb25zLFxuICAgICAgICAgICAgZmlybWxpc3RJdGVtVG1wbDogJ2Zpcm1saXN0SXRlbScsXG4gICAgICAgICAgICBvbkxpc3RSZWFkeTogREcuYmluZCh0aGlzLl9yZW5kZXJGaXJtTGlzdCwgdGhpcylcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgX2luaXRTaG9ydEZpcm1MaXN0OiBmdW5jdGlvbiAoZmlybXMpIHsgLy8oT2JqZWN0KSAtPiBET01FbGVtZW50XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5fZmlybUxpc3RTZXR1cCgpO1xuXG4gICAgICAgIHRoaXMuX3Nob3J0RmlybUxpc3QgPSBuZXcgRmlybUNhcmQuTGlzdChmaXJtcywgb3B0aW9ucyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3Nob3J0RmlybUxpc3QucmVuZGVyTGlzdCgpO1xuICAgIH0sXG5cbiAgICBfaW5pdEZpcm1MaXN0OiBmdW5jdGlvbiAocmVzKSB7IC8vKE9iamVjdCkgLT4gUHJvbWlzZVxuICAgICAgICBpZiAoIXJlcykgeyByZXR1cm4gZmFsc2U7IH1cblxuICAgICAgICB2YXIgcmVzdWx0cyA9IHJlcy5yZXN1bHQuaXRlbXMsXG4gICAgICAgICAgICBvcHRpb25zID0gdGhpcy5fZmlybUxpc3RTZXR1cCgpO1xuXG4gICAgICAgIG9wdGlvbnMuZmlybUNhcmQuYmFja0J0biA9IERHLmJpbmQodGhpcy5fc2hvd0xpc3RQb3B1cCwgdGhpcyk7XG5cbiAgICAgICAgdGhpcy5fc2hvcnRGaXJtTGlzdC5fdG9nZ2xlRXZlbnRIYW5kbGVycyh0cnVlKTtcblxuICAgICAgICB0aGlzLl9maXJtTGlzdCA9IG5ldyBGaXJtQ2FyZC5MaXN0KHJlc3VsdHMsIG9wdGlvbnMpO1xuXG4gICAgICAgIHRoaXMuX2Zpcm1MaXN0T2JqZWN0ID0gdGhpcy5fZmlsbEZpcm1MaXN0T2JqZWN0KHRoaXMuX2Zpcm1MaXN0LnJlbmRlckxpc3QoKSk7XG4gICAgICAgIHRoaXMuX2NsZWFyQW5kUmVuZGVyUG9wdXAodGhpcy5fZmlybUxpc3RPYmplY3QpO1xuICAgIH0sXG5cbiAgICBfZmlsbEZpcm1MaXN0T2JqZWN0OiBmdW5jdGlvbiAoZmlybUxpc3QpIHsgLy8oRE9NRWxlbWVudCkgLT4gT2JqZWN0XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG1wbDogZmlybUxpc3QsXG4gICAgICAgICAgICBoZWFkZXI6IHRoaXMuX2hlYWRlcixcbiAgICAgICAgICAgIGZvb3RlcjogdGhpcy5fdmlldy5yZW5kZXIoe1xuICAgICAgICAgICAgICAgIHRtcGw6ICdwb3B1cEZvb3RlckJ0bnMnLFxuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgYnRuczogW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdiYWNrJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogdGhpcy50KCdiYWNrX2J1dHRvbicpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGljb246IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgYWZ0ZXJSZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzZWxmLl9pbml0UG9wdXBDbG9zZSgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuX3RvdGFsUGFnZXMgPiAxICYmIHNlbGYuX2Zpcm1MaXN0TG9hZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFwidGhpc1wiIGhlcmUgaXMgc2VsZi5fZmlybUxpc3RPYmplY3RcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50bXBsLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQoc2VsZi5fZmlybUxpc3RMb2FkZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgX29uRmlybVJlYWR5OiBmdW5jdGlvbiAoZmlybUNvbnRlbnRPYmplY3QpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBmaXJtQ29udGVudE9iamVjdC5hZnRlclJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBoZWFkZXJUaXRsZSA9IHNlbGYuX3BvcHVwLl9wb3B1cFN0cnVjdHVyZS5oZWFkZXIuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIGlmICghREcuQnJvd3Nlci5pZWx0OSkge1xuICAgICAgICAgICAgICAgIGlmIChoZWFkZXJUaXRsZS5vZmZzZXRIZWlnaHQgPiA3MikgeyAvL1RPRE86IG1hZ2ljIG51bWJlclxuICAgICAgICAgICAgICAgICAgICBERy5Eb21VdGlsLmFkZENsYXNzKGhlYWRlclRpdGxlLCAnZGctcG9wdXBfX2hlYWRlci10ZWFzZXInKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFERy5Ccm93c2VyLndlYmtpdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgREcuR2VvY2xpY2tlci5jbGFtcEhlbHBlcihoZWFkZXJUaXRsZSwgMyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2NsZWFyQW5kUmVuZGVyUG9wdXAoZmlybUNvbnRlbnRPYmplY3QpO1xuICAgIH0sXG5cbiAgICBfc2hvd0hvdXNlUG9wdXA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fcG9wdXAub2ZmKCdzY3JvbGwnLCB0aGlzLl9vblNjcm9sbCk7XG4gICAgICAgIHRoaXMuX2NsZWFyQW5kUmVuZGVyUG9wdXAodGhpcy5faG91c2VPYmplY3QpO1xuICAgICAgICB0aGlzLl9zaG9ydEZpcm1MaXN0Ll90b2dnbGVFdmVudEhhbmRsZXJzKCk7XG4gICAgfSxcblxuICAgIF9vbkZpcm1MaXN0Q2xpY2s6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fcG9wdXAub2ZmKCdzY3JvbGwnLCB0aGlzLl9vblNjcm9sbCk7XG4gICAgfSxcblxuICAgIF9wYXN0ZUxvYWRlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbG9hZGVyV3JhcHBlciAgPSBERy5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgJ2RnLW1hcC1nZW9jbGlja2VyX19wcmVsb2FkZXItd3JhcHBlcicpLFxuICAgICAgICAgICAgbG9hZGVyID0gdGhpcy5fdmlldy5pbml0TG9hZGVyKCk7XG5cbiAgICAgICAgbG9hZGVyV3JhcHBlci5pbnNlcnRCZWZvcmUobG9hZGVyLCBsb2FkZXJXcmFwcGVyLmZpcnN0Q2hpbGQpO1xuICAgICAgICBsb2FkZXJXcmFwcGVyLnN0eWxlLmhlaWdodCA9IHRoaXMuX3BvcHVwLl9jb250ZW50Tm9kZS5vZmZzZXRIZWlnaHQgLSAxICsgJ3B4JzsgLy8gTUFHSUNcbiAgICAgICAgbG9hZGVyV3JhcHBlci5zdHlsZS53aWR0aCA9IHRoaXMuX3BvcHVwLl9jb250ZW50Tm9kZS5vZmZzZXRXaWR0aCArICdweCc7XG4gICAgICAgIHRoaXMuX2NsZWFyQW5kUmVuZGVyUG9wdXAoe3RtcGw6IGxvYWRlcldyYXBwZXJ9KTtcbiAgICB9LFxuXG4gICAgX2luaXRQb3B1cENsb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9pbml0ZWRQb3B1cENsb3NlKSB7IHJldHVybjsgfVxuXG4gICAgICAgIHRoaXMuX2NvbnRyb2xsZXIuZ2V0TWFwKCkub25jZSgncG9wdXBjbG9zZScsIERHLmJpbmQodGhpcy5fb25Qb3B1cENsb3NlLCB0aGlzKSk7XG4gICAgICAgIHRoaXMuX2luaXRlZFBvcHVwQ2xvc2UgPSB0cnVlO1xuICAgIH0sXG5cbiAgICBfc2hvd0xpc3RQb3B1cDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZmlybUxpc3QgPSB0aGlzLl9maXJtTGlzdE9iamVjdDtcblxuICAgICAgICB0aGlzLl9wYXN0ZUxvYWRlcigpO1xuXG4gICAgICAgIGlmICghZmlybUxpc3QpIHtcbiAgICAgICAgICAgIGZpcm1MaXN0ID0gdGhpcy5fYXBpLmZpcm1zSW5Ib3VzZSh0aGlzLl9pZCkudGhlbihERy5iaW5kKHRoaXMuX2luaXRGaXJtTGlzdCwgdGhpcykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fY2xlYXJBbmRSZW5kZXJQb3B1cChmaXJtTGlzdCk7XG4gICAgICAgICAgICB0aGlzLl9maXJtTGlzdC5fdG9nZ2xlRXZlbnRIYW5kbGVycygpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLl9vblNjcm9sbCkge1xuICAgICAgICAgICAgdGhpcy5fb25TY3JvbGwgPSBERy5VdGlsLnRocm90dGxlKHRoaXMuX2hhbmRsZVBvcHVwU2Nyb2xsLCB0aGlzLl9zY3JvbGxUaHJvdHRsZUludGVydmFsLCB0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3BvcHVwLm9uKCdzY3JvbGwnLCB0aGlzLl9vblNjcm9sbCk7XG4gICAgfSxcblxuICAgIF9yZW5kZXJGaXJtTGlzdDogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2lzRmlybWxpc3RPcGVuKSB7XG4gICAgICAgICAgICB0aGlzLl9wb3B1cC5yZXNpemUoKTtcbiAgICAgICAgICAgIHRoaXMuX2lzRmlybWxpc3RPcGVuID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfb25Qb3B1cENsb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2luaXRlZFBvcHVwQ2xvc2UgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuX2Zpcm1MaXN0KSB7XG4gICAgICAgICAgICB0aGlzLl9maXJtTGlzdC5jbGVhckxpc3QoKTtcbiAgICAgICAgICAgIHRoaXMuX2Zpcm1MaXN0ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX3BvcHVwLm9mZignc2Nyb2xsJywgdGhpcy5fb25TY3JvbGwpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2Zpcm1JZCA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLmZpcm1DYXJkKSB7XG4gICAgICAgICAgICB0aGlzLmZpcm1DYXJkLl90b2dnbGVFdmVudEhhbmRsZXJzKHRydWUpO1xuICAgICAgICAgICAgdGhpcy5maXJtQ2FyZCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZmlybUxpc3RMb2FkZXIgPSBudWxsO1xuICAgICAgICB0aGlzLl9wYWdlID0gMTtcbiAgICAgICAgdGhpcy5fY2xlYXJFdmVudEhhbmRsZXJzKCk7XG4gICAgfSxcblxuICAgIF9pbml0U2hvd01vcmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGxpbmsgPSB0aGlzLl9wb3B1cC5maW5kRWxlbWVudCgnLmRnLXBvcHVwX19idXR0b25fbmFtZV9hbGwnKTtcblxuICAgICAgICBpZiAobGluaykge1xuICAgICAgICAgICAgdGhpcy5fYWRkRXZlbnRIYW5kbGVyKCdkZy1wb3B1cF9fYnV0dG9uX25hbWVfYWxsJywgREcuYmluZCh0aGlzLl9zaG93TGlzdFBvcHVwLCB0aGlzKSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX2NsZWFyQW5kUmVuZGVyUG9wdXA6IGZ1bmN0aW9uIChwb3B1cE9iamVjdCkge1xuICAgICAgICB0aGlzLl9jbGVhckV2ZW50SGFuZGxlcnMoKTtcbiAgICAgICAgdGhpcy5fcG9wdXAuY2xlYXIoJ2hlYWRlcicsICdmb290ZXInKTtcbiAgICAgICAgdGhpcy5fdmlldy5yZW5kZXJQb3B1cChwb3B1cE9iamVjdCk7XG4gICAgfSxcblxuICAgIF9hcHBlbmRGaXJtTGlzdDogZnVuY3Rpb24gKHJlcykgeyAvLyAoT2JqZWN0KVxuICAgICAgICB0aGlzLl9maXJtTGlzdC5hZGRGaXJtcyhyZXMucmVzdWx0Lml0ZW1zKTtcbiAgICAgICAgdGhpcy5fcG9wdXAuX3VwZGF0ZVNjcm9sbFBvc2l0aW9uKCk7XG4gICAgfSxcblxuICAgIF9oYW5kbGVQb3B1cFNjcm9sbDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIHNjcm9sbGVyID0gZS5vcmlnaW5hbEV2ZW50LnRhcmdldCB8fCBlLnRhcmdldC5fc2Nyb2xsZXI7XG5cbiAgICAgICAgREcuRG9tRXZlbnQuc3RvcChlKTtcblxuICAgICAgICBpZiAodGhpcy5fdG90YWxQYWdlcyA8PSAxKSB7IHJldHVybjsgfVxuICAgICAgICBpZiAoc2Nyb2xsZXIgJiYgc2Nyb2xsZXIuc2Nyb2xsSGVpZ2h0IDw9IHNjcm9sbGVyLnNjcm9sbFRvcCArIHNjcm9sbGVyLm9mZnNldEhlaWdodCArIHRoaXMuX3Njcm9sbEhlaWdodFJlc2VydmUpIHtcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZVBhZ2luZygpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9oYW5kbGVQYWdpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fcGFnZSsrO1xuXG4gICAgICAgIGlmICh0aGlzLl90b3RhbFBhZ2VzICYmIHRoaXMuX3BhZ2UgPD0gdGhpcy5fdG90YWxQYWdlcykge1xuICAgICAgICAgICAgdGhpcy5fYXBpLmZpcm1zSW5Ib3VzZSh0aGlzLl9pZCwge3BhZ2U6IHRoaXMuX3BhZ2V9KS50aGVuKERHLmJpbmQodGhpcy5fYXBwZW5kRmlybUxpc3QsIHRoaXMpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9wYWdlID09PSB0aGlzLl90b3RhbFBhZ2VzKSB7XG4gICAgICAgICAgICB2YXIgbG9hZGVyID0gdGhpcy5fZmlybUxpc3RMb2FkZXI7XG5cbiAgICAgICAgICAgIGlmIChsb2FkZXIgJiYgbG9hZGVyLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICBsb2FkZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChsb2FkZXIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9wb3B1cC5vZmYoJ3Njcm9sbCcsIHRoaXMuX29uU2Nyb2xsKTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuIiwiREcuR2VvY2xpY2tlci5IYW5kbGVyLkhvdXNlLmluY2x1ZGUoe1xuICAgIF9nZXRBZGRyZXNzU3RyaW5nOiBmdW5jdGlvbiAoaG91c2UpIHtcbiAgICAgICAgaWYgKCFob3VzZS5hZGRyZXNzIHx8ICFob3VzZS5hZGRyZXNzLmNvbXBvbmVudHMpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBob3VzZS5hZGRyZXNzLmNvbXBvbmVudHNcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21wb25lbnQudHlwZSA9PT0gJ3N0cmVldF9udW1iZXInO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21wb25lbnQuc3RyZWV0ICsgJywgJyArIGNvbXBvbmVudC5udW1iZXI7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmpvaW4oJyAvICcpO1xuICAgIH0sXG5cbiAgICBfZmlsbEJvZHk6IGZ1bmN0aW9uIChob3VzZSkgeyAvLyAvLyAoT2JqZWN0KSAtPiAoRE9NRWxlbWVudClcbiAgICAgICAgdmFyIGRhdGEgPSB7fSxcbiAgICAgICAgICAgIHdyYXBwZXIgPSBERy5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgJ2RnLWJ1aWxkaW5nLWNhbGxvdXRfX2JvZHknKSxcbiAgICAgICAgICAgIGZpbGlhbHMgPSBob3VzZS5saW5rcy5icmFuY2hlcztcblxuICAgICAgICB2YXIgZHJpbGxkb3duID0gdGhpcy5fZ2V0RHJpbGxkb3duKGhvdXNlKTtcblxuICAgICAgICBpZiAoaG91c2UuYnVpbGRpbmdfbmFtZSkge1xuICAgICAgICAgICAgZGF0YS5hZGRyZXNzID0ge1xuICAgICAgICAgICAgICAgIGhlYWRlcjogdGhpcy5fZ2V0QWRkcmVzc1N0cmluZyhob3VzZSksXG4gICAgICAgICAgICAgICAgZHJpbGxkb3duOiBkcmlsbGRvd25cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoZHJpbGxkb3duKSB7XG4gICAgICAgICAgICBkYXRhLmFkZHJlc3MgPSB7XG4gICAgICAgICAgICAgICAgZHJpbGxkb3duOiBkcmlsbGRvd25cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBkYXRhLnB1cnBvc2UgPSBob3VzZS5wdXJwb3NlX25hbWUgK1xuICAgICAgICAgICAgKGhvdXNlLmZsb29ycyA/ICcsICcgKyB0aGlzLnQoJ25fZmxvb3JzJywgaG91c2UuZmxvb3JzLmdyb3VuZF9jb3VudCkgOiAnJyk7XG5cbiAgICAgICAgaWYgKGhvdXNlLmxpbmtzLmJyYW5jaGVzLmNvdW50ID4gMCkge1xuICAgICAgICAgICAgdGhpcy5fdG90YWxQYWdlcyA9IE1hdGguY2VpbChob3VzZS5saW5rcy5icmFuY2hlcy5jb3VudCAvIHRoaXMuX2Zpcm1zT25QYWdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChob3VzZS5saW5rcy5hdHRyYWN0aW9ucyAmJiBob3VzZS5saW5rcy5hdHRyYWN0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGRhdGEuYXR0cmFjdGlvbnMgPSBob3VzZS5saW5rcy5hdHRyYWN0aW9ucy5yZWR1Y2UoZnVuY3Rpb24oYXR0cmFjdGlvbnMsIGF0dHJhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBpZiAoYXR0cmFjdGlvbi5uYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGF0dHJhY3Rpb25zLnB1c2goYXR0cmFjdGlvbi5uYW1lKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gYXR0cmFjdGlvbnM7XG4gICAgICAgICAgICB9LCBbXSk7XG4gICAgICAgIH1cblxuICAgICAgICB3cmFwcGVyLmlubmVySFRNTCA9IHRoaXMuX3ZpZXcucmVuZGVyKHtcbiAgICAgICAgICAgIHRtcGw6ICdob3VzZScsXG4gICAgICAgICAgICBkYXRhOiBkYXRhXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChmaWxpYWxzLml0ZW1zKSB7XG4gICAgICAgICAgICB3cmFwcGVyLmFwcGVuZENoaWxkKHRoaXMuX2luaXRTaG9ydEZpcm1MaXN0KGZpbGlhbHMuaXRlbXMpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB3cmFwcGVyO1xuICAgIH0sXG5cbiAgICBfZmlsbEhlYWRlcjogZnVuY3Rpb24gKGhvdXNlKSB7IC8vIChPYmplY3QpIC0+IChIVE1MU3RyaW5nKVxuICAgICAgICB2YXIgaGVhZGVyID0ge307XG5cbiAgICAgICAgaWYgKGhvdXNlLmJ1aWxkaW5nX25hbWUpIHtcbiAgICAgICAgICAgIGhlYWRlci50aXRsZSA9IGhvdXNlLmJ1aWxkaW5nX25hbWU7XG4gICAgICAgIH0gZWxzZSBpZiAoaG91c2UuYWRkcmVzcyAmJiBob3VzZS5hZGRyZXNzLmNvbXBvbmVudHMpIHtcbiAgICAgICAgICAgIGhlYWRlci50aXRsZSA9IHRoaXMuX2dldEFkZHJlc3NTdHJpbmcoaG91c2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaGVhZGVyLnRpdGxlID0gaG91c2UucHVycG9zZV9uYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5faGVhZGVyID0gdGhpcy5fdmlldy5yZW5kZXIoe1xuICAgICAgICAgICAgdG1wbDogJ3BvcHVwSGVhZGVyJyxcbiAgICAgICAgICAgIGRhdGE6IGhlYWRlclxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdGhpcy5faGVhZGVyO1xuICAgIH0sXG5cbiAgICBfZmlsbEZvb3RlcjogZnVuY3Rpb24gKGhvdXNlKSB7IC8vIChPYmplY3QpIC0+IChIVE1MU3RyaW5nKVxuICAgICAgICB2YXIgYnRucyA9IFtdO1xuICAgICAgICB2YXIgaG91c2VGaWxpYWxzID0gaG91c2UubGlua3MuYnJhbmNoZXM7XG5cbiAgICAgICAgLy8gRGVjaWRlIGlmIHdlIG5lZWQgdG8gZGlzcGxheSAnbW9yZSBvcmdhbmlzYXRpb25zJyBidXR0b25cbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgaG91c2VGaWxpYWxzLml0ZW1zICYmXG4gICAgICAgICAgICBob3VzZUZpbGlhbHMuaXRlbXMubGVuZ3RoICYmXG4gICAgICAgICAgICBob3VzZUZpbGlhbHMuY291bnQgPiBob3VzZUZpbGlhbHMuaXRlbXMubGVuZ3RoXG4gICAgICAgICkge1xuICAgICAgICAgICAgYnRucy5wdXNoKHRoaXMuX2dldFNob3dBbGxEYXRhKGhvdXNlRmlsaWFscy5jb3VudCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2lzUm91dGVTZWFyY2hBbGxvd2VkKCkpIHtcbiAgICAgICAgICAgIGJ0bnMucHVzaCh7XG4gICAgICAgICAgICAgICAgbmFtZTogJ2dvdG8nLFxuICAgICAgICAgICAgICAgIGxhYmVsOiB0aGlzLnQoJ2dvX3RvJyksXG4gICAgICAgICAgICAgICAgaWNvbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBocmVmOiB0aGlzLl9kaXJlY3Rpb25zVXJsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl92aWV3LnJlbmRlcih7XG4gICAgICAgICAgICB0bXBsOiAncG9wdXBGb290ZXJCdG5zJyxcbiAgICAgICAgICAgIGRhdGE6IHsnYnRucyc6IGJ0bnN9XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBfZ2V0U2hvd0FsbERhdGE6IGZ1bmN0aW9uIChmaWxpYWxzQ291bnQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5hbWU6ICdhbGwnLFxuICAgICAgICAgICAgbGFiZWw6IHRoaXMudCgnc2hvd19vcmdhbml6YXRpb25faW5fYnVpbGRpbmcnLCBmaWxpYWxzQ291bnQpXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIF9maWxsSG91c2VPYmplY3Q6IGZ1bmN0aW9uIChob3VzZSkgeyAvLyAoT2JqZWN0KSAtPiAoT2JqZWN0KVxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGhlYWRlcjogdGhpcy5fZmlsbEhlYWRlcihob3VzZSksXG4gICAgICAgICAgICB0bXBsOiB0aGlzLl9maWxsQm9keShob3VzZSksXG4gICAgICAgICAgICBmb290ZXI6IHRoaXMuX2ZpbGxGb290ZXIoaG91c2UpLFxuICAgICAgICAgICAgYWZ0ZXJSZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzZWxmLl9pbml0U2hvd01vcmUoKTtcbiAgICAgICAgICAgICAgICBzZWxmLl9pbml0UG9wdXBDbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbn0pO1xuIiwiREcuR2VvY2xpY2tlci5IYW5kbGVyLlBvaSA9IERHLkdlb2NsaWNrZXIuSGFuZGxlci5Ib3VzZS5leHRlbmQoe1xuXG4gICAgaGFuZGxlOiBmdW5jdGlvbiAocmVzdWx0cykgeyAvLyAoT2JqZWN0KSAtPiBQcm9taXNlXG4gICAgICAgIGlmICghcmVzdWx0cy5wb2kpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGluaXRpYWxpemF0aW9uIHNldHVwXG4gICAgICAgIHRoaXMuZmlybUNhcmQgPSBudWxsO1xuICAgICAgICB0aGlzLl9wYWdlID0gMTtcbiAgICAgICAgdGhpcy5faG91c2VPYmplY3QgPSBudWxsO1xuICAgICAgICB0aGlzLl9maXJtTGlzdCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2Zpcm1MaXN0T2JqZWN0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fZmlybUNhcmRPYmplY3QgPSBudWxsO1xuICAgICAgICB0aGlzLl9vblNjcm9sbCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pc0Zpcm1saXN0T3BlbiA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuX2lkID0gcmVzdWx0cy5wb2kucmVmZXJlbmNlLmlkO1xuICAgICAgICB0aGlzLl90b3RhbFBhZ2VzID0gMTtcbiAgICAgICAgdGhpcy5fYXBpID0gdGhpcy5fY29udHJvbGxlci5nZXRDYXRhbG9nQXBpKCk7XG4gICAgICAgIHRoaXMuX3BvcHVwID0gdGhpcy5fdmlldy5nZXRQb3B1cCgpO1xuICAgICAgICB0aGlzLl9pbml0ZWRQb3B1cENsb3NlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2RpcmVjdGlvbnNVcmwgPSB0aGlzLl9nZXREaXJlY3Rpb25zVXJsKHJlc3VsdHMucG9pLnJlZmVyZW5jZS5uYW1lKTtcbiAgICAgICAgdGhpcy5fZmlybUxpc3RMb2FkZXIgPSB0aGlzLl92aWV3LmluaXRMb2FkZXIodHJ1ZSk7XG5cbiAgICAgICAgLy8gSWYgdGhlIFBPSSByZWZlcnMgdG8gYSBidWlsZGluZyAoZS5nLiBnYWxsZXJpZXMgaW4gU2FudGlhZ28pLFxuICAgICAgICAvLyBzaG93IGEgYnVpbGRpbmcgY2FsbG91dFxuICAgICAgICBpZiAocmVzdWx0cy5wb2kucmVmZXJlbmNlLnR5cGUgPT09ICdidWlsZGluZycpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICAgICAgcmV0dXJuIHNlbGYuX2FwaS5nZW9HZXQocmVzdWx0cy5wb2kucmVmZXJlbmNlLmlkKVxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5faG91c2VPYmplY3QgPSBzZWxmLl9maWxsSG91c2VPYmplY3QocmVzdWx0LnJlc3VsdC5pdGVtc1swXSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoc2VsZi5faG91c2VPYmplY3QpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBzaG93IGEgZmlybSBjYWxsb3V0XG4gICAgICAgIGlmIChyZXN1bHRzLnBvaS5yZWZlcmVuY2UudHlwZSA9PT0gJ2JyYW5jaCcpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZpbGxGaXJtQ2FyZE9iamVjdChyZXN1bHRzLnBvaS5yZWZlcmVuY2UuaWQpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG59KTtcbiIsIkRHLkdlb2NsaWNrZXIuSGFuZGxlci5TaWdodCA9IERHLkdlb2NsaWNrZXIuSGFuZGxlci5EZWZhdWx0LmV4dGVuZCh7XG5cbiAgICBoYW5kbGU6IGZ1bmN0aW9uIChyZXN1bHRzKSB7IC8vIChPYmplY3QsIFN0cmluZykgLT4gUHJvbWlzZVxuICAgICAgICBpZiAoIXJlc3VsdHMuYXR0cmFjdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fcG9wdXAgPSB0aGlzLl92aWV3LmdldFBvcHVwKCk7XG4gICAgICAgIHRoaXMuX2luaXRlZFBvcHVwQ2xvc2UgPSBmYWxzZTtcblxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2ZpbGxTaWdodE9iamVjdChyZXN1bHRzKSk7XG4gICAgfSxcblxuICAgIF9maWxsU2lnaHRPYmplY3Q6IGZ1bmN0aW9uIChyZXN1bHRzKSB7IC8vIChPYmplY3QpIC0+IE9iamVjdFxuICAgICAgICB2YXIgYXR0cmFjdGlvbiA9IHJlc3VsdHMuYXR0cmFjdGlvbixcbiAgICAgICAgICAgIGRhdGEgPSB7fSxcbiAgICAgICAgICAgIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgZm9vdGVyID0ge1xuICAgICAgICAgICAgICAgIGJ0bnM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2dvdG8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IHRoaXMudCgnZ29fdG8nKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGljb246IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgaWYgKGF0dHJhY3Rpb24ubmFtZSkge1xuICAgICAgICAgICAgZGF0YS5idWlsZGluZ05hbWUgPSBhdHRyYWN0aW9uLm5hbWU7XG4gICAgICAgICAgICBkYXRhLnB1cnBvc2UgPSBhdHRyYWN0aW9uLnN1YnR5cGVfbmFtZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRhdGEuYnVpbGRpbmdOYW1lID0gYXR0cmFjdGlvbi5zdWJ0eXBlX25hbWU7XG4gICAgICAgIH1cblxuICAgICAgICBkYXRhLmRlc2NyaXB0aW9uID0gYXR0cmFjdGlvbi5kZXNjcmlwdGlvbjtcblxuICAgICAgICBkYXRhLmRyaWxsRG93biA9IHRoaXMuX2dldERyaWxsZG93bihhdHRyYWN0aW9uKTtcblxuICAgICAgICBpZiAodGhpcy5fY2hlY2tEZXNjRmllbGRIZWlnaHQoZGF0YS5kZXNjcmlwdGlvbikpIHtcbiAgICAgICAgICAgIGRhdGEuc2hvd01vcmVUZXh0ID0gdGhpcy50KCdzaG93X21vcmVfYWJvdXRfc2lnaHQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvb3Rlci5idG5zWzBdLmhyZWYgPSB0aGlzLl9nZXREaXJlY3Rpb25zVXJsKGRhdGEuYnVpbGRpbmdOYW1lKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG1wbDogJ3NpZ2h0JyxcbiAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgICBoZWFkZXI6IHRoaXMuX3ZpZXcucmVuZGVyKHtcbiAgICAgICAgICAgICAgICB0bXBsOiAncG9wdXBIZWFkZXInLFxuICAgICAgICAgICAgICAgIGRhdGE6IHsndGl0bGUnOiBkYXRhLmJ1aWxkaW5nTmFtZX1cbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgZm9vdGVyOiB0aGlzLl92aWV3LnJlbmRlcih7XG4gICAgICAgICAgICAgICAgdG1wbDogJ3BvcHVwRm9vdGVyQnRucycsXG4gICAgICAgICAgICAgICAgZGF0YTogZm9vdGVyXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGFmdGVyUmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuX25lZWRTaG93TW9yZSkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLl9pbml0U2hvd01vcmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2VsZi5faW5pdFBvcHVwQ2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgX2luaXRQb3B1cENsb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9pbml0ZWRQb3B1cENsb3NlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9jb250cm9sbGVyLmdldE1hcCgpLm9uY2UoJ3BvcHVwY2xvc2UnLCBERy5iaW5kKHRoaXMuX2NsZWFyUG9wdXAsIHRoaXMpKTtcbiAgICAgICAgdGhpcy5faW5pdGVkUG9wdXBDbG9zZSA9IHRydWU7XG4gICAgfSxcblxuICAgIF9jbGVhclBvcHVwOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2luaXRlZFBvcHVwQ2xvc2UgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fY2xlYXJFdmVudEhhbmRsZXJzKCk7XG4gICAgfSxcblxuICAgIF9zaG93TW9yZVRleHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fZGVzYy5zdHlsZS5tYXhIZWlnaHQgPSAnMTAwJSc7XG4gICAgICAgIHRoaXMuX2xpbmsucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLl9saW5rKTtcbiAgICAgICAgdGhpcy5fcG9wdXAucmVzaXplKCk7XG4gICAgfSxcblxuICAgIF9pbml0U2hvd01vcmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fbGluayA9IHRoaXMuX3BvcHVwLmZpbmRFbGVtZW50KCcuZGctbWFwLWdlb2NsaWNrZXJfX3Nob3ctbW9yZS1zaWdodHMtbGluaycpO1xuICAgICAgICB0aGlzLl9kZXNjID0gdGhpcy5fcG9wdXAuZmluZEVsZW1lbnQoJy5kZy1tYXAtZ2VvY2xpY2tlcl9fc2lnaHQtZGVzY3JpcHRpb24nKTtcblxuICAgICAgICBpZiAodGhpcy5fbGluayAmJiB0aGlzLl9kZXNjKSB7XG4gICAgICAgICAgICB0aGlzLl9hZGRFdmVudEhhbmRsZXIoJ2RnLW1hcC1nZW9jbGlja2VyX19zaG93LW1vcmUtc2lnaHRzLWxpbmsnLCBERy5iaW5kKHRoaXMuX3Nob3dNb3JlVGV4dCwgdGhpcykpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9jaGVja0Rlc2NGaWVsZEhlaWdodDogZnVuY3Rpb24gKGRlc2MpIHtcbiAgICAgICAgdmFyIGVsID0gREcuRG9tVXRpbC5jcmVhdGUoJ2RpdicsICcnKSxcbiAgICAgICAgICAgIGhlaWdodDtcblxuICAgICAgICBlbC5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgICAgIGVsLmlubmVySFRNTCA9IGRlc2M7XG5cbiAgICAgICAgdGhpcy5fcG9wdXAuX2NvbnRlbnROb2RlLmFwcGVuZENoaWxkKGVsKTtcbiAgICAgICAgaGVpZ2h0ID0gZWwub2Zmc2V0SGVpZ2h0O1xuICAgICAgICB0aGlzLl9wb3B1cC5fY29udGVudE5vZGUucmVtb3ZlQ2hpbGQoZWwpO1xuICAgICAgICB0aGlzLl9uZWVkU2hvd01vcmUgPSAoaGVpZ2h0ID4gNDApO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9uZWVkU2hvd01vcmU7XG4gICAgfVxufSk7XG4iLCJERy5HZW9jbGlja2VyLlZpZXcgPSBERy5DbGFzcy5leHRlbmQoe1xuXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKG1hcCwgb3B0aW9ucykgeyAvLyAoT2JqZWN0LCBPYmplY3QpXG4gICAgICAgIHRoaXMuX21hcCA9IG1hcDtcbiAgICAgICAgdGhpcy5fcG9wdXAgPSBERy5wb3B1cCh7XG4gICAgICAgICAgICBtYXhIZWlnaHQ6IDMwMCxcbiAgICAgICAgICAgIG1pbkhlaWdodDogNTAsXG4gICAgICAgICAgICBtYXhXaWR0aDogMzg1LFxuICAgICAgICAgICAgbWluV2lkdGg6IDMxMCxcbiAgICAgICAgICAgIHNwcmF3bGluZzogdHJ1ZSxcbiAgICAgICAgICAgIGNsb3NlT25DbGljazogdHJ1ZVxuICAgICAgICB9KTtcblxuICAgICAgICAvKmdsb2JhbCBfX0RHR2VvY2xpY2tlcl9UTVBMX18gKi9cbiAgICAgICAgdGhpcy5fdGVtcGxhdGVzID0gREcuZHVzdCh7XCJjaXR5YXJlYVwiOlwiKGZ1bmN0aW9uKCl7ZHVzdC5yZWdpc3RlcihcXFwiY2l0eWFyZWFcXFwiLGJvZHlfMCk7ZnVuY3Rpb24gYm9keV8wKGNoayxjdHgpe3JldHVybiBjaGsud3JpdGUoXFxcIjxkaXYgY2xhc3M9XFxcXFxcXCJkZy1tYXAtZ2VvY2xpY2tlcl9fcHVycG9zZSBkZy1tYXAtZ2VvY2xpY2tlcl9fcHVycG9zZV90eXBlX1xcXCIpLnJlZmVyZW5jZShjdHguZ2V0KFtcXFwidHlwZVxcXCJdLCBmYWxzZSksY3R4LFxcXCJoXFxcIikud3JpdGUoXFxcIlxcXFxcXFwiPlxcXCIpLnJlZmVyZW5jZShjdHguZ2V0KFtcXFwicHVycG9zZVxcXCJdLCBmYWxzZSksY3R4LFxcXCJoXFxcIikud3JpdGUoXFxcIjwvZGl2PlxcXCIpLnNlY3Rpb24oY3R4LmdldChbXFxcImRyaWxsZG93blxcXCJdLCBmYWxzZSksY3R4LHtcXFwiYmxvY2tcXFwiOmJvZHlfMX0sbnVsbCk7fWZ1bmN0aW9uIGJvZHlfMShjaGssY3R4KXtyZXR1cm4gY2hrLndyaXRlKFxcXCI8ZGl2IGNsYXNzPVxcXFxcXFwiZGctbWFwLWdlb2NsaWNrZXJfX2RyaWxsZG93blxcXFxcXFwiPlxcXCIpLnJlZmVyZW5jZShjdHguZ2V0KFtcXFwiZHJpbGxkb3duXFxcIl0sIGZhbHNlKSxjdHgsXFxcImhcXFwiKS53cml0ZShcXFwiPC9kaXY+XFxcIik7fXJldHVybiBib2R5XzA7fSkoKTtcIixcImZpcm1DYXJkQWRkclwiOlwiKGZ1bmN0aW9uKCl7ZHVzdC5yZWdpc3RlcihcXFwiZmlybUNhcmRBZGRyXFxcIixib2R5XzApO2Z1bmN0aW9uIGJvZHlfMChjaGssY3R4KXtyZXR1cm4gY2hrLndyaXRlKFxcXCI8YWRkcmVzcyBjbGFzcz1cXFxcXFxcImRnLWZpcm0tY2FyZF9fYWRkcmVzcyBkZy1maXJtLWNhcmRfX2ljb25cXFxcXFxcIj5cXFwiKS5yZWZlcmVuY2UoY3R4LmdldChbXFxcImFkZHJlc3NcXFwiXSwgZmFsc2UpLGN0eCxcXFwiaFxcXCIpLnNlY3Rpb24oY3R4LmdldChbXFxcImNvbW1lbnRcXFwiXSwgZmFsc2UpLGN0eCx7XFxcImJsb2NrXFxcIjpib2R5XzF9LG51bGwpLndyaXRlKFxcXCI8L2FkZHJlc3M+XFxcIik7fWZ1bmN0aW9uIGJvZHlfMShjaGssY3R4KXtyZXR1cm4gY2hrLndyaXRlKFxcXCI8c3BhbiBjbGFzcz1cXFxcXFxcImRnLWZpcm0tY2FyZF9fY29tbWVudFxcXFxcXFwiPiZtZGFzaDsgXFxcIikucmVmZXJlbmNlKGN0eC5nZXRQYXRoKHRydWUsIFtdKSxjdHgsXFxcImhcXFwiKS53cml0ZShcXFwiPC9zcGFuPlxcXCIpO31yZXR1cm4gYm9keV8wO30pKCk7XCIsXCJmaXJtQ2FyZENvbnRhY3RzXCI6XCIoZnVuY3Rpb24oKXtkdXN0LnJlZ2lzdGVyKFxcXCJmaXJtQ2FyZENvbnRhY3RzXFxcIixib2R5XzApO2Z1bmN0aW9uIGJvZHlfMChjaGssY3R4KXtyZXR1cm4gY2hrLnNlY3Rpb24oY3R4LmdldChbXFxcImdyb3Vwc1xcXCJdLCBmYWxzZSksY3R4LHtcXFwiYmxvY2tcXFwiOmJvZHlfMX0sbnVsbCk7fWZ1bmN0aW9uIGJvZHlfMShjaGssY3R4KXtyZXR1cm4gY2hrLnNlY3Rpb24oY3R4LmdldChbXFxcImNvbnRhY3RzXFxcIl0sIGZhbHNlKSxjdHgse1xcXCJibG9ja1xcXCI6Ym9keV8yfSxudWxsKTt9ZnVuY3Rpb24gYm9keV8yKGNoayxjdHgpe3JldHVybiBjaGsuaGVscGVyKFxcXCJzZWxlY3RcXFwiLGN0eCx7XFxcImJsb2NrXFxcIjpib2R5XzN9LHtcXFwia2V5XFxcIjpjdHguZ2V0KFtcXFwidHlwZVxcXCJdLCBmYWxzZSksXFxcInR5cGVcXFwiOlxcXCJzdHJpbmdcXFwifSk7fWZ1bmN0aW9uIGJvZHlfMyhjaGssY3R4KXtyZXR1cm4gY2hrLmhlbHBlcihcXFwiZXFcXFwiLGN0eCx7XFxcImJsb2NrXFxcIjpib2R5XzR9LHtcXFwidmFsdWVcXFwiOlxcXCJwaG9uZVxcXCIsXFxcInR5cGVcXFwiOlxcXCJzdHJpbmdcXFwifSkuaGVscGVyKFxcXCJlcVxcXCIsY3R4LHtcXFwiYmxvY2tcXFwiOmJvZHlfNn0se1xcXCJ2YWx1ZVxcXCI6XFxcImZheFxcXCIsXFxcInR5cGVcXFwiOlxcXCJzdHJpbmdcXFwifSkuaGVscGVyKFxcXCJlcVxcXCIsY3R4LHtcXFwiYmxvY2tcXFwiOmJvZHlfOH0se1xcXCJ2YWx1ZVxcXCI6XFxcIndlYnNpdGVcXFwiLFxcXCJ0eXBlXFxcIjpcXFwic3RyaW5nXFxcIn0pLmhlbHBlcihcXFwiZXFcXFwiLGN0eCx7XFxcImJsb2NrXFxcIjpib2R5Xzl9LHtcXFwidmFsdWVcXFwiOlxcXCJlbWFpbFxcXCIsXFxcInR5cGVcXFwiOlxcXCJzdHJpbmdcXFwifSk7fWZ1bmN0aW9uIGJvZHlfNChjaGssY3R4KXtyZXR1cm4gY2hrLndyaXRlKFxcXCI8ZGl2IGNsYXNzPVxcXFxcXFwiZGctZmlybS1jYXJkX19waG9uZSBkZy1maXJtLWNhcmRfX2ljb25cXFxcXFxcIj48c3BhbiBjbGFzcz1cXFxcXFxcImRnLWZpcm0tY2FyZF9fcGhvbmUtbnVtXFxcXFxcXCI+XFxcIikucmVmZXJlbmNlKGN0eC5nZXQoW1xcXCJ0ZXh0XFxcIl0sIGZhbHNlKSxjdHgsXFxcImhcXFwiKS5zZWN0aW9uKGN0eC5nZXQoW1xcXCJjb21tZW50XFxcIl0sIGZhbHNlKSxjdHgse1xcXCJibG9ja1xcXCI6Ym9keV81fSxudWxsKS53cml0ZShcXFwiPC9zcGFuPjwvZGl2PlxcXCIpO31mdW5jdGlvbiBib2R5XzUoY2hrLGN0eCl7cmV0dXJuIGNoay53cml0ZShcXFwiPHNwYW4gY2xhc3M9XFxcXFxcXCJkZy1maXJtLWNhcmRfX2NvbW1lbnRcXFxcXFxcIiB0aXRsZT1cXFxcXFxcIlxcXCIpLnJlZmVyZW5jZShjdHguZ2V0UGF0aCh0cnVlLCBbXSksY3R4LFxcXCJoXFxcIikud3JpdGUoXFxcIlxcXFxcXFwiPiZtZGFzaDsmbmJzcDsmbmJzcDtcXFwiKS5yZWZlcmVuY2UoY3R4LmdldFBhdGgodHJ1ZSwgW10pLGN0eCxcXFwiaFxcXCIpLndyaXRlKFxcXCI8L3NwYW4+XFxcIik7fWZ1bmN0aW9uIGJvZHlfNihjaGssY3R4KXtyZXR1cm4gY2hrLndyaXRlKFxcXCI8ZGl2IGNsYXNzPVxcXFxcXFwiZGctZmlybS1jYXJkX19waG9uZSBkZy1maXJtLWNhcmRfX2ljb25cXFxcXFxcIj48c3BhbiBjbGFzcz1cXFxcXFxcImRnLWZpcm0tY2FyZF9fcGhvbmUtbnVtXFxcXFxcXCI+XFxcIikucmVmZXJlbmNlKGN0eC5nZXQoW1xcXCJ0ZXh0XFxcIl0sIGZhbHNlKSxjdHgsXFxcImhcXFwiKS5zZWN0aW9uKGN0eC5nZXQoW1xcXCJjb21tZW50XFxcIl0sIGZhbHNlKSxjdHgse1xcXCJibG9ja1xcXCI6Ym9keV83fSxudWxsKS53cml0ZShcXFwiPC9zcGFuPjwvZGl2PlxcXCIpO31mdW5jdGlvbiBib2R5XzcoY2hrLGN0eCl7cmV0dXJuIGNoay53cml0ZShcXFwiPHNwYW4gY2xhc3M9XFxcXFxcXCJkZy1maXJtLWNhcmRfX2NvbW1lbnRcXFxcXFxcIiB0aXRsZT1cXFxcXFxcIlxcXCIpLnJlZmVyZW5jZShjdHguZ2V0UGF0aCh0cnVlLCBbXSksY3R4LFxcXCJoXFxcIikud3JpdGUoXFxcIlxcXFxcXFwiPiZtZGFzaDsmbmJzcDsmbmJzcDtcXFwiKS5yZWZlcmVuY2UoY3R4LmdldFBhdGgodHJ1ZSwgW10pLGN0eCxcXFwiaFxcXCIpLndyaXRlKFxcXCI8L3NwYW4+XFxcIik7fWZ1bmN0aW9uIGJvZHlfOChjaGssY3R4KXtyZXR1cm4gY2hrLndyaXRlKFxcXCI8ZGl2IGNsYXNzPVxcXFxcXFwiZGctZmlybS1jYXJkX19saW5rIGRnLWZpcm0tY2FyZF9fc2l0ZSBkZy1maXJtLWNhcmRfX2ljb25cXFxcXFxcIj48YSBocmVmPVxcXFxcXFwiXFxcIikucmVmZXJlbmNlKGN0eC5nZXQoW1xcXCJ1cmxcXFwiXSwgZmFsc2UpLGN0eCxcXFwiaFxcXCIpLndyaXRlKFxcXCJcXFxcXFxcIiB0YXJnZXQ9XFxcXFxcXCJfYmxhbmtcXFxcXFxcIiBjbGFzcz1cXFxcXFxcImRnLWxpbmtfc2NoZW1lX2RhcmsgZGctZmlybS1jYXJkX19zaXRlbGlua1xcXFxcXFwiPlxcXCIpLnJlZmVyZW5jZShjdHguZ2V0KFtcXFwidGV4dFxcXCJdLCBmYWxzZSksY3R4LFxcXCJoXFxcIikud3JpdGUoXFxcIjwvYT48L2Rpdj5cXFwiKTt9ZnVuY3Rpb24gYm9keV85KGNoayxjdHgpe3JldHVybiBjaGsud3JpdGUoXFxcIjxkaXYgY2xhc3M9XFxcXFxcXCJkZy1maXJtLWNhcmRfX2xpbmsgZGctZmlybS1jYXJkX19lbWFpbCBkZy1maXJtLWNhcmRfX2ljb25cXFxcXFxcIj48YSBocmVmPVxcXFxcXFwibWFpbHRvOiBcXFwiKS5yZWZlcmVuY2UoY3R4LmdldChbXFxcInZhbHVlXFxcIl0sIGZhbHNlKSxjdHgsXFxcImhcXFwiKS53cml0ZShcXFwiXFxcXFxcXCI+XFxcIikucmVmZXJlbmNlKGN0eC5nZXQoW1xcXCJ2YWx1ZVxcXCJdLCBmYWxzZSksY3R4LFxcXCJoXFxcIikud3JpdGUoXFxcIjwvYT48L2Rpdj5cXFwiKTt9cmV0dXJuIGJvZHlfMDt9KSgpO1wiLFwiZmlybUNhcmRIZWFkZXJcIjpcIihmdW5jdGlvbigpe2R1c3QucmVnaXN0ZXIoXFxcImZpcm1DYXJkSGVhZGVyXFxcIixib2R5XzApO2Z1bmN0aW9uIGJvZHlfMChjaGssY3R4KXtyZXR1cm4gY2hrLndyaXRlKFxcXCI8ZGl2IGNsYXNzPVxcXFxcXFwiZGctcG9wdXBfX2hlYWRlci10aXRsZSBkZy1wb3B1cF9faGVhZGVyLXRpdGxlX2Zvcl9maXJtY2FyZFxcXFxcXFwiIHRpdGxlPVxcXFxcXFwiXFxcIikucmVmZXJlbmNlKGN0eC5nZXQoW1xcXCJmaXJtTmFtZVxcXCJdLCBmYWxzZSksY3R4LFxcXCJoXFxcIikud3JpdGUoXFxcIlxcXFxcXFwiPlxcXCIpLnJlZmVyZW5jZShjdHguZ2V0KFtcXFwiZmlybU5hbWVcXFwiXSwgZmFsc2UpLGN0eCxcXFwiaFxcXCIpLndyaXRlKFxcXCI8L2Rpdj5cXFwiKS5leGlzdHMoY3R4LmdldChbXFxcImxpbmtzXFxcIl0sIGZhbHNlKSxjdHgse1xcXCJibG9ja1xcXCI6Ym9keV8xfSxudWxsKTt9ZnVuY3Rpb24gYm9keV8xKGNoayxjdHgpe3JldHVybiBjaGsud3JpdGUoXFxcIjxkaXYgY2xhc3M9XFxcXFxcXCJkZy1wb3B1cF9faGVhZGVyLWxpbmtzXFxcXFxcXCI+XFxcIikuc2VjdGlvbihjdHguZ2V0KFtcXFwibGlua3NcXFwiXSwgZmFsc2UpLGN0eCx7XFxcImJsb2NrXFxcIjpib2R5XzJ9LG51bGwpLndyaXRlKFxcXCI8L2Rpdj5cXFwiKTt9ZnVuY3Rpb24gYm9keV8yKGNoayxjdHgpe3JldHVybiBjaGsuaGVscGVyKFxcXCJlcVxcXCIsY3R4LHtcXFwiZWxzZVxcXCI6Ym9keV8zLFxcXCJibG9ja1xcXCI6Ym9keV82fSx7XFxcImtleVxcXCI6Ym9keV83LFxcXCJ2YWx1ZVxcXCI6XFxcImZsYW1wX3N0YXJzXFxcIixcXFwidHlwZVxcXCI6XFxcInN0cmluZ1xcXCJ9KTt9ZnVuY3Rpb24gYm9keV8zKGNoayxjdHgpe3JldHVybiBjaGsud3JpdGUoXFxcIjxhIGNsYXNzPVxcXFxcXFwiZGctcG9wdXBfX2hlYWRlci1saW5rIGRnLXBvcHVwX19saW5rIGRnLXBvcHVwX19saW5rX3R5cGVfXFxcIikucmVmZXJlbmNlKGN0eC5nZXQoW1xcXCJuYW1lXFxcIl0sIGZhbHNlKSxjdHgsXFxcImhcXFwiKS53cml0ZShcXFwiXFxcXFxcXCJcXFwiKS5leGlzdHMoY3R4LmdldChbXFxcImhyZWZcXFwiXSwgZmFsc2UpLGN0eCx7XFxcImVsc2VcXFwiOmJvZHlfNCxcXFwiYmxvY2tcXFwiOmJvZHlfNX0sbnVsbCkud3JpdGUoXFxcIj5cXFwiKS5yZWZlcmVuY2UoY3R4LmdldChbXFxcImxhYmVsXFxcIl0sIGZhbHNlKSxjdHgsXFxcImhcXFwiKS53cml0ZShcXFwiPC9hPlxcXCIpO31mdW5jdGlvbiBib2R5XzQoY2hrLGN0eCl7cmV0dXJuIGNoay53cml0ZShcXFwiaHJlZj1cXFxcXFxcImphdmFzY3JpcHQ6dm9pZCgwKVxcXFxcXFwiXFxcIik7fWZ1bmN0aW9uIGJvZHlfNShjaGssY3R4KXtyZXR1cm4gY2hrLndyaXRlKFxcXCJocmVmPVxcXCIpLnJlZmVyZW5jZShjdHguZ2V0KFtcXFwiaHJlZlxcXCJdLCBmYWxzZSksY3R4LFxcXCJoXFxcIikud3JpdGUoXFxcIiB0YXJnZXQ9XFxcXFxcXCJfYmxhbmtcXFxcXFxcIlxcXCIpO31mdW5jdGlvbiBib2R5XzYoY2hrLGN0eCl7cmV0dXJuIGNoay53cml0ZShcXFwiPGRpdiBjbGFzcz1cXFxcXFxcImRnLXBvcHVwX19yYXRpbmdcXFxcXFxcIj48ZGl2IGNsYXNzPVxcXFxcXFwiZGctcG9wdXBfX3JhdGluZy1zdGFyc1xcXFxcXFwiIHN0eWxlPVxcXFxcXFwid2lkdGg6IFxcXCIpLnJlZmVyZW5jZShjdHguZ2V0KFtcXFwid2lkdGhcXFwiXSwgZmFsc2UpLGN0eCxcXFwiaFxcXCIpLndyaXRlKFxcXCIlXFxcXFxcXCI+PC9kaXY+PC9kaXY+XFxcIik7fWZ1bmN0aW9uIGJvZHlfNyhjaGssY3R4KXtyZXR1cm4gY2hrLnJlZmVyZW5jZShjdHguZ2V0KFtcXFwibmFtZVxcXCJdLCBmYWxzZSksY3R4LFxcXCJoXFxcIik7fXJldHVybiBib2R5XzA7fSkoKTtcIixcImZpcm1DYXJkUnVicmljXCI6XCIoZnVuY3Rpb24oKXtkdXN0LnJlZ2lzdGVyKFxcXCJmaXJtQ2FyZFJ1YnJpY1xcXCIsYm9keV8wKTtmdW5jdGlvbiBib2R5XzAoY2hrLGN0eCl7cmV0dXJuIGNoay5zZWN0aW9uKGN0eC5nZXQoW1xcXCJydWJyaWNzXFxcIl0sIGZhbHNlKSxjdHgse1xcXCJibG9ja1xcXCI6Ym9keV8xfSxudWxsKTt9ZnVuY3Rpb24gYm9keV8xKGNoayxjdHgpe3JldHVybiBjaGsud3JpdGUoXFxcIjxzZWN0aW9uIGNsYXNzPVxcXFxcXFwiZGctZmlybS1jYXJkX19ydWJyaWNzXFxcXFxcXCI+XFxcIikuZXhpc3RzKGN0eC5nZXQoW1xcXCJwcmltYXJ5XFxcIl0sIGZhbHNlKSxjdHgse1xcXCJibG9ja1xcXCI6Ym9keV8yfSxudWxsKS5leGlzdHMoY3R4LmdldChbXFxcImFkZGl0aW9uYWxcXFwiXSwgZmFsc2UpLGN0eCx7XFxcImJsb2NrXFxcIjpib2R5XzR9LG51bGwpLndyaXRlKFxcXCI8L3NlY3Rpb24+XFxcIik7fWZ1bmN0aW9uIGJvZHlfMihjaGssY3R4KXtyZXR1cm4gY2hrLndyaXRlKFxcXCI8dWwgY2xhc3M9XFxcXFxcXCJkZy1maXJtLWNhcmRfX3J1YnJpY3MtbGlzdCBkZy1maXJtLWNhcmRfX3J1YnJpY3MtbGlzdF90eXBlX3ByaW1hcnlcXFxcXFxcIj5cXFwiKS5zZWN0aW9uKGN0eC5nZXQoW1xcXCJwcmltYXJ5XFxcIl0sIGZhbHNlKSxjdHgse1xcXCJibG9ja1xcXCI6Ym9keV8zfSxudWxsKS53cml0ZShcXFwiPC91bD5cXFwiKTt9ZnVuY3Rpb24gYm9keV8zKGNoayxjdHgpe3JldHVybiBjaGsud3JpdGUoXFxcIjxsaSBjbGFzcz1cXFxcXFxcImRnLWZpcm0tY2FyZF9fcnVicmljcy1saXN0LWl0ZW1cXFxcXFxcIj5cXFwiKS5yZWZlcmVuY2UoY3R4LmdldChbXFxcIm5hbWVcXFwiXSwgZmFsc2UpLGN0eCxcXFwiaFxcXCIpLndyaXRlKFxcXCI8L2xpPlxcXCIpO31mdW5jdGlvbiBib2R5XzQoY2hrLGN0eCl7cmV0dXJuIGNoay53cml0ZShcXFwiPHVsIGNsYXNzPVxcXFxcXFwiZGctZmlybS1jYXJkX19ydWJyaWNzLWxpc3QgZGctZmlybS1jYXJkX19ydWJyaWNzLWxpc3RfdHlwZV9hZGRpdGlvbmFsXFxcXFxcXCI+XFxcIikuc2VjdGlvbihjdHguZ2V0KFtcXFwiYWRkaXRpb25hbFxcXCJdLCBmYWxzZSksY3R4LHtcXFwiYmxvY2tcXFwiOmJvZHlfNX0sbnVsbCkud3JpdGUoXFxcIjwvdWw+XFxcIik7fWZ1bmN0aW9uIGJvZHlfNShjaGssY3R4KXtyZXR1cm4gY2hrLndyaXRlKFxcXCI8bGkgY2xhc3M9XFxcXFxcXCJkZy1maXJtLWNhcmRfX3J1YnJpY3MtbGlzdC1pdGVtXFxcXFxcXCI+XFxcIikucmVmZXJlbmNlKGN0eC5nZXQoW1xcXCJuYW1lXFxcIl0sIGZhbHNlKSxjdHgsXFxcImhcXFwiKS53cml0ZShcXFwiPC9saT5cXFwiKTt9cmV0dXJuIGJvZHlfMDt9KSgpO1wiLFwiZmlybUNhcmRTY2hlZHVsZVwiOlwiKGZ1bmN0aW9uKCl7ZHVzdC5yZWdpc3RlcihcXFwiZmlybUNhcmRTY2hlZHVsZVxcXCIsYm9keV8wKTtmdW5jdGlvbiBib2R5XzAoY2hrLGN0eCl7cmV0dXJuIGNoay53cml0ZShcXFwiPGRpdiBjbGFzcz1cXFxcXFxcImRnLWZpcm0tY2FyZF9fc2NoZWR1bGUgZGctc2NoZWR1bGUgZGctc2NoZWR1bGVfb3Blbl9cXFwiKS5leGlzdHMoY3R4LmdldFBhdGgoZmFsc2UsIFtcXFwiZm9yZWNhc3RcXFwiLFxcXCJvcGVuXFxcIl0pLGN0eCx7XFxcImVsc2VcXFwiOmJvZHlfMSxcXFwiYmxvY2tcXFwiOmJvZHlfMn0sbnVsbCkud3JpdGUoXFxcIiBkZy1zY2hlZHVsZV93b3Jrcy1ldmVyeWRheV9cXFwiKS5leGlzdHMoY3R4LmdldFBhdGgoZmFsc2UsIFtcXFwic2NoZWR1bGVcXFwiLFxcXCJldmVyeWRheVxcXCJdKSxjdHgse1xcXCJlbHNlXFxcIjpib2R5XzMsXFxcImJsb2NrXFxcIjpib2R5XzR9LG51bGwpLndyaXRlKFxcXCJcXFxcXFxcIj5cXFwiKS5leGlzdHMoY3R4LmdldChbXFxcInNjaGVkdWxlXFxcIl0sIGZhbHNlKSxjdHgse1xcXCJibG9ja1xcXCI6Ym9keV81fSxudWxsKS53cml0ZShcXFwiPC9kaXY+XFxcIik7fWZ1bmN0aW9uIGJvZHlfMShjaGssY3R4KXtyZXR1cm4gY2hrLndyaXRlKFxcXCJmYWxzZVxcXCIpO31mdW5jdGlvbiBib2R5XzIoY2hrLGN0eCl7cmV0dXJuIGNoay53cml0ZShcXFwidHJ1ZVxcXCIpO31mdW5jdGlvbiBib2R5XzMoY2hrLGN0eCl7cmV0dXJuIGNoay53cml0ZShcXFwiZmFsc2VcXFwiKTt9ZnVuY3Rpb24gYm9keV80KGNoayxjdHgpe3JldHVybiBjaGsud3JpdGUoXFxcInRydWVcXFwiKTt9ZnVuY3Rpb24gYm9keV81KGNoayxjdHgpe3JldHVybiBjaGsuZXhpc3RzKGN0eC5nZXRQYXRoKGZhbHNlLCBbXFxcImZvcmVjYXN0XFxcIixcXFwidG9kYXlcXFwiXSksY3R4LHtcXFwiYmxvY2tcXFwiOmJvZHlfNn0sbnVsbCkuc2VjdGlvbihjdHguZ2V0UGF0aChmYWxzZSwgW1xcXCJmb3JlY2FzdFxcXCIsXFxcIm5vd1xcXCJdKSxjdHgse1xcXCJibG9ja1xcXCI6Ym9keV8xMH0sbnVsbCkubm90ZXhpc3RzKGN0eC5nZXRQYXRoKGZhbHNlLCBbXFxcInNjaGVkdWxlXFxcIixcXFwiZXZlcnlkYXlcXFwiXSksY3R4LHtcXFwiYmxvY2tcXFwiOmJvZHlfMTJ9LG51bGwpO31mdW5jdGlvbiBib2R5XzYoY2hrLGN0eCl7cmV0dXJuIGNoay53cml0ZShcXFwiPGRpdiBjbGFzcz1cXFxcXFxcImRnLXNjaGVkdWxlX190b2RheVxcXFxcXFwiPjxkaXYgY2xhc3M9XFxcXFxcXCJkZy1zY2hlZHVsZV9fdG9kYXktaW5uZXJcXFxcXFxcIj5cXFwiKS5yZWZlcmVuY2UoY3R4LmdldFBhdGgoZmFsc2UsIFtcXFwiZm9yZWNhc3RcXFwiLFxcXCJ0b2RheVxcXCIsXFxcInRleHRcXFwiXSksY3R4LFxcXCJoXFxcIikud3JpdGUoXFxcIiZuYnNwO1xcXCIpLmV4aXN0cyhjdHguZ2V0UGF0aChmYWxzZSwgW1xcXCJmb3JlY2FzdFxcXCIsXFxcInRvZGF5XFxcIixcXFwiZnJvbVxcXCJdKSxjdHgse1xcXCJibG9ja1xcXCI6Ym9keV83fSxudWxsKS5leGlzdHMoY3R4LmdldFBhdGgoZmFsc2UsIFtcXFwic2NoZWR1bGVcXFwiLFxcXCJsdW5jaFxcXCJdKSxjdHgse1xcXCJibG9ja1xcXCI6Ym9keV84fSxudWxsKS53cml0ZShcXFwiPC9kaXY+PC9kaXY+XFxcIik7fWZ1bmN0aW9uIGJvZHlfNyhjaGssY3R4KXtyZXR1cm4gY2hrLnJlZmVyZW5jZShjdHguZ2V0UGF0aChmYWxzZSwgW1xcXCJmb3JlY2FzdFxcXCIsXFxcInRvZGF5XFxcIixcXFwiZnJvbVxcXCJdKSxjdHgsXFxcImhcXFwiKS53cml0ZShcXFwiJm5kYXNoO1xcXCIpLnJlZmVyZW5jZShjdHguZ2V0UGF0aChmYWxzZSwgW1xcXCJmb3JlY2FzdFxcXCIsXFxcInRvZGF5XFxcIixcXFwidG9cXFwiXSksY3R4LFxcXCJoXFxcIik7fWZ1bmN0aW9uIGJvZHlfOChjaGssY3R4KXtyZXR1cm4gY2hrLndyaXRlKFxcXCIsJm5ic3A7XFxcIikucmVmZXJlbmNlKGN0eC5nZXRQYXRoKGZhbHNlLCBbXFxcImZvcmVjYXN0XFxcIixcXFwidG9kYXlcXFwiLFxcXCJsdW5jaFN0clxcXCJdKSxjdHgsXFxcImhcXFwiKS53cml0ZShcXFwiJm5ic3A7XFxcIikuc2VjdGlvbihjdHguZ2V0UGF0aChmYWxzZSwgW1xcXCJzY2hlZHVsZVxcXCIsXFxcImx1bmNoXFxcIl0pLGN0eCx7XFxcImJsb2NrXFxcIjpib2R5Xzl9LG51bGwpO31mdW5jdGlvbiBib2R5XzkoY2hrLGN0eCl7cmV0dXJuIGNoay5yZWZlcmVuY2UoY3R4LmdldChbXFxcImZyb21cXFwiXSwgZmFsc2UpLGN0eCxcXFwiaFxcXCIpLndyaXRlKFxcXCImbmRhc2g7XFxcIikucmVmZXJlbmNlKGN0eC5nZXQoW1xcXCJ0b1xcXCJdLCBmYWxzZSksY3R4LFxcXCJoXFxcIik7fWZ1bmN0aW9uIGJvZHlfMTAoY2hrLGN0eCl7cmV0dXJuIGNoay53cml0ZShcXFwiPGRpdiBjbGFzcz1cXFxcXFxcImRnLXNjaGVkdWxlX19ub3dcXFxcXFxcIj48c3BhbiBjbGFzcz1cXFxcXFxcImRnLXNjaGVkdWxlX19ub3ctdGV4dFxcXFxcXFwiPlxcXCIpLnJlZmVyZW5jZShjdHguZ2V0UGF0aCh0cnVlLCBbXSksY3R4LFxcXCJoXFxcIikuc2VjdGlvbihjdHguZ2V0UGF0aChmYWxzZSwgW1xcXCJzY2hlZHVsZVxcXCIsXFxcImNvbW1lbnRcXFwiXSksY3R4LHtcXFwiYmxvY2tcXFwiOmJvZHlfMTF9LG51bGwpLndyaXRlKFxcXCI8L3NwYW4+PC9kaXY+XFxcIik7fWZ1bmN0aW9uIGJvZHlfMTEoY2hrLGN0eCl7cmV0dXJuIGNoay53cml0ZShcXFwiLCBcXFwiKS5yZWZlcmVuY2UoY3R4LmdldFBhdGgodHJ1ZSwgW10pLGN0eCxcXFwiaFxcXCIpO31mdW5jdGlvbiBib2R5XzEyKGNoayxjdHgpe3JldHVybiBjaGsuZXhpc3RzKGN0eC5nZXRQYXRoKGZhbHNlLCBbXFxcInNjaGVkdWxlXFxcIixcXFwid2Vla1xcXCJdKSxjdHgse1xcXCJibG9ja1xcXCI6Ym9keV8xM30sbnVsbCk7fWZ1bmN0aW9uIGJvZHlfMTMoY2hrLGN0eCl7cmV0dXJuIGNoay5leGlzdHMoY3R4LmdldFBhdGgoZmFsc2UsIFtcXFwic2NoZWR1bGVcXFwiLFxcXCJ3ZWVrXFxcIixcXFwiZXZlbnRseVxcXCJdKSxjdHgse1xcXCJibG9ja1xcXCI6Ym9keV8xNH0sbnVsbCkuZXhpc3RzKGN0eC5nZXRQYXRoKGZhbHNlLCBbXFxcInNjaGVkdWxlXFxcIixcXFwid2Vla1xcXCIsXFxcInRhYmxlXFxcIl0pLGN0eCx7XFxcImJsb2NrXFxcIjpib2R5XzIyfSxudWxsKTt9ZnVuY3Rpb24gYm9keV8xNChjaGssY3R4KXtyZXR1cm4gY2hrLndyaXRlKFxcXCI8ZGl2IGNsYXNzPVxcXFxcXFwiZGctc2NoZWR1bGVfX3RhYmxlXFxcXFxcXCI+XFxcIikuc2VjdGlvbihjdHguZ2V0UGF0aChmYWxzZSwgW1xcXCJzY2hlZHVsZVxcXCIsXFxcIndlZWtcXFwiLFxcXCJldmVudGx5XFxcIl0pLGN0eCx7XFxcImJsb2NrXFxcIjpib2R5XzE1fSxudWxsKS53cml0ZShcXFwiPC9kaXY+XFxcIik7fWZ1bmN0aW9uIGJvZHlfMTUoY2hrLGN0eCl7cmV0dXJuIGNoay53cml0ZShcXFwiPGRpdiBjbGFzcz1cXFxcXFxcImRnLXNjaGVkdWxlX19zdHJpbmdcXFxcXFxcIj5cXFwiKS5leGlzdHMoY3R4LmdldChbXFxcImFsbHRpbWVcXFwiXSwgZmFsc2UpLGN0eCx7XFxcImJsb2NrXFxcIjpib2R5XzE2fSxudWxsKS5leGlzdHMoY3R4LmdldChbXFxcImV2ZXJ5ZGF5XFxcIl0sIGZhbHNlKSxjdHgse1xcXCJlbHNlXFxcIjpib2R5XzE3LFxcXCJibG9ja1xcXCI6Ym9keV8xOH0sbnVsbCkuZXhpc3RzKGN0eC5nZXQoW1xcXCJob2xpZGF5XFxcIl0sIGZhbHNlKSxjdHgse1xcXCJlbHNlXFxcIjpib2R5XzE5LFxcXCJibG9ja1xcXCI6Ym9keV8yMX0sbnVsbCkud3JpdGUoXFxcIjwvZGl2PlxcXCIpO31mdW5jdGlvbiBib2R5XzE2KGNoayxjdHgpe3JldHVybiBjaGsucmVmZXJlbmNlKGN0eC5nZXQoW1xcXCJhbGx0aW1lU3RyXFxcIl0sIGZhbHNlKSxjdHgsXFxcImhcXFwiKTt9ZnVuY3Rpb24gYm9keV8xNyhjaGssY3R4KXtyZXR1cm4gY2hrLnJlZmVyZW5jZShjdHguZ2V0KFtcXFwiZGF5TGlzdFxcXCJdLCBmYWxzZSksY3R4LFxcXCJoXFxcIik7fWZ1bmN0aW9uIGJvZHlfMTgoY2hrLGN0eCl7cmV0dXJuIGNoay5yZWZlcmVuY2UoY3R4LmdldFBhdGgoZmFsc2UsIFtcXFwiZm9yZWNhc3RcXFwiLFxcXCJ0b2RheVxcXCIsXFxcInRleHRcXFwiXSksY3R4LFxcXCJoXFxcIik7fWZ1bmN0aW9uIGJvZHlfMTkoY2hrLGN0eCl7cmV0dXJuIGNoay53cml0ZShcXFwiPHNwYW4gY2xhc3M9XFxcXFxcXCJzY2hlZHVsZV9fc3RyaW5nLXRpbWVcXFxcXFxcIj4mbmJzcDtcXFwiKS5yZWZlcmVuY2UoY3R4LmdldChbXFxcImZyb21cXFwiXSwgZmFsc2UpLGN0eCxcXFwiaFxcXCIpLndyaXRlKFxcXCImbmRhc2g7XFxcIikucmVmZXJlbmNlKGN0eC5nZXQoW1xcXCJ0b1xcXCJdLCBmYWxzZSksY3R4LFxcXCJoXFxcIikud3JpdGUoXFxcIjwvc3Bhbj5cXFwiKS5zZWN0aW9uKGN0eC5nZXQoW1xcXCJsdW5jaFxcXCJdLCBmYWxzZSksY3R4LHtcXFwiYmxvY2tcXFwiOmJvZHlfMjB9LG51bGwpO31mdW5jdGlvbiBib2R5XzIwKGNoayxjdHgpe3JldHVybiBjaGsud3JpdGUoXFxcIjxwPlxcXCIpLnJlZmVyZW5jZShjdHguZ2V0KFtcXFwibHVuY2hTdHJcXFwiXSwgZmFsc2UpLGN0eCxcXFwiaFxcXCIpLndyaXRlKFxcXCImbWRhc2g7PHNwYW4gY2xhc3M9XFxcXFxcXCJzY2hlZHVsZV9fc3RyaW5nLXRpbWVcXFxcXFxcIj5cXFwiKS5yZWZlcmVuY2UoY3R4LmdldChbXFxcImZyb21cXFwiXSwgZmFsc2UpLGN0eCxcXFwiaFxcXCIpLndyaXRlKFxcXCImbmRhc2g7XFxcIikucmVmZXJlbmNlKGN0eC5nZXQoW1xcXCJ0b1xcXCJdLCBmYWxzZSksY3R4LFxcXCJoXFxcIikud3JpdGUoXFxcIjwvc3Bhbj48L3A+XFxcIik7fWZ1bmN0aW9uIGJvZHlfMjEoY2hrLGN0eCl7cmV0dXJuIGNoay53cml0ZShcXFwiJm5ic3A7Jm1kYXNoOzxzcGFuIGNsYXNzPVxcXFxcXFwic2NoZWR1bGVfX3N0cmluZy10aW1lXFxcXFxcXCI+Jm5ic3A7XFxcIikucmVmZXJlbmNlKGN0eC5nZXQoW1xcXCJob2xpZGF5U3RyXFxcIl0sIGZhbHNlKSxjdHgsXFxcImhcXFwiKS53cml0ZShcXFwiPC9zcGFuPlxcXCIpO31mdW5jdGlvbiBib2R5XzIyKGNoayxjdHgpe3JldHVybiBjaGsud3JpdGUoXFxcIjxkaXY+PGRpdiBjbGFzcz1cXFxcXFxcImRnLXNjaGVkdWxlX190YWJsZVxcXFxcXFwiPjxkaXYgY2xhc3M9XFxcXFxcXCJkZy1zY2hlZHVsZV9fdGMgZGctc2NoZWR1bGVfX3RjX3ByZVxcXFxcXFwiPjxkaXYgY2xhc3M9XFxcXFxcXCJkZy1zY2hlZHVsZV9fZGF5LW5hbWVcXFxcXFxcIj4mbmJzcDs8L2Rpdj48ZGl2IGNsYXNzPVxcXFxcXFwiZGctc2NoZWR1bGVfX3RhYmxlLWNsb2NrIGRnLXNjaGVkdWxlX190ZFxcXFxcXFwiPjwvZGl2PlxcXCIpLmV4aXN0cyhjdHguZ2V0UGF0aChmYWxzZSwgW1xcXCJzY2hlZHVsZVxcXCIsXFxcIndlZWtcXFwiLFxcXCJoYXNMdW5jaFxcXCJdKSxjdHgse1xcXCJibG9ja1xcXCI6Ym9keV8yM30sbnVsbCkud3JpdGUoXFxcIjwvZGl2PlxcXCIpLnNlY3Rpb24oY3R4LmdldFBhdGgoZmFsc2UsIFtcXFwic2NoZWR1bGVcXFwiLFxcXCJ3ZWVrXFxcIixcXFwidGFibGVcXFwiXSksY3R4LHtcXFwiYmxvY2tcXFwiOmJvZHlfMjR9LG51bGwpLndyaXRlKFxcXCI8L2Rpdj4gIDwvZGl2PlxcXCIpO31mdW5jdGlvbiBib2R5XzIzKGNoayxjdHgpe3JldHVybiBjaGsud3JpdGUoXFxcIjxkaXYgY2xhc3M9XFxcXFxcXCJkZy1zY2hlZHVsZV9fdGFibGUtbHVuY2ggZGctc2NoZWR1bGVfX3RkXFxcXFxcXCI+PC9kaXY+XFxcIik7fWZ1bmN0aW9uIGJvZHlfMjQoY2hrLGN0eCl7cmV0dXJuIGNoay5oZWxwZXIoXFxcImlmXFxcIixjdHgse1xcXCJibG9ja1xcXCI6Ym9keV8yNX0se1xcXCJjb25kXFxcIjpib2R5XzI2fSkud3JpdGUoXFxcIjxkaXYgY2xhc3M9XFxcXFxcXCJkZy1zY2hlZHVsZV9fdGNcXFwiKS5leGlzdHMoY3R4LmdldChbXFxcImFjdGl2ZVxcXCJdLCBmYWxzZSksY3R4LHtcXFwiYmxvY2tcXFwiOmJvZHlfMjd9LG51bGwpLndyaXRlKFxcXCJcXFxcXFxcIj48ZGl2IGNsYXNzPVxcXFxcXFwiZGctc2NoZWR1bGVfX2RheS1uYW1lXFxcXFxcXCI+XFxcIikucmVmZXJlbmNlKGN0eC5nZXQoW1xcXCJrZXlcXFwiXSwgZmFsc2UpLGN0eCxcXFwiaFxcXCIpLndyaXRlKFxcXCI8L2Rpdj48ZGl2IGNsYXNzPVxcXFxcXFwiZGctc2NoZWR1bGVfX3RkXFxcXFxcXCI+XFxcIikuZXhpc3RzKGN0eC5nZXQoW1xcXCJmcm9tXFxcIl0sIGZhbHNlKSxjdHgse1xcXCJlbHNlXFxcIjpib2R5XzI4LFxcXCJibG9ja1xcXCI6Ym9keV8yOX0sbnVsbCkud3JpdGUoXFxcIjwvZGl2PlxcXCIpLnNlY3Rpb24oY3R4LmdldChbXFxcImx1bmNoXFxcIl0sIGZhbHNlKSxjdHgse1xcXCJibG9ja1xcXCI6Ym9keV8zMH0sbnVsbCkud3JpdGUoXFxcIjwvZGl2PiBcXFwiKS5oZWxwZXIoXFxcImlmXFxcIixjdHgse1xcXCJibG9ja1xcXCI6Ym9keV8zM30se1xcXCJjb25kXFxcIjpib2R5XzM0fSk7fWZ1bmN0aW9uIGJvZHlfMjUoY2hrLGN0eCl7cmV0dXJuIGNoay53cml0ZShcXFwiPHNwYW4gY2xhc3M9XFxcXFxcXCJkZy1zY2hlZHVsZV9fdGFibGUtY2VsbC1ncm91cFxcXFxcXFwiPlxcXCIpO31mdW5jdGlvbiBib2R5XzI2KGNoayxjdHgpe3JldHVybiBjaGsud3JpdGUoXFxcIihcXFwiKS5yZWZlcmVuY2UoY3R4LmdldChbXFxcIiRpZHhcXFwiXSwgZmFsc2UpLGN0eCxcXFwiaFxcXCIpLndyaXRlKFxcXCIgPT0gXFxcIikucmVmZXJlbmNlKGN0eC5nZXQoW1xcXCIkbGVuXFxcIl0sIGZhbHNlKSxjdHgsXFxcImhcXFwiKS53cml0ZShcXFwiIC0gMilcXFwiKTt9ZnVuY3Rpb24gYm9keV8yNyhjaGssY3R4KXtyZXR1cm4gY2hrLndyaXRlKFxcXCIgZGctc2NoZWR1bGVfX3RjX2FjdGl2ZV90cnVlXFxcIik7fWZ1bmN0aW9uIGJvZHlfMjgoY2hrLGN0eCl7cmV0dXJuIGNoay53cml0ZShcXFwiJm5kYXNoO1xcXCIpO31mdW5jdGlvbiBib2R5XzI5KGNoayxjdHgpe3JldHVybiBjaGsucmVmZXJlbmNlKGN0eC5nZXQoW1xcXCJmcm9tXFxcIl0sIGZhbHNlKSxjdHgsXFxcImhcXFwiKS53cml0ZShcXFwiIFxcXCIpLnJlZmVyZW5jZShjdHguZ2V0KFtcXFwidG9cXFwiXSwgZmFsc2UpLGN0eCxcXFwiaFxcXCIpO31mdW5jdGlvbiBib2R5XzMwKGNoayxjdHgpe3JldHVybiBjaGsud3JpdGUoXFxcIjxkaXYgY2xhc3M9XFxcXFxcXCJkZy1zY2hlZHVsZV9fdGRcXFxcXFxcIj5cXFwiKS5leGlzdHMoY3R4LmdldChbXFxcImZyb21cXFwiXSwgZmFsc2UpLGN0eCx7XFxcImVsc2VcXFwiOmJvZHlfMzEsXFxcImJsb2NrXFxcIjpib2R5XzMyfSxudWxsKS53cml0ZShcXFwiPC9kaXY+XFxcIik7fWZ1bmN0aW9uIGJvZHlfMzEoY2hrLGN0eCl7cmV0dXJuIGNoay53cml0ZShcXFwiJm5kYXNoO1xcXCIpO31mdW5jdGlvbiBib2R5XzMyKGNoayxjdHgpe3JldHVybiBjaGsucmVmZXJlbmNlKGN0eC5nZXQoW1xcXCJmcm9tXFxcIl0sIGZhbHNlKSxjdHgsXFxcImhcXFwiKS53cml0ZShcXFwiIFxcXCIpLnJlZmVyZW5jZShjdHguZ2V0KFtcXFwidG9cXFwiXSwgZmFsc2UpLGN0eCxcXFwiaFxcXCIpO31mdW5jdGlvbiBib2R5XzMzKGNoayxjdHgpe3JldHVybiBjaGsud3JpdGUoXFxcIjwvc3Bhbj5cXFwiKTt9ZnVuY3Rpb24gYm9keV8zNChjaGssY3R4KXtyZXR1cm4gY2hrLndyaXRlKFxcXCIoXFxcIikucmVmZXJlbmNlKGN0eC5nZXQoW1xcXCIkaWR4XFxcIl0sIGZhbHNlKSxjdHgsXFxcImhcXFwiKS53cml0ZShcXFwiID09IFxcXCIpLnJlZmVyZW5jZShjdHguZ2V0KFtcXFwiJGxlblxcXCJdLCBmYWxzZSksY3R4LFxcXCJoXFxcIikud3JpdGUoXFxcIilcXFwiKTt9cmV0dXJuIGJvZHlfMDt9KSgpO1wiLFwiZmlybWxpc3RJdGVtXCI6XCIoZnVuY3Rpb24oKXtkdXN0LnJlZ2lzdGVyKFxcXCJmaXJtbGlzdEl0ZW1cXFwiLGJvZHlfMCk7ZnVuY3Rpb24gYm9keV8wKGNoayxjdHgpe3JldHVybiBjaGsud3JpdGUoXFxcIjxhIGlkPVxcXFxcXFwiXFxcIikucmVmZXJlbmNlKGN0eC5nZXRQYXRoKGZhbHNlLCBbXFxcImZpcm1cXFwiLFxcXCJpZFxcXCJdKSxjdHgsXFxcImhcXFwiKS53cml0ZShcXFwiXFxcXFxcXCIgY2xhc3M9XFxcXFxcXCJkZy1wb3B1cF9fbGlua1xcXFxcXFwiIGhyZWY9XFxcXFxcXCIjXFxcXFxcXCI+XFxcIikucmVmZXJlbmNlKGN0eC5nZXRQYXRoKGZhbHNlLCBbXFxcImZpcm1cXFwiLFxcXCJuYW1lXFxcIl0pLGN0eCxcXFwiaFxcXCIpLndyaXRlKFxcXCI8L2E+XFxcIik7fXJldHVybiBib2R5XzA7fSkoKTtcIixcImZyaW1DYXJkUGF5bWVudHNcIjpcIihmdW5jdGlvbigpe2R1c3QucmVnaXN0ZXIoXFxcImZyaW1DYXJkUGF5bWVudHNcXFwiLGJvZHlfMCk7ZnVuY3Rpb24gYm9keV8wKGNoayxjdHgpe3JldHVybiBjaGsuZXhpc3RzKGN0eC5nZXQoW1xcXCJwYXltZW50c1xcXCJdLCBmYWxzZSksY3R4LHtcXFwiYmxvY2tcXFwiOmJvZHlfMX0sbnVsbCk7fWZ1bmN0aW9uIGJvZHlfMShjaGssY3R4KXtyZXR1cm4gY2hrLndyaXRlKFxcXCI8c2VjdGlvbiBjbGFzcz1cXFxcXFxcImRnLWZpcm0tY2FyZF9fYWFcXFxcXFxcIj48dWwgY2xhc3M9XFxcXFxcXCJkZy1maXJtLWNhcmRfX2FhLWxpc3RcXFxcXFxcIj5cXFwiKS5zZWN0aW9uKGN0eC5nZXQoW1xcXCJwYXltZW50c1xcXCJdLCBmYWxzZSksY3R4LHtcXFwiYmxvY2tcXFwiOmJvZHlfMn0sbnVsbCkud3JpdGUoXFxcIjwvdWw+PC9zZWN0aW9uPlxcXCIpO31mdW5jdGlvbiBib2R5XzIoY2hrLGN0eCl7cmV0dXJuIGNoay53cml0ZShcXFwiPGxpIGNsYXNzPVxcXFxcXFwiZGctZmlybS1jYXJkX19hYS1saXN0LWl0ZW1cXFxcXFxcIj5cXFwiKS5yZWZlcmVuY2UoY3R4LmdldFBhdGgodHJ1ZSwgW10pLGN0eCxcXFwiaFxcXCIpLndyaXRlKFxcXCI8L2xpPlxcXCIpO31yZXR1cm4gYm9keV8wO30pKCk7XCIsXCJob3VzZVwiOlwiKGZ1bmN0aW9uKCl7ZHVzdC5yZWdpc3RlcihcXFwiaG91c2VcXFwiLGJvZHlfMCk7ZnVuY3Rpb24gYm9keV8wKGNoayxjdHgpe3JldHVybiBjaGsuc2VjdGlvbihjdHguZ2V0KFtcXFwiYWRkcmVzc1xcXCJdLCBmYWxzZSksY3R4LHtcXFwiYmxvY2tcXFwiOmJvZHlfMX0sbnVsbCkuc2VjdGlvbihjdHguZ2V0KFtcXFwicHVycG9zZVxcXCJdLCBmYWxzZSksY3R4LHtcXFwiYmxvY2tcXFwiOmJvZHlfNH0sbnVsbCkuc2VjdGlvbihjdHguZ2V0KFtcXFwiYXR0cmFjdGlvbnNcXFwiXSwgZmFsc2UpLGN0eCx7XFxcImJsb2NrXFxcIjpib2R5XzV9LG51bGwpO31mdW5jdGlvbiBib2R5XzEoY2hrLGN0eCl7cmV0dXJuIGNoay53cml0ZShcXFwiPGFkZHJlc3MgY2xhc3M9XFxcXFxcXCJkZy1tYXAtZ2VvY2xpY2tlcl9fYWRkcmVzc1xcXFxcXFwiPlxcXCIpLnNlY3Rpb24oY3R4LmdldFBhdGgoZmFsc2UsIFtcXFwiYWRkcmVzc1xcXCIsXFxcImhlYWRlclxcXCJdKSxjdHgse1xcXCJibG9ja1xcXCI6Ym9keV8yfSxudWxsKS5zZWN0aW9uKGN0eC5nZXRQYXRoKGZhbHNlLCBbXFxcImFkZHJlc3NcXFwiLFxcXCJkcmlsbGRvd25cXFwiXSksY3R4LHtcXFwiYmxvY2tcXFwiOmJvZHlfM30sbnVsbCkud3JpdGUoXFxcIjwvYWRkcmVzcz5cXFwiKTt9ZnVuY3Rpb24gYm9keV8yKGNoayxjdHgpe3JldHVybiBjaGsud3JpdGUoXFxcIjxkaXYgY2xhc3M9XFxcXFxcXCJkZy1tYXAtZ2VvY2xpY2tlcl9fYWRkcmVzcy1oZWFkZXJcXFxcXFxcIj5cXFwiKS5yZWZlcmVuY2UoY3R4LmdldFBhdGgodHJ1ZSwgW10pLGN0eCxcXFwiaFxcXCIpLndyaXRlKFxcXCI8L2Rpdj5cXFwiKTt9ZnVuY3Rpb24gYm9keV8zKGNoayxjdHgpe3JldHVybiBjaGsud3JpdGUoXFxcIjxkaXYgY2xhc3M9XFxcXFxcXCJkZy1tYXAtZ2VvY2xpY2tlcl9fYWRkcmVzcy1kcmlsbGRvd25cXFxcXFxcIj5cXFwiKS5yZWZlcmVuY2UoY3R4LmdldFBhdGgodHJ1ZSwgW10pLGN0eCxcXFwiaFxcXCIpLndyaXRlKFxcXCI8L2Rpdj5cXFwiKTt9ZnVuY3Rpb24gYm9keV80KGNoayxjdHgpe3JldHVybiBjaGsud3JpdGUoXFxcIjxkaXYgY2xhc3M9XFxcXFxcXCJkZy1tYXAtZ2VvY2xpY2tlcl9fcHVycG9zZVxcXFxcXFwiPlxcXCIpLnJlZmVyZW5jZShjdHguZ2V0UGF0aCh0cnVlLCBbXSksY3R4LFxcXCJoXFxcIikud3JpdGUoXFxcIjwvZGl2PlxcXCIpO31mdW5jdGlvbiBib2R5XzUoY2hrLGN0eCl7cmV0dXJuIGNoay53cml0ZShcXFwiPGRpdiBjbGFzcz1cXFxcXFxcImRnLW1hcC1nZW9jbGlja2VyX19wdXJwb3NlIGRnLW1hcC1nZW9jbGlja2VyX19wdXJwb3NlX3R5cGVfc2lnaHRcXFxcXFxcIj5cXFwiKS5yZWZlcmVuY2UoY3R4LmdldFBhdGgodHJ1ZSwgW10pLGN0eCxcXFwiaFxcXCIpLndyaXRlKFxcXCI8L2Rpdj5cXFwiKTt9cmV0dXJuIGJvZHlfMDt9KSgpO1wiLFwibG9hZGVyXCI6XCIoZnVuY3Rpb24oKXtkdXN0LnJlZ2lzdGVyKFxcXCJsb2FkZXJcXFwiLGJvZHlfMCk7ZnVuY3Rpb24gYm9keV8wKGNoayxjdHgpe3JldHVybiBjaGsud3JpdGUoXFxcIjxkaXYgY2xhc3M9XFxcXFxcXCJkZy1wcmVsb2FkZXIgZGctcHJlbG9hZGVyX3NjaGVtZV9yZWd1bGFyIGRnLXByZWxvYWRlcl9hbmltYXRpb25fXFxcIikuZXhpc3RzKGN0eC5nZXQoW1xcXCJhbmltXFxcIl0sIGZhbHNlKSxjdHgse1xcXCJlbHNlXFxcIjpib2R5XzEsXFxcImJsb2NrXFxcIjpib2R5XzJ9LG51bGwpLmV4aXN0cyhjdHguZ2V0KFtcXFwic21hbGxcXFwiXSwgZmFsc2UpLGN0eCx7XFxcImJsb2NrXFxcIjpib2R5XzN9LG51bGwpLndyaXRlKFxcXCJcXFxcXFxcIj48L2Rpdj5cXFwiKTt9ZnVuY3Rpb24gYm9keV8xKGNoayxjdHgpe3JldHVybiBjaGsud3JpdGUoXFxcImZhbHNlXFxcIik7fWZ1bmN0aW9uIGJvZHlfMihjaGssY3R4KXtyZXR1cm4gY2hrLndyaXRlKFxcXCJ0cnVlXFxcIik7fWZ1bmN0aW9uIGJvZHlfMyhjaGssY3R4KXtyZXR1cm4gY2hrLndyaXRlKFxcXCIgZGctcHJlbG9hZGVyX3NpemVfc21hbGxcXFwiKTt9cmV0dXJuIGJvZHlfMDt9KSgpO1wiLFwicG9wdXBGb290ZXJcIjpcIihmdW5jdGlvbigpe2R1c3QucmVnaXN0ZXIoXFxcInBvcHVwRm9vdGVyXFxcIixib2R5XzApO2Z1bmN0aW9uIGJvZHlfMChjaGssY3R4KXtyZXR1cm4gY2hrLndyaXRlKFxcXCI8ZGl2IGNsYXNzPVxcXFxcXFwiZGctcG9wdXBfX2Zvb3Rlci10aXRsZVxcXFxcXFwiPjxhIGNsYXNzPVxcXFxcXFwiZGctcG9wdXBfX3Nob3ctbGVzcy1ob3VzZS1saW5rXFxcXFxcXCIgaHJlZj1cXFxcXFxcImphdmFzY3JpcHQ6dm9pZCgwKVxcXFxcXFwiPlxcXCIpLnJlZmVyZW5jZShjdHguZ2V0KFtcXFwiaGlkZUZpcm1zVGV4dFxcXCJdLCBmYWxzZSksY3R4LFxcXCJoXFxcIikud3JpdGUoXFxcIjwvYT48L2Rpdj5cXFwiKTt9cmV0dXJuIGJvZHlfMDt9KSgpO1wiLFwicG9wdXBGb290ZXJCdG5zXCI6XCIoZnVuY3Rpb24oKXtkdXN0LnJlZ2lzdGVyKFxcXCJwb3B1cEZvb3RlckJ0bnNcXFwiLGJvZHlfMCk7ZnVuY3Rpb24gYm9keV8wKGNoayxjdHgpe3JldHVybiBjaGsuZXhpc3RzKGN0eC5nZXQoW1xcXCJidG5zXFxcIl0sIGZhbHNlKSxjdHgse1xcXCJibG9ja1xcXCI6Ym9keV8xfSxudWxsKTt9ZnVuY3Rpb24gYm9keV8xKGNoayxjdHgpe3JldHVybiBjaGsud3JpdGUoXFxcIjxmb290ZXIgY2xhc3M9XFxcXFxcXCJkZy1wb3B1cF9fZm9vdGVyLWJ1dHRvbnNcXFxcXFxcIj5cXFwiKS5zZWN0aW9uKGN0eC5nZXQoW1xcXCJidG5zXFxcIl0sIGZhbHNlKSxjdHgse1xcXCJibG9ja1xcXCI6Ym9keV8yfSxudWxsKS53cml0ZShcXFwiPC9mb290ZXI+XFxcIik7fWZ1bmN0aW9uIGJvZHlfMihjaGssY3R4KXtyZXR1cm4gY2hrLndyaXRlKFxcXCI8ZGl2IGNsYXNzPVxcXFxcXFwiZGctcG9wdXBfX2Zvb3Rlci1idXR0b24td3JhcHBlclxcXFxcXFwiPjxhIGNsYXNzPVxcXFxcXFwiZGctcG9wdXBfX2J1dHRvbl9uYW1lX1xcXCIpLnJlZmVyZW5jZShjdHguZ2V0KFtcXFwibmFtZVxcXCJdLCBmYWxzZSksY3R4LFxcXCJoXFxcIikud3JpdGUoXFxcIiBkZy1wb3B1cF9fZm9vdGVyLWJ1dHRvblxcXCIpLmV4aXN0cyhjdHguZ2V0KFtcXFwiaWNvblxcXCJdLCBmYWxzZSksY3R4LHtcXFwiYmxvY2tcXFwiOmJvZHlfM30sbnVsbCkud3JpdGUoXFxcIlxcXFxcXFwiXFxcIikuZXhpc3RzKGN0eC5nZXQoW1xcXCJocmVmXFxcIl0sIGZhbHNlKSxjdHgse1xcXCJlbHNlXFxcIjpib2R5XzQsXFxcImJsb2NrXFxcIjpib2R5XzV9LG51bGwpLndyaXRlKFxcXCI+XFxcIikucmVmZXJlbmNlKGN0eC5nZXQoW1xcXCJsYWJlbFxcXCJdLCBmYWxzZSksY3R4LFxcXCJoXFxcIikud3JpdGUoXFxcIjwvYT48L2Rpdj5cXFwiKTt9ZnVuY3Rpb24gYm9keV8zKGNoayxjdHgpe3JldHVybiBjaGsud3JpdGUoXFxcIiBkZy1wb3B1cF9fZm9vdGVyLWljb24tYnV0dG9uXFxcIik7fWZ1bmN0aW9uIGJvZHlfNChjaGssY3R4KXtyZXR1cm4gY2hrLndyaXRlKFxcXCJocmVmPVxcXFxcXFwiamF2YXNjcmlwdDp2b2lkKDApXFxcXFxcXCJcXFwiKTt9ZnVuY3Rpb24gYm9keV81KGNoayxjdHgpe3JldHVybiBjaGsud3JpdGUoXFxcImhyZWY9XFxcIikucmVmZXJlbmNlKGN0eC5nZXQoW1xcXCJocmVmXFxcIl0sIGZhbHNlKSxjdHgsXFxcImhcXFwiKS53cml0ZShcXFwiIHRhcmdldD1cXFxcXFxcIl9ibGFua1xcXFxcXFwiXFxcIik7fXJldHVybiBib2R5XzA7fSkoKTtcIixcInBvcHVwSGVhZGVyXCI6XCIoZnVuY3Rpb24oKXtkdXN0LnJlZ2lzdGVyKFxcXCJwb3B1cEhlYWRlclxcXCIsYm9keV8wKTtmdW5jdGlvbiBib2R5XzAoY2hrLGN0eCl7cmV0dXJuIGNoay5zZWN0aW9uKGN0eC5nZXQoW1xcXCJ0aXRsZVxcXCJdLCBmYWxzZSksY3R4LHtcXFwiYmxvY2tcXFwiOmJvZHlfMX0sbnVsbCk7fWZ1bmN0aW9uIGJvZHlfMShjaGssY3R4KXtyZXR1cm4gY2hrLndyaXRlKFxcXCI8ZGl2IGNsYXNzPVxcXFxcXFwiZGctcG9wdXBfX2hlYWRlci10aXRsZVxcXFxcXFwiPlxcXCIpLnJlZmVyZW5jZShjdHguZ2V0UGF0aCh0cnVlLCBbXSksY3R4LFxcXCJoXFxcIikud3JpdGUoXFxcIjwvZGl2PlxcXCIpO31yZXR1cm4gYm9keV8wO30pKCk7XCIsXCJzaWdodFwiOlwiKGZ1bmN0aW9uKCl7ZHVzdC5yZWdpc3RlcihcXFwic2lnaHRcXFwiLGJvZHlfMCk7ZnVuY3Rpb24gYm9keV8wKGNoayxjdHgpe3JldHVybiBjaGsuc2VjdGlvbihjdHguZ2V0KFtcXFwicHVycG9zZVxcXCJdLCBmYWxzZSksY3R4LHtcXFwiYmxvY2tcXFwiOmJvZHlfMX0sbnVsbCkuc2VjdGlvbihjdHguZ2V0KFtcXFwiYWRkcmVzc1xcXCJdLCBmYWxzZSksY3R4LHtcXFwiYmxvY2tcXFwiOmJvZHlfMn0sbnVsbCkuc2VjdGlvbihjdHguZ2V0KFtcXFwiZGVzY3JpcHRpb25cXFwiXSwgZmFsc2UpLGN0eCx7XFxcImJsb2NrXFxcIjpib2R5XzV9LG51bGwpO31mdW5jdGlvbiBib2R5XzEoY2hrLGN0eCl7cmV0dXJuIGNoay53cml0ZShcXFwiPGRpdiBjbGFzcz1cXFxcXFxcImRnLW1hcC1nZW9jbGlja2VyX19wdXJwb3NlIGRnLW1hcC1nZW9jbGlja2VyX19wdXJwb3NlX3R5cGVfc2lnaHRcXFxcXFxcIj5cXFwiKS5yZWZlcmVuY2UoY3R4LmdldFBhdGgodHJ1ZSwgW10pLGN0eCxcXFwiaFxcXCIpLndyaXRlKFxcXCI8L2Rpdj5cXFwiKTt9ZnVuY3Rpb24gYm9keV8yKGNoayxjdHgpe3JldHVybiBjaGsud3JpdGUoXFxcIjxhZGRyZXNzIGNsYXNzPVxcXFxcXFwiZGctbWFwLWdlb2NsaWNrZXJfX2FkZHJlc3NcXFxcXFxcIj5cXFwiKS5zZWN0aW9uKGN0eC5nZXRQYXRoKGZhbHNlLCBbXFxcImFkZHJlc3NcXFwiLFxcXCJoZWFkZXJcXFwiXSksY3R4LHtcXFwiYmxvY2tcXFwiOmJvZHlfM30sbnVsbCkuc2VjdGlvbihjdHguZ2V0UGF0aChmYWxzZSwgW1xcXCJhZGRyZXNzXFxcIixcXFwiZHJpbGxkb3duXFxcIl0pLGN0eCx7XFxcImJsb2NrXFxcIjpib2R5XzR9LG51bGwpLndyaXRlKFxcXCI8L2FkZHJlc3M+XFxcIik7fWZ1bmN0aW9uIGJvZHlfMyhjaGssY3R4KXtyZXR1cm4gY2hrLndyaXRlKFxcXCI8ZGl2IGNsYXNzPVxcXFxcXFwiZGctbWFwLWdlb2NsaWNrZXJfX2FkZHJlc3MtaGVhZGVyXFxcXFxcXCI+XFxcIikucmVmZXJlbmNlKGN0eC5nZXRQYXRoKHRydWUsIFtdKSxjdHgsXFxcImhcXFwiKS53cml0ZShcXFwiPC9kaXY+XFxcIik7fWZ1bmN0aW9uIGJvZHlfNChjaGssY3R4KXtyZXR1cm4gY2hrLndyaXRlKFxcXCI8ZGl2IGNsYXNzPVxcXFxcXFwiZGctbWFwLWdlb2NsaWNrZXJfX2FkZHJlc3MtZHJpbGxkb3duXFxcXFxcXCI+XFxcIikucmVmZXJlbmNlKGN0eC5nZXRQYXRoKHRydWUsIFtdKSxjdHgsXFxcImhcXFwiKS53cml0ZShcXFwiPC9kaXY+XFxcIik7fWZ1bmN0aW9uIGJvZHlfNShjaGssY3R4KXtyZXR1cm4gY2hrLndyaXRlKFxcXCI8ZGl2IGNsYXNzPVxcXFxcXFwiZGctbWFwLWdlb2NsaWNrZXJfX3NpZ2h0LWRlc2NyaXB0aW9uXFxcXFxcXCI+XFxcIikucmVmZXJlbmNlKGN0eC5nZXRQYXRoKHRydWUsIFtdKSxjdHgsXFxcImhcXFwiKS53cml0ZShcXFwiPC9kaXY+XFxcIikuc2VjdGlvbihjdHguZ2V0KFtcXFwic2hvd01vcmVUZXh0XFxcIl0sIGZhbHNlKSxjdHgse1xcXCJibG9ja1xcXCI6Ym9keV82fSxudWxsKTt9ZnVuY3Rpb24gYm9keV82KGNoayxjdHgpe3JldHVybiBjaGsud3JpdGUoXFxcIjxhIGNsYXNzPVxcXFxcXFwiZGctbWFwLWdlb2NsaWNrZXJfX3Nob3ctbW9yZS1zaWdodHMtbGlua1xcXFxcXFwiIGhyZWY9XFxcXFxcXCJqYXZhc2NyaXB0OnZvaWQoMClcXFxcXFxcIj5cXFwiKS5yZWZlcmVuY2UoY3R4LmdldFBhdGgodHJ1ZSwgW10pLGN0eCxcXFwiaFxcXCIpLndyaXRlKFxcXCI8L2E+XFxcIik7fXJldHVybiBib2R5XzA7fSkoKTtcIn0pO1xuXG4gICAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgICAgICBERy5VdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgaW5pdExvYWRlcjogZnVuY3Rpb24gKGlzU21hbGwpIHtcbiAgICAgICAgdmFyIGxvYWRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBsb2FkZXIuaW5uZXJIVE1MID0gdGhpcy5fdGVtcGxhdGVzKCdsb2FkZXInLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHNtYWxsOiBpc1NtYWxsLFxuICAgICAgICAgICAgICAgIGFuaW06IHRoaXMuX2RldGVjdENzc0FuaW1hdGlvbigpXG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuIGxvYWRlci5maXJzdENoaWxkO1xuICAgIH0sXG5cbiAgICBzaG93UG9wdXA6IGZ1bmN0aW9uIChsYXRsbmcsIGNvbnRlbnQpIHsgLy8gKE9iamVjdClcbiAgICAgICAgdGhpcy5fcG9wdXBcbiAgICAgICAgICAgICAgICAuc2V0Q29udGVudChjb250ZW50KVxuICAgICAgICAgICAgICAgIC5zZXRMYXRMbmcobGF0bG5nKVxuICAgICAgICAgICAgICAgIC5vcGVuT24odGhpcy5fbWFwKTtcbiAgICB9LFxuXG4gICAgcmVuZGVyOiBmdW5jdGlvbiAob3B0aW9ucykgeyAvLyAoT2JqZWN0KSAtPiBTdHJpbmdcbiAgICAgICAgdmFyIGh0bWwsXG4gICAgICAgICAgICBkYXRhID0ge307XG5cbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIG9wdGlvbnMudG1wbCA9IG9wdGlvbnMudG1wbCB8fCAnJztcblxuICAgICAgICBpZiAob3B0aW9ucy5kYXRhKSB7XG4gICAgICAgICAgICBodG1sID0gdGhpcy5fdGVtcGxhdGVzKG9wdGlvbnMudG1wbCwgb3B0aW9ucy5kYXRhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGh0bWwgPSBvcHRpb25zLnRtcGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5iZWZvcmVSZW5kZXIpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuYmVmb3JlUmVuZGVyKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5wb3B1cCkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuaGVhZGVyKSB7XG4gICAgICAgICAgICAgICAgZGF0YS5oZWFkZXIgPSBvcHRpb25zLmhlYWRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmZvb3Rlcikge1xuICAgICAgICAgICAgICAgIGRhdGEuZm9vdGVyID0gb3B0aW9ucy5mb290ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkYXRhLmJvZHkgPSBodG1sO1xuICAgICAgICAgICAgdGhpcy5fcG9wdXAuc2V0Q29udGVudChkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5hZnRlclJlbmRlcikge1xuICAgICAgICAgICAgb3B0aW9ucy5hZnRlclJlbmRlcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGh0bWw7XG4gICAgfSxcblxuICAgIHJlbmRlclBvcHVwOiBmdW5jdGlvbiAob3B0aW9ucykgeyAvLyAoT2JqZWN0KSAtPiBTdHJpbmdcbiAgICAgICAgb3B0aW9ucy5wb3B1cCA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlcihvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgZ2V0UG9wdXA6IGZ1bmN0aW9uICgpIHsgLy8gKCkgLT4gT2JqZWN0XG4gICAgICAgIHJldHVybiB0aGlzLl9wb3B1cDtcbiAgICB9LFxuXG4gICAgX2RldGVjdENzc0FuaW1hdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYW5pbWF0aW9uID0gZmFsc2UsXG4gICAgICAgICAgICBkb21QcmVmaXhlcyA9ICdXZWJraXQgTW96IE8gbXMgS2h0bWwnLnNwbGl0KCcgJyksXG4gICAgICAgICAgICBlbG0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAgICAgICBpZiAoZWxtLnN0eWxlLmFuaW1hdGlvbk5hbWUpIHsgYW5pbWF0aW9uID0gdHJ1ZTsgfVxuXG4gICAgICAgIGlmIChhbmltYXRpb24gPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRvbVByZWZpeGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVsbS5zdHlsZVtkb21QcmVmaXhlc1tpXSArICdBbmltYXRpb25OYW1lJ10gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBhbmltYXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFuaW1hdGlvbjtcbiAgICB9XG59KTtcbiIsIkRHLkdlb2NsaWNrZXIuQ29udHJvbGxlciA9IERHLkNsYXNzLmV4dGVuZCh7XG5cbiAgICBvcHRpb25zOiB7XG4gICAgICAgIC8vIGlmIGhhbmRsZXIgd29ya2VkIHN1Y2Nlc3NmdWxseSwgaXQgc2hvdWxkIHJldHVybiByZW5kZXJpbmcgb2JqZWN0IHRoYXQgd2lsbCBiZSBwcm9jZXNzZWQgaW4gVmlldyAsIG90aGVyd2lzZSBpdCBzaG91bGQgcmV0dXJuIGZhbHNlXG4gICAgICAgIC8vIGRlZmF1bHQgaGFuZGxlciBhbHdheXMgc2hvdWxkIHJldHVybiByZW5kZXJpbmcgb2JqZWN0XG4gICAgICAgICdoYW5kbGVyc1NlcXVlbmNlJzoge1xuICAgICAgICAgICAgJ3BvaSc6IERHLkdlb2NsaWNrZXIuSGFuZGxlci5Qb2ksXG4gICAgICAgICAgICAnYXR0cmFjdGlvbic6IERHLkdlb2NsaWNrZXIuSGFuZGxlci5TaWdodCxcbiAgICAgICAgICAgICdidWlsZGluZyc6IERHLkdlb2NsaWNrZXIuSGFuZGxlci5Ib3VzZSxcbiAgICAgICAgICAgICdzdHJlZXQnOiBERy5HZW9jbGlja2VyLkhhbmRsZXIuQ2l0eUFyZWEsXG4gICAgICAgICAgICAnYWRtX2Rpdi5wbGFjZSc6IERHLkdlb2NsaWNrZXIuSGFuZGxlci5DaXR5QXJlYSxcbiAgICAgICAgICAgICdhZG1fZGl2LmRpc3RyaWN0JzogREcuR2VvY2xpY2tlci5IYW5kbGVyLkNpdHlBcmVhLFxuICAgICAgICAgICAgJ2FkbV9kaXYuZGl2aXNpb24nOiBERy5HZW9jbGlja2VyLkhhbmRsZXIuQ2l0eUFyZWEsXG4gICAgICAgICAgICAnYWRtX2Rpdi5zZXR0bGVtZW50JzogREcuR2VvY2xpY2tlci5IYW5kbGVyLkNpdHlBcmVhLFxuICAgICAgICAgICAgJ2FkbV9kaXYuY2l0eSc6IERHLkdlb2NsaWNrZXIuSGFuZGxlci5DaXR5QXJlYSxcblxuICAgICAgICAgICAgJ2RlZmF1bHQnOiBERy5HZW9jbGlja2VyLkhhbmRsZXIuRGVmYXVsdCxcblxuICAgICAgICAgICAgJ2FwaUVycm9yJzogREcuR2VvY2xpY2tlci5IYW5kbGVyLkFwaUVycm9yXG5cbi8vICAgICAgICAgICAgc3RhdGlvbl9wbGF0Zm9ybVxuLy8gICAgICAgICAgICBwcm9qZWN0XG4vLyAgICAgICAgICAgIHN0YXRpb25cbi8vICAgICAgICAgICAgY3Jvc3Nicm9hZFxuLy8gICAgICAgICAgICBtZXRyb1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIChtYXAsIG9wdGlvbnMpIHsgLy8gKE9iamVjdCwgT2JqZWN0KVxuICAgICAgICB0aGlzLl9vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5faGFuZGxlcnMgPSB7fTtcbiAgICAgICAgdGhpcy5fY2F0YWxvZ0FwaSA9IG5ldyBERy5HZW9jbGlja2VyLlByb3ZpZGVyLkNhdGFsb2dBcGkobWFwKTtcbiAgICAgICAgdGhpcy5fbWFwID0gbWFwO1xuICAgICAgICB0aGlzLl92aWV3ID0gbmV3IERHLkdlb2NsaWNrZXIuVmlldyhtYXApO1xuXG4gICAgICAgIHRoaXMuX3JlbmRlckhhbmRsZXJSZXN1bHQgPSBERy5iaW5kKHRoaXMuX3JlbmRlckhhbmRsZXJSZXN1bHQsIHRoaXMpO1xuICAgICAgICB0aGlzLl9sYXN0SGFuZGxlQ2xpY2tBcmd1bWVudHMgPSBudWxsO1xuICAgIH0sXG5cbiAgICBoYW5kbGVQb3B1cENsb3NlOiBmdW5jdGlvbiAocG9wdXApIHsgLy8gKE9iamVjdClcbiAgICAgICAgaWYgKHBvcHVwID09PSB0aGlzLl92aWV3LmdldFBvcHVwKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2xhc3RIYW5kbGVDbGlja0FyZ3VtZW50cyA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9jYXRhbG9nQXBpLmNhbmNlbExhc3RSZXF1ZXN0KCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgaGFuZGxlQ2xpY2s6IGZ1bmN0aW9uIChsYXRsbmcsIHpvb20sIG1ldGEpIHsgLy8gKE9iamVjdCwgTnVtYmVyLCBPYmplY3QpXG4gICAgICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuXG4gICAgICAgIGZ1bmN0aW9uIGJlZm9yZVJlcXVlc3QoKSB7XG4gICAgICAgICAgICB2YXIgbG9hZGVyID0gc2VsZi5fdmlldy5pbml0TG9hZGVyKCk7XG4gICAgICAgICAgICBzZWxmLl92aWV3Ll9wb3B1cC5jbGVhcigpO1xuICAgICAgICAgICAgc2VsZi5fdmlldy5zaG93UG9wdXAobGF0bG5nLCBsb2FkZXIpO1xuICAgICAgICAgICAgc2VsZi5fbGFzdEhhbmRsZUNsaWNrQXJndW1lbnRzID0gYXJncztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtZXRhICYmIG1ldGEubGlua2VkKSB7XG4gICAgICAgICAgICBiZWZvcmVSZXF1ZXN0KCk7XG4gICAgICAgICAgICBzZWxmLmhhbmRsZVJlc3BvbnNlKHtcbiAgICAgICAgICAgICAgICBwb2k6IHtcbiAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlOiBtZXRhLmxpbmtlZFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fY2F0YWxvZ0FwaS5nZXRMb2NhdGlvbnMoe1xuICAgICAgICAgICAgICAgIGxhdGxuZzogbGF0bG5nLFxuICAgICAgICAgICAgICAgIHpvb206IHpvb20sXG4gICAgICAgICAgICAgICAgYmVmb3JlUmVxdWVzdDogYmVmb3JlUmVxdWVzdFxuICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgc2VsZi5oYW5kbGVSZXNwb25zZShyZXN1bHQpO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5oYW5kbGVSZXNwb25zZShlcnJvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBoYW5kbGVSZXNwb25zZTogZnVuY3Rpb24gKHJlc3VsdCkgeyAvLyAoT2JqZWN0KVxuICAgICAgICB2YXIgdHlwZTtcblxuICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgdGhpcy5fcnVuSGFuZGxlcignZGVmYXVsdCcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gJ25vIHR5cGUnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVzdWx0ID09PSAnYWJvcnRlZCcpIHtcbiAgICAgICAgICAgIHRoaXMuX3J1bkhhbmRsZXIoJ2FwaUVycm9yJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0eXBlID0gdGhpcy5maW5kSGFuZGxlcihyZXN1bHQpO1xuXG4gICAgICAgIHdoaWxlICh0eXBlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcnVuSGFuZGxlcih0eXBlLCByZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVsZXRlIHJlc3VsdFt0eXBlXTtcblxuICAgICAgICAgICAgdHlwZSA9IHRoaXMuZmluZEhhbmRsZXIocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9ydW5IYW5kbGVyKCdkZWZhdWx0Jyk7XG4gICAgfSxcblxuICAgIGZpbmRIYW5kbGVyOiBmdW5jdGlvbiAocmVzdWx0KSB7IC8vIChPYmplY3QpIC0+IFN0cmluZ3xOdWxsXG4gICAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5vcHRpb25zLmhhbmRsZXJzU2VxdWVuY2UpIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHRbaV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG5cbiAgICBnZXRDYXRhbG9nQXBpOiBmdW5jdGlvbiAoKSB7IC8vICgpIC0+IE9iamVjdFxuICAgICAgICByZXR1cm4gdGhpcy5fY2F0YWxvZ0FwaTtcbiAgICB9LFxuXG4gICAgZ2V0TWFwOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXA7XG4gICAgfSxcblxuICAgIHJlaW52b2tlSGFuZGxlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fbGFzdEhhbmRsZUNsaWNrQXJndW1lbnRzKSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZUNsaWNrLmFwcGx5KHRoaXMsIHRoaXMuX2xhc3RIYW5kbGVDbGlja0FyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX3J1bkhhbmRsZXI6IGZ1bmN0aW9uICh0eXBlLCBkYXRhKSB7IC8vIChTdHJpbmcsIE9iamVjdCkgLT4gQm9vbGVhblxuICAgICAgICBkYXRhID0gZGF0YSB8fCB7fTtcbiAgICAgICAgdGhpcy5faW5pdEhhbmRsZXJPbmNlKHR5cGUpO1xuICAgICAgICB0aGlzLl9oYW5kbGVyc1t0eXBlXS5hZGRDbGlja0V2ZW50KCk7XG5cbiAgICAgICAgdmFyIGhhbmRsZXJSZXN1bHQgPSB0aGlzLl9oYW5kbGVyc1t0eXBlXS5oYW5kbGUoZGF0YSwgdHlwZSk7XG5cbiAgICAgICAgcmV0dXJuIGhhbmRsZXJSZXN1bHQgJiYgaGFuZGxlclJlc3VsdC50aGVuID9cbiAgICAgICAgICAgIGhhbmRsZXJSZXN1bHQudGhlbih0aGlzLl9yZW5kZXJIYW5kbGVyUmVzdWx0KSA6XG4gICAgICAgICAgICBoYW5kbGVyUmVzdWx0O1xuICAgIH0sXG5cbiAgICBfcmVuZGVySGFuZGxlclJlc3VsdDogZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICB0aGlzLl92aWV3LnJlbmRlclBvcHVwKHJlc3VsdCk7XG4gICAgfSxcblxuICAgIF9pbml0SGFuZGxlck9uY2U6IGZ1bmN0aW9uICh0eXBlKSB7IC8vIChTdHJpbmcpXG4gICAgICAgIGlmICghdGhpcy5faGFuZGxlcnNbdHlwZV0pIHtcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZXJzW3R5cGVdID0gbmV3IHRoaXMub3B0aW9ucy5oYW5kbGVyc1NlcXVlbmNlW3R5cGVdKHRoaXMsIHRoaXMuX3ZpZXcsIHRoaXMuX21hcCwgdGhpcy5fb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG59KTtcbiIsIkRHLkdlb2NsaWNrZXIuSGFuZGxlci5EZWZhdWx0LkRpY3Rpb25hcnkuaXQgPSBERy5leHRlbmQoe1xuICAgIGFwaUVycm9yVGl0bGU6ICdPaCBvaCwgY1xcJ8OoJm5ic3A7dW4mbmJzcDtlcnJvcmUnLFxuICAgIGFwaUVycm9yQm9keTogJ0kgbm9zdHJpIHNlcnZlciBzaSByaWZpdXRhbm8gZGkgcmlzcG9uZGVyZS4gU3RpYW1vIGZhY2VuZG8gZGVsIG5vc3RybyBtZWdsaW8gcGVyIGNvbnZpbmNlcmxpIGEmbmJzcDtjb21wb3J0YXJzaSBiZW5lLiBSaXRvcm5hIHRyYSBxdWFsY2hlIG1pbnV0by4nLFxuICAgIHdlX2hhdmVfbm90IDogJ05vbiBkaXNwb25pYW1vIGFuY29yYSBkaSBpbmZvcm1hemlvbmkgc3UgcXVlc3RvIHBvc3RvJyxcbiAgICBub25hbWUgOiAnTm9tZSBub24gaW5kaWNhdG8nLFxuICAgICdhZG1fZGl2LnBsYWNlJyA6ICdMdW9nbycsXG4gICAgJ2FkbV9kaXYuZGl2aXNpb24nIDogJ1pvbmEnLFxuICAgICdhZG1fZGl2LnNldHRsZW1lbnQnIDogJ0NvbXVuZScsXG4gICAgc3RyZWV0IDogJ1ZpYScsXG4gICAgJ2FkbV9kaXYuZGlzdHJpY3QnIDogJ011bmljaXBhbGl0w6AnLFxuICAgICdhZG1fZGl2LmNpdHknIDogJ9ChaXR0w6AnLFxuICAgIGdvX3RvIDogJ0NvbWUgYXJyaXZhcmUnLFxuICAgIHNob3dfb3JnYW5pemF0aW9uX2luX2J1aWxkaW5nIDogWyd7bn0gYXppZW5kYSBpbiB0dXR0bycsICd7bn0gYXppZW5kZSBpbiB0dXR0byddLFxuICAgIHNob3dfbW9yZV9hYm91dF9zaWdodCA6ICdNYWdnaW9yaSBpbmZvcm1hemlvbmknLFxuICAgIGJhY2tfYnV0dG9uOiAnSW5kaWV0cm8nLFxuICAgIG5fZmxvb3JzIDogWyd7bn0gcGlhbm8nLCAne259IHBpYW5pJ11cbn0sIERHLkRpY3Rpb25hcnkuaXQpO1xuIiwiREcuR2VvY2xpY2tlci5IYW5kbGVyLkRlZmF1bHQuRGljdGlvbmFyeS5ydSA9IERHLmV4dGVuZCh7XG4gICAgYXBpRXJyb3JUaXRsZTogJ9Ce0YjQuNCx0L7Rh9C60LAg0LLRi9GI0LvQsCcsXG4gICAgYXBpRXJyb3JCb2R5OiAn0J3QsNGI0Lgg0YHQtdGA0LLQtdGA0Ysg0L7RgtC60LDQt9GL0LLQsNGO0YLRgdGPINC+0YLQstC10YfQsNGC0YwuINCc0Ysg0YPQttC1INC/0YDQuNC60LvQsNC00YvQstCw0LXQvCDQstGB0LUg0YHQuNC70YssINGH0YLQvtCx0Ysg0LLRgNCw0LfRg9C80LjRgtGMINC40YUuINCS0L7Qt9Cy0YDQsNGJ0LDQudGC0LXRgdGMINC6Jm5ic3A70L3QsNC8INGH0LXRgNC10LcmbmJzcDvQvdC10YHQutC+0LvRjNC60L4g0LzQuNC90YPRgi4nLFxuICAgIHdlX2hhdmVfbm90IDogJ9Ct0YLQviDQvNC10YHRgtC+INC80Ysg0LXRidGRINC90LUg0YPRgdC/0LXQu9C4INC40LfRg9GH0LjRgtGMJyxcbiAgICBub25hbWU6ICfQkdC10Lcg0L3QsNC30LLQsNC90LjRjycsXG4gICAgJ2FkbV9kaXYucGxhY2UnOiAn0JzQtdGB0YLQvicsXG4gICAgJ2FkbV9kaXYuZGl2aXNpb24nOiAn0J7QutGA0YPQsycsXG4gICAgJ2FkbV9kaXYuc2V0dGxlbWVudCc6ICfQndCw0YHQtdC70LXQvdC90YvQuSDQv9GD0L3QutGCJyxcbiAgICBzdHJlZXQ6ICfQo9C70LjRhtCwJyxcbiAgICAnYWRtX2Rpdi5kaXN0cmljdCc6ICfQoNCw0LnQvtC9JyxcbiAgICAnYWRtX2Rpdi5jaXR5JzogJ9CT0L7RgNC+0LQnLFxuICAgIGdvX3RvOiAn0J/RgNC+0LXRhdCw0YLRjCDRgdGO0LTQsCcsXG4gICAgc2hvd19vcmdhbml6YXRpb25faW5fYnVpbGRpbmc6IFsn0JLRgdC10LPQviB7bn0g0L7RgNCz0LDQvdC40LfQsNGG0LjRjycsICfQktGB0LXQs9C+IHtufSDQvtGA0LPQsNC90LjQt9Cw0YbQuNC4JywgJ9CS0YHQtdCz0L4ge259INC+0YDQs9Cw0L3QuNC30LDRhtC40LknXSxcbiAgICBzaG93X21vcmVfYWJvdXRfc2lnaHQ6ICfQn9C+0LTRgNC+0LHQvdC10LUnLFxuICAgIGJhY2tfYnV0dG9uOiAn0J3QsNC30LDQtCcsXG4gICAgbl9mbG9vcnM6IFsne259INGN0YLQsNC2JywgJ3tufSDRjdGC0LDQttCwJywgJ3tufSDRjdGC0LDQttC10LknXVxufSwgREcuRGljdGlvbmFyeS5ydSk7XG4iLCJERy5HZW9jbGlja2VyLkhhbmRsZXIuRGVmYXVsdC5EaWN0aW9uYXJ5LmVuID0gREcuZXh0ZW5kKHtcbiAgICBhcGlFcnJvclRpdGxlOiAnT29wcyEgRXJyb3IgZGV0ZWN0ZWQuJyxcbiAgICBhcGlFcnJvckJvZHk6ICdPdXIgc2VydmVycyBhcmUgbm90IHJlc3BvbmRpbmcuIFdlIGFyZSBkb2luZyBvdXIgYmVzdCB0byBzdHJhaWdodGVuIHRoZW0gb3V0LiBQbGVhc2UgcmV0dXJuIHRvIHVzIGluIGEgZmV3IG1pbnV0ZXMuJyxcbiAgICB3ZV9oYXZlX25vdDogJ1dlIGhhdmVuXFwndCBjb2xsZWN0ZWQgaW5mbyBhYm91dCB0aGlzIHBsYWNlIHlldCcsXG4gICAgbm9uYW1lIDogJ05vIG5hbWUnLFxuICAgICdhZG1fZGl2LnBsYWNlJyA6ICdQbGFjZScsXG4gICAgJ2FkbV9kaXYuZGl2aXNpb24nIDogJ0FyZWEnLFxuICAgICdhZG1fZGl2LnNldHRsZW1lbnQnIDogJ1ZpbGxhZ2UnLFxuICAgIHN0cmVldCA6ICdTdHJlZXQnLFxuICAgICdhZG1fZGl2LmRpc3RyaWN0JyA6ICdEaXN0cmljdCcsXG4gICAgJ2FkbV9kaXYuY2l0eScgOiAnQ2l0eScsXG4gICAgZ29fdG8gOiAnRGlyZWN0aW9ucyB0byBoZXJlJyxcbiAgICBzaG93X29yZ2FuaXphdGlvbl9pbl9idWlsZGluZyA6IFsne259IG9yZ2FuaXphdGlvbiB0b3RhbCcsICd7bn0gb3JnYW5pemF0aW9ucyB0b3RhbCddLFxuICAgIGJhY2tfYnV0dG9uIDogJ0JhY2snLFxuICAgIHNob3dfbW9yZV9hYm91dF9zaWdodCA6ICdNb3JlIGluZm9ybWF0aW9uJyxcbiAgICBuX2Zsb29ycyA6IFsne259IGZsb29yJywgJ3tufSBmbG9vcnMnXVxufSwgREcuRGljdGlvbmFyeS5lbik7XG4iLCJERy5HZW9jbGlja2VyLkhhbmRsZXIuRGVmYXVsdC5EaWN0aW9uYXJ5LmNzID0gREcuZXh0ZW5kKHtcbiAgICBhcGlFcnJvclRpdGxlOiAnQ2h5YmnEjWthIHNlJm5ic3A7dmxvdWRpbGEnLFxuICAgIGFwaUVycm9yQm9keTogJ05hxaFlIHNlcnZlcnkgb2Rtw610YWrDrSByZWFnb3ZhdC4gSmnFviBueW7DrSB2eW5ha2zDoWTDoW1lIHZlxaFrZXLDqSDDunNpbMOtLCBhYnljaG9tIGplIHDFmWl2ZWRsaSBrIHJvenVtdS4gWmt1c3RlIGFrY2kgb3Bha292YXQgemEgbsSba29saWsgbWludXQuJyxcbiAgICB3ZV9oYXZlX25vdCA6ICdPIHRvbXRvIG3DrXN0xJsgemF0w61tIG5lbcOhbWUgaW5mb3JtYWNlJyxcbiAgICBub25hbWUgOiAnQmV6IG7DoXp2dScsXG4gICAgJ2FkbV9kaXYucGxhY2UnIDogJ03DrXN0bycsXG4gICAgJ2FkbV9kaXYuZGl2aXNpb24nIDogJ1NwcsOhdm7DrSBvYnZvZCcsXG4gICAgJ2FkbV9kaXYuc2V0dGxlbWVudCcgOiAnT2JlYycsXG4gICAgc3RyZWV0IDogJ1VsaWNlJyxcbiAgICAnYWRtX2Rpdi5kaXN0cmljdCcgOiAnTcSbc3Rza8OhIMSNw6FzdCcsXG4gICAgJ2FkbV9kaXYuY2l0eScgOiAnTcSbc3RvJyxcbiAgICBnb190byA6ICdDZXN0YSBzZW0nLFxuICAgIHNob3dfb3JnYW5pemF0aW9uX2luX2J1aWxkaW5nIDogWydDZWxrZW0ge259IG9yZ2FuaXphY2UnLCAnQ2Vsa2VtIHtufSBvcmdhbml6YWNlJywgJ0NlbGtlbSB7bn0gb3JnYW5pemFjw60nXSxcbiAgICBiYWNrX2J1dHRvbiA6ICdacMSbdCcsXG4gICAgc2hvd19tb3JlX2Fib3V0X3NpZ2h0IDogJ1bDrWNlJyxcbiAgICBuX2Zsb29ycyA6IFsne259IHBhdHJvJywgJ3tufSBwYXRyYScsICd7bn0gcGF0ZXInXVxufSwgREcuRGljdGlvbmFyeS5jcyk7XG4iLCJERy5HZW9jbGlja2VyLkhhbmRsZXIuRGVmYXVsdC5EaWN0aW9uYXJ5LmVzID0gREcuZXh0ZW5kKHtcbiAgICBhcGlFcnJvclRpdGxlOiAnVmF5YSwgaGEgb2N1cnJpZG8gdW4gZXJyb3InLFxuICAgIGFwaUVycm9yQm9keTogJ051ZXN0cm9zIHNlcnZpZG9yZXMgc2UgbmllZ2FuIGEgcmVzcG9uZGVyLiBZYSBub3MgZXN0YW1vcyBlc2ZvcnphbmRvIHBvciBoYWNlcmxvcyBlbnRyYXIgZW4gcmF6w7NuLiBWdWVsdmEgY29uIG5vc290cm9zwqBwYXNhZG9zIHVub3MgbWludXRvcy4nLFxuICAgIHdlX2hhdmVfbm90IDogJ1RvZGF2w61hIG5vIGhlbW9zIHJlY29waWxhZG8gbGEgaW5mb3JtYWNpw7NuIHNvYnJlIGVzdGUgbHVnYXInLFxuICAgIG5vbmFtZSA6ICdTaW4gbm9tYnJlJyxcbiAgICAnYWRtX2Rpdi5wbGFjZScgOiAnTHVnYXInLFxuICAgICdhZG1fZGl2LmRpdmlzaW9uJyA6ICdDb211bmEnLFxuICAgICdhZG1fZGl2LnNldHRsZW1lbnQnIDogJ1BvYmxhY2nDs24nLFxuICAgIHN0cmVldCA6ICdDYWxsZScsXG4gICAgJ2FkbV9kaXYuZGlzdHJpY3QnIDogJ0NvbXVuYScsXG4gICAgJ2FkbV9kaXYuY2l0eScgOiAnQ2l1ZGFkJyxcbiAgICBnb190byA6ICdJciBwYXJhIGFsbMOhJyxcbiAgICBzaG93X29yZ2FuaXphdGlvbl9pbl9idWlsZGluZyA6IFsnVG90YWwge259IG9yZ2FuaXphY2nDs24nLCAnVG90YWwge259IG9yZ2FuaXphY2lvbmVzJywgJ1RvdGFsIHtufSBvcmdhbml6YWNpb25lcyddLFxuICAgIHNob3dfbW9yZV9hYm91dF9zaWdodCA6ICdSZWFkIG1vcmUnLFxuICAgIGJhY2tfYnV0dG9uOiAnQXRyw6FzJyxcbiAgICBuX2Zsb29ycyA6IFsne259IHBpc28nLCAne259IHBpc29zJ11cbn0sIERHLkRpY3Rpb25hcnkuZXMpO1xuIiwidmFyIEZpcm1DYXJkID0gZnVuY3Rpb24gKGZpcm0sIG9wdGlvbnMpIHtcbiAgICB0aGlzLl9zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgIHRoaXMuX2Zpcm1Db250ZW50T2JqZWN0ID0ge307XG4gICAgdGhpcy5fc2NoZWR1bGUgPSBuZXcgRmlybUNhcmQuU2NoZWR1bGUoe1xuICAgICAgICBsb2NhbExhbmc6IHRoaXMub3B0aW9ucy5sYW5nLFxuICAgICAgICBkaWN0OiB0aGlzLmRpY3RcbiAgICB9KTtcblxuICAgIHRoaXMucmVuZGVyKGZpcm0pO1xufTtcblxuRmlybUNhcmQucHJvdG90eXBlID0ge1xuXG4gICAgcmVuZGVyOiBmdW5jdGlvbiAoZmlybUlkKSB7XG4gICAgICAgIGlmICghZmlybUlkKSB7IHJldHVybjsgfVxuXG4gICAgICAgIGlmIChmaXJtSWQgIT09IHRoaXMuX2Zpcm1JZCkge1xuICAgICAgICAgICAgdGhpcy5fZmlybUNvbnRlbnRPYmplY3QgPSB7fTtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlckNhcmRCeUlkKGZpcm1JZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl90b2dnbGVFdmVudEhhbmRsZXJzKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fZmlybUNvbnRlbnRPYmplY3Q7XG4gICAgfSxcblxuICAgIGdldFNjaGVkdWxlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zY2hlZHVsZTtcbiAgICB9LFxuXG4gICAgZ2V0Q29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb250YWluZXI7XG4gICAgfSxcblxuICAgIF9yZW5kZXJDYXJkQnlJZDogZnVuY3Rpb24gKGZpcm1JZCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgdGhpcy5vcHRpb25zLmFqYXgoZmlybUlkKS50aGVuKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgICAgIGlmICghcmVzKSB7IHJldHVybiBmYWxzZTsgfVxuICAgICAgICAgICAgdmFyIGRhdGEgPSByZXMucmVzdWx0Lml0ZW1zO1xuICAgICAgICAgICAgaWYgKGRhdGEgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5fZmlybURhdGEgPSBkYXRhWzBdO1xuXG4gICAgICAgICAgICAgICAgLy8gU3VwcG9ydCBmb3Igb2xkIFdlYkFQSSBmb3JtYXQuXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogcmVtb3ZlIHRoaXMgY2FsbCBhZnRlciBXZWJBUEkgcmVsZWFzZVxuICAgICAgICAgICAgICAgIHNlbGYuX2NvbnZlcnRXZWJzaXRlKCk7XG5cbiAgICAgICAgICAgICAgICBzZWxmLl9maXJtSWQgPSBmaXJtSWQ7XG4gICAgICAgICAgICAgICAgc2VsZi5fcmVuZGVyRmlybUNhcmQoKTtcbiAgICAgICAgICAgICAgICBzZWxmLl90b2dnbGVFdmVudEhhbmRsZXJzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgc2VsZi5fcmVuZGVyRXJyb3IoKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIF9jcmVhdGVGaXJtQ29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBmaXJtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGZpcm0uc2V0QXR0cmlidXRlKCdpZCcsICdkZy1tYXAtZmlybS1mdWxsLScgKyB0aGlzLl9maXJtSWQpO1xuICAgICAgICBmaXJtLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnZGctbWFwLWZpcm0tZnVsbCcpO1xuXG4gICAgICAgIHJldHVybiBmaXJtO1xuICAgIH0sXG5cbiAgICBfZ2V0UGF5bWVudFR5cGVzOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW10sXG4gICAgICAgICAgICBncm91cE5hbWUgPSAnZ2VuZXJhbF9wYXltZW50X3R5cGUnO1xuXG4gICAgICAgIGlmICghZGF0YS5hdHRyaWJ1dGVfZ3JvdXBzKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgZGF0YS5hdHRyaWJ1dGVfZ3JvdXBzLmZvckVhY2goZnVuY3Rpb24gKGdyb3VwKSB7XG4gICAgICAgICAgICBpZiAoZ3JvdXAubmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZ3JvdXAuYXR0cmlidXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGF0dHIudGFnLnN1YnN0cmluZygwLCBncm91cE5hbWUubGVuZ3RoKSA9PT0gZ3JvdXBOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGF0dHIubmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIF9ncm91cFJ1YnJpY3M6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgICAgICBwcmltYXJ5OiBbXSxcbiAgICAgICAgICAgIGFkZGl0aW9uYWw6IFtdXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKCFkYXRhLnJ1YnJpY3MgfHwgIWRhdGEucnVicmljcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICBkYXRhLnJ1YnJpY3MuZm9yRWFjaChmdW5jdGlvbiAocnVicmljKSB7XG4gICAgICAgICAgICByZXN1bHRbcnVicmljLmtpbmRdLnB1c2gocnVicmljKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgLy8gU3VwcG9ydCBmb3Igb2xkIFdlYkFQSSBmb3JtYXQuXG4gICAgLy8gVE9ETzogcmVtb3ZlIHRoaXMgZnVuY3Rpb24gYWZ0ZXIgV2ViQVBJIHJlbGVhc2VcbiAgICBfY29udmVydFdlYnNpdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9maXJtRGF0YS5jb250YWN0X2dyb3Vwcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZmlybURhdGEuY29udGFjdF9ncm91cHMuZm9yRWFjaChmdW5jdGlvbiAoZ3JvdXApIHtcbiAgICAgICAgICAgIGlmICghZ3JvdXAuY29udGFjdHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGdyb3VwLmNvbnRhY3RzLmZvckVhY2goZnVuY3Rpb24gKGNvbnRhY3QpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29udGFjdC50eXBlICE9ICd3ZWJzaXRlJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFjb250YWN0LnVybCkge1xuICAgICAgICAgICAgICAgICAgICBjb250YWN0LnVybCA9IGNvbnRhY3QudmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBfcmVuZGVyRmlybUNhcmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGZpcm1DYXJkQm9keSwgc2NoZWR1bGUsIGZvcmVjYXN0LCBsaW5rcywgYnRucywgcGF5bWVudFR5cGVzLCBydWJyaWNzLFxuICAgICAgICAgICAgZGF0YSA9IHRoaXMuX2Zpcm1EYXRhLFxuICAgICAgICAgICAgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyID0gdGhpcy5fY3JlYXRlRmlybUNvbnRhaW5lcigpO1xuXG4gICAgICAgIHNjaGVkdWxlID0gdGhpcy5fc2NoZWR1bGUudHJhbnNmb3JtKGRhdGEuc2NoZWR1bGUsIHtcbiAgICAgICAgICAgIHpvbmVPZmZzZXQ6IHRoaXMub3B0aW9ucy50aW1lem9uZU9mZnNldCxcbiAgICAgICAgICAgIGFwaUxhbmc6IHRoaXMub3B0aW9ucy5sYW5nLFxuICAgICAgICAgICAgbG9jYWxMYW5nOiB0aGlzLm9wdGlvbnMubGFuZ1xuICAgICAgICB9KTtcblxuICAgICAgICBmb3JlY2FzdCA9IHRoaXMuX3NjaGVkdWxlLmZvcmVjYXN0KHNjaGVkdWxlKTtcblxuICAgICAgICBwYXltZW50VHlwZXMgPSB0aGlzLl9nZXRQYXltZW50VHlwZXMoZGF0YSk7XG4gICAgICAgIHJ1YnJpY3MgPSB0aGlzLl9ncm91cFJ1YnJpY3MoZGF0YSk7XG5cbiAgICAgICAgZmlybUNhcmRCb2R5ID0gdGhpcy5fYnVpbGRGaXJtQ2FyZEJvZHkoXG4gICAgICAgICAgICB0aGlzLl9nZXRDb25maWdGaXJtQ2FyZEJvZHkoZGF0YSwgc2NoZWR1bGUsIGZvcmVjYXN0LCBwYXltZW50VHlwZXMsIHJ1YnJpY3MpXG4gICAgICAgICk7XG5cbiAgICAgICAgbGlua3MgPSB0aGlzLl9maWxsSGVhZGVyTGlua3MoKTtcbiAgICAgICAgYnRucyA9IHRoaXMuX2ZpbGxGb290ZXJCdXR0b25zKCk7XG5cbiAgICAgICAgLy9maWxsIG9iamVjdCBmb3IgdmlldyByZW5kZXJcbiAgICAgICAgdGhpcy5fZmlybUNvbnRlbnRPYmplY3QuaGVhZGVyID0gdGhpcy5vcHRpb25zLnJlbmRlcignZmlybUNhcmRIZWFkZXInLCB7J2Zpcm1OYW1lJzogZGF0YS5uYW1lLCAnbGlua3MnOiBsaW5rc30pO1xuICAgICAgICBjb250YWluZXIuaW5uZXJIVE1MID0gZmlybUNhcmRCb2R5O1xuICAgICAgICB0aGlzLl9maXJtQ29udGVudE9iamVjdC50bXBsID0gY29udGFpbmVyO1xuICAgICAgICBpZiAoYnRucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuX2Zvb3RlckNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gICAgICAgICAgICB0aGlzLl9mb290ZXJDb250YWluZXIuaW5uZXJIVE1MID0gdGhpcy5vcHRpb25zLnJlbmRlcigncG9wdXBGb290ZXJCdG5zJywgeydidG5zJzogYnRuc30pO1xuICAgICAgICAgICAgdGhpcy5fZmlybUNvbnRlbnRPYmplY3QuZm9vdGVyID0gdGhpcy5fZm9vdGVyQ29udGFpbmVyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5vbkZpcm1SZWFkeSkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLm9uRmlybVJlYWR5KHRoaXMuX2Zpcm1Db250ZW50T2JqZWN0KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfcmVuZGVyRXJyb3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9maXJtQ29udGVudE9iamVjdC5oZWFkZXIgPSB0aGlzLm9wdGlvbnMucmVuZGVyKCdwb3B1cEhlYWRlcicsIHtcbiAgICAgICAgICAgIHRpdGxlOiB0aGlzLm9wdGlvbnMudCgnYXBpRXJyb3JUaXRsZScpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuX2Zpcm1Db250ZW50T2JqZWN0LnRtcGwgPSB0aGlzLm9wdGlvbnMudCgnYXBpRXJyb3JCb2R5Jyk7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5vbkZpcm1SZWFkeSkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLm9uRmlybVJlYWR5KHRoaXMuX2Zpcm1Db250ZW50T2JqZWN0KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfZ2V0Q29uZmlnRmlybUNhcmRCb2R5OiBmdW5jdGlvbiAoZGF0YSwgc2NoZWR1bGUsIGZvcmVjYXN0LCBhdHRyaWJ1dGVzLCBydWJyaWNzKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdG1wbDogJ2Zpcm1DYXJkQWRkcicsXG4gICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICBhZGRyZXNzOiBkYXRhLmFkZHJlc3NfbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgY29tbWVudDogZGF0YS5hZGRyZXNzX2NvbW1lbnRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRtcGw6ICdmaXJtQ2FyZENvbnRhY3RzJyxcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwczogZGF0YS5jb250YWN0X2dyb3Vwc1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdG1wbDogJ2Zpcm1DYXJkU2NoZWR1bGUnLFxuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgc2NoZWR1bGU6IHNjaGVkdWxlLFxuICAgICAgICAgICAgICAgICAgICBmb3JlY2FzdDogZm9yZWNhc3RcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRtcGw6ICdmcmltQ2FyZFBheW1lbnRzJyxcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIHBheW1lbnRzOiBhdHRyaWJ1dGVzXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0bXBsOiAnZmlybUNhcmRSdWJyaWMnLFxuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgcnVicmljczogcnVicmljc1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgXTtcbiAgICB9LFxuXG4gICAgX2J1aWxkRmlybUNhcmRCb2R5OiBmdW5jdGlvbiAocGFydHMpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICByZXR1cm4gcGFydHMucmVkdWNlKGZ1bmN0aW9uIChib2R5LCBpdGVtKSB7XG4gICAgICAgICAgICB2YXIgaHRtbCA9IHNlbGYub3B0aW9ucy5yZW5kZXIoaXRlbS50bXBsLCBpdGVtLmRhdGEpO1xuICAgICAgICAgICAgcmV0dXJuIGJvZHkgKyBodG1sO1xuICAgICAgICB9LCAnJyk7XG4gICAgfSxcblxuICAgIF9maWxsRm9vdGVyQnV0dG9uczogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYnRucyA9IFtdO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYmFja0J0bikge1xuICAgICAgICAgICAgYnRucy5wdXNoKHsgbmFtZTogJ2Zpcm0tY2FyZC1iYWNrJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiB0aGlzLmRpY3QudCh0aGlzLm9wdGlvbnMubGFuZywgJ2J0bkJhY2snKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGljb246IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zaG93Um91dGVTZWFyY2gpIHtcbiAgICAgICAgICAgIGJ0bnMucHVzaCh7IG5hbWU6ICdnb3RvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiB0aGlzLmRpY3QudCh0aGlzLm9wdGlvbnMubGFuZywgJ2J0bkZpbmRXYXknKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGljb246IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBocmVmOiB0aGlzLm9wdGlvbnMuZ290b1VybFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXG4gICAgICAgICAgICB0aGlzLl9maXJtRGF0YS5saW5rcyAmJlxuICAgICAgICAgICAgICAgIHRoaXMuX2Zpcm1EYXRhLmxpbmtzLmVudHJhbmNlcyAmJlxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5zaG93RW50cmFuY2VcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBidG5zLnB1c2goeyBuYW1lOiAnc2hvdy1lbnRyYW5jZScsXG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogdGhpcy5kaWN0LnQodGhpcy5vcHRpb25zLmxhbmcsICdidG5FbnRyYW5jZScpLFxuICAgICAgICAgICAgICAgICAgICAgICAgaWNvbjogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYnRucztcbiAgICB9LFxuXG4gICAgX2ZpbGxIZWFkZXJMaW5rczogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbGlua3MgPSBbXSxcbiAgICAgICAgICAgIHJldmlld0RhdGEgPSB0aGlzLl9maXJtRGF0YS5yZXZpZXdzLFxuICAgICAgICAgICAgYm9va2xldCxcbiAgICAgICAgICAgIGxpbms7XG5cbiAgICAgICAgaWYgKHRoaXMuX2Zpcm1EYXRhLmV4dGVybmFsX2NvbnRlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX2Zpcm1EYXRhLmV4dGVybmFsX2NvbnRlbnQuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgICAgICBpZiAoZWwgJiYgZWwudHlwZSA9PSAnYm9va2xldCcpIHtcbiAgICAgICAgICAgICAgICAgICAgYm9va2xldCA9IGVsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJldmlld0RhdGEgJiYgcmV2aWV3RGF0YS5pc19yZXZpZXdhYmxlKSB7XG4gICAgICAgICAgICBsaW5rcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnZmxhbXBfc3RhcnMnLFxuICAgICAgICAgICAgICAgIHdpZHRoOiByZXZpZXdEYXRhLnJhdGluZyAqIDIwXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxpbmtzLnB1c2goe1xuICAgICAgICAgICAgICAgIG5hbWU6ICdmbGFtcF9yZXZpZXdzJyxcbiAgICAgICAgICAgICAgICBsYWJlbDogdGhpcy5kaWN0LnQodGhpcy5vcHRpb25zLmxhbmcsICdsaW5rUmV2aWV3cycsIHJldmlld0RhdGEucmV2aWV3X2NvdW50ID8gcmV2aWV3RGF0YS5yZXZpZXdfY291bnQgOiAwKSxcbiAgICAgICAgICAgICAgICBocmVmOiBGaXJtQ2FyZC5EYXRhSGVscGVyLmdldEZsYW1wVXJsKHRoaXMuX2Zpcm1JZClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmV0cmlldmUgcGhvdG8gZGF0YSBmcm9tIGV4dGVybmFsIGNvbnRlbnQgYmxvY2tcbiAgICAgICAgdmFyIHBob3RvcztcbiAgICAgICAgdmFyIGV4dGVybmFsQ29udGVudCA9IHRoaXMuX2Zpcm1EYXRhLmV4dGVybmFsX2NvbnRlbnQ7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHRlcm5hbENvbnRlbnQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBleHRlcm5hbENvbnRlbnRbaV0udHlwZSA9PSAncGhvdG9fYWxidW0nICYmXG4gICAgICAgICAgICAgICAgZXh0ZXJuYWxDb250ZW50W2ldLnN1YnR5cGUgPT0gJ2NvbW1vbidcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHBob3RvcyA9IGV4dGVybmFsQ29udGVudFtpXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLmlzTW9iaWxlICYmIHBob3RvcyAmJiBwaG90b3MuY291bnQgJiYgdGhpcy5vcHRpb25zLnNob3dQaG90b3MpIHtcbiAgICAgICAgICAgIGxpbmsgPSBMLlV0aWwudGVtcGxhdGUoJ2h0dHA6Ly8yZ2lzLntkb21haW59L3Bob3Rvcy97aWR9Jywge1xuICAgICAgICAgICAgICAgICdpZCc6IHRoaXMuX2Zpcm1JZCxcbiAgICAgICAgICAgICAgICAnZG9tYWluJzogdGhpcy5vcHRpb25zLmRvbWFpblxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGxpbmtzLnB1c2goe25hbWU6ICdwaG90b3MnLFxuICAgICAgICAgICAgICAgIGhyZWY6IGxpbmssXG4gICAgICAgICAgICAgICAgbGFiZWw6IHRoaXMuZGljdC50KHRoaXMub3B0aW9ucy5sYW5nLCAnbGlua1Bob3RvJywgcGhvdG9zLmNvdW50KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5pc01vYmlsZSAmJiBib29rbGV0ICYmIGJvb2tsZXQudXJsICYmIHRoaXMub3B0aW9ucy5zaG93Qm9va2xldCkge1xuICAgICAgICAgICAgbGlua3MucHVzaCh7XG4gICAgICAgICAgICAgICAgbmFtZTogJ2Jvb2tsZXQnLFxuICAgICAgICAgICAgICAgIGhyZWY6ICBib29rbGV0LnVybCxcbiAgICAgICAgICAgICAgICBsYWJlbDogdGhpcy5kaWN0LnQodGhpcy5vcHRpb25zLmxhbmcsICdsaW5rQm9va2xldCcpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgcmV0dXJuIGxpbmtzO1xuICAgIH0sXG5cbiAgICBfZXZlbnRzOiB7XG4gICAgICAgICdkZy1wb3B1cF9fYnV0dG9uX25hbWVfZmlybS1jYXJkLWJhY2snOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5iYWNrQnRuKCk7XG4gICAgICAgICAgICB0aGlzLl90b2dnbGVFdmVudEhhbmRsZXJzKHRydWUpO1xuICAgICAgICB9LFxuICAgICAgICAnZGctcG9wdXBfX2J1dHRvbl9uYW1lX3Nob3ctZW50cmFuY2UnOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBlbnQgPSBuZXcgdGhpcy5vcHRpb25zLnNob3dFbnRyYW5jZSh7J3ZlY3RvcnMnOiB0aGlzLl9maXJtRGF0YS5saW5rcy5lbnRyYW5jZXNbMF0uZ2VvbWV0cnkudmVjdG9yc30pO1xuICAgICAgICAgICAgZW50LmFkZFRvKHRoaXMub3B0aW9ucy5tYXApLnNob3coKTtcbiAgICAgICAgICAgIHRoaXMuX3RvZ2dsZUV2ZW50SGFuZGxlcnModHJ1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgICdkZy1zY2hlZHVsZV9fdG9kYXknOiBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICAgICAgICAgIHRoaXMuX29uVG9nZ2xlU2NoZWR1bGUodGFyZ2V0KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfdG9nZ2xlRXZlbnRIYW5kbGVyczogZnVuY3Rpb24gKGZsYWcpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLnBvcHVwW2ZsYWcgPyAnb2ZmJyA6ICdvbiddKCdjbGljaycsIHRoaXMuX29uQ2xpY2ssIHRoaXMpO1xuICAgICAgICB0aGlzLm9wdGlvbnMubWFwW2ZsYWcgPyAnb2ZmJyA6ICdvbiddKCdwb3B1cGNsb3NlJywgdGhpcy5fb25DbG9zZSwgdGhpcyk7XG4gICAgfSxcblxuICAgIF9vbkNsaWNrOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgdGFyZ2V0ID0gZS5vcmlnaW5hbEV2ZW50LnRhcmdldDtcblxuICAgICAgICBmb3IgKHZhciBldmVudENsYXNzIGluIHRoaXMuX2V2ZW50cykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2V2ZW50cy5oYXNPd25Qcm9wZXJ0eShldmVudENsYXNzKSAmJiB0YXJnZXQuY2xhc3NOYW1lLmluZGV4T2YoZXZlbnRDbGFzcykgPiAtMSkge1xuICAgICAgICAgICAgICAgIERHLkRvbUV2ZW50LnByZXZlbnREZWZhdWx0KGUub3JpZ2luYWxFdmVudCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRzW2V2ZW50Q2xhc3NdLmNhbGwodGhpcywgdGFyZ2V0KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX29uQ2xvc2U6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHRoaXMuX3RvZ2dsZUV2ZW50SGFuZGxlcnModHJ1ZSk7XG4gICAgfSxcblxuICAgIF9vblRvZ2dsZVNjaGVkdWxlOiBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICAgIHZhciBzY2hlZHVsZSA9IHRoaXMuX2NvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCcuZGctc2NoZWR1bGVfX3RhYmxlJyksXG4gICAgICAgICAgICBmb3JlY2FzdCA9IHRoaXMuX2NvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCcuZGctc2NoZWR1bGVfX25vdycpLFxuICAgICAgICAgICAgc2hvd0NsYXNzID0gJyBkZy1zY2hlZHVsZV9fdG9kYXlfc2hvd25fdHJ1ZSc7XG5cbiAgICAgICAgaWYgKCFzY2hlZHVsZSkgeyByZXR1cm47IH1cblxuICAgICAgICBpZiAoc2NoZWR1bGUuc3R5bGUuZGlzcGxheSA9PT0gJ2Jsb2NrJykge1xuICAgICAgICAgICAgc2NoZWR1bGUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgIGZvcmVjYXN0LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICAgICAgdGFyZ2V0LmNsYXNzTmFtZSA9IHRhcmdldC5jbGFzc05hbWUucmVwbGFjZShzaG93Q2xhc3MsICcnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvcmVjYXN0LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICBzY2hlZHVsZS5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgICAgIHRhcmdldC5jbGFzc05hbWUgKz0gc2hvd0NsYXNzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5vblRvZ2dsZSkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLm9uVG9nZ2xlKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX3NldE9wdGlvbnM6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHZhciBvcHRpb24sXG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICBvcHRpb25zLmxhbmcgPSBvcHRpb25zLmxhbmcgfHwgJ3J1JztcblxuICAgICAgICBmb3IgKG9wdGlvbiBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShvcHRpb24pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zW29wdGlvbl0gPSBvcHRpb25zW29wdGlvbl07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX2hhc1RvdWNoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoKCdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdykgfHxcbiAgICAgICAgICAgICAgICAobmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzID4gMCkgfHxcbiAgICAgICAgICAgICAgICAobmF2aWdhdG9yLm1zTWF4VG91Y2hQb2ludHMgPiAwKSk7XG4gICAgfVxufTtcbiIsIkZpcm1DYXJkLkRhdGFIZWxwZXIgPSB7XG5cblx0RkxBTVBfVVJMIDogJ2h0dHA6Ly9mbGFtcC5ydS9yLycsXG5cdEZMQU1QX0dPT0dMRV9BTkFMWVRJQ1MgOiAndXRtX3NvdXJjZT1hcGkyZ2lzJnV0bV9tZWRpdW09YXBpJnV0bV9jYW1wYWlnbj1nZW9jbGlja2VyJyxcblxuXHRwYXlNZXRob2RzIDogW1xuXHRcdCdhbWVyaWNhbmV4cHJlc3MnLFxuXHRcdCdjYXNoJyxcblx0XHQnZGluZXJzY2x1YicsXG5cdFx0J2dvbGRjcm93bicsXG5cdFx0J2ludGVybmV0Jyxcblx0XHQnbWFzdGVyY2FyZCcsXG5cdFx0J25vbmNhc2gnLFxuXHRcdCd2aXNhJ1xuXHRdLFxuXG5cdF9tc2dzIDoge30sXG5cblx0Z2V0RmxhbXBVcmwgOiBmdW5jdGlvbiAoaWQpIHtcblx0ICAgIHJldHVybiB0aGlzLkZMQU1QX1VSTC5jb25jYXQoaWQsICc/JywgdGhpcy5GTEFNUF9HT09HTEVfQU5BTFlUSUNTKTtcblx0fSxcblxuXHRtc2cgOiBmdW5jdGlvbiAobXNnKSB7XG5cdFx0aWYgKHRoaXMuX21zZ3MuaGFzT3duUHJvcGVydHkobXNnKSkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX21zZ3NbbXNnXTtcblx0XHR9XG5cdFx0Y29uc29sZSAmJiBjb25zb2xlLmxvZyhcIkNhbnQndCBmaW5kIHRyYW5zbGF0aW9uIGZvciAnXCIgKyBtc2cgKyBcIicuXCIpO1xuXHRcdHJldHVybiBtc2cudG9TdHJpbmcoKS5yZXBsYWNlKCdfJywgJyAnKTtcblx0fSxcblxuXHRnZXRQcm9qZWN0VGltZTogZnVuY3Rpb24gKHRpbWV6b25lT2Zmc2V0LCB0aW1lKSB7XG4gICAgICAgIHZhciBub3csIHV0YztcblxuICAgICAgICBpZiAodGltZSkge1xuICAgICAgICAgICAgbm93ID0gbmV3IERhdGUodGltZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBub3cgPSBuZXcgRGF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRpbWV6b25lT2Zmc2V0KSB7XG4gICAgICAgICAgICB1dGMgPSBub3cuZ2V0VGltZSgpICsgKG5vdy5nZXRUaW1lem9uZU9mZnNldCgpICogNjAwMDApO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHV0YyArICg2MDAwMCAqIHRpbWV6b25lT2Zmc2V0KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbm93O1xuICAgICAgICB9XG4gICAgfVxufTtcbiIsIi8qIGdsb2JhbFxuICAgIEZpcm1DYXJkOiBmYWxzZVxuKi9cbihmdW5jdGlvbiAoKSB7XG4gICAgRmlybUNhcmQuTGlzdCA9IGZ1bmN0aW9uIChmaXJtcywgb3B0aW9ucykge1xuICAgICAgICB0aGlzLl9maXJtcyA9IHt9OyAvLyB7J2Zpcm1JRCc6IGZpcm1Eb21PYmp9XG4gICAgICAgIHRoaXMuX3NldE9wdGlvbnMob3B0aW9ucyk7XG5cbiAgICAgICAgdGhpcy5fY29udGFpbmVyID0gb3B0aW9ucyAmJiBvcHRpb25zLmNvbnRhaW5lciB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd1bCcpO1xuICAgICAgICB0aGlzLl9jb250YWluZXIuc2V0QXR0cmlidXRlKCdjbGFzcycsICdkZy1idWlsZGluZy1jYWxsb3V0X19saXN0Jyk7XG5cbiAgICAgICAgdGhpcy5fZXZlbnRIYW5kbGVyc0luaXRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9maXJtQ2FyZCA9IHRoaXMuX2NyZWF0ZUZpcm0oKTtcbiAgICAgICAgdGhpcy5yZW5kZXJMaXN0KGZpcm1zKTtcbiAgICB9O1xuXG4gICAgRmlybUNhcmQuTGlzdC5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgcmVuZGVyTGlzdDogZnVuY3Rpb24gKGZpcm1zKSB7XG4gICAgICAgICAgICBpZiAoZmlybXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90b2dnbGVFdmVudEhhbmRsZXJzKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRGaXJtcyhmaXJtcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLm9uTGlzdFJlYWR5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLm9uTGlzdFJlYWR5KHRoaXMuX2NvbnRhaW5lcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb250YWluZXI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX3Byb2Nlc3NGaXJtczogZnVuY3Rpb24gKGZpcm1zLCBhY3Rpb24pIHtcbiAgICAgICAgICAgIGlmICghZmlybXMpIHsgcmV0dXJuOyB9XG4gICAgICAgICAgICB2YXIgbWV0aG9kID0gJ18nICsgYWN0aW9uICsgJ0Zpcm0nO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2lzQXJyYXkoZmlybXMpKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBmaXJtcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1ttZXRob2RdKGZpcm1zW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXNbbWV0aG9kXShmaXJtcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSxcblxuICAgICAgICBhZGRGaXJtczogZnVuY3Rpb24oZmlybXMpIHtcbiAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3NGaXJtcyhmaXJtcywgJ2FkZCcpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlbW92ZUZpcm1zOiBmdW5jdGlvbihmaXJtcykge1xuICAgICAgICAgICAgdGhpcy5fcHJvY2Vzc0Zpcm1zKGZpcm1zLCAncmVtb3ZlJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0TGFuZzogZnVuY3Rpb24gKG5ld0xhbmcpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5maXJtQ2FyZC5sYW5nID0gbmV3TGFuZztcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRMYW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmZpcm1DYXJkLmxhbmc7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0Q29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29udGFpbmVyO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNsZWFyTGlzdCA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX2Zpcm1zID0ge307XG4gICAgICAgICAgICB0aGlzLl90b2dnbGVFdmVudEhhbmRsZXJzKHRydWUpO1xuICAgICAgICAgICAgdGhpcy5fY2xlYXJDb250YWluZXIoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBfcmVtb3ZlRmlybTogZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2Zpcm1zW2lkXSkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICAgICAgICAgIHRoaXMuX2NvbnRhaW5lci5yZW1vdmVDaGlsZCh0aGlzLl9maXJtc1tpZF0pO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2Zpcm1zW2lkXTtcbiAgICAgICAgfSxcblxuICAgICAgICBfYWRkRmlybTogZnVuY3Rpb24gKGZpcm1EYXRhKSB7XG4gICAgICAgICAgICB2YXIgdG1wbCA9IHRoaXMub3B0aW9ucy5maXJtbGlzdEl0ZW1UbXBsLFxuICAgICAgICAgICAgICAgIGRvbUZpcm0sIGZpcm0sIGNvbnRlbnQ7XG5cbiAgICAgICAgICAgIGZpcm0gPSB7XG4gICAgICAgICAgICAgICAgbmFtZTogZmlybURhdGEubmFtZSxcbiAgICAgICAgICAgICAgICBpZDogZmlybURhdGEuaWQuc3BsaXQoJ18nKS5zbGljZSgwLCAxKVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKCEoZmlybS5pZCBpbiB0aGlzLl9maXJtcykpIHtcblxuICAgICAgICAgICAgICAgIGRvbUZpcm0gPSB0aGlzLl9jcmVhdGVMaXN0SXRlbSgpO1xuXG4gICAgICAgICAgICAgICAgY29udGVudCA9IHRtcGwgPyB0aGlzLm9wdGlvbnMuZmlybUNhcmQucmVuZGVyKHRtcGwsIHsnZmlybSc6IGZpcm19KSA6IGZpcm0ubmFtZTtcblxuICAgICAgICAgICAgICAgIGRvbUZpcm0uaW5zZXJ0QWRqYWNlbnRIVE1MKCdiZWZvcmVlbmQnLCBjb250ZW50KTtcblxuICAgICAgICAgICAgICAgIHRoaXMuX2Zpcm1zW2Zpcm0uaWRdID0gZG9tRmlybTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb250YWluZXIuYXBwZW5kQ2hpbGQoZG9tRmlybSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2NyZWF0ZUxpc3RJdGVtOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpJyk7XG4gICAgICAgICAgICBpdGVtLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnZGctYnVpbGRpbmctY2FsbG91dF9fbGlzdC1pdGVtJyk7XG5cbiAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9pc0FycmF5OiBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICByZXR1cm4ge30udG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBBcnJheV0nO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9jcmVhdGVGaXJtOiBmdW5jdGlvbiAoZmlybURhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRmlybUNhcmQoZmlybURhdGEsIHRoaXMub3B0aW9ucy5maXJtQ2FyZCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2lzRW1wdHlPYmo6IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgIGZvciAodmFyIHByb3AgaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICBfZXZlbnRzOiB7XG4gICAgICAgICAgICAnZGctcG9wdXBfX2xpbmsnOiBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICB2YXIgcyA9IHRoaXMuX2Zpcm1DYXJkLnJlbmRlcih0YXJnZXQuaWQpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmZpcm1DYXJkW3RoaXMuX2lzRW1wdHlPYmoocykgPyAncGFzdGVMb2FkZXInIDogJ29uRmlybVJlYWR5J10ocyk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuZmlybUNhcmQub25GaXJtQ2xpY2sgJiYgdGhpcy5vcHRpb25zLmZpcm1DYXJkLm9uRmlybUNsaWNrKCk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl90b2dnbGVFdmVudEhhbmRsZXJzKHRydWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdkZy1idWlsZGluZy1jYWxsb3V0X19saXN0LWl0ZW0nOiBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQgPSB0YXJnZXQuY2hpbGRyZW5bMF07XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9ldmVudHNbJ2RnLXBvcHVwX19saW5rJ10uY2FsbCh0aGlzLCB0YXJnZXQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdkZy1wb3B1cF9fYnV0dG9uX25hbWVfYmFjayc6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5maXJtQ2FyZC5vblNob3dMZXNzKCk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl90b2dnbGVFdmVudEhhbmRsZXJzKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIF90b2dnbGVFdmVudEhhbmRsZXJzIDogZnVuY3Rpb24gKGZsYWcpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5maXJtQ2FyZC5wb3B1cFtmbGFnID8gJ29mZicgOiAnb24nXSgnY2xpY2snLCB0aGlzLl9vbkNsaWNrLCB0aGlzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBfb25DbGljazogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSBlLm9yaWdpbmFsRXZlbnQudGFyZ2V0O1xuXG4gICAgICAgICAgICBmb3IgKHZhciBldmVudENsYXNzIGluIHRoaXMuX2V2ZW50cykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9ldmVudHMuaGFzT3duUHJvcGVydHkoZXZlbnRDbGFzcykgJiYgdGFyZ2V0LmNsYXNzTmFtZS5pbmRleE9mKGV2ZW50Q2xhc3MpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgREcuRG9tRXZlbnQucHJldmVudERlZmF1bHQoZS5vcmlnaW5hbEV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRzW2V2ZW50Q2xhc3NdLmNhbGwodGhpcywgdGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBfY2xlYXJDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXI7XG5cbiAgICAgICAgICAgIHdoaWxlIChjb250YWluZXIuaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLnJlbW92ZUNoaWxkKGNvbnRhaW5lci5maXJzdENoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBfc2V0T3B0aW9uczogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7fSk7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmZpcm1DYXJkIHx8ICh0aGlzLm9wdGlvbnMuZmlybUNhcmQgPSB7fSk7XG5cbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5maXJtQ2FyZC5sYW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmZpcm1DYXJkLmxhbmcgPSAncnUnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBvcHRpb24gaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KG9wdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zW29wdGlvbl0gPSBvcHRpb25zW29wdGlvbl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbn0pKCk7XG4iLCIvKmdsb2JhbFxuICAgIEZpcm1DYXJkOmZhbHNlXG4qL1xuRmlybUNhcmQuU2NoZWR1bGUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgdGhpcy5sb2NhbExhbmcgPSBvcHRpb25zLmxvY2FsTGFuZyB8fCAncnUnO1xuICAgIHRoaXMuZGljdCA9IG9wdGlvbnMuZGljdDtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbkZpcm1DYXJkLlNjaGVkdWxlLnByb3RvdHlwZSA9IHtcblxuICAgIHNldExhbmc6IGZ1bmN0aW9uIChsYW5nKSB7XG4gICAgICAgIHRoaXMubG9jYWxMYW5nID0gbGFuZyB8fCAncnUnO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgdHJhbnNmb3JtOiBmdW5jdGlvbiAobW9kZWwsIHBhcmFtcykge1xuICAgICAgICBpZiAoIW1vZGVsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuXG4gICAgICAgIGZ1bmN0aW9uIGJpbmQoZm4sIG9iaikgeyAvLyAoRnVuY3Rpb24sIE9iamVjdCkgLT4gRnVuY3Rpb25cbiAgICAgICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpIDogbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KG9iaiwgYXJncyB8fCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0b2RheUtleSwgLy8gTW9uLCBUdWUgLi4uXG4gICAgICAgICAgICB0b2RheSwgLy8g0J7QsdGK0LXQutGCINC80L7QtNC10LvQuCAtINGC0LXQutGD0YnQuNC5INC00LXQvdGMINC90LXQtNC10LvQuFxuICAgICAgICAgICAgZnJvbSwgLy8g0KHQsNC80L7QtSDRgNCw0L3QvdC10LUg0LLRgNC10LzRjyDQvtGC0LrRgNGL0YLQuNGPINC30LAg0LTQtdC90YxcbiAgICAgICAgICAgIHRvLCAvLyDQodCw0LzQvtC1INC/0L7Qt9C00L3QtdC1INCy0YDQtdC80Y8g0LfQsNC60YDRi9GC0LjRjyDQt9CwINC00LXQvdGMXG4gICAgICAgICAgICB6b25lT2Zmc2V0ID0gcGFyYW1zLnpvbmVPZmZzZXQgfHwgMCxcbiAgICAgICAgICAgIHNjaGVkdWxlID0ge30sIC8vINCe0LHRitC10LrRgi3RgNCw0YHQv9C40YHQsNC90LjQtSwg0YTQvtGA0LzQuNGA0YPQtdC80YvQuSDQv9C+0LQg0YjQsNCx0LvQvtC9XG4gICAgICAgICAgICBub3cgPSBwYXJhbXMubm93IHx8IEZpcm1DYXJkLkRhdGFIZWxwZXIuZ2V0UHJvamVjdFRpbWUoem9uZU9mZnNldCkuZ2V0VGltZSgpLCAvLyBDdXJyZW50IHRpbWVzdGFtcCBpbiBtaWxsaXNlY29uZHNcbiAgICAgICAgICAgIHdlZWtLZXlzID0gW10sIC8vINCa0LvRjtGH0Lgg0LTQvdC10Lkg0L3QtdC00LXQu9C4LCDQvtC/0YDQtdC00LXQu9GP0Y7RgiDQv9C+0YDRj9C00L7QuiDQtNC90LXQuSDQuCDQv9C10YDQstGL0Lkg0LTQtdC90Ywg0L3QtdC00LXQu9C4LiAwIC0g0L/QtdGA0LLRi9C5INC00LXQvdGMINC90LXQtNC10LvQuCDQsiDRgNC10LPQuNC+0L3QtSAo0L3QtSDQvtCx0Y/Qt9Cw0YLQtdC70YzQvdC+IE1vbilcbiAgICAgICAgICAgIHdlZWtLZXlzTG9jYWwgPSBbXSxcbiAgICAgICAgICAgIHdlZWtGdWxsS2V5c0xvY2FsID0gW10sXG4gICAgICAgICAgICB3ZWVrS2V5c1Nob3J0ID0gIFsgJ01vbicsICdUdWUnLCAnV2VkJywgJ1RodScsICdGcmknLCAnU2F0JywgJ1N1bicgXSxcbiAgICAgICAgICAgIHdlZWtLZXlzRnVsbCA9IFsnbW9uZGF5JywndHVlc2RheScsJ3dlZG5lc2RheScsJ3RodXJzZGF5JywnZnJpZGF5Jywnc2F0dXJkYXknLCdzdW5kYXknXSxcbiAgICAgICAgICAgIGxvY2FsTGFuZyA9IHBhcmFtcy5sb2NhbExhbmcgfHwgdGhpcy5sb2NhbExhbmcsXG4gICAgICAgICAgICBsb2NhbFdvcmtpbmdEYXlzID0gcGFyYW1zLmxvY2FsV29ya2luZ0RheXMgfHwgWzAsIDEsIDEsIDEsIDEsIDEsIDBdLFxuICAgICAgICAgICAgZmlyc3RkYXlPZmZzZXQgPSBwYXJhbXMuZmlyc3RkYXlPZmZzZXQgfHwgMSxcbiAgICAgICAgICAgIG1pbkhvdXJzVG9EaXNwbGF5Q2xvc3VyZSA9IHBhcmFtcy5taW5Ib3Vyc1RvRGlzcGxheUNsb3N1cmUgfHwgNCxcbiAgICAgICAgICAgIHQgPSBiaW5kKHRoaXMuZGljdC50LCB0aGlzLmRpY3QpO1xuXG5cbiAgICAgICAgZnVuY3Rpb24gY2FwaXRhbGlzZUZpcnN0TGV0dGVyKHN0cmluZykge1xuICAgICAgICAgICAgcmV0dXJuIHN0cmluZy5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0cmluZy5zbGljZSgxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldEhvdXJzKHN0cikge1xuICAgICAgICAgICAgcmV0dXJuIHN0ci5zdWJzdHIoMCwgMik7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBnZXRNaW51dGVzKHN0cikge1xuICAgICAgICAgICAgcmV0dXJuIHN0ci5zdWJzdHIoMywgMik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyDQmtC+0L3QstC10YDRgtCw0YbQuNGPINCy0YDQtdC80LXQvdC90L7QuSDRgtC+0YfQutC4INGE0L7RgNC80LDRgtCwINCw0L/QuCDQsiDRhNC+0YDQvNCw0YIg0L7RgtC+0LHRgNCw0LbQtdC90LjRjyAoMjU6MDAgLT4gMDE6MDApXG4gICAgICAgIGZ1bmN0aW9uIGZvcm1hdFRpbWUoc3RyKSB7XG4gICAgICAgICAgICB2YXIgaG91cnMgPSArZ2V0SG91cnMoc3RyKSAlIDI0ICsgJyc7XG5cbiAgICAgICAgICAgIGlmIChob3Vycy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICBob3VycyA9ICcwJyArIGhvdXJzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gaG91cnMgKyAnOicgKyBnZXRNaW51dGVzKHN0cik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyDQmtC+0L3QstC10YDRgtCw0YbQuNGPIGludCDRh9C40YHQu9CwINCyINC90L7QvNC10YAg0LTQvdGPINC90LXQtNC10LvQuCAo0LTQuNCw0L/QsNC30L7QvSAwLTYpXG4gICAgICAgIGZ1bmN0aW9uIGRheU51bShuKSB7XG4gICAgICAgICAgICByZXR1cm4gbiAlIDc7XG4gICAgICAgIH1cblxuXG4gICAgICAgIC8qIGpzaGludCBpZ25vcmU6c3RhcnQgKi9cbiAgICAgICAgLy8g0JLQvtC30LLRgNCw0YnQsNC10YIg0L/QvtGB0LvQtdC00L3QuNC5INGN0LvQtdC80LXQvdGCINC80LDRgdGB0LjQstCwXG4gICAgICAgIC8vINCS0LfRj9GC0L4g0LjQtyBVbmRlcnNjb3JlLmpzIGh0dHA6Ly91bmRlcnNjb3JlanMub3JnLyNsYXN0XG4gICAgICAgIGZ1bmN0aW9uIGdldEFycmF5TGFzdChhcnIsIG4pIHtcbiAgICAgICAgICAgIGlmICggYXJyID09IG51bGwgKSByZXR1cm4gdm9pZCAwO1xuICAgICAgICAgICAgaWYgKCAgIG4gPT0gbnVsbCApIHJldHVybiBhcnJbIGFyci5sZW5ndGggLSAxIF07XG4gICAgICAgICAgICByZXR1cm4gc2xpY2UuY2FsbCggYXJyLCBNYXRoLm1heChhcnIubGVuZ3RoIC0gbiAsIDApICk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIC8vINCS0YvQv9C+0LvQvdGP0LXRgiDQs9C70YPQsdC+0LrQvtC1INGB0YDQsNCy0L3QtdC90LjQtSDQvtCx0YrQtdC60YLQvtCyXG4gICAgICAgIC8vINCS0LfRj9GC0L4g0LjQtyBVbmRlcnNjb3JlLmpzIGh0dHA6Ly91bmRlcnNjb3JlanMub3JnLyNpc0VxdWFsXG4gICAgICAgIC8vINCj0L/RgNC+0YnQtdC90L4g0LTQu9GPINGC0LXRhSDRgtGA0ZHRhSDRgdGA0LDQstC90LXQvdC40LksINC60L7RgtC+0YDRi9C1INCy0YvQv9C+0LvQvdGP0Y7RgtGB0Y8g0LIgU2hlZHVsZS5qc1xuICAgICAgICBmdW5jdGlvbiBpc0VxdWFsKG9iajEsIG9iajIpIHtcbiAgICAgICAgICAgIGlmICggb2JqMSA9PT0gb2JqMiApIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgaWYgKCAhICggb2JqMSBpbnN0YW5jZW9mIE9iamVjdCApIHx8ICEgKCBvYmoyIGluc3RhbmNlb2YgT2JqZWN0ICkgKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpZiAoIG9iajEuY29uc3RydWN0b3IgIT09IG9iajIuY29uc3RydWN0b3IgKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKCB2YXIgcHJvcCBpbiBvYmoxICkge1xuICAgICAgICAgICAgICAgIGlmICggISBvYmoxLmhhc093blByb3BlcnR5KCBwcm9wICkgKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBpZiAoICEgb2JqMi5oYXNPd25Qcm9wZXJ0eSggcHJvcCApICkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmICggb2JqMVsgcHJvcCBdID09PSBvYmoyWyBwcm9wIF0gKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBpZiAoIHR5cGVvZiggb2JqMVsgcHJvcCBdICkgIT09IFwib2JqZWN0XCIgKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKCAhIGlzRXF1YWwoIG9iajFbIHByb3AgXSwgIG9iajJbIHByb3AgXSApICkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICggcHJvcCBpbiBvYmoyICkge1xuICAgICAgICAgICAgaWYgKCBvYmoyLmhhc093blByb3BlcnR5KCBwcm9wICkgJiYgISBvYmoxLmhhc093blByb3BlcnR5KCBwcm9wICkgKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gR2VuZXJhdGUgYW4gaW50ZWdlciBBcnJheSBjb250YWluaW5nIGFuIGFyaXRobWV0aWMgcHJvZ3Jlc3Npb24uIEEgcG9ydCBvZlxuICAgICAgICAvLyB0aGUgbmF0aXZlIFB5dGhvbiBgcmFuZ2UoKWAgZnVuY3Rpb24uIFNlZVxuICAgICAgICAvLyBbdGhlIFB5dGhvbiBkb2N1bWVudGF0aW9uXShodHRwOi8vZG9jcy5weXRob24ub3JnL2xpYnJhcnkvZnVuY3Rpb25zLmh0bWwjcmFuZ2UpLlxuICAgICAgICBmdW5jdGlvbiByYW5nZShzdGFydCwgc3RvcCwgc3RlcCkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgICAgICBzdG9wID0gc3RhcnQgfHwgMDtcbiAgICAgICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBzdGVwID0gYXJndW1lbnRzWzJdIHx8IDE7XG5cbiAgICAgICAgdmFyIGxlbmd0aCA9IE1hdGgubWF4KE1hdGguY2VpbCgoc3RvcCAtIHN0YXJ0KSAvIHN0ZXApLCAwKTtcbiAgICAgICAgdmFyIGlkeCA9IDA7XG4gICAgICAgIHZhciByYW5nZSA9IG5ldyBBcnJheShsZW5ndGgpO1xuICAgICAgICB3aGlsZShpZHggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHJhbmdlW2lkeCsrXSA9IHN0YXJ0O1xuICAgICAgICAgICAgc3RhcnQgKz0gc3RlcDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByYW5nZTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgLy/Ql9Cw0L/QvtC70L3Rj9C10YIg0YHQstC+0LnRgdGC0LLQsCDQvtCx0YrQtdC60YLQsCDQt9C90LDRh9C10L3QuNGP0LzQuCDQv9C+INGD0LzQvtC70YfQsNC90LjRjlxuICAgICAgICAvL9CS0LfRj9GC0L4g0LjQtyBVbmRlcnNjb3JlLmpzIGh0dHA6Ly91bmRlcnNjb3JlanMub3JnLyNkZWZhdWx0c1xuICAgICAgICBmdW5jdGlvbiBmaWxsRGVmYXVsdHMob2JqKSB7XG4gICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgICBhcmdzLmZvckVhY2goZnVuY3Rpb24oc291cmNlKSB7XG4gICAgICAgICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9ialtwcm9wXSA9PT0gdm9pZCAwKSBvYmpbcHJvcF0gPSBzb3VyY2VbcHJvcF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfVxuXG4gICAgICAgIC8v0KHQvtGA0YLQuNGA0YPQtdGCINC30L3QsNGH0LXQvdC40Y8g0YHQvtCz0LvQsNGB0L3QviDRgSDQuNGC0LXRgNCw0YLQvtGA0L7QvFxuICAgICAgICAvL9CS0LfRj9GC0L4g0YEgVW5kZXJzY29yZS5qcyBodHRwOi8vdW5kZXJzY29yZWpzLm9yZy8jc29ydEJ5XG4gICAgICAgIGZ1bmN0aW9uIHNvcnRCeShvYmosIGl0ZXJhdG9yKXtcbiAgICAgICAgICAgIHJldHVybiBwbHVjayhvYmoubWFwKCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgY3JpdGVyaWE6IGl0ZXJhdG9yLmNhbGwodGhpcywgdmFsdWUsIGluZGV4LCBsaXN0KVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KS5zb3J0KGZ1bmN0aW9uKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IGxlZnQuY3JpdGVyaWE7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYiA9IHJpZ2h0LmNyaXRlcmlhO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGEgIT09IGIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhID4gYiB8fCBhID09PSB2b2lkIDApIHJldHVybiAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGEgPCBiIHx8IGIgPT09IHZvaWQgMCkgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBsZWZ0LmluZGV4IC0gcmlnaHQuaW5kZXg7XG4gICAgICAgICAgICAgICAgfSksICd2YWx1ZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoganNoaW50IGlnbm9yZTplbmQgKi9cblxuICAgICAgICBmdW5jdGlvbiBwbHVjayhhcnIsIGtleSl7XG4gICAgICAgICAgICB2YXIgaSwgcnYgPSBbXTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHJ2W2ldID0gYXJyW2ldW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcnY7XG4gICAgICAgIH1cblxuXG4gICAgICAgIC8vINCf0YDQtdC+0LHRgNCw0LfQvtCy0LDRgtGMINGA0LDRgdC/0LjRgdCw0L3QuNC1INC90LAg0LTQtdC90Ywg0LIg0YPQv9C+0YDRj9C00L7Rh9C10L3QvdGL0Lkg0LzQsNGB0YHQuNCyINCy0YDQtdC80LXQvdC90YvRhSDQvtGC0YHQtdGH0LXQuiAoc3RyaW5nKVxuICAgICAgICAvLyDQodC10LnRh9Cw0YEg0L/QvtC70LDQs9Cw0LXRgtGB0Y8sINGH0YLQviBBUEkg0YPQttC1INCy0YvQtNCw0ZHRgiDRgdC+0YDRgtC40YDQvtCy0LDQvdC90YvQuSDQvNCw0YHRgdC40LJcbiAgICAgICAgZnVuY3Rpb24gZ2V0U29ydGVkVGltZVBvaW50cyhkYXkpIHtcbiAgICAgICAgICAgIHZhciBwb2ludHMgPSBbXSxcbiAgICAgICAgICAgICAgICBmcm9tLCB0byxcbiAgICAgICAgICAgICAgICBkZWx0YUhvdXJzLCBkZWx0YU1pbnV0ZXM7XG5cbiAgICAgICAgICAgIGlmICghZGF5IHx8ICFkYXkud29ya2luZ19ob3Vycykge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAgOyBpIDwgZGF5LndvcmtpbmdfaG91cnMubGVuZ3RoIDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZnJvbSA9IGRheS53b3JraW5nX2hvdXJzW2ldLmZyb207XG4gICAgICAgICAgICAgICAgdG8gPSBkYXkud29ya2luZ19ob3Vyc1tpXS50bztcblxuICAgICAgICAgICAgICAgIGRlbHRhSG91cnMgPSBnZXRIb3Vycyh0bykgLSBnZXRIb3Vycyhmcm9tKTtcbiAgICAgICAgICAgICAgICBkZWx0YU1pbnV0ZXMgPSBnZXRNaW51dGVzKHRvKSAtIGdldE1pbnV0ZXMoZnJvbSk7XG4gICAgICAgICAgICAgICAgaWYgKGRlbHRhSG91cnMgPCAwIHx8IChkZWx0YUhvdXJzID09PSAwICYmIGRlbHRhTWludXRlcyA8PSAwKSkgeyAvLyDQldGB0LvQuCBcItC00L5cIiDQvNC10L3RjNGI0LUg0LjQu9C4INGA0LDQstC90L4gXCLQvtGCXCIgLSDQt9C90LDRh9C40YIg0YPQutCw0LfRi9Cy0LDQtdGCINC90LAg0LfQsNCy0YLRgNCwXG4gICAgICAgICAgICAgICAgICAgIHRvID0gKCtnZXRIb3Vycyh0bykgKyAyNCkgKyAnOicgKyBnZXRNaW51dGVzKHRvKTsgLy8gKDAxOjAwIC0+IDI1OjAwKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHBvaW50c1tpICogMl0gPSB7XG4gICAgICAgICAgICAgICAgICAgIHRpbWU6IGZyb20sXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdvcGVuJ1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcG9pbnRzW2kgKiAyICsgMV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIHRpbWU6IHRvLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBkYXkud29ya2luZ19ob3Vycy5sZW5ndGggLSAxID09PSBpID8gJ2Nsb3NlJyA6ICdsdW5jaCdcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcG9pbnRzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8g0JLQvtC30LLRgNCw0YnQsNC10YIg0LzQsNGB0YHQuNCyIHRpbWVzdGFtcCDQstGB0LXRhSDRgtC+0YfQtdC6LCDQstGB0LXRhSDQtNC90LXQuSDQvdC10LTQtdC70LgsINC+0YIg0YHQtdCz0L7QtNC90Y/RiNC90LXQs9C+INC4INCyINCx0YPQtNGD0YnQtdC1XG4gICAgICAgIC8vINCd0LDQv9GA0LjQvNC10YAsINGB0LXQs9C+0LTQvdGPINGB0YDQtdC00LAsINC+0YLRgdC10YfQutC4INCx0YPQtNGD0YIg0LLQt9GP0YLRiyDQtNC70Y8g0LTQsNGCINGB0L4g0YHRgNC10LTRiyAo0YHQtdCz0L7QtNC90Y8pINC/0L4g0YHQu9C10LTRg9GO0YnQuNC5INCy0YLQvtGA0L3QuNC6INCy0LrQu9GO0YfQuNGC0LXQu9GM0L3QvlxuICAgICAgICBmdW5jdGlvbiBnZXRUaW1lU3RhbXBzKG1vZGVsKSB7XG4gICAgICAgICAgICB2YXIgdGltZXN0YW1wcyA9IFtdLFxuICAgICAgICAgICAgICAgIG91dCA9IFtdLFxuICAgICAgICAgICAgICAgIHRpbWVQb2ludHMsXG4gICAgICAgICAgICAgICAgbnVtID0gd2Vla0tleXMuaW5kZXhPZih0b2RheUtleSk7IC8vINCd0L7QvNC10YAg0YHQtdCz0L7QtNC90Y/RiNC90LXQs9C+INC00L3RjyDQvdC10LTQtdC70LggKNC00LvRjyDQtNCw0L3QvdC+0LPQviDRgNC10LPQuNC+0L3QsClcblxuXG4gICAgICAgICAgICAvLyDQptC40LrQuyDQv9C+INC00L3Rj9C8INC90LXQtNC10LvQuCDQvdCw0YfQuNC90LDRjyDRgSDRgdC10LPQvtC00L3Rj9GI0L3QtdCz0L5cbiAgICAgICAgICAgIHZhciBqOyAvLyDQndC+0LzQtdGAINGC0LXQutGD0YnQtdCz0L4g0LTQvdGPINCyINC80LDRgdGB0LjQstC1IHdlZWtLZXlzXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCA7IGkgPCA3IDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaiA9IGRheU51bShudW0gKyBpKTtcbiAgICAgICAgICAgICAgICB0aW1lUG9pbnRzID0gZ2V0U29ydGVkVGltZVBvaW50cyhtb2RlbFt3ZWVrS2V5c1tqXV0pO1xuICAgICAgICAgICAgICAgIC8vINCm0LjQutC7INC/0L4g0YLQvtGH0LrQsNC8INCy0YDQtdC80LXQvdC4INGBINC60L7QvdCy0LXRgNGC0LDRhtC40LXQuSDQsiB0aW1lc3RhbXBcbiAgICAgICAgICAgICAgICB0aW1lUG9pbnRzLmZvckVhY2goXG4gICAgICAgICAgICAgICAgICAgIC8qIGpzaGludCAtVzA4MyAqL1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAocG9pbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbm93IC0g0L7QsdGP0LfQsNGC0LXQu9GM0L3QviEg0LjQvdCw0YfQtSDQsdGD0LTQtdGCINCx0YDQsNGC0YzRgdGPINGC0LXQutGD0YnQuNC5IHRpbWVzdGFtcCDRh9GC0L4g0YfRgNC10LLQsNGC0L4g0L3QtdGB0L7QstC/0LDQtNC10L3QuNGP0LzQuCDQv9GA0Lgg0LzQtdC00LvQtdC90L3QvtC8INCx0YvRgdGC0YDQvtC00LXQudGB0YLQstC40LhcbiAgICAgICAgICAgICAgICAgICAgLy8g0JLRi9GH0LjRgdC70LjRgtGMINGC0LDQudC80YHRgtC10LzQvyDQtNC70Y8g0LTQsNC90L3QvtCz0L4g0LTQvdGPINC90LXQtNC10LvQuCwg0YfQsNGB0LAg0Lgg0LzQuNC90YPRgtGLLCDQsiDQsdGD0LTRg9GJ0LXQvCwg0L3QviDQsdC70LjQttCw0LnRiNC40Lkg0Logbm93XG4gICAgICAgICAgICAgICAgICAgIHZhciB0c3AgPSBuZXcgRGF0ZShub3cpO1xuICAgICAgICAgICAgICAgICAgICB0c3Auc2V0RGF0ZSh0c3AuZ2V0RGF0ZSgpK2kpO1xuICAgICAgICAgICAgICAgICAgICB0c3Auc2V0SG91cnMoZ2V0SG91cnMocG9pbnQudGltZSkpO1xuICAgICAgICAgICAgICAgICAgICB0c3Auc2V0TWludXRlcyhnZXRNaW51dGVzKHBvaW50LnRpbWUpKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRzID0gdHNwLmdldFRpbWUoKTtcblxuXG5cbiAgICAgICAgICAgICAgICAgICAgdGltZXN0YW1wcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRzOiB0cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IHBvaW50LnR5cGVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWVzdGFtcHNbdGltZXN0YW1wcy5sZW5ndGggLSAxXSAmJiB0aW1lc3RhbXBzW3RpbWVzdGFtcHMubGVuZ3RoIC0gMl0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vINCf0LDRgNC90L4g0YPQtNCw0LvRj9C10Lwg0YHQvtCy0L/QsNC00LDRjtGJ0LjQtSDRgtC+0YfQutC4ICjQvtC90Lgg0L3QtSDQuNC80LXRjtGCINGB0LzRi9GB0LvQsCAtINGN0YLQviDRgdC10LPQvtC00L3RjyAyNDowMCDQuCDQt9Cw0LLRgtGA0LAgMDA6MDApXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGltZXN0YW1wc1t0aW1lc3RhbXBzLmxlbmd0aCAtIDFdLnRzID09PSB0aW1lc3RhbXBzW3RpbWVzdGFtcHMubGVuZ3RoIC0gMl0udHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXBzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAodGltZXN0YW1wc1t0aW1lc3RhbXBzLmxlbmd0aCAtIDFdICYmIHRpbWVzdGFtcHNbdGltZXN0YW1wcy5sZW5ndGggLSAyXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8g0J/QsNGA0L3QviDQv9C10YDQtdC90L7RgdC40Lwg0YLQvtGH0LrQuCDQsiDQsdGD0LTRg9GJ0LXQtSwg0LXRgdC70Lgg0L7QvdC4INC+0LHQtSDQsiDQv9GA0L7RiNC70L7QvCAo0L/QtdGA0LLQsNGPINGC0L7Rh9C60LAgKFswXSkg0LTQvtC70LbQvdCwINCx0YvRgtGMINCy0YHQtdCz0LTQsCDQvtGC0LrRgNGL0YLQuNC10LwhKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWVzdGFtcHNbdGltZXN0YW1wcy5sZW5ndGggLSAxXS50cyA8PSBub3cgJiYgdGltZXN0YW1wc1t0aW1lc3RhbXBzLmxlbmd0aCAtIDJdLnRzIDw9IG5vdykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcHNbdGltZXN0YW1wcy5sZW5ndGggLSAxXS50cyArPSAoNyAqIDI0ICogNjAgKiA2MCAqIDEwMDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcHNbdGltZXN0YW1wcy5sZW5ndGggLSAyXS50cyArPSAoNyAqIDI0ICogNjAgKiA2MCAqIDEwMDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8qIGpzaGludCArVzA4MyAqL1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vINCh0L7RgNGC0LjRgNGD0LXQvCDQvdCwINCy0L7Qt9GA0LDRgdGC0LDQvdC40LUsINCy0LXQtNGMINCy0L7Qt9C80L7QttC90L4g0LHRi9C70Lgg0L/QtdGA0LXQvdC+0YHRiyDQsiDQsdGD0LTRg9GJ0LXQtVxuICAgICAgICAgICAgdGltZXN0YW1wcyA9IHNvcnRCeSh0aW1lc3RhbXBzLCBmdW5jdGlvbiAodGltZXN0YW1wKSB7IHJldHVybiB0aW1lc3RhbXAudHM7IH0pO1xuXG4gICAgICAgICAgICAvLyDQo9C00LDQu9GP0LXQvCDQv9C+0L/QsNGA0L3QviDRgdC+0LLQv9Cw0LTQsNGO0YnQuNC1INGC0L7Rh9C60Lgg0LLRgNC10LzQtdC90LhcbiAgICAgICAgICAgIGkgPSAwO1xuICAgICAgICAgICAgd2hpbGUgKGkgPCB0aW1lc3RhbXBzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmICh0aW1lc3RhbXBzW2kgKyAxXSAmJiB0aW1lc3RhbXBzW2ldLnRzID09PSB0aW1lc3RhbXBzW2kgKyAxXS50cykge1xuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0LnB1c2godGltZXN0YW1wc1tpXS50cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8g0J/RgNC+0LLQtdGA0LrQsCDQvdCwINC10LbQtdC00L3QtdCy0L3Qvi3QutGA0YPQs9C70L7RgdGD0YLQvtGH0L3QvtGB0YLRjFxuICAgICAgICAgICAgaWYgKG91dC5sZW5ndGggPT09IDIgJiYgKG91dFsxXSAtIG91dFswXSkgPT09ICg3ICogMjQgKiA2MCAqIDYwICogMTAwMCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aW1lc3RhbXBzO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gd2hlbk9wZW5JbnZlcnNlKGgsIGQsIG51bSkge1xuICAgICAgICAgICAgaWYgKGQgPT09IDEgJiYgaCA+IG1pbkhvdXJzVG9EaXNwbGF5Q2xvc3VyZSApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdChsb2NhbExhbmcsICd0b21tb3JvdycpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChkID4gMSkge1xuICAgICAgICAgICAgICAgIC8qIGpzaGludCAtVzAxNSAqL1xuICAgICAgICAgICAgICAgIHN3aXRjaCAobnVtKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIHQobG9jYWxMYW5nLCAnbmV4dFN1bicpO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiB0KGxvY2FsTGFuZywgJ25leHRNb24nKTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gdChsb2NhbExhbmcsICduZXh0VHVlJyk7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuIHQobG9jYWxMYW5nLCAnbmV4dFdlZCcpO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6IHJldHVybiB0KGxvY2FsTGFuZywgJ25leHRUaHUnKTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1OiByZXR1cm4gdChsb2NhbExhbmcsICduZXh0RnJpJyk7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNjogcmV0dXJuIHQobG9jYWxMYW5nLCAnbmV4dFNhdCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvKiBqc2hpbnQgK1cwMTUgKi9cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cblxuICAgICAgICAvL9CS0L7Qt9Cy0YDQsNGJ0LDQtdGCINC40L3RgtC10YDQstCw0Lsg0LIg0YbQtdC70YvRhSDQtNC90Y/RhSwg0YEg0L/QvtC/0YDQsNCy0LrQvtC5INC90LAg0YHQvNC10L3RgyDQtNC90Y8g0LIg0L/QvtC70L3QvtGH0YwsINC80LXQttC00YNcbiAgICAgICAgLy9AcGFyYW0gdGltZXN0YW1wRW5kINC4IEBwYXJhbSBkYXRlU3RhcnRcbiAgICAgICAgZnVuY3Rpb24gZGF5SW50ZXJ2YWwodGltZXN0YW1wRW5kLCBkYXRlU3RhcnQpIHtcblxuICAgICAgICAgICAgdmFyIG9uZURheSA9IDEwMDAgKiA2MCAqIDYwICogMjQsXG4gICAgICAgICAgICAgICAgZGF0ZUVuZCA9IG5ldyBEYXRlKHRpbWVzdGFtcEVuZC50cyk7XG5cbiAgICAgICAgICAgIHZhciBkaWZmO1xuXG4gICAgICAgICAgICBkaWZmID0gTWF0aC5yb3VuZCgoZGF0ZUVuZCAtIGRhdGVTdGFydCkgLyBvbmVEYXkpO1xuXG4gICAgICAgICAgICBpZiggdGltZXN0YW1wRW5kLnR5cGU9PT0nb3BlbicgJiYgZGF0ZUVuZC5nZXRIb3VycygpIDwgMSApXG4gICAgICAgICAgICAgICAgeyBkaWZmICsrOyB9XG5cbiAgICAgICAgICAgIHJldHVybiBkaWZmO1xuICAgICAgICB9XG5cblxuICAgICAgICAvLyDQn9C+0LzQtdGB0YLQuNGC0Ywg0LTQsNC90L3Ri9C1INCyINC+0LHRitC10LrRgiDQtNC70Y8g0YjQsNCx0LvQvtC90LAg0L4g0YHQtdCz0L7QtNC90Y/RiNC90LXQvCDQtNC90LVcbiAgICAgICAgZnVuY3Rpb24gc2V0VG9kYXlTdHJpbmcodG9kYXkpIHtcblxuICAgICAgICAgICAgdmFyIHRpbWVQb2ludHMsXG4gICAgICAgICAgICAgICAgcGVyaW9kcyA9IFtdLFxuICAgICAgICAgICAgICAgIHRpbWVzdGFtcHM7XG5cbiAgICAgICAgICAgIHNjaGVkdWxlLm5vdyA9IHt9O1xuXG4gICAgICAgICAgICAvLyBUaW1lc3RhbXBzINCy0YHQtdGFINC+0YLRgdC10YfQtdC6XG4gICAgICAgICAgICB0aW1lc3RhbXBzID0gZ2V0VGltZVN0YW1wcyhtb2RlbCk7XG5cbiAgICAgICAgICAgIGlmICghdGltZXN0YW1wcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBzY2hlZHVsZS5hbHdheXMgPSB0cnVlOyAvLyDQoNCw0LHQvtGC0LDQtdGCINC10LbQtdC00L3QtdCy0L3QviDQutGA0YPQs9C70L7RgdGD0YLQvtGH0L3QvlxuICAgICAgICAgICAgICAgIHNjaGVkdWxlLm5vdy5vcGVuID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCA7IGkgPCB0aW1lc3RhbXBzLmxlbmd0aCA7IGkrKykge1xuICAgICAgICAgICAgICAgIC8vINCf0L7Qv9Cw0LvQuCDQvNC10LbQtNGDINGC0L7Rh9C60LDQvNC4IGktMSDQuCBpIC8vINCc0Ysg0L3QsNGF0L7QtNC40LzRgdGPINC30LDQstC10LTQvtC80L4g0LIg0LHRg9C00YPRidC10Lwg0L7RgtC90L7RgdC40YLQtdC70YzQvdC+IDFcbiAgICAgICAgICAgICAgICBpZiAobm93ID49ICh0aW1lc3RhbXBzW2kgLSAxXSAmJiB0aW1lc3RhbXBzW2kgLSAxXS50cyB8fCAwKSAmJiBub3cgPCB0aW1lc3RhbXBzW2ldLnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBoID0gTWF0aC5mbG9vcigodGltZXN0YW1wc1tpXS50cyAtIG5vdykgLyAoMTAwMCAqIDYwICogNjApKSwgLy8g0JrQvtC70LjRh9C10YHRgtCy0L4g0YfQsNGB0L7QsiDQtNC+INGB0LvQtdC00YPRjtGJ0LXQs9C+IHRpbWVzdGFtcFxuICAgICAgICAgICAgICAgICAgICAgICAgbSA9IE1hdGguZmxvb3IoKHRpbWVzdGFtcHNbaV0udHMgLSBub3cpIC8gKDEwMDAgKiA2MCkgLSBoICogNjApLCAvLyDQmtC+0LvQuNGH0LXRgdGC0LLQviDQvNC40L3Rg9GCICjQsdC10Lcg0YfQsNGB0L7Qsikg0LTQviDRgdC70LXQtNGD0Y7RidC10LPQviB0aW1lc3RhbXBcbiAgICAgICAgICAgICAgICAgICAgICAgIGRheU5vdyA9IG5ldyBEYXRlKG5vdyksXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vINC+0YLQutGA0YvRgtC+INC10YHQu9C4INGB0LvQtdC00YPRjtGJ0LDRjyDQuNGC0LXRgNCw0YbQuNGPINC90LUg0L7RgtC60YDRi9GC0LjQtVxuICAgICAgICAgICAgICAgICAgICAgICAgbm93SXNPcGVuID0gdGltZXN0YW1wc1tpXS50eXBlICE9PSAnb3Blbic7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vdmFyIGQgPSBkYXlPZlllYXIoZGF5VHMpIC0gZGF5T2ZZZWFyKGRheU5vdyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL3ZhciBkID0gZGF5SW50ZXJ2YWwoZGF5VHMsIGRheU5vdywgbm93SXNPcGVuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkID0gZGF5SW50ZXJ2YWwodGltZXN0YW1wc1tpXSwgZGF5Tm93KTtcblxuXG5cbiAgICAgICAgICAgICAgICAgICAgLy8g0L7QutGA0YPQs9C70Y/QtdC8INC80LjQvdGD0YLRiyDQtNC+INC60YDQsNGC0L3Ri9GFIDVcbiAgICAgICAgICAgICAgICAgICAgbSA9IE1hdGguZmxvb3IobSAvIDEwKSAqIDEwID8gTWF0aC5mbG9vcihtIC8gMTApICogMTAgOiA1O1xuXG4gICAgICAgICAgICAgICAgICAgIHNjaGVkdWxlLm5vdy5vcGVuID0gbm93SXNPcGVuO1xuICAgICAgICAgICAgICAgICAgICBzY2hlZHVsZS5ub3cubHVuY2ggPSAhISh0aW1lc3RhbXBzW2kgLSAxXSAmJiB0aW1lc3RhbXBzW2kgLSAxXS50eXBlID09PSAnbHVuY2gnIHx8IGdldEFycmF5TGFzdCh0aW1lc3RhbXBzKS50eXBlID09PSAnbHVuY2gnKTtcblxuICAgICAgICAgICAgICAgICAgICBzY2hlZHVsZS53aWxsID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2lsbFR5cGU6IHRpbWVzdGFtcHNbaV0udHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGQ6IGQsXG4gICAgICAgICAgICAgICAgICAgICAgICBoOiBoLFxuICAgICAgICAgICAgICAgICAgICAgICAgbTogbVxuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIC8vINCa0L7Qs9C00LAg0LfQsNC60YDQvtC10YLRgdGPINC40LvQuCDQvtGC0LrRgNC+0LXRgtGB0Y9cbiAgICAgICAgICAgICAgICAgICAgdmFyIHdpbGxXaGVuID0gbmV3IERhdGUodGltZXN0YW1wc1tpXS50cyk7XG4gICAgICAgICAgICAgICAgICAgIHNjaGVkdWxlLndpbGwud2hlbiA9IHdoZW5PcGVuSW52ZXJzZShoLCBkLCB3aWxsV2hlbi5nZXREYXkoKSk7XG5cblxuICAgICAgICAgICAgICAgICAgICB2YXIgd2lsbFRpbGwgPSBuZXcgRGF0ZSh0aW1lc3RhbXBzW2ldLnRzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ckhvdXJzID0gd2lsbFRpbGwuZ2V0SG91cnMoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ck1pbnV0ZXMgPSB3aWxsVGlsbC5nZXRNaW51dGVzKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0ckhvdXJzIDwgMTApIHsgc3RySG91cnMgPSAnMCcgKyBzdHJIb3VyczsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RyTWludXRlcyA8IDEwKSB7IHN0ck1pbnV0ZXMgPSAnMCcgKyBzdHJNaW51dGVzOyB9XG5cbiAgICAgICAgICAgICAgICAgICAgc2NoZWR1bGUud2lsbC50aWxsID0gc3RySG91cnMrJzonK3N0ck1pbnV0ZXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXRvZGF5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuOyAvLyDQndCwINGB0LXQs9C+0LTQvdGPINGA0LDRgdC/0LjRgdCw0L3QuNGPINC90LXRgiAtINGB0LXQudGH0LDRgSDQt9Cw0LrRgNGL0YLQvlxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aW1lUG9pbnRzID0gcGx1Y2soZ2V0U29ydGVkVGltZVBvaW50cyh0b2RheSksICd0aW1lJyk7XG5cbiAgICAgICAgICAgIC8vINCm0LjQutC7INC/0L4g0L/QtdGA0LjQvtC00LDQvCDRgNCw0LHQvtGC0Ysg0LfQsCDQtNC10L3RjFxuICAgICAgICAgICAgZm9yIChpID0gMiA7IGkgPCB0aW1lUG9pbnRzLmxlbmd0aCA7IGkgPSBpICsgMikge1xuICAgICAgICAgICAgICAgIHBlcmlvZHMucHVzaCh7IGZyb206IHRpbWVQb2ludHNbaSAtIDFdLCB0bzogdGltZVBvaW50c1tpXSB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnJvbSA9IGZvcm1hdFRpbWUodGltZVBvaW50c1swXSk7XG4gICAgICAgICAgICB0byA9IGZvcm1hdFRpbWUodGltZVBvaW50c1t0aW1lUG9pbnRzLmxlbmd0aCAtIDFdKTtcblxuICAgICAgICAgICAgaWYgKGZyb20gPT09IHRvKSB7IC8vINCa0YDRg9Cz0LvQvtGB0YPRgtC+0YfQvdC+XG4gICAgICAgICAgICAgICAgc2NoZWR1bGUudG9kYXkgPSB7XG4gICAgICAgICAgICAgICAgICAgIGFsbHRpbWU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGFsbHRpbWVTdHI6IHQobG9jYWxMYW5nLCAnd29ya3NBcm91bmRUaGVDbG9jaycpLFxuICAgICAgICAgICAgICAgICAgICBmcm9tOiAnMDA6MDAnLFxuICAgICAgICAgICAgICAgICAgICB0bzogJzI0OjAwJ1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2UgeyAvLyDQntGCIGZyb20g0LTQviB0b1xuICAgICAgICAgICAgICAgIHNjaGVkdWxlLnRvZGF5ID0ge1xuICAgICAgICAgICAgICAgICAgICBmcm9tOiBmcm9tLFxuICAgICAgICAgICAgICAgICAgICB0bzogdG9cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocGVyaW9kcy5sZW5ndGggPiAwKSB7IC8vINCf0LXRgNC10YDRi9Cy0Ysg0L3QsCDQvtCx0LXQtFxuICAgICAgICAgICAgICAgIHNjaGVkdWxlLmx1bmNoID0gcGVyaW9kcztcbiAgICAgICAgICAgICAgICBzY2hlZHVsZS5sdW5jaFN0ciA9IHQobG9jYWxMYW5nLCAnbHVuY2gnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vINCk0L7RgNC80LjRgNC+0LLQsNC90LjQtSDQvtCx0YrQtdC60YLQsC3RgtCw0LHQu9C40YbRiy3RgNCw0YHQv9C40YHQsNC90LjRjyDQtNC70Y8g0YjQsNCx0LvQvtC90LBcbiAgICAgICAgZnVuY3Rpb24gbWFrZVRhYmxlKCkge1xuICAgICAgICAgICAgdmFyIGNvbHVtbiA9IFtdLFxuICAgICAgICAgICAgICAgIGhhc0x1bmNoID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwIDsgaiA8IDcgOyBqKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZGF5S2V5ID0gd2Vla0tleXNbal0sXG4gICAgICAgICAgICAgICAgICAgIGx1bmNoTWF4TGVuZ3RoID0gMDtcblxuICAgICAgICAgICAgICAgIGNvbHVtbltqXSA9IHt9O1xuXG4gICAgICAgICAgICAgICAgaWYgKG1vZGVsW2RheUtleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRheSA9IG1vZGVsW2RheUtleV0sXG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lUG9pbnRzID0gcGx1Y2soZ2V0U29ydGVkVGltZVBvaW50cyhkYXkpLCAndGltZScpLFxuICAgICAgICAgICAgICAgICAgICAgICAgbHVuY2ggPSBbXTsgLy8g0J7RgtGA0LXQt9C60Lgg0LLRgNC10LzQtdC90LggKNC+0YLRgdC+0YDRgtC40YDQvtCy0LDQvdC90YvQtSDQvNC+0LzQtdC90YLRiykg0L3QsCDQvtCx0LXQtNGLXG5cbiAgICAgICAgICAgICAgICAgICAgLy8g0KbQuNC60Lsg0L/QviDQv9C10YDQuNC+0LTQsNC8INGA0LDQsdC+0YLRiyDQt9CwINC00LXQvdGMXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAyIDsgaSA8IHRpbWVQb2ludHMubGVuZ3RoIDsgaSA9IGkgKyAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNMdW5jaCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBsdW5jaC5wdXNoKHsgZnJvbTogdGltZVBvaW50c1tpIC0gMV0sIHRvOiB0aW1lUG9pbnRzW2ldIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGx1bmNoTWF4TGVuZ3RoID0gTWF0aC5tYXgodGltZVBvaW50cy5sZW5ndGggLyAyLCBsdW5jaE1heExlbmd0aCk7XG5cbiAgICAgICAgICAgICAgICAgICAgY29sdW1uW2pdID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJvbTogZm9ybWF0VGltZSh0aW1lUG9pbnRzWzBdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvOiBmb3JtYXRUaW1lKHRpbWVQb2ludHNbdGltZVBvaW50cy5sZW5ndGggLSAxXSksXG4gICAgICAgICAgICAgICAgICAgICAgICBsdW5jaDogbHVuY2hcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoZGF5S2V5ID09PSB0b2RheUtleSkgeyAvLyDQodC10LPQvtC00L3Rj9GI0L3QuNC5INC00LXQvdGMINC90LDQtNC+INC/0L7QtNGB0LLQtdGC0LjRgtGMXG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbltqXS5hY3RpdmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbHVtbltqXS5rZXkgPSB3ZWVrS2V5c0xvY2FsW2pdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyDQlNC+0L/QvtC70L3QtdC90LjQtSDQv9GD0YHRgtGL0LzQuCDQvtCx0YrQtdC60YLQsNC80Lgg0LzQsNGB0YHQuNCy0L7QsiBsdW5jaFxuICAgICAgICAgICAgY29sdW1uLmZvckVhY2goIGZ1bmN0aW9uIChjb2wpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29sLmx1bmNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbGxEZWZhdWx0cyhjb2wubHVuY2gsIHJhbmdlKDEsIGx1bmNoTWF4TGVuZ3RoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdGFibGU6IGNvbHVtbixcbiAgICAgICAgICAgICAgICBoYXNMdW5jaDogaGFzTHVuY2hcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyDQodCz0LXQvdC10YDQuNGA0L7QstCw0YLRjCDRgdGC0YDQvtC60YMg0LTQu9GPINCy0YHQtdGFINC00L3QtdC5IG1vZGVsLCDRgdC+0LLQv9Cw0LTQsNGO0YnQuNGFINGBIGRheVxuICAgICAgICBmdW5jdGlvbiBtYWtlU2ltcGxlU3RyaW5nKGRheSwgbW9kZWwpIHtcbiAgICAgICAgICAgIHZhciBwb2ludHMsXG4gICAgICAgICAgICAgICAgb3V0ID0ge1xuICAgICAgICAgICAgICAgICAgICBkYXlMaXN0OiBbXSxcbiAgICAgICAgICAgICAgICAgICAgbHVuY2g6IFtdXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBsdW5jaGVzVGltZSA9IFtdO1xuXG4gICAgICAgICAgICBpZiAoZGF5ICYmIGRheS53b3JraW5nX2hvdXJzICYmIGRheS53b3JraW5nX2hvdXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHBvaW50cyA9IHBsdWNrKGdldFNvcnRlZFRpbWVQb2ludHMoZGF5KSwgJ3RpbWUnKTtcbiAgICAgICAgICAgICAgICBwb2ludHMuZm9yRWFjaCggZnVuY3Rpb24gKHBvaW50LCBrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0LmZyb20gPSBmb3JtYXRUaW1lKHBvaW50KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChrZXkgPT09IHBvaW50cy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXQudG8gPSBmb3JtYXRUaW1lKHBvaW50KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGx1bmNoZXNUaW1lLnB1c2goZm9ybWF0VGltZShwb2ludCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsdW5jaGVzVGltZS5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgICAgICAgICBvdXQubHVuY2gucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBmcm9tOiBsdW5jaGVzVGltZVtpXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvOiBsdW5jaGVzVGltZVtpICsgMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBsdW5jaFN0cjogY2FwaXRhbGlzZUZpcnN0TGV0dGVyKHQobG9jYWxMYW5nLCAnbHVuY2gnKSlcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKG91dC5mcm9tID09ICcwMDowMCcgJiYgb3V0LnRvID09ICcwMDowMCcpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0LnRvID0gJzI0OjAwJztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoZGF5LnJvdW5kX3RoZV9jbG9jaykge1xuICAgICAgICAgICAgICAgICAgICBvdXQuYWxsdGltZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIG91dC5hbGx0aW1lU3RyID0gdChsb2NhbExhbmcsICd3b3Jrc0Fyb3VuZFRoZUNsb2NrJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHsgLy8g0JLRi9GF0L7QtNC90L7QuVxuICAgICAgICAgICAgICAgIG91dC5ob2xpZGF5ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8g0KTQvtGA0LzQuNGA0YPQtdC8INGB0L/QuNGB0L7QuiDQtNC90LXQuSDQvdCwINC70L7QutCw0LvRjNC90L7QvCDRj9C30YvQutC1XG4gICAgICAgICAgICB2YXIgZ3JvdXBXb3JraW5nRGF5cyA9IFswLCAwLCAwLCAwLCAwLCAwLCAwXTsgLy8g0KTQu9Cw0LPQuCDRgNCw0LHQvtGC0Ysg0YTQuNGA0LzRiyDQsiDQtNC90Lgg0YLQtdC60YPRidC10Lkg0LPRgNGD0L/Qv9GLXG4gICAgICAgICAgICB2YXIgZmxvdyA9IDA7XG5cbiAgICAgICAgICAgIHdlZWtLZXlzLmZvckVhY2goIGZ1bmN0aW9uIChkYXlLZXksIG51bUtleSkgeyAvLyAnTW9uJywgMFxuICAgICAgICAgICAgICAgIGlmIChpc0VxdWFsKG1vZGVsW2RheUtleV0sIGRheSkgfHwgKCFtb2RlbFtkYXlLZXldICYmIGRheSA9PT0gbnVsbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0LmRheUxpc3QucHVzaCh3ZWVrRnVsbEtleXNMb2NhbFtudW1LZXldKTtcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBXb3JraW5nRGF5c1tkYXlOdW0obnVtS2V5ICsgZmlyc3RkYXlPZmZzZXQpXSA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGZsb3crKztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmxvdyA+IDIpIHsgLy8g0JHQvtC70LXQtSAyINC00L3QtdC5INC/0L7QtNGA0Y/QtFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxhc3REYXkgPSBvdXQuZGF5TGlzdC5wb3AoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDEgOyBpIDwgZmxvdyAtIDEgOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXQuZGF5TGlzdC5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0LmRheUxpc3Rbb3V0LmRheUxpc3QubGVuZ3RoIC0gMV0gKz0gJyDigJQgJyArIGxhc3REYXk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBmbG93ID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8g0KHQv9C40YHQvtC6INC00L3QtdC5INCyINC00LDQvdC90L7QuSDQs9GA0YPQv9C/0LUg0LjQtNC10L3RgtC40YfQtdC9INGB0L/QuNGB0LrRgyDQsdGD0LTQvdC40YUg0LTQvdC10LksINC30L3QsNGH0LjRgiDQvNC+0LbQvdC+INC30LDQvNC10L3QuNGC0Ywg0YHQu9C+0LLQvtC8IFwi0JHRg9C00L3QuFwiXG4gICAgICAgICAgICBvdXQuYnVkbmkgPSBpc0VxdWFsKGxvY2FsV29ya2luZ0RheXMsIGdyb3VwV29ya2luZ0RheXMpO1xuICAgICAgICAgICAgLy8g0KHQv9C40YHQvtC6INGA0LDQsdC+0YfQuNGFINC00L3QtdC5IC0g0LLRgdC1INC00L3QuCDQvdC10LTQtdC70LgsINC30L3QsNGH0LjRgiDQvdGD0LbQvdC+INCy0YvQstC+0LTQuNGC0Ywg0YTRgNCw0LfRgyBcItCV0LbQtdC00L3QtdCy0L3QvlwiXG4gICAgICAgICAgICBvdXQuZXZlcnlkYXkgPSAoIE1hdGgubWluLmFwcGx5KE1hdGgsIGdyb3VwV29ya2luZ0RheXMpID09PSAxICk7XG5cbiAgICAgICAgICAgIGlmICggb3V0LmhvbGlkYXkgKSB7IG91dC5ob2xpZGF5U3RyID0gdChsb2NhbExhbmcsICdyZXN0RGF5Jywgb3V0LmRheUxpc3QubGVuZ3RoKS5zbGljZSgyKTsgfVxuXG4gICAgICAgICAgICAvLyDQlNC10LvQsNC10Lwg0LjQtyDQvNCw0YHRgdC40LLQsCDRgdGC0YDQvtC60YMg0Lgg0L/QvtC00L3QuNC80LDQtdC8INC/0LXRgNCy0YvQuSDRgdC40LzQstC+0LtcbiAgICAgICAgICAgIG91dC5kYXlMaXN0ID0gb3V0LmRheUxpc3Quam9pbignLCAnKTtcbiAgICAgICAgICAgIG91dC5kYXlMaXN0ID0gb3V0LmRheUxpc3QuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBvdXQuZGF5TGlzdC5zbGljZSgxKTtcblxuXG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8g0JLQvtC30LLRgNCw0YnQsNC10YIg0LzQsNGB0YHQuNCyIHNpbXBsZSDRgdGC0YDQvtC6INC90LAg0L7RgdC90L7QstC1INC80LDRgdGB0LjQstCwINC00L3QtdC5IGRheXNcbiAgICAgICAgZnVuY3Rpb24gbWFrZUFkdmFuY2VkU3RyaW5nKGRheXMsIG1vZGVsKSB7XG4gICAgICAgICAgICB2YXIgb3V0ID0gW107XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBkYXlzLmxlbmd0aCAtIDEgOyBpID49IDAgOyBpLS0pIHtcbiAgICAgICAgICAgICAgICBvdXQucHVzaChtYWtlU2ltcGxlU3RyaW5nKGRheXNbaV0sIG1vZGVsKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyDQl9Cw0L/QvtC70L3Rj9C10Lwg0L3QsNC30LLQsNC90LjRjyDQtNC90LXQuSDQvdC10LTQtdC70LgsIDEgLSDQv9C+0L3QtdC00LXQu9GM0L3QuNC6LiDQkiDQt9Cw0L/QvtC70L3QtdC90L3Ri9GFINC80LDRgdGB0LjQstCw0YUg0L/QvtC90LXQtNC10LvRjNC90LjQuiDRjdGC0L4gMFxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwIDsgaSA8IDcgOyBpKyspIHtcbiAgICAgICAgICAgIHdlZWtLZXlzW2ldID0gd2Vla0tleXNTaG9ydFtpXTtcbiAgICAgICAgICAgIHdlZWtLZXlzTG9jYWxbaV0gPSB0aGlzLmRpY3QudChsb2NhbExhbmcsIHdlZWtLZXlzU2hvcnRbaV0udG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgICB3ZWVrRnVsbEtleXNMb2NhbFtpXSA9IHRoaXMuZGljdC50KGxvY2FsTGFuZywgd2Vla0tleXNGdWxsW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vINCS0YvRh9C40YHQu9GP0LXQvCDRgdC10LPQvtC00L3Rj9GI0L3QuNC5INC00LXQvdGMINC90LXQtNC10LvQuCAo0YHRgdGL0LvQutGDINC90LAg0L7QsdGK0LXQutGCINC00L3RjyDQsiDQvNC+0LTQtdC70LgpXG4gICAgICAgIHRvZGF5S2V5ID0gd2Vla0tleXNTaG9ydFsobmV3IERhdGUobm93KS5nZXREYXkoKS1maXJzdGRheU9mZnNldCkgJSA3XTtcbiAgICAgICAgdG9kYXkgPSBtb2RlbFt0b2RheUtleV07IC8vINCe0LHRitC10LrRgiDRgNCw0YHQv9C40YHQsNC90LjRjyAtINGC0LXQutGD0YnQuNC5INC00LXQvdGMINC90LXQtNC10LvQuFxuICAgICAgICBzZXRUb2RheVN0cmluZyh0b2RheSk7IC8vINCh0LTQtdC70LDRgtGMINC+0LHRitC10LrRgiDQtNC70Y8g0YjQsNCx0LvQvtC90LAgLSDRgdGC0YDQvtC60LAsINC60L7RgtC+0YDQsNGPINC+0L/QuNGB0YvQstCw0LXRgiDQstGA0LXQvNGPINGA0LDQsdC+0YLRiyDRgdC10LPQvtC00L3Rj1xuXG4gICAgICAgIC8vINCd0LDRhdC+0LTQuNC8INC60L7Qu9C40YfQtdGB0YLQstC+INGA0LDQt9C90YvRhSDRgNCw0YHQv9C40YHQsNC90LjQuSDQuCDRgdC+0YXRgNCw0L3Rj9C10Lwg0LjRhSDQsiDQvNCw0YHRgdC40LJcbiAgICAgICAgdmFyIGFwaURpZmZlcmVudERheXMgPSBbXSwgLy8g0JzQsNGB0YHQuNCyINGA0LDQt9C70LjRh9Cw0Y7RidC40YXRgdGPINC00L3QtdC5INC40Lcg0LzQvtC00LXQu9C4XG4gICAgICAgICAgICBhcGlTY2hlZHVsZURheXNDb3VudCA9IDAsIC8vINCa0L7Qu9C40YfQtdGB0YLQstC+INC+0L/QuNGB0LDQvdC90YvRhSDQtNC90LXQuSDQsiDRgNCw0YHQv9C40YHQsNC90LjQuCDQvNC+0LTQtdC70LhcbiAgICAgICAgICAgIGFwaURpZmZlcmVudERheXNDb3VudCA9IDAsIC8vINCa0L7Qu9C40YfQtdGB0YLQstC+INGA0LDQt9C90YvRhSDQtNC90LXQuSDQsiDRgNCw0YHQv9C40YHQsNC90LjQuCDQvNC+0LTQtdC70LhcbiAgICAgICAgICAgIGRpZmZlcmVudFdvcmtpbmdIb3Vyc0NvdW50ID0gW107IC8vINCa0L7Qu9C40YfQtdGB0YLQstC+INGA0LDQsdC+0YfQuNGFINGH0LDRgdC+0LIg0LIg0YDQsNC30L3Ri9GFINC00L3Rj9GFXG5cbiAgICAgICAgT2JqZWN0LmtleXMobW9kZWwpLmZvckVhY2goIGZ1bmN0aW9uKGRheSkge1xuICAgICAgICAgICAgaWYgKG1vZGVsW2RheV0gJiYgbW9kZWxbZGF5XS53b3JraW5nX2hvdXJzKSB7IC8vINCf0YDQvtCy0LXRgNGP0LXQvCDRh9GC0L4g0Y3RgtC+INC00LXQvdGMLCDQsCDQvdC1INC60L7QvNC80LXQvdGC0LDRgNC40Lkg0LjQu9C4INGH0YLQvi3RgtC+INC10YnRkVxuICAgICAgICAgICAgICAgIGFwaVNjaGVkdWxlRGF5c0NvdW50Kys7XG4gICAgICAgICAgICAgICAgaWYgKCFpc0VxdWFsKG1vZGVsW2RheV0sIGdldEFycmF5TGFzdChhcGlEaWZmZXJlbnREYXlzKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYXBpRGlmZmVyZW50RGF5cy5wdXNoKG1vZGVsW2RheV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgYXBpRGlmZmVyZW50RGF5c0NvdW50ID0gYXBpRGlmZmVyZW50RGF5cy5sZW5ndGg7XG4gICAgICAgIC8vINCV0YHQu9C4INC90LUg0LLRgdC1INC00L3QuCDQvtC/0LjRgdCw0L3RiyDQsiDQvNC+0LTQtdC70LgsINC30L3QsNGH0LjRgiDQtdGB0YLRjCDQtdGJ0ZEg0L7QtNC40L0g0YLQuNC/INC00L3QtdC5IC0g0LLRi9GF0L7QtNC90L7QuSAo0L7RgtGB0YPRgtGB0YLQstGD0YnQuNC5INCyINC80L7QtNC10LvQuClcbiAgICAgICAgaWYgKGFwaVNjaGVkdWxlRGF5c0NvdW50IDwgNykge1xuICAgICAgICAgICAgYXBpRGlmZmVyZW50RGF5c0NvdW50Kys7XG4gICAgICAgIH1cblxuICAgICAgICAvLyDQldGB0LvQuCDRgNCw0LfQvdGL0YUg0LHQvtC70LXQtSAyLCDRgtC+INGD0L/RgNC+0YHRgtC40YLRjCDQvdC1INC/0L7Qu9GD0YfQuNGC0YHRjyAtINC00LXQu9Cw0LXQvCDRgtCw0LHQu9C40YbRg1xuICAgICAgICBpZiAoYXBpRGlmZmVyZW50RGF5c0NvdW50ID4gMikge1xuICAgICAgICAgICAgc2NoZWR1bGUud2VlayA9IG1ha2VUYWJsZShtb2RlbCk7XG4gICAgICAgIH0gZWxzZSB7IC8vINCY0L3QsNGH0LUsINGB0L7RgdGC0LDQstC70Y/QtdC8INC60L7QvNC80LXQvdGC0LDRgNC40Lkg0LjQtyDQtNCy0YPRhSDRgdGC0YDQvtC6XG5cbiAgICAgICAgICAgIC8vINCh0LvRg9GH0LDQuSwg0LrQvtCz0LTQsCDQstGB0LUg0L7QtNC40L3QsNC60L7QstGL0LVcbiAgICAgICAgICAgIGlmIChhcGlEaWZmZXJlbnREYXlzQ291bnQgPT09IDEpIHtcbiAgICAgICAgICAgICAgICBzY2hlZHVsZS53ZWVrID0ge1xuICAgICAgICAgICAgICAgICAgICBldmVudGx5OiBbbWFrZVNpbXBsZVN0cmluZyhtb2RlbFt3ZWVrS2V5c1swXV0sIG1vZGVsKV1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHsgLy8g0J7RgdGC0LDRkdGC0YHRjyDRgdC70YPRh9Cw0LksINC60L7Qs9C00LAg0LXRgdGC0Ywg0LTQstCwINGC0LjQv9CwINC00L3QtdC5XG4gICAgICAgICAgICAgICAgLy8g0J7Qv9GA0LXQtNC10LvRj9C10Lwg0LTQtdC90Ywg0YEg0L3QsNC40LHQvtC70YzRiNC40Lwg0LrQvtC70LjRh9C10YHRgtCy0L7QvCDRgNCw0LHQvtGH0LjRhSDRh9Cw0YHQvtCyINC40Lcg0YfQuNGB0LvQsCDRgNCw0LfQvdGL0YUg0LTQvdC10LlcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwIDsgaSA8IGFwaURpZmZlcmVudERheXNDb3VudCA7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBkaWZmZXJlbnRXb3JraW5nSG91cnNDb3VudFtpXSA9IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGFwaURpZmZlcmVudERheXNbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwb2ludHMgPSBwbHVjayhnZXRTb3J0ZWRUaW1lUG9pbnRzKGFwaURpZmZlcmVudERheXNbaV0pLCAndGltZScpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMCA7IGogPCBwb2ludHMubGVuZ3RoIDsgaiA9IGogKyAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhvdXJzID0gKGdldEhvdXJzKHBvaW50c1tqICsgMV0pICsgZ2V0TWludXRlcyhwb2ludHNbaiArIDFdKSAvIDYwKSAtIChnZXRIb3Vycyhwb2ludHNbal0pICsgZ2V0TWludXRlcyhwb2ludHNbal0pIC8gNjApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpZmZlcmVudFdvcmtpbmdIb3Vyc0NvdW50W2ldICs9IGhvdXJzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgeyAvLyDQktGL0YXQvtC00L3QvtC5XG4gICAgICAgICAgICAgICAgICAgICAgICBhcGlEaWZmZXJlbnREYXlzW2ldID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBhcGlTb3J0ZWREaWZmZXJlbnREYXlzID0gc29ydEJ5KGFwaURpZmZlcmVudERheXMsIGZ1bmN0aW9uIChkYXksIGtleSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGlmZmVyZW50V29ya2luZ0hvdXJzQ291bnRba2V5XTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHNjaGVkdWxlLndlZWsgPSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50bHk6IG1ha2VBZHZhbmNlZFN0cmluZyhhcGlTb3J0ZWREaWZmZXJlbnREYXlzLCBtb2RlbClcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc2NoZWR1bGUuY29tbWVudCA9IG1vZGVsLmNvbW1lbnQ7XG4gICAgICAgIGlmIChzY2hlZHVsZS53ZWVrICYmIHNjaGVkdWxlLndlZWsuZXZlbnRseSAmJiBzY2hlZHVsZS53ZWVrLmV2ZW50bHkubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBzY2hlZHVsZS5ldmVyeWRheSA9IHNjaGVkdWxlLndlZWsuZXZlbnRseVswXS5ldmVyeWRheTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2NoZWR1bGU7XG4gICAgfSxcblxuICAgIGZvcmVjYXN0OiBmdW5jdGlvbiAoc2NoZWR1bGUsIHBhcmFtcykge1xuICAgICAgICB2YXIgaW50ZXJ2YWwgPSAnJyxcbiAgICAgICAgb3BlbixcbiAgICAgICAgdG9kYXkgPSB7fSxcbiAgICAgICAgbm93VGV4dCxcbiAgICAgICAgbWF4SG91cnMgPSBwYXJhbXMgJiYgcGFyYW1zLm1heEhvdXJzIHx8IDE7XG5cbiAgICAgICAgaWYgKCFzY2hlZHVsZSkge1xuICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNjaGVkdWxlLmFsd2F5cykgeyAvLyDQmtGA0YPQs9C70L7RgdGD0YLQvtGH0L3QviDQtdC20LXQtNC90LXQstC90L4gLSDQsdC+0LvQtdC1INC90LjRh9C10LPQviDQstGL0LLQvtC00LjRgtGMINC90LUg0L3Rg9C20L3QvlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0b2RheToge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0OiB0aGlzLmRpY3QudCh0aGlzLmxvY2FsTGFuZywgJ2Fyb3VuZFRoZUNsb2NrJylcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9wZW46IHRydWVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyDQpNC+0YDQvNC40YDRg9C10Lwg0YHRgtGA0L7QutGDIC0g0YfQtdGA0LXQtyDRgdC60L7Qu9GM0LrQviDQv9GA0L7QuNC30L7QudC00ZHRgiDRgdC70LXQtNGD0Y7RidCw0Y8g0LjQvdCy0LXRgNGB0LjRjyDQvtGC0LrRgNGL0YLQvtGB0YLQuFxuICAgICAgICBpZiAoc2NoZWR1bGUud2lsbCAmJiBzY2hlZHVsZS53aWxsLmggPCBtYXhIb3Vycykge1xuICAgICAgICAgICAgaWYgKHNjaGVkdWxlLndpbGwuaCkge1xuICAgICAgICAgICAgICAgIGludGVydmFsICs9IHRoaXMuZGljdC50KHRoaXMubG9jYWxMYW5nLCAnbkhvdXJzJywgc2NoZWR1bGUud2lsbC5oKSArICcgJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNjaGVkdWxlLndpbGwubSkge1xuICAgICAgICAgICAgICAgIGludGVydmFsICs9IHRoaXMuZGljdC50KHRoaXMubG9jYWxMYW5nLCAnbk1pbnMnLCBzY2hlZHVsZS53aWxsLm0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8g0JTQsNC90L3Ri9C1INC90LAg0YHQtdCz0L7QtNC90Y9cbiAgICAgICAgaWYgKHNjaGVkdWxlLnRvZGF5KSB7XG4gICAgICAgICAgICB0b2RheS50ZXh0ID0gdGhpcy5kaWN0LnQodGhpcy5sb2NhbExhbmcsICd0b2RheScpO1xuICAgICAgICAgICAgaWYgKHNjaGVkdWxlLmV2ZXJ5ZGF5KSB7XG4gICAgICAgICAgICAgICAgdG9kYXkudGV4dCA9IHRoaXMuZGljdC50KHRoaXMubG9jYWxMYW5nLCAnZXZlcnlkYXknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRvZGF5LmZyb20gPSBzY2hlZHVsZS50b2RheS5mcm9tO1xuICAgICAgICAgICAgdG9kYXkudG8gPSBzY2hlZHVsZS50b2RheS50bztcbiAgICAgICAgICAgIHRvZGF5Lmx1bmNoID0gc2NoZWR1bGUubHVuY2g7XG4gICAgICAgICAgICBpZiAodG9kYXkubHVuY2gpIHtcbiAgICAgICAgICAgICAgICB0b2RheS5sdW5jaFN0ciA9IHRoaXMuZGljdC50KHRoaXMubG9jYWxMYW5nLCAnbHVuY2gnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRvZGF5LnRleHQgPSB0aGlzLmRpY3QudCh0aGlzLmxvY2FsTGFuZywgJ3RvZGF5SXNSZXN0RGF5Jyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyDQotC10LrRg9GJ0LjQuSDRgdGC0LDRgtGD0YEg0Lgg0L/RgNC+0LPQvdC+0LdcbiAgICAgICAgaWYgKHNjaGVkdWxlLmFsd2F5cykgeyAvLyDQldGB0LvQuCDQutGA0YPQs9C70L7RgdGD0YLQvtGH0L3Qviwg0L3QuNGH0LXQs9C+INC60YDQvtC80LUgXCLQmtGA0YPQs9C70L7RgdGD0YLQvtGH0L3QvlwiINCy0YvQstC+0LTQuNGC0Ywg0L3QtSDQvdGD0LbQvdC+XG4gICAgICAgICAgICB0b2RheS50ZXh0ID0gdGhpcy5kaWN0LnQodGhpcy5sb2NhbExhbmcsICdhcm91bmRUaGVDbG9jaycpO1xuICAgICAgICAgICAgb3BlbiA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoc2NoZWR1bGUubm93KSB7XG4gICAgICAgICAgICBvcGVuID0gc2NoZWR1bGUubm93Lm9wZW47XG4gICAgICAgICAgICBpZiAob3BlbikgeyAvLyDQvtGC0LrRgNGL0YLQvlxuICAgICAgICAgICAgICAgIGlmIChzY2hlZHVsZS53aWxsICYmIHNjaGVkdWxlLndpbGwud2lsbFR5cGUgPT09ICdsdW5jaCcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8g0LTQsNC70LXQtSAtINC30LDQutGA0YvRgtC40LUg0L3QsCDQvtCx0LXQtFxuICAgICAgICAgICAgICAgICAgICBpZiAoc2NoZWR1bGUud2lsbCAmJiBzY2hlZHVsZS53aWxsLmggPCBtYXhIb3Vycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8g0LzQtdC90LXQtSBtYXhIb3VycyDQtNC+INC30LDQutGA0YvRgtC40Y8gINC90LAg0L7QsdC10LRcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vd1RleHQgPSB0aGlzLmRpY3QudCh0aGlzLmxvY2FsTGFuZywgJ19pbicpICsgJyAnICsgdGhpcy5kaWN0LnQodGhpcy5sb2NhbExhbmcsICduTWlucycsIGludGVydmFsKSArIHRoaXMuZGljdC50KHRoaXMubG9jYWxMYW5nLCAnaXNDbG9zaW5nT25EaW5uZXInKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vINCx0L7Qu9GM0YjQtSBtYXhIb3VycyDQtNC+INC30LDQutGA0YvRgtC40Y8gINC90LAg0L7QsdC10LRcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vd1RleHQgPSB0aGlzLmRpY3QudCh0aGlzLmxvY2FsTGFuZywgJ2lzT3BlbicpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyDQtNCw0LvQtdC1INC/0YDQvtGB0YLQviDQt9Cw0LrRgNGL0YLQuNC1XG4gICAgICAgICAgICAgICAgICAgIGlmIChzY2hlZHVsZS53aWxsLmggPCBtYXhIb3Vycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8g0LzQtdC90LXQtSBtYXhIb3VycyDQtNC+INC30LDQutGA0YvRgtC40Y8g0L/RgNC+0YHRgtC+XG4gICAgICAgICAgICAgICAgICAgICAgICBub3dUZXh0ID0gdGhpcy5kaWN0LnQodGhpcy5sb2NhbExhbmcsICdjbG9zZUluJykgKyB0aGlzLmRpY3QudCh0aGlzLmxvY2FsTGFuZywgJ25NaW5zJywgaW50ZXJ2YWwpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8g0LHQvtC70YzRiNC1IG1heEhvdXJzINC00L4g0LfQsNC60YDRi9GC0LjRjyDQv9GA0L7RgdGC0L5cbiAgICAgICAgICAgICAgICAgICAgICAgIG5vd1RleHQgPSB0aGlzLmRpY3QudCh0aGlzLmxvY2FsTGFuZywgJ2lzT3BlbicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHsgLy8g0LfQsNC60YDRi9GC0L5cbiAgICAgICAgICAgICAgICBpZiAoc2NoZWR1bGUud2lsbCAmJiBzY2hlZHVsZS53aWxsLndoZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8g0L7RgtC60YDQvtC10YLRgdGPINC90LUg0YHQtdCz0L7QtNC90Y9cbiAgICAgICAgICAgICAgICAgICAgbm93VGV4dCA9IHRoaXMuZGljdC50KHRoaXMubG9jYWxMYW5nLCAnb3BlbicpICsgc2NoZWR1bGUud2lsbC53aGVuO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vINC+0YLQutGA0L7QtdGC0YHRjyDRgdC10LPQvtC00L3Rj1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2NoZWR1bGUubm93ICYmIHNjaGVkdWxlLm5vdy5sdW5jaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8g0YHQtdC50YfQsNGBINC+0LHQtdC0XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2NoZWR1bGUud2lsbC5oIDwgbWF4SG91cnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyDQvNC10L3QtdC1IG1heEhvdXJzINC00L4g0L7RgtC60YDRi9GC0LjRjyDRgSDQvtCx0LXQtNCwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm93VGV4dCA9IHRoaXMuZGljdC50KHRoaXMubG9jYWxMYW5nLCAnTHVuY2gnKSArIHRoaXMuZGljdC50KHRoaXMubG9jYWxMYW5nLCAnb3BlbkluJykgKyB0aGlzLmRpY3QudCh0aGlzLmxvY2FsTGFuZywgJ25NaW5zJywgaW50ZXJ2YWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyDQsdC+0LvRjNGI0LUgbWF4SG91cnMg0LTQviDQvtGC0LrRgNGL0YLQuNGPINGBINC+0LHQtdC00LBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3dUZXh0ID0gdGhpcy5kaWN0LnQodGhpcy5sb2NhbExhbmcsICdMdW5jaCcpICsgdGhpcy5kaWN0LnQodGhpcy5sb2NhbExhbmcsICdvcGVuQXQnKSArIHNjaGVkdWxlLndpbGwudGlsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vINC/0YDQvtGB0YLQviDQt9Cw0LrRgNGL0YLQvlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNjaGVkdWxlLndpbGwgJiYgc2NoZWR1bGUud2lsbC5oIDwgbWF4SG91cnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyDQvNC10L3QtdC1IG1heEhvdXJzINC00L4g0L7RgtC60YDRi9GC0LjRjyDQv9GA0L7RgdGC0L5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3dUZXh0ID0gdGhpcy5kaWN0LnQodGhpcy5sb2NhbExhbmcsICdvcGVuSW4nKSArIHRoaXMuZGljdC50KHRoaXMubG9jYWxMYW5nLCAnbk1pbnMnLCBpbnRlcnZhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vINCx0L7Qu9GM0YjQtSBtYXhIb3VycyDQtNC+INC+0YLQutGA0YvRgtC40Y8g0L/RgNC+0YHRgtC+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm93VGV4dCA9IHRoaXMuZGljdC50KHRoaXMubG9jYWxMYW5nLCAnb3BlbkF0JykgKyBzY2hlZHVsZS53aWxsLnRpbGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG9kYXk6IHRvZGF5LFxuICAgICAgICAgICAgbm93OiBub3dUZXh0LFxuICAgICAgICAgICAgb3Blbjogb3BlbixcbiAgICAgICAgICAgIHdlZWs6IHNjaGVkdWxlLndlZWssXG4gICAgICAgICAgICBjb21tZW50OiBzY2hlZHVsZS5jb21tZW50LFxuICAgICAgICAgICAgZXZlcnlkYXk6IHNjaGVkdWxlLmV2ZXJ5ZGF5XG4gICAgICAgIH07XG4gICAgfVxufTtcbiIsIi8qZ2xvYmFsXG4gICAgRmlybUNhcmQ6ZmFsc2VcbiovXG4vLyBGaXJtQ2FyZC5kaWN0aW9uYXJ5ID0ge307XG5cbkZpcm1DYXJkLnByb3RvdHlwZS5kaWN0ID0ge1xuXG4gICAgdDogZnVuY3Rpb24gKGxhbmcsIG1zZywgYXJndW1lbnQpIHsgLy8gKFN0cmluZywgTnVtYmVyKSAtPiBTdHJpbmdcbiAgICAgICAgdmFyIHJlc3VsdCxcbiAgICAgICAgICAgIG1zZ0lzc2V0ID0gZmFsc2UsXG4gICAgICAgICAgICBkaWN0aW9uYXJ5TXNnLFxuICAgICAgICAgICAgZXhwO1xuXG4gICAgICAgIGlmICh0eXBlb2YgdGhpc1tsYW5nXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGxhbmcgPSAncnUnO1xuICAgICAgICB9XG4gICAgICAgIGRpY3Rpb25hcnlNc2cgPSB0aGlzW2xhbmddW21zZ107XG4gICAgICAgIG1zZ0lzc2V0ID0gdHlwZW9mIGRpY3Rpb25hcnlNc2cgIT09ICd1bmRlZmluZWQnO1xuICAgICAgICBpZiAoIW1zZ0lzc2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gbXNnO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCA9IG1zZ0lzc2V0ID8gZGljdGlvbmFyeU1zZyA6IG1zZztcblxuICAgICAgICBpZiAoYXJndW1lbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYXJndW1lbnQgPSBwYXJzZUludChhcmd1bWVudCwgMTApO1xuICAgICAgICAgICAgYXJndW1lbnQgPSBpc05hTihhcmd1bWVudCkgPyAwIDogYXJndW1lbnQ7XG4gICAgICAgICAgICBleHAgPSB0aGlzW2xhbmddLnBsdXJhbFJ1bGVzKGFyZ3VtZW50KTtcbiAgICAgICAgICAgIHJlc3VsdCA9IGFyZ3VtZW50ICsgJyAnICsgZGljdGlvbmFyeU1zZ1tleHBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQgPyByZXN1bHQgOiBtc2c7XG4gICAgfSxcblxuICAgIHJ1OiB7XG4gICAgICAgIHBsdXJhbFJ1bGVzOiBmdW5jdGlvbiAobikgeyAvLyAoTnVtYmVyKVxuICAgICAgICAgICAgaWYgKG4gJSAxMCA9PT0gMSAmJiBuICUgMTAwICE9PSAxMSkgeyAvLyAxLCAyMVxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChuICUgMTAgPj0gMiAmJiBuICUgMTAgPD0gNCAmJiAobiAlIDEwKSAlIDEgPT09IDApICYmIChuICUgMTAwIDwgMTIgfHwgbiAlIDEwMCA+IDE0KSkgeyAvLyAyLCAzXG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICgobiAlIDEwID09PSAwKSB8fCAobiAlIDEwID49IDUgJiYgbiAlIDEwIDw9IDkgJiYgKG4gJSAxMCkgJSAxID09PSAwKSB8fCAobiAlIDEwMCA+PSAxMSAmJiAobiAlIDEwMCkgPD0gMTQgJiYgKG4gJSAxMDApICUgMSA9PT0gMCkpIHsgLy8gMTMsIDE3XG4gICAgICAgICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgYnRuQmFjazogJ9Cd0LDQt9Cw0LQnLFxuICAgICAgICBidG5GaW5kV2F5OiAn0J/RgNC+0LXRhdCw0YLRjCDRgdGO0LTQsCcsXG4gICAgICAgIGJ0bkVudHJhbmNlOiAn0J3QsNC50YLQuCDQstGF0L7QtCcsXG4gICAgICAgIGxpbmtSZXZpZXdzOiBbJ9C+0YLQt9GL0LInLCAn0L7RgtC30YvQstCwJywgJ9C+0YLQt9GL0LLQvtCyJ10sXG4gICAgICAgIGxpbmtQaG90bzogWyfRhNC+0YLQvicsICfRhNC+0YLQvicsICfRhNC+0YLQviddLFxuICAgICAgICBsaW5rQm9va2xldDogJ9CR0YPQutC70LXRgicsXG4gICAgICAgIHRvbW1vcm93OiAn0LfQsNCy0YLRgNCwJyxcbiAgICAgICAgYWZ0ZXJUb21tb3JvdzogJ9C/0L7RgdC70LXQt9Cw0LLRgtGA0LAnLFxuICAgICAgICBhZnRlcldlZWs6ICfRh9C10YDQtdC3INC90LXQtNC10LvRjicsXG4gICAgICAgIG5leHRTdW46ICfQsiDQstC+0YHQutGA0LXRgdC10L3RjNC1JyxcbiAgICAgICAgbmV4dE1vbjogJ9CyINC/0L7QvdC10LTQtdC70YzQvdC40LonLFxuICAgICAgICBuZXh0VHVlOiAn0LLQviDQstGC0L7RgNC90LjQuicsXG4gICAgICAgIG5leHRXZWQ6ICfQsiDRgdGA0LXQtNGDJyxcbiAgICAgICAgbmV4dFRodTogJ9CyINGH0LXRgtCy0LXRgNCzJyxcbiAgICAgICAgbmV4dEZyaTogJ9CyINC/0Y/RgtC90LjRhtGDJyxcbiAgICAgICAgbmV4dFNhdDogJ9CyINGB0YPQsdCx0L7RgtGDJyxcbiAgICAgICAgd2lsbE9wZW46ICfQvtGC0LrRgNC+0LXRgtGB0Y8nLFxuICAgICAgICB3aWxsQ2xvc2U6ICfQt9Cw0LrRgNC+0LXRgtGB0Y8nLFxuICAgICAgICBpc09wZW46ICfQntGC0LrRgNGL0YLQvicsXG4gICAgICAgIG9wZW5UaWxsOiAn0J7RgtC60YDRi9GC0L4g0LTQviAnLFxuICAgICAgICBjbG9zZUluOiAn0JfQsNC60YDQvtC10YLRgdGPINGH0LXRgNC10LcgJyxcbiAgICAgICAgb3BlbkF0OiAn0J7RgtC60YDQvtC10YLRgdGPINCyICcsXG4gICAgICAgIG9wZW5JbjogJ9Ce0YLQutGA0L7QtdGC0YHRjyDRh9C10YDQtdC3ICcsXG4gICAgICAgIG9wZW46ICfQntGC0LrRgNC+0LXRgtGB0Y8gJyxcbiAgICAgICAgbkhvdXJzOiBbJ9GH0LDRgScsICfRh9Cw0YHQsCcsICfRh9Cw0YHQvtCyJ10sXG4gICAgICAgIG5NaW5zOiBbJ9C80LjQvdGD0YLRgycsICfQvNC40L3Rg9GC0YsnLCAn0LzQuNC90YPRgiddLFxuICAgICAgICBsdW5jaDogJ9C+0LHQtdC0JyxcbiAgICAgICAgTHVuY2g6ICfQntCx0LXQtC4gJyxcbiAgICAgICAgd29ya2luZ0RheXM6ICfQoNCw0LHQvtGH0LjQtSDQtNC90LgnLFxuICAgICAgICB3ZWVrZGF5czogJ9CR0YPQtNC90LjQtSDQtNC90LgnLFxuICAgICAgICByZXN0RGF5OiBbJ9Cy0YvRhdC+0LTQvdC+0LknLCAn0LLRi9GF0L7QtNC90YvQtScsJ9Cy0YvRhdC+0LTQvdGL0LUnXSxcbiAgICAgICAgcmV2aWV3c09uRmxhbXA6ICfQntGC0LfRi9Cy0Ysg0L3QsCDQpNC70LDQvNC/0LUnLFxuICAgICAgICB3cml0ZVJldmlld09uRmxhbXA6ICfQndCw0L/QuNGB0LDRgtGMINC+0YLQt9GL0LIg0L3QsCDQpNC70LDQvNC/0LUnLFxuICAgICAgICBwYXltZW50OiAn0L7Qv9C70LDRgtCwJyxcbiAgICAgICAgZXZlcnlkYXk6ICfQldC20LXQtNC90LXQstC90L4gYycsXG4gICAgICAgIHdvcmtzQXJvdW5kVGhlQ2xvY2s6ICfQoNCw0LHQvtGC0LDQtdGCINC60YDRg9Cz0LvQvtGB0YPRgtC+0YfQvdC+JyxcbiAgICAgICAgYXJvdW5kVGhlQ2xvY2s6ICfQmtGA0YPQs9C70L7RgdGD0YLQvtGH0L3QvicsXG4gICAgICAgIGtub3dNb3JlOiAn0YPQt9C90LDRgtGMINCx0L7Qu9GM0YjQtScsXG4gICAgICAgIHRvQ2xvc2U6ICfQtNC+INC30LDQutGA0YvRgtC40Y8nLFxuICAgICAgICBtb25kYXk6ICfQv9C+0L3QtdC00LXQu9GM0L3QuNC6JyxcbiAgICAgICAgdHVlc2RheTogJ9Cy0YLQvtGA0L3QuNC6JyxcbiAgICAgICAgd2VkbmVzZGF5OiAn0YHRgNC10LTQsCcsXG4gICAgICAgIHRodXJzZGF5OiAn0YfQtdGC0LLQtdGA0LMnLFxuICAgICAgICBmcmlkYXk6ICfQv9GP0YLQvdC40YbQsCcsXG4gICAgICAgIHNhdHVyZGF5OiAn0YHRg9Cx0LHQvtGC0LAnLFxuICAgICAgICBzdW5kYXk6ICfQstC+0YHQutGA0LXRgdC10L3RjNC1JyxcbiAgICAgICAgbW9uOiAn0L/QvtC9JyxcbiAgICAgICAgdHVlOiAn0LLRgtGAJyxcbiAgICAgICAgd2VkOiAn0YHRgNC0JyxcbiAgICAgICAgdGh1OiAn0YfRgtCyJyxcbiAgICAgICAgZnJpOiAn0L/RgtC9JyxcbiAgICAgICAgc2F0OiAn0YHQsdGCJyxcbiAgICAgICAgc3VuOiAn0LLRgdC6JyxcbiAgICAgICAgdG9MdW5jaDogJ9C00L4g0L7QsdC10LTQsCcsXG4gICAgICAgIHRvZGF5OiAn0KHQtdCz0L7QtNC90Y8nLFxuICAgICAgICBsZXNzVGhlbkhvdXI6ICfQvNC10L3QtdC1INGH0LDRgdCwJyxcbiAgICAgICAgeW91Q291bGRMYXRlOiAn0LLRiyDQvNC+0LbQtdGC0LUg0L3QtSDRg9GB0L/QtdGC0YwnLFxuICAgICAgICB3b3JraW5nVGltZTogJ9GA0LDQsdC+0YfQtdC1INCy0YDQtdC80Y8nLFxuICAgICAgICBzaG93QWxsT3JnSW5SdWJyaWM6ICfQn9C+0LrQsNC30LDRgtGMINCy0YHQtSDQvtGA0LPQsNC90LjQt9Cw0YbQuNC4INGA0YPQsdGA0LjQutC4JyxcbiAgICAgICAgdG9kYXlJc1Jlc3REYXk6ICfQodC10LPQvtC00L3RjyDQstGL0YXQvtC00L3QvtC5JyxcbiAgICAgICAgaW50ZXJuZXQ6ICfQntC/0LvQsNGC0LAg0YfQtdGA0LXQtyDQmNC90YLQtdGA0L3QtdGCJyxcbiAgICAgICAgbm9uY2FzaDogJ9CR0LXQt9C90LDQu9C40YfQvdGL0Lkg0YDQsNGB0YfQtdGCJyxcbiAgICAgICAgZ29sZGNyb3duOiAn0JfQvtC70L7RgtCw0Y8g0JrQvtGA0L7QvdCwJyxcbiAgICAgICAgZGluZXJzY2x1YjogJ0RpbmVycyBDbHViJyxcbiAgICAgICAgbWFzdGVyY2FyZDogJ01hc3RlcmNhcmQnLFxuICAgICAgICBtYWVzdHJvY2FyZDogJ01hZXN0cm9DYXJkJyxcbiAgICAgICAgdmlzYTogJ1Zpc2EnLFxuICAgICAgICBjYXNoOiAn0J3QsNC70LjRh9C90YvQuSDRgNCw0YHRh9C10YInLFxuICAgICAgICBhbWVyaWNhbmV4cHJlc3M6ICdBbWVyaWNhbiBFeHByZXNzJyxcbiAgICAgICAgaG91ciA6ICfRh9Cw0YEnLFxuICAgICAgICBsZXNzOiAn0LzQtdC90LXQtScsXG4gICAgICAgIF9pbiA6ICfQp9C10YDQtdC3JyxcbiAgICAgICAgaXNDbG9zaW5nT25EaW5uZXIgOiAnINC30LDQutGA0YvQstCw0LXRgtGB0Y8g0L3QsCDQvtCx0LXQtCdcbiAgICB9LFxuXG4gICAgaXQ6IHtcbiAgICAgICAgcGx1cmFsUnVsZXM6IGZ1bmN0aW9uIChuKSB7IC8vIChOdW1iZXIpXG4gICAgICAgICAgICBpZiAobiA9PT0gMSkgeyAvLyAxXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAxOyAvLzAsIDIsIDMsIDQgLi5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBidG5CYWNrOiAnSW5kaWV0cm8nLFxuICAgICAgICBidG5GaW5kV2F5OiAnQ29tZSBhcnJpdmFyZSAnLFxuICAgICAgICBidG5FbnRyYW5jZTogJ1Ryb3ZhIGxcXCdpbmdyZXNzbycsXG4gICAgICAgIGxpbmtSZXZpZXdzOiBbJ3JlY2Vuc2lvbmUnLCAncmVjZW5zaW9uaSddLFxuICAgICAgICBsaW5rUGhvdG86IFsnZm90b2dyYWZpYScsICdmb3RvZ3JhZmllJ10sXG4gICAgICAgIGxpbmtCb29rbGV0OiAnU3VsbFxcJ2F6aWVuZGEnLFxuICAgICAgICB0b21tb3JvdzogJ2RvbWFuaScsXG4gICAgICAgIGFmdGVyVG9tbW9yb3c6ICdkb3BvZG9tYW5pJyxcbiAgICAgICAgYWZ0ZXJXZWVrOiAndHJhIHVuYSBzZXR0aW1hbmEnLFxuICAgICAgICBuZXh0U3VuOiAnbGEgZG9tZW5pY2EnLFxuICAgICAgICBuZXh0TW9uOiAnaWwgbHVuZWRpJyxcbiAgICAgICAgbmV4dFR1ZTogJ2lsIG1hcnRlZMOsJyxcbiAgICAgICAgbmV4dFdlZDogJ2lsIG1lcmNvbGVkw6wnLFxuICAgICAgICBuZXh0VGh1OiAnaWwgZ2lvdmVkaScsXG4gICAgICAgIG5leHRGcmk6ICdpbCB2ZW5lcmTDrCcsXG4gICAgICAgIG5leHRTYXQ6ICdpbCBzYWJhdG8nLFxuICAgICAgICB3aWxsT3BlbjogJ2FwcmUnLFxuICAgICAgICB3aWxsQ2xvc2U6ICdjaXVzbycsXG4gICAgICAgIGlzT3BlbjogJ0FwZXJ0bycsXG4gICAgICAgIG9wZW5UaWxsOiAnQXBlcnRvIGZpbm8gYWxsZSAnLFxuICAgICAgICBjbG9zZUluOiAnQ2hpdWRlIHRyYSAnLFxuICAgICAgICBvcGVuQXQ6ICdBcHJlIGFsbGUgJyxcbiAgICAgICAgb3BlbkluOiAnQXByZSB0cmEgJyxcbiAgICAgICAgb3BlbjogJ0FwcmUgJyxcbiAgICAgICAgbkhvdXJzOiBbJ29yYScsICdvcmUnXSxcbiAgICAgICAgbk1pbnM6IFsnbWludXRvJywgJ21pbnV0aSddLFxuICAgICAgICBsdW5jaDogJ3BhdXNhIHByYW56bycsXG4gICAgICAgIEx1bmNoOiAnUGF1c2EgcHJhbnpvLiAnLFxuICAgICAgICB3b3JraW5nRGF5czogJ0dpb3JuaSBmZXJpYWxpJyxcbiAgICAgICAgd2Vla2RheXM6ICdHaW9ybmkgZmVyaWFsaScsXG4gICAgICAgIHJlc3REYXk6IFsnY2hpdXN1cmEnLCdjaGl1c3VyYSddLFxuICAgICAgICByZXZpZXdzT25GbGFtcDogJ1JlY2Vuc2lvbmkgc3UgRmxhbXAnLFxuICAgICAgICB3cml0ZVJldmlld09uRmxhbXA6ICdTY3JpdmkgdW5hIHJlY2Vuc2lvbmUgc3UgRmxhbXAnLFxuICAgICAgICBwYXltZW50OiAncGFnYW1lbnRvJyxcbiAgICAgICAgZXZlcnlkYXk6ICdPZ25pIGdpb3JubyBkYWxvbGUnLFxuICAgICAgICB3b3Jrc0Fyb3VuZFRoZUNsb2NrOiAnT3BlcmF0aXZvIDI0IG9yZSBzdSAyNCcsXG4gICAgICAgIGFyb3VuZFRoZUNsb2NrOiAnMjQgb3JlIHN1IDI0JyxcbiAgICAgICAga25vd01vcmU6ICd1bHRlcmlvcmkgaW5mb3JtYXppb25pJyxcbiAgICAgICAgdG9DbG9zZTogJ2Zpbm8gYWxsYSBjaGl1c3VyYScsXG4gICAgICAgIG1vbmRheTogJ2x1bmVkaScsXG4gICAgICAgIHR1ZXNkYXk6ICdtYXJ0ZWTDrCcsXG4gICAgICAgIHdlZG5lc2RheTogJ21lcmNvbGVkw6wnLFxuICAgICAgICB0aHVyc2RheTogJ2dpb3ZlZGknLFxuICAgICAgICBmcmlkYXk6ICd2ZW5lcmTDrCcsXG4gICAgICAgIHNhdHVyZGF5OiAnc2FiYXRvJyxcbiAgICAgICAgc3VuZGF5OiAnZG9tZW5pY2EnLFxuICAgICAgICBtb246ICdsdW4nLFxuICAgICAgICB0dWU6ICdtYXInLFxuICAgICAgICB3ZWQ6ICdtZXInLFxuICAgICAgICB0aHU6ICdnaW8nLFxuICAgICAgICBmcmk6ICd2ZW4nLFxuICAgICAgICBzYXQ6ICdzYWInLFxuICAgICAgICBzdW46ICdkb20nLFxuICAgICAgICB0b0x1bmNoOiAnZmlubyBhbGxhIHBhdXNhIHByYW56bycsXG4gICAgICAgIHRvZGF5OiAnT2dnaScsXG4gICAgICAgIGxlc3NUaGVuSG91cjogJ21lbm8gZGkgdW5cXCdvcmEnLFxuICAgICAgICB5b3VDb3VsZExhdGU6ICdhZmZyZXR0YXJzaSwgY2hpdXN1cmEgaW1taW5lbnRlJyxcbiAgICAgICAgd29ya2luZ1RpbWU6ICdvcmFyaW8gZGkgbGF2b3JvJyxcbiAgICAgICAgc2hvd0FsbE9yZ0luUnVicmljOiAnVmlzdWFsaXp6YSB0dXR0ZSBsZSBhemllbmRlIGRlbGxhIGNhdGVnb3JpYScsXG4gICAgICAgIHRvZGF5SXNSZXN0RGF5OiAnb2dnaSBjaGl1c28nLFxuICAgICAgICBpbnRlcm5ldDogJ1BhZ2FtZW50byBvbi1saW5lJyxcbiAgICAgICAgbm9uY2FzaDogJ1BhZ2FtZW50byBub24gaW4gY29udGFudGknLFxuICAgICAgICBnb2xkY3Jvd246ICdab2xvdGFqYSBLb3JvbmEnLFxuICAgICAgICBkaW5lcnNjbHViOiAnRGluZXJzIENsdWInLFxuICAgICAgICBtYXN0ZXJjYXJkOiAnTWFzdGVyQ2FyZCcsXG4gICAgICAgIG1hZXN0cm9jYXJkOiAnTWFlc3Ryb0NhcmQnLFxuICAgICAgICB2aXNhOiAnVmlzYScsXG4gICAgICAgIGNhc2g6ICdQYWdhbWVudG8gaW4gY29udGFudGknLFxuICAgICAgICBhbWVyaWNhbmV4cHJlc3M6ICdBbWVyaWNhbiBFeHByZXNzJyxcbiAgICAgICAgaG91ciA6ICd1blxcJ29yYScsXG4gICAgICAgIGxlc3M6ICdtZW5vIGRpJyxcbiAgICAgICAgX2luIDogJ1RyYScsXG4gICAgICAgIGlzQ2xvc2luZ09uRGlubmVyIDogJ2NoaXVkZSBwZXIgcGF1c2EgcHJhbnpvJ1xuICAgIH0sXG5cbiAgICBlbjoge1xuICAgICAgICBwbHVyYWxSdWxlczogZnVuY3Rpb24gKG4pIHsgLy8gKE51bWJlcilcbiAgICAgICAgICAgIGlmIChuID09PSAxKSB7IC8vIDFcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7IC8vMCwgMiwgMywgNCAuLlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGJ0bkJhY2s6ICdCYWNrJyxcbiAgICAgICAgYnRuRmluZFdheTogJ0dldCBoZXJlJyxcbiAgICAgICAgYnRuRW50cmFuY2U6ICdGaW5kIGVudHJhbmNlJyxcbiAgICAgICAgbGlua1Jldmlld3M6IFsncmV2aWV3JywgJ3Jldmlld3MnXSxcbiAgICAgICAgbGlua1Bob3RvOiBbJ3Bob3RvJywgJ3Bob3RvcyddLFxuICAgICAgICBsaW5rQm9va2xldDogJ0Fib3V0IGNvbXBhbnknLFxuICAgICAgICB0b21tb3JvdzogJ3RvbW9ycm93JyxcbiAgICAgICAgYWZ0ZXJUb21tb3JvdzogJ3RoZSBkYXkgYWZ0ZXIgdG9tb3Jyb3cnLFxuICAgICAgICBhZnRlcldlZWs6ICdpbiBhIHdlZWsnLFxuICAgICAgICBuZXh0U3VuOiAnb24gU3VuZGF5JyxcbiAgICAgICAgbmV4dE1vbjogJ29uIE1vbmRheScsXG4gICAgICAgIG5leHRUdWU6ICdvbiBUdWVzZGF5JyxcbiAgICAgICAgbmV4dFdlZDogJ29uIFdlZG5lc2RheScsXG4gICAgICAgIG5leHRUaHU6ICdvbiBUaHVyc2RheScsXG4gICAgICAgIG5leHRGcmk6ICdvbiBGcmlkYXknLFxuICAgICAgICBuZXh0U2F0OiAnb24gU2F0dXJkYXknLFxuICAgICAgICB3aWxsT3BlbjogJ29wZW5zICcsXG4gICAgICAgIHdpbGxDbG9zZTogJ2Nsb3NlcycsXG4gICAgICAgIGlzT3BlbjogJ09wZW4nLFxuICAgICAgICBvcGVuVGlsbDogJ09wZW4gdGlsbCAnLFxuICAgICAgICBjbG9zZUluOiAnQ2xvc2VzIGluICcsXG4gICAgICAgIG9wZW5BdDogJ09wZW5zIGF0ICcsXG4gICAgICAgIG9wZW5JbjogJ09wZW5zIGluICcsXG4gICAgICAgIG9wZW46ICdPcGVucyAnLFxuICAgICAgICBuSG91cnM6IFsnaG91cicsICdob3VycyddLFxuICAgICAgICBuTWluczogWydtaW51dGUnLCAnbWludXRlcyddLFxuICAgICAgICBsdW5jaDogJ2x1bmNoIGJyZWFrJyxcbiAgICAgICAgTHVuY2g6ICdMdW5jaCBicmVhay4gJyxcbiAgICAgICAgd29ya2luZ0RheXM6ICdXb3JraW5nIGRheXMnLFxuICAgICAgICB3ZWVrZGF5czogJ1dlZWtkYXlzJyxcbiAgICAgICAgcmVzdERheTogWydkYXkgb2ZmJywnZGF5cyBvZmYnXSxcbiAgICAgICAgcmV2aWV3c09uRmxhbXA6ICdSZXZpZXdzIG9uIEZsYW1wJyxcbiAgICAgICAgd3JpdGVSZXZpZXdPbkZsYW1wOiAnV3JpdGUgYSByZXZpZXcgb24gRmxhbXAnLFxuICAgICAgICBwYXltZW50OiAncGF5bWVudCcsXG4gICAgICAgIGV2ZXJ5ZGF5OiAnRGFpbHkgZnJvbScsXG4gICAgICAgIHdvcmtzQXJvdW5kVGhlQ2xvY2s6ICdPcGVuIDI0IGhvdXJzJyxcbiAgICAgICAgYXJvdW5kVGhlQ2xvY2s6ICcyNGgnLFxuICAgICAgICBrbm93TW9yZTogJ3NlZSBhbHNvJyxcbiAgICAgICAgdG9DbG9zZTogJ3VudGlsIGNsb3NpbmcnLFxuICAgICAgICBtb25kYXk6ICdNb25kYXknLFxuICAgICAgICB0dWVzZGF5OiAnVHVlc2RheScsXG4gICAgICAgIHdlZG5lc2RheTogJ1dlZG5lc2RheScsXG4gICAgICAgIHRodXJzZGF5OiAnVGh1cnNkYXknLFxuICAgICAgICBmcmlkYXk6ICdGcmlkYXknLFxuICAgICAgICBzYXR1cmRheTogJ1NhdHVyZGF5JyxcbiAgICAgICAgc3VuZGF5OiAnU3VuZGF5JyxcbiAgICAgICAgbW9uOiAnTW9uJyxcbiAgICAgICAgdHVlOiAnVHVlJyxcbiAgICAgICAgd2VkOiAnV2VkJyxcbiAgICAgICAgdGh1OiAnVGh1JyxcbiAgICAgICAgZnJpOiAnRnJpJyxcbiAgICAgICAgc2F0OiAnU2F0JyxcbiAgICAgICAgc3VuOiAnU3VuJyxcbiAgICAgICAgdG9MdW5jaDogJ3VudGlsIGx1bmNoJyxcbiAgICAgICAgdG9kYXk6ICdUb2RheScsXG4gICAgICAgIGxlc3NUaGVuSG91cjogJ2xlc3MgdGhlbiBvbmUgaG91cicsXG4gICAgICAgIHlvdUNvdWxkTGF0ZTogJ3lvdSBtaWdodCBiZSBsYXRlJyxcbiAgICAgICAgd29ya2luZ1RpbWU6ICd3b3JraW5nIGhvdXJzJyxcbiAgICAgICAgc2hvd0FsbE9yZ0luUnVicmljOiAnU2hvdyBhbGwgb3JnYW5pemF0aW9ucyBpbiB0aGUgY2F0ZWdvcnknLFxuICAgICAgICB0b2RheUlzUmVzdERheTogJ2Nsb3NlZCB0b2RheScsXG4gICAgICAgIGludGVybmV0OiAnT25saW5lJyxcbiAgICAgICAgbm9uY2FzaDogJyBOby1jYXNoJyxcbiAgICAgICAgZ29sZGNyb3duOiAnR29sZGVuIENyb3duJyxcbiAgICAgICAgZGluZXJzY2x1YjogJ0RpbmVycyBDbHViJyxcbiAgICAgICAgbWFzdGVyY2FyZDogJ01hc3RlcmNhcmQnLFxuICAgICAgICBtYWVzdHJvY2FyZDogJ01hZXN0cm9DYXJkJyxcbiAgICAgICAgdmlzYTogJ1Zpc2EnLFxuICAgICAgICBjYXNoOiAnQ2FzaCcsXG4gICAgICAgIGFtZXJpY2FuZXhwcmVzczogJ0FtZXJpY2FuIEV4cHJlc3MnLFxuICAgICAgICBob3VyIDogJ2hvdXInLFxuICAgICAgICBsZXNzOiAnbGVzcycsXG4gICAgICAgIF9pbiA6ICdJbicsXG4gICAgICAgIGlzQ2xvc2luZ09uRGlubmVyIDogJ3dpbGwgYmUgY2xvc2luZyBmb3IgbHVuY2gnXG4gICAgfSxcblxuICAgIGNzOiB7XG4gICAgICAgIHBsdXJhbFJ1bGVzOiBmdW5jdGlvbiAobikgeyAvLyAoTnVtYmVyKVxuICAgICAgICAgICAgcmV0dXJuIChuID09PSAxKSA/IDAgOiAobiA+PSAyICYmIG4gPD0gNCkgPyAxIDogMjtcbiAgICAgICAgfSxcblxuICAgICAgICBidG5CYWNrOiAnWnDEm3QnLFxuICAgICAgICBidG5GaW5kV2F5OiAnSmV0IHNlbScsXG4gICAgICAgIGJ0bkVudHJhbmNlOiAnSGxlZGF0IHZzdHVwJyxcbiAgICAgICAgbGlua1Jldmlld3M6IFsncmVjZW56ZScsICdyZWNlbnplJywgJ3JlY2VuesOtJ10sXG4gICAgICAgIGxpbmtQaG90bzogWydmb3RvZ3JhZmllJywgJ2ZvdG9ncmFmaWUnLCAnZm90b2dyYWZpw60nXSxcbiAgICAgICAgbGlua0Jvb2tsZXQ6ICdMZXTDoWsnLFxuICAgICAgICB0b21tb3JvdzogJ3rDrXRyYScsXG4gICAgICAgIGFmdGVyVG9tbW9yb3c6ICdwb3rDrXTFmcOtJyxcbiAgICAgICAgYWZ0ZXJXZWVrOiAnemEgdMO9ZGVuJyxcbiAgICAgICAgbmV4dFN1bjogJ3YgbmVkxJtsaScsXG4gICAgICAgIG5leHRNb246ICd2IHBvbmTEm2zDrScsXG4gICAgICAgIG5leHRUdWU6ICd2IMO6dGVyw70nLFxuICAgICAgICBuZXh0V2VkOiAndmUgc3TFmWVkdScsXG4gICAgICAgIG5leHRUaHU6ICd2ZSDEjXR2cnRlaycsXG4gICAgICAgIG5leHRGcmk6ICd2IHDDoXRlaycsXG4gICAgICAgIG5leHRTYXQ6ICd2IHNvYm90dScsXG4gICAgICAgIHdpbGxPcGVuOiAnb3RldsWZZSBzZScsXG4gICAgICAgIHdpbGxDbG9zZTogJ3phdsWZZSBzZScsXG4gICAgICAgIGlzT3BlbjogJ090ZXbFmWVubycsXG4gICAgICAgIG9wZW5UaWxsOiAnT3RldsWZZW5vIGRvICcsXG4gICAgICAgIGNsb3NlSW46ICdaYXbFmWUgc2UgemEgJyxcbiAgICAgICAgb3BlbkF0OiAnT3RldsWZZSBzZSB2ICcsXG4gICAgICAgIG9wZW5JbjogJ090ZXbFmWUgc2UgemEgJyxcbiAgICAgICAgb3BlbjogJ090ZXbFmWUgc2UgJyxcbiAgICAgICAgbkhvdXJzOiBbICdob2RpbnUnICwgJ2hvZGlueScgLCAnaG9kaW4nIF0sXG4gICAgICAgIG5NaW5zOiBbICdtaW51dHUnICwgJ21pbnV0eScgLCAnbWludXQnIF0sXG4gICAgICAgIGx1bmNoOiAncG9sZWRuw60gcMWZZXN0w6F2a2EnLFxuICAgICAgICBMdW5jaDogJ1BvbGVkbsOtIHDFmWVzdMOhdmthLiAnLFxuICAgICAgICB3b3JraW5nRGF5czogJ1bFoWVkbsOtIGRueScsXG4gICAgICAgIHdlZWtkYXlzOiAnVsWhZWRuw60gZG55JyxcbiAgICAgICAgcmVzdERheTogWyd6YXbFmWVubycsICd6YXbFmWVubyddLFxuICAgICAgICByZXZpZXdzT25GbGFtcDogJ1JlY2VuemUgbmEgRmxhbXB1JyxcbiAgICAgICAgd3JpdGVSZXZpZXdPbkZsYW1wOiAnTmFwc2F0IHJlY2VuemkgbmEgRmxhbXB1JyxcbiAgICAgICAgcGF5bWVudDogJ3BsYXRiYScsXG4gICAgICAgIGV2ZXJ5ZGF5OiAnRGVubsSbIG9kICcsXG4gICAgICAgIHdvcmtzQXJvdW5kVGhlQ2xvY2s6ICdQcmFjdWplIG5vbnN0b3AnLFxuICAgICAgICBhcm91bmRUaGVDbG9jazogJ05vbnN0b3AnLFxuICAgICAgICBrbm93TW9yZTogJ2RvenbEm2TEm3Qgc2UgdsOtY2UnLFxuICAgICAgICB0b0Nsb3NlOiAnZG8gdXphdsWZZW7DrScsXG4gICAgICAgIG1vbmRheTogJ3BvbmTEm2zDrScsXG4gICAgICAgIHR1ZXNkYXk6ICfDunRlcsO9JyxcbiAgICAgICAgd2VkbmVzZGF5OiAnc3TFmWVkYScsXG4gICAgICAgIHRodXJzZGF5OiAnxI10dnJ0ZWsnLFxuICAgICAgICBmcmlkYXk6ICdww6F0ZWsnLFxuICAgICAgICBzYXR1cmRheTogJ3NvYm90YScsXG4gICAgICAgIHN1bmRheTogJ25lZMSbbGUnLFxuICAgICAgICBtb246ICdwbycsXG4gICAgICAgIHR1ZTogJ8O6dCcsXG4gICAgICAgIHdlZDogJ3N0JyxcbiAgICAgICAgdGh1OiAnxI10JyxcbiAgICAgICAgZnJpOiAncMOhJyxcbiAgICAgICAgc2F0OiAnc28nLFxuICAgICAgICBzdW46ICduZScsXG4gICAgICAgIHRvTHVuY2g6ICdkbyBwb2xlZG7DrSBwxZllc3TDoXZreScsXG4gICAgICAgIHRvZGF5OiAnRG5lcycsXG4gICAgICAgIGxlc3NUaGVuSG91cjogJ23DqW7EmyBuZcW+IGhvZGludScsXG4gICAgICAgIHlvdUNvdWxkTGF0ZTogJ25lbXVzw610ZSB0byBzdGlobm91dCcsXG4gICAgICAgIHdvcmtpbmdUaW1lOiAncHJhY292bsOtIGRvYmEnLFxuICAgICAgICBzaG93QWxsT3JnSW5SdWJyaWM6ICdab2JyYXppdCB2xaFlY2hueSBvcmdhbml6YWNlIHYgcnVicmljZScsXG4gICAgICAgIHRvZGF5SXNSZXN0RGF5OiAnRG5lcyBqZSB6YXbFmWVubycsXG4gICAgICAgIGludGVybmV0OiAnUGxhdGJhIHByb3N0xZllZG5pY3R2w61tIEludGVybmV0dScsXG4gICAgICAgIG5vbmNhc2g6ICdCZXpob3Rvdm9zdG7DrSBwbGF0YmEnLFxuICAgICAgICBnb2xkY3Jvd246ICdab2xvdGFqYSBLb3JvbmEnLFxuICAgICAgICBkaW5lcnNjbHViOiAnRGluZXJzIENsdWInLFxuICAgICAgICBtYXN0ZXJjYXJkOiAnTWFzdGVyY2FyZCcsXG4gICAgICAgIG1hZXN0cm9jYXJkOiAnTWFlc3Ryb0NhcmQnLFxuICAgICAgICB2aXNhOiAnVmlzYScsXG4gICAgICAgIGNhc2g6ICdQbGF0YmEgaG90b3bEmycsXG4gICAgICAgIGFtZXJpY2FuZXhwcmVzczogJ0FtZXJpY2FuIEV4cHJlc3MnLFxuICAgICAgICBob3VyIDogJ2hvZGludScsXG4gICAgICAgIGxlc3M6ICdtw6luxJsnLFxuICAgICAgICBfaW4gOiAnWmEnLFxuICAgICAgICBpc0Nsb3NpbmdPbkRpbm5lciA6ICd6YcSNw61uw6EgcG9sZWRuw60gcMWZZXN0w6F2a2EnXG4gICAgfSxcblxuICAgIGVzOiB7XG4gICAgICAgIHBsdXJhbFJ1bGVzOiBmdW5jdGlvbiAobikgeyAvLyAoTnVtYmVyKVxuICAgICAgICAgIHJldHVybiAobiA9PT0gMSkgPyAwIDogKG4gPj0gMiAmJiBuIDw9IDQpID8gMSA6IDI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYnRuQmFjazogJ0F0csOhcycsXG4gICAgICAgIGJ0bkZpbmRXYXk6ICdJciBwYXJhIGFsbMOhJyxcbiAgICAgICAgYnRuRW50cmFuY2U6ICdCdXNjYXIgYWNjZXNvJyxcbiAgICAgICAgbGlua1Jldmlld3M6IFsnY29tZW50YXJpbycsICdjb21lbnRhcmlvcycsICdjb21lbnRhcmlvcyddLFxuICAgICAgICBsaW5rUGhvdG86IFsnZm90bycsICdmb3RvcycsICdmb3RvcyddLFxuICAgICAgICBsaW5rQm9va2xldDogJ0ZvbGxldG8nLFxuICAgICAgICB0b21tb3JvdzogJ21hw7FhbmEnLFxuICAgICAgICBhZnRlclRvbW1vcm93OiAncGFzYWRvIG1hw7FhbmEnLFxuICAgICAgICBhZnRlcldlZWs6ICdlbiB1bmEgc2VtYW5hIG3DoXMnLFxuICAgICAgICBuZXh0U3VuOiAnZWwgZG9taW5nbycsXG4gICAgICAgIG5leHRNb246ICdlbCBsdW5lcycsXG4gICAgICAgIG5leHRUdWU6ICdlbCBtYXJ0ZXMnLFxuICAgICAgICBuZXh0V2VkOiAnZWwgbWnDqXJjb2xlcycsXG4gICAgICAgIG5leHRUaHU6ICdlbCBqdWV2ZXMnLFxuICAgICAgICBuZXh0RnJpOiAnZWwgdmllcm5lcycsXG4gICAgICAgIG5leHRTYXQ6ICdlbCBzw6FiYWRvJyxcbiAgICAgICAgd2lsbE9wZW46ICdzZSBhYnJpcsOhJyxcbiAgICAgICAgd2lsbENsb3NlOiAnc2UgY2VycmFyw6EnLFxuICAgICAgICBpc09wZW46ICdBYmllcnRvJyxcbiAgICAgICAgb3BlblRpbGw6ICdBYmllcnRvIGhhc3RhICcsXG4gICAgICAgIGNsb3NlSW46ICdTZSBjZXJyYXLDoSBkZW50cm8gZGUgJyxcbiAgICAgICAgb3BlbkF0OiAnU2UgYWJyaXLDoSBlbCAnLFxuICAgICAgICBvcGVuSW46ICdTZSBhYnJpcsOhIGRlbnRybyBkZSAnLFxuICAgICAgICBvcGVuOiAnU2UgYWJyaXLDoSAnLFxuICAgICAgICBuSG91cnM6IFsnaG9yYScsICdob3JhcycsICdob3JhcyddLFxuICAgICAgICBuTWluczogWydtaW51dG8nLCAnbWludXRvcycsICdtaW51dG9zJ10sXG4gICAgICAgIGx1bmNoOiAnaG9yYSBkZSBjb2xhY2nDs24nLFxuICAgICAgICBMdW5jaDogJ0hvcmEgZGUgY29sYWNpw7NuLiAnLFxuICAgICAgICB3b3JraW5nRGF5czogJ0TDrWFzIGxhYm9yYWJsZXMnLFxuICAgICAgICB3ZWVrZGF5czogJ0TDrWFzIGxhYm9yYWJsZXMnLFxuICAgICAgICByZXN0RGF5OiBbJ2NlcnJhZG8nLCdjZXJyYWRvJ10sXG4gICAgICAgIHJldmlld3NPbkZsYW1wOiAnQ29tZW50YXJpb3MgZW4gRmxhbXAnLFxuICAgICAgICB3cml0ZVJldmlld09uRmxhbXA6ICdFc2NyaWJpciB1biBjb21lbnRhcmlvIGVuIEZsYW1wJyxcbiAgICAgICAgcGF5bWVudDogJ3BhZ28nLFxuICAgICAgICBldmVyeWRheTogJ0NhZGEgZMOtYSBkZXNkZScsXG4gICAgICAgIHdvcmtzQXJvdW5kVGhlQ2xvY2s6ICdBYmllcnRvIGxhcyAyNCBob3JhcycsXG4gICAgICAgIGFyb3VuZFRoZUNsb2NrOiAnMjQgaG9yYXMnLFxuICAgICAgICBrbm93TW9yZTogJ3BhcmEgc2FiZXIgbcOhcycsXG4gICAgICAgIHRvQ2xvc2U6ICdoYXN0YSBlbCBjaWVycmUnLFxuICAgICAgICBtb25kYXk6ICdsdW5lcycsXG4gICAgICAgIHR1ZXNkYXk6ICdtYXJ0ZXMnLFxuICAgICAgICB3ZWRuZXNkYXk6ICdtacOpcmNvbGVzJyxcbiAgICAgICAgdGh1cnNkYXk6ICdqdWV2ZXMnLFxuICAgICAgICBmcmlkYXk6ICd2aWVybmVzJyxcbiAgICAgICAgc2F0dXJkYXk6ICdzw6FiYWRvJyxcbiAgICAgICAgc3VuZGF5OiAnZG9taW5nbycsXG4gICAgICAgIG1vbjogJ2x1bicsXG4gICAgICAgIHR1ZTogJ21hcicsXG4gICAgICAgIHdlZDogJ21pw6knLFxuICAgICAgICB0aHU6ICdqdWUnLFxuICAgICAgICBmcmk6ICd2aWUnLFxuICAgICAgICBzYXQ6ICdzw6FiJyxcbiAgICAgICAgc3VuOiAnZG9tJyxcbiAgICAgICAgdG9MdW5jaDogJ2FudGVzIGRlIGxhIGhvcmEgZGUgY29sYWNpw7NuJyxcbiAgICAgICAgdG9kYXk6ICdIb3knLFxuICAgICAgICBsZXNzVGhlbkhvdXI6ICdtZW5vcyBkZSB1bmEgaG9yYScsXG4gICAgICAgIHlvdUNvdWxkTGF0ZTogJ3B1ZWRlIHNlciBxdWUgbm8gYWxjYW56YXMgYSBsbGVnYXInLFxuICAgICAgICB3b3JraW5nVGltZTogJ2hvcmFyaW8gZGUgdHJhYmFqbycsXG4gICAgICAgIHNob3dBbGxPcmdJblJ1YnJpYzogJ01vc3RyYXIgdG9kYXMgbGFzIGVtcHJlc2FzIGRlIGxhIGNhdGVnb3LDrWEnLFxuICAgICAgICB0b2RheUlzUmVzdERheTogJ0hveSBjZXJyYWRvJyxcbiAgICAgICAgaW50ZXJuZXQ6ICdQYWdvIHBvciBJbnRlcm5ldCcsXG4gICAgICAgIG5vbmNhc2g6ICdQYWdvIHNpbiBlZmVjdGl2bycsXG4gICAgICAgIGdvbGRjcm93bjogJ1pvbG90YXlhIEtvcm9uYScsXG4gICAgICAgIGRpbmVyc2NsdWI6ICdEaW5lcnMgQ2x1YicsXG4gICAgICAgIG1hc3RlcmNhcmQ6ICdNYXN0ZXJjYXJkJyxcbiAgICAgICAgbWFlc3Ryb2NhcmQ6ICdNYWVzdHJvQ2FyZCcsXG4gICAgICAgIHZpc2E6ICdWaXNhJyxcbiAgICAgICAgY2FzaDogJ1BhZ28gZW4gZWZlY3Rpdm8nLFxuICAgICAgICBhbWVyaWNhbmV4cHJlc3M6ICdBbWVyaWNhbiBFeHByZXNzJyxcbiAgICAgICAgaG91ciA6ICdob3JhJyxcbiAgICAgICAgbGVzczogJ21lbm9zIGRlJyxcbiAgICAgICAgX2luIDogJ0RlbnRybyBkZScsXG4gICAgICAgIGlzQ2xvc2luZ09uRGlubmVyIDogJ3NlIGNpZXJyYSBwb3IgaG9yYSBkZSBjb2xhY2nDs24nXG4gICAgfVxufTtcbiIsIi8qIGdsb2JhbCAzMDAwMDAsIDEwLHRydWUgKi9cblxuREcuVHJhZmZpYyA9IERHLlRpbGVMYXllci5leHRlbmQoe1xuXG4gICAgb3B0aW9uczoge1xuICAgICAgICBwZXJpb2Q6IDAsXG4gICAgICAgIGRpc2FibGVMYWJlbDogZmFsc2VcbiAgICB9LFxuXG4gICAgc3RhdGljczoge1xuICAgICAgICBEaWN0aW9uYXJ5OiB7fSxcbiAgICAgICAgdGlsZVVybDogJ2h0dHA6Ly90cmFmZmlje3N9Lm1hcHMuMmdpcy5jb20ve3Byb2plY3RDb2RlfS90cmFmZmljL3t6fS97eH0ve3l9L3NwZWVkL3twZXJpb2R9L3t0aW1lc3RhbXBTdHJpbmd9JyxcbiAgICAgICAgbWV0YVVybDogJ2h0dHA6Ly9tZXRhe3N9Lm1hcHMuMmdpcy5jb20ve3Byb2plY3RDb2RlfS9tZXRhL3t6fS97eH0ve3l9L2dyYXBoX3NwZWVkL3twZXJpb2R9L3t0aW1lc3RhbXBTdHJpbmd9JyxcbiAgICAgICAgdGltZVVybDogJ2h0dHA6Ly90cmFmZmlje3N9Lm1hcHMuMmdpcy5jb20ve3Byb2plY3RDb2RlfS9tZXRhL3NwZWVkL3RpbWUvJyxcbiAgICAgICAgdXBkYXRlSW50ZXJ2YWw6IDMwMDAwMCxcbiAgICAgICAgbGF5ZXJzT3B0aW9uczoge1xuICAgICAgICAgICAgZXJyb3JUaWxlVXJsOiAnZGF0YTppbWFnZS9naWY7YmFzZTY0LFIwbEdPRGxoQVFBQkFJQUFBQUFBQVAvLy95SDVCQUVBQUFBQUxBQUFBQUFCQUFFQUFBSUJSQUE3JyxcbiAgICAgICAgICAgIHN1YmRvbWFpbnM6ICcwMTIzNDU2NzknLFxuICAgICAgICAgICAgbWF4TmF0aXZlWm9vbTogMTgsXG4gICAgICAgICAgICBkZXRlY3RSZXRpbmE6IHRydWUsXG4gICAgICAgICAgICBtaW5ab29tOiAxMFxuICAgICAgICB9XG4gICAgfSxcblxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBERy5zZXRPcHRpb25zKHRoaXMsIERHLmV4dGVuZChvcHRpb25zIHx8IHt9LCBERy5UcmFmZmljLmxheWVyc09wdGlvbnMpKTtcbiAgICAgICAgb3B0aW9ucy50aW1lc3RhbXBTdHJpbmcgPSBvcHRpb25zLnBlcmlvZCA/ICcnIDogKCc/JyArICAobmV3IERhdGUoKSkuZ2V0VGltZSgpKTtcbiAgICAgICAgdGhpcy5fbWV0YUxheWVyID0gREcuTWV0YS5sYXllcihudWxsLCB7XG4gICAgICAgICAgICBkZXRlY3RSZXRpbmE6IG9wdGlvbnMuZGV0ZWN0UmV0aW5hLFxuICAgICAgICAgICAgbWF4TmF0aXZlWm9vbTogb3B0aW9ucy5tYXhOYXRpdmVab29tLFxuICAgICAgICAgICAgZGF0YUZpbHRlcjogREcuYmluZCh0aGlzLl9wcm9jZXNzRGF0YSwgdGhpcyksXG4gICAgICAgICAgICBtaW5ab29tOiBvcHRpb25zLm1pblpvb21cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2lzRGcgPSB0cnVlO1xuICAgICAgICB0aGlzLl9vblRpbWVyID0gREcuYmluZCh0aGlzLl9vblRpbWVyLCB0aGlzKTtcbiAgICAgICAgREcuVGlsZUxheWVyLnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcywgREcuVHJhZmZpYy50aWxlVXJsLCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgLy8gI3NldFRpbWUoZGF5IFswLTZdLCB0aW1lWzAtMjNdKSA/Pz8/XG5cbiAgICBvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xuICAgICAgICB0aGlzLl91cGRhdGVMYXllclByb2plY3QoKTtcblxuICAgICAgICBtYXBcbiAgICAgICAgICAgIC5hZGRMYXllcih0aGlzLl9tZXRhTGF5ZXIpXG4gICAgICAgICAgICAub24oJ3Byb2plY3RjaGFuZ2UgcHJvamVjdGxlYXZlJywgdGhpcy5fb25NYXBQcm9qZWN0Q2hhbmdlLCB0aGlzKTtcblxuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5kaXNhYmxlTGFiZWwpIHtcbiAgICAgICAgICAgIHRoaXMuX21ldGFMYXllci5vbih0aGlzLl9sYXllckV2ZW50c0xpc3RlbmVycywgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9sYWJlbEhlbHBlciA9IERHLmxhYmVsKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoREcuVHJhZmZpYy51cGRhdGVJbnRlcnZhbCkge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlVGltZXIgPSBzZXRJbnRlcnZhbCh0aGlzLl9vblRpbWVyLCBERy5UcmFmZmljLnVwZGF0ZUludGVydmFsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIERHLlRpbGVMYXllci5wcm90b3R5cGUub25BZGQuY2FsbCh0aGlzLCBtYXApO1xuICAgIH0sXG5cbiAgICBvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xuICAgICAgICBjbGVhckludGVydmFsKHRoaXMuX3VwZGF0ZVRpbWVyKTtcblxuICAgICAgICBtYXBcbiAgICAgICAgICAgIC5yZW1vdmVMYXllcih0aGlzLl9tZXRhTGF5ZXIpXG4gICAgICAgICAgICAub2ZmKCdwcm9qZWN0Y2hhbmdlIHByb2plY3RsZWF2ZScsIHRoaXMuX29uTWFwUHJvamVjdENoYW5nZSwgdGhpcyk7XG5cbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuZGlzYWJsZUxhYmVsKSB7XG4gICAgICAgICAgICB0aGlzLl9tZXRhTGF5ZXIub2ZmKHRoaXMuX2xheWVyRXZlbnRzTGlzdGVuZXJzLCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX21hcC5yZW1vdmVMYXllcih0aGlzLl9sYWJlbEhlbHBlcik7XG4gICAgICAgICAgICB0aGlzLl9sYWJlbEhlbHBlciA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBERy5UaWxlTGF5ZXIucHJvdG90eXBlLm9uUmVtb3ZlLmNhbGwodGhpcywgbWFwKTtcbiAgICB9LFxuXG4gICAgdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdGhpcy5fZ2V0VGltZXN0YW1wU3RyaW5nKCkudGhlbihcbiAgICAgICAgICAgIGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIHNlbGYub3B0aW9ucy50aW1lc3RhbXBTdHJpbmcgPSAnPycgKyByZXNwb25zZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5vcHRpb25zLnRpbWVzdGFtcFN0cmluZyA9ICc/JyArIChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG4gICAgICAgICAgICB9KS50aGVuKFxuICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHNlbGYuZmlyZSgndXBkYXRlJywge3RpbWVzdGFtcDogc2VsZi5vcHRpb25zLnRpbWVzdGFtcFN0cmluZ30pO1xuICAgICAgICAgICAgICAgIHNlbGYuX2xheWVyRXZlbnRzTGlzdGVuZXJzLm1vdXNlb3V0LmNhbGwoc2VsZik7XG4gICAgICAgICAgICAgICAgc2VsZi5fbWV0YUxheWVyLmdldE9yaWdpbigpLnNldFVSTChzZWxmLl9wcmVwYXJlTWV0YVVSTCgpLCBzZWxmKTtcbiAgICAgICAgICAgICAgICBzZWxmLnJlZHJhdygpO1xuICAgICAgICAgICAgfVxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICBnZXRTdWJkb21haW46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIERHLlRyYWZmaWMubGF5ZXJzT3B0aW9ucy5zdWJkb21haW5zW1xuICAgICAgICAgICAgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogREcuVHJhZmZpYy5sYXllcnNPcHRpb25zLnN1YmRvbWFpbnMubGVuZ3RoKVxuICAgICAgICBdO1xuICAgIH0sXG5cbiAgICBfZ2V0VGltZXN0YW1wU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBERy5hamF4KFxuICAgICAgICAgICAgREcuVXRpbC50ZW1wbGF0ZShcbiAgICAgICAgICAgICAgICBERy5UcmFmZmljLnRpbWVVcmwsXG4gICAgICAgICAgICAgICAgREcuZXh0ZW5kKHtcbiAgICAgICAgICAgICAgICAgICAgcyA6IHRoaXMuZ2V0U3ViZG9tYWluKCksXG4gICAgICAgICAgICAgICAgICAgIHByb2plY3RDb2RlOiB0aGlzLl9tYXAucHJvamVjdERldGVjdG9yLmdldFByb2plY3QoKS5jb2RlXG4gICAgICAgICAgICAgICAgfSwgdGhpcy5vcHRpb25zIHx8IHt9KSksXG4gICAgICAgICAgICB7dHlwZTogJ2dldCd9XG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIF9vblRpbWVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucGVyaW9kID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9wcm9jZXNzRGF0YTogZnVuY3Rpb24gKHRyYWZmaWNEYXRhLCBjb29yZCkge1xuICAgICAgICB2YXIgbWFwID0gdGhpcy5fbWFwLFxuICAgICAgICAgICAgdGlsZU9yaWdpblBvaW50ID0gY29vcmQubXVsdGlwbHlCeSh0aGlzLl9nZXRUaWxlU2l6ZSgpKSxcbiAgICAgICAgICAgIGhpbnRzID0ge307XG5cbiAgICAgICAgaWYgKCFERy5VdGlsLmlzQXJyYXkodHJhZmZpY0RhdGEpKSB7ICAgIC8vIFRPRE8gcmVtb3ZlXG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cblxuICAgICAgICB0cmFmZmljRGF0YVsxXS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICB0aGlzW2l0ZW0uZ3JhcGhfaWRdID0gaXRlbS5zcGVlZF90ZXh0O1xuICAgICAgICB9LCBoaW50cyk7XG5cbiAgICAgICAgcmV0dXJuIHRyYWZmaWNEYXRhWzBdLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgdmFyIGdlb0pzb24gPSBERy5Xa3QudG9HZW9KU09OKGl0ZW0uZ2VvbWV0cnlbMF0ub2JqZWN0WzBdKTtcblxuICAgICAgICAgICAgZ2VvSnNvbi5jb29yZGluYXRlc1swXSA9IGdlb0pzb24uY29vcmRpbmF0ZXNbMF0ubWFwKGZ1bmN0aW9uIChyZXZlcnRlZExhdGxuZykge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYXBcbiAgICAgICAgICAgICAgICAgICAgICAgIC5wcm9qZWN0KFtyZXZlcnRlZExhdGxuZ1sxXSwgcmV2ZXJ0ZWRMYXRsbmdbMF1dKS5yb3VuZCgpXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3VidHJhY3QodGlsZU9yaWdpblBvaW50KTtcbiAgICAgICAgICAgIH0pOyAvLyBUT0RPIGNoZWNrIHdpdGggTXVsdGlQb2lnb24gYW5kIGV0Yy5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaWQ6IGl0ZW0uZ3JhcGhfaWQsXG4gICAgICAgICAgICAgICAgc3BlZWQ6IGhpbnRzW2l0ZW0uZ3JhcGhfaWRdLFxuICAgICAgICAgICAgICAgIGdlb21ldHJ5OiBnZW9Kc29uXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgX3ByZXBhcmVNZXRhVVJMOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBERy5VdGlsLnRlbXBsYXRlKERHLlRyYWZmaWMubWV0YVVybCwgREcuZXh0ZW5kKHtcbiAgICAgICAgICAgIHg6ICd7eH0nLFxuICAgICAgICAgICAgeTogJ3t5fScsXG4gICAgICAgICAgICB6OiAne3p9JyxcbiAgICAgICAgICAgIHM6ICd7c30nXG4gICAgICAgIH0sIHRoaXMub3B0aW9ucykpO1xuICAgIH0sXG5cbiAgICBfdXBkYXRlTGF5ZXJQcm9qZWN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwcm9qZWN0ID0gdGhpcy5fbWFwLnByb2plY3REZXRlY3Rvci5nZXRQcm9qZWN0KCk7XG4gICAgICAgIERHLnNldE9wdGlvbnModGhpcywgcHJvamVjdCAmJiBwcm9qZWN0LnRyYWZmaWMgPyB7XG4gICAgICAgICAgICAgICAgcHJvamVjdENvZGU6IHByb2plY3QuY29kZSxcbiAgICAgICAgICAgICAgICBib3VuZHM6IHByb2plY3QubGF0TG5nQm91bmRzLFxuICAgICAgICAgICAgICAgIG1pblpvb206IE1hdGgubWF4KHByb2plY3QubWluWm9vbSwgREcuVHJhZmZpYy5sYXllcnNPcHRpb25zLm1pblpvb20pLFxuICAgICAgICAgICAgICAgIG1heFpvb206IHByb2plY3QubWF4Wm9vbVxuICAgICAgICAgICAgfSA6IHtcbiAgICAgICAgICAgICAgICBtYXhab29tOiAwLFxuICAgICAgICAgICAgICAgIG1pblpvb206IDBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9tZXRhTGF5ZXIuZ2V0T3JpZ2luKCkuc2V0VVJMKHRoaXMuX3ByZXBhcmVNZXRhVVJMKCkpO1xuICAgIH0sXG5cbiAgICBfb25NYXBQcm9qZWN0Q2hhbmdlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUxheWVyUHJvamVjdCgpO1xuICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgIH0sXG5cbiAgICBfbGF5ZXJFdmVudHNMaXN0ZW5lcnM6IHtcbiAgICAgICAgbW91c2VvdmVyOiBmdW5jdGlvbiAoZSkgeyAvLyAoT2JqZWN0KVxuICAgICAgICAgICAgdGhpcy5fc2V0Q3Vyc29yKCdwb2ludGVyJyk7XG4gICAgICAgICAgICBpZiAodGhpcy5fbGFiZWxIZWxwZXIgJiYgZS5tZXRhLnNwZWVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGFiZWxIZWxwZXJcbiAgICAgICAgICAgICAgICAgICAgLnNldFBvc2l0aW9uKGUubGF0bG5nKVxuICAgICAgICAgICAgICAgICAgICAuc2V0Q29udGVudChlLm1ldGEuc3BlZWQgKyAnICcgKyB0aGlzLnQoJ3NwZWVkX3VuaXRfa21faCcpKVxuICAgICAgICAgICAgICAgICAgICAuYWRkVG8odGhpcy5fbWFwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbW91c2VvdXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX3NldEN1cnNvcignJyk7XG4gICAgICAgICAgICBpZiAodGhpcy5fbGFiZWxIZWxwZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXAucmVtb3ZlTGF5ZXIodGhpcy5fbGFiZWxIZWxwZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBtb3VzZW1vdmU6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fbGFiZWxIZWxwZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sYWJlbEhlbHBlci5zZXRQb3NpdGlvbihlLmxhdGxuZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX3NldEN1cnNvcjogZnVuY3Rpb24gKGN1cnNvcikgeyAvLyAoU3RyaW5nKVxuICAgICAgICB0aGlzLl9tYXAuZ2V0Q29udGFpbmVyKCkuc3R5bGUuY3Vyc29yID0gY3Vyc29yO1xuICAgIH1cblxufSk7XG5cbkRHLlRyYWZmaWMuaW5jbHVkZShERy5Mb2NhbGUpO1xuXG5ERy50cmFmZmljID0gZnVuY3Rpb24gKG9wdGlvbnMpIHsgLy8gKE9iamVjdClcbiAgICByZXR1cm4gbmV3IERHLlRyYWZmaWMob3B0aW9ucyk7XG59O1xuIiwiREcuVHJhZmZpYy5EaWN0aW9uYXJ5LnJ1ID0ge1xuICAgIHNwZWVkX3VuaXRfa21faDogJ9C60Lwv0YcnXG59OyIsIkRHLlRyYWZmaWMuRGljdGlvbmFyeS5pdCA9IHtcbiAgICBzcGVlZF91bml0X2ttX2g6ICdrbS9oJ1xufTsiLCJERy5UcmFmZmljLkRpY3Rpb25hcnkuY3MgPSB7XG4gICAgc3BlZWRfdW5pdF9rbV9oOiAna20vaCdcbn07IiwiREcuVHJhZmZpYy5EaWN0aW9uYXJ5LmVzID0ge1xuICAgIHNwZWVkX3VuaXRfa21faDogJ2ttL2gnXG59OyIsIkRHLlRyYWZmaWMuRGljdGlvbmFyeS5lbiA9IHtcbiAgICBzcGVlZF91bml0X2ttX2g6ICdrbS9oJ1xufTsiLCIvKiBnbG9iYWwgMTAgKi9cblxuREcuQ29udHJvbC5UcmFmZmljID0gREcuUm91bmRDb250cm9sLmV4dGVuZCh7XG5cbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHBvc2l0aW9uOiAndG9wcmlnaHQnLFxuICAgICAgICBpY29uQ2xhc3M6ICd0cmFmZmljJ1xuICAgIH0sXG5cbiAgICBzdGF0aWNzOiB7XG4gICAgICAgIERpY3Rpb25hcnk6IHt9LFxuICAgICAgICBzY29yZVVybDogJ2h0dHA6Ly90cmFmZmlje3N9Lm1hcHMuMmdpcy5jb20ve3Byb2plY3RDb2RlfS9tZXRhL3Njb3JlLzAvJyxcbiAgICAgICAgdHJhZmZpY01pblpvb206IDEwXG4gICAgfSxcblxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuX3RyYWZmaWNDbGFzcyA9ICdkZy10cmFmZmljLWNvbnRyb2wnO1xuICAgICAgICB0aGlzLl9jb250cm9sSGlkZUNsYXNzID0gJ2RnLWNvbnRyb2wtcm91bmRfaXMtaGlkZGVuX3RydWUnO1xuXG4gICAgICAgIERHLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG4gICAgICAgIERHLmV4dGVuZCh0aGlzLCB7XG4gICAgICAgICAgICBfYWN0aXZlOiBmYWxzZSxcbiAgICAgICAgICAgIF90cmFmZmljTGF5ZXI6IG51bGxcbiAgICAgICAgfSkub24odGhpcy5fY29udHJvbEV2ZW50cywgdGhpcyk7XG4gICAgfSxcblxuICAgIF9jb250cm9sRXZlbnRzOiB7XG4gICAgICAgIGFkZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fdHJhZmZpY0xheWVyID0gREcudHJhZmZpYygpO1xuICAgICAgICAgICAgdGhpcy5fbWFwLm9uKCd6b29tZW5kIHByb2plY3RjaGFuZ2UgcHJvamVjdGxlYXZlJywgdGhpcy5fdXBkYXRlQ29udHJvbFZpc2liaWxpdHksIHRoaXMpO1xuICAgICAgICB9LFxuICAgICAgICBjbGljazogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fYWN0aXZlID0gIXRoaXMuX2FjdGl2ZTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX2FjdGl2ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoJ2FjdGl2ZScpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Nob3dUcmFmZmljKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoJycpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2hpZGVUcmFmZmljKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5vZmYodGhpcy5fY29udHJvbEV2ZW50cywgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9tYXAub2ZmKCd6b29tZW5kIHByb2plY3RjaGFuZ2UgcHJvamVjdGxlYXZlJywgdGhpcy5fdXBkYXRlQ29udHJvbFZpc2liaWxpdHksIHRoaXMpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2FjdGl2ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX21hcC5yZW1vdmVMYXllcih0aGlzLl90cmFmZmljTGF5ZXIpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2FjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fdHJhZmZpY0xheWVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfc2hvd1RyYWZmaWM6IGZ1bmN0aW9uICgpIHsgLy8gKClcbiAgICAgICAgdGhpcy5fdXBkYXRlVHJhZmZpY1Njb3JlKCk7XG4gICAgICAgIHRoaXMuX21hcC5hZGRMYXllcih0aGlzLl90cmFmZmljTGF5ZXIpO1xuICAgIH0sXG5cbiAgICBfaGlkZVRyYWZmaWM6IGZ1bmN0aW9uICgpIHsgLy8gKClcbiAgICAgICAgdGhpcy5faGFuZGxlRG9tKCdyZW1vdmUnKTtcbiAgICAgICAgdGhpcy5fbWFwLnJlbW92ZUxheWVyKHRoaXMuX3RyYWZmaWNMYXllcik7XG4gICAgfSxcblxuICAgIF9oYW5kbGVEb206IGZ1bmN0aW9uIChtZXRob2QsIHNjb3JlKSB7XG4gICAgICAgIHZhciBhID0gdGhpcy5fbGluaztcblxuICAgICAgICBhLmlubmVySFRNTCA9IHNjb3JlIHx8ICcnO1xuICAgICAgICBERy5Eb21VdGlsW21ldGhvZCArICdDbGFzcyddKGEsIHRoaXMuX3RyYWZmaWNDbGFzcyk7XG4gICAgICAgIERHLkRvbVV0aWxbbWV0aG9kICsgJ0NsYXNzJ10oYSwgdGhpcy5fdHJhZmZpY0NsYXNzICsgJ19jb2xvcl8nICsgdGhpcy5fc2NvcmVSYXRlKTtcbiAgICB9LFxuXG4gICAgX2dldFRyYWZmaWNDb2xvcjogZnVuY3Rpb24gKHNjb3JlKSB7IC8vIChOdW1iZXIpIC0+IFN0cmluZ1xuICAgICAgICB2YXIgcmVzdWx0ID0gJ2dyZWVuJztcblxuICAgICAgICBpZiAoc2NvcmUgPiA3KSB7XG4gICAgICAgICAgICByZXN1bHQgPSAncmVkJztcbiAgICAgICAgfSBlbHNlIGlmIChzY29yZSA+IDQpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9ICd5ZWxsb3cnO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgX3VwZGF0ZUNvbnRyb2xWaXNpYmlsaXR5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHByb2plY3QgPSB0aGlzLl9tYXAucHJvamVjdERldGVjdG9yLmdldFByb2plY3QoKSxcbiAgICAgICAgICAgIHByb2plY3RIYXNUcmFmZmljID0gcHJvamVjdCAmJiBwcm9qZWN0LnRyYWZmaWMsXG4gICAgICAgICAgICBtZXRob2QgPSAoKHRoaXMuX21hcC5nZXRab29tKCkgPCBERy5Db250cm9sLlRyYWZmaWMudHJhZmZpY01pblpvb20pIHx8XG4gICAgICAgICAgICAoIXByb2plY3RIYXNUcmFmZmljKSkgPyAnYWRkQ2xhc3MnIDogJ3JlbW92ZUNsYXNzJztcblxuICAgICAgICBERy5Eb21VdGlsW21ldGhvZF0odGhpcy5fY29udGFpbmVyLCB0aGlzLl9jb250cm9sSGlkZUNsYXNzKTtcbiAgICAgICAgaWYgKHRoaXMuX2FjdGl2ZSAmJiBwcm9qZWN0SGFzVHJhZmZpYykge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlVHJhZmZpY1Njb3JlKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX3VwZGF0ZVRyYWZmaWNTY29yZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICB0aGlzLl9nZXRUcmFmZmljU2NvcmUoKS50aGVuKGZ1bmN0aW9uIChzY29yZSkge1xuICAgICAgICAgICAgc2NvcmUgPSBwYXJzZUludChzY29yZSwgMTApOyAvLyBzb21ldGltZXMgd2ViYXBpIHJldHVybnMgc29tZXRoaW5nIGxpa2UgJzUsKydcblxuICAgICAgICAgICAgc2VsZi5fc2NvcmVSYXRlID0gc2VsZi5fZ2V0VHJhZmZpY0NvbG9yKHNjb3JlKTtcbiAgICAgICAgICAgIHNlbGYuX2hhbmRsZURvbSgnYWRkJywgc2NvcmUpO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgX2dldFRyYWZmaWNTY29yZTogZnVuY3Rpb24gKCkgeyAvLyAoKSAtPiBQcm9taXNlXG4gICAgICAgIHZhciB1cmwgPSBERy5VdGlsLnRlbXBsYXRlKFxuICAgICAgICAgICAgREcuQ29udHJvbC5UcmFmZmljLnNjb3JlVXJsLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHM6IHRoaXMuX3RyYWZmaWNMYXllci5nZXRTdWJkb21haW4oKSxcbiAgICAgICAgICAgICAgICBwcm9qZWN0Q29kZTogdGhpcy5fbWFwLnByb2plY3REZXRlY3Rvci5nZXRQcm9qZWN0KCkuY29kZVxuICAgICAgICAgICAgfVxuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybiBERy5hamF4KHVybCwge3R5cGU6ICdnZXQnfSk7XG4gICAgfSxcblxuICAgIF9yZW5kZXJUcmFuc2xhdGlvbjogZnVuY3Rpb24gKCkgeyAvLyAoKVxuICAgICAgICB0aGlzLl9saW5rLnRpdGxlID0gdGhpcy50KCdidXR0b25fdGl0bGUnKTtcbiAgICB9XG59KTtcblxuREcuY29udHJvbC50cmFmZmljID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IERHLkNvbnRyb2wuVHJhZmZpYyhvcHRpb25zKTtcbn07XG4iLCJERy5Db250cm9sLlRyYWZmaWMuRGljdGlvbmFyeS5ydSA9IHtcblx0YnV0dG9uX3RpdGxlOiAn0J/RgNC+0LHQutC4J1xufTtcbiIsIkRHLkNvbnRyb2wuVHJhZmZpYy5EaWN0aW9uYXJ5Lml0ID0ge1xuXHRidXR0b25fdGl0bGU6ICdDb2xvbm5hJ1xufTtcbiIsIkRHLkNvbnRyb2wuVHJhZmZpYy5EaWN0aW9uYXJ5LmNzID0ge1xuXHRidXR0b25fdGl0bGU6ICdaw6FjcHknXG59O1xuIiwiREcuQ29udHJvbC5UcmFmZmljLkRpY3Rpb25hcnkuZXMgPSB7XG5cdGJ1dHRvbl90aXRsZTogJ1RhY28nXG59O1xuIiwiREcuQ29udHJvbC5UcmFmZmljLkRpY3Rpb25hcnkuZW4gPSB7XG5cdGJ1dHRvbl90aXRsZTogJ1RyYWZmaWMnXG59O1xuIiwiREcuUnVsZXIgPSBERy5MYXllci5leHRlbmQoe1xuXG4gICAgb3B0aW9uczoge1xuICAgICAgICBlZGl0YWJsZTogdHJ1ZVxuICAgIH0sXG5cbiAgICBpbmNsdWRlczogW0RHLkxvY2FsZV0sXG5cbiAgICBzdGF0aWNzOiB7XG4gICAgICAgIERpY3Rpb25hcnk6IHt9XG4gICAgfSxcblxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIChsYXRsbmdzLCBvcHRpb25zKSB7IC8vIChBcnJheSwgT2JqZWN0KVxuICAgICAgICBERy5VdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG5cbiAgICAgICAgdGhpcy5fbGF5ZXJzID0ge1xuICAgICAgICAgICAgYmFjayA6IG51bGwsXG4gICAgICAgICAgICBtaWRkbGUgOiBudWxsLFxuICAgICAgICAgICAgZnJvbnQgOiBudWxsLFxuICAgICAgICAgICAgbW91c2UgOiBudWxsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3BvaW50cyA9IFtdO1xuXG4gICAgICAgIHRoaXMuX2xheWVyc0NvbnRhaW5lciA9IERHLmZlYXR1cmVHcm91cCgpO1xuICAgICAgICBPYmplY3Qua2V5cyh0aGlzLl9sYXllcnMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2xheWVyc0NvbnRhaW5lci5hZGRMYXllcih0aGlzLl9sYXllcnNbbmFtZV0gPSBERy5mZWF0dXJlR3JvdXAoKSk7XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIHRoaXMuX3Jlc2V0KCk7XG5cbiAgICAgICAgaWYgKERHLkJyb3dzZXIudG91Y2gpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9saW5lTW91c2VFdmVudHMubW91c2VvdmVyO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2xpbmVNb3VzZUV2ZW50cy5tb3VzZW91dDtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9saW5lTW91c2VFdmVudHMubW91c2Vtb3ZlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2xpbmVNb3VzZUV2ZW50cy5jbGljaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsYXRsbmdzICYmIGxhdGxuZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLnNldExhdExuZ3MobGF0bG5ncyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgb25BZGQ6IGZ1bmN0aW9uIChtYXApIHsgLy8gKE1hcClcbiAgICAgICAgdGhpcy5fbWFwID0gbWFwLm9uKCdsYW5nY2hhbmdlJywgdGhpcy5fdXBkYXRlRGlzdGFuY2UsIHRoaXMpO1xuXG4gICAgICAgIC8vIHBhbmUgZm9yIHRoZSBydW5uaW5nIGxhYmVsXG4gICAgICAgIGlmICghdGhpcy5fbWFwLmdldFBhbmUoJ3J1bGVyTGFiZWxQYW5lJykpIHtcbiAgICAgICAgICAgIHRoaXMuX21hcC5jcmVhdGVQYW5lKCdydWxlckxhYmVsUGFuZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcGFuZSB3aXRoIHRyYW5zcGVyZW50IHZlY3RvciBmb3IgZXZlbnRzIGhhbmRsaW5nIChvdmVyIHJ1bm5pbmcgbGFiZWwpXG4gICAgICAgIGlmICghdGhpcy5fbWFwLmdldFBhbmUoJ3J1bGVyRXZlbnRQYW5lJykpIHtcbiAgICAgICAgICAgIHRoaXMuX21hcC5jcmVhdGVQYW5lKCdydWxlckV2ZW50UGFuZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbGF5ZXJzQ29udGFpbmVyLmFkZFRvKHRoaXMuX21hcCk7XG5cbiAgICAgICAgaWYgKHRoaXMuX3BvaW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuX2xheWVycy5tb3VzZS5maXJlKCdsYXllcmFkZCcpO1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlRGlzdGFuY2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2xheWVycy5tb3VzZS5vbih0aGlzLl9saW5lTW91c2VFdmVudHMsIHRoaXMpO1xuICAgIH0sXG5cbiAgICBvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkgeyAvLyAoTWFwKVxuICAgICAgICBtYXBcbiAgICAgICAgICAgIC5vZmYoJ2xhbmdjaGFuZ2UnLCB0aGlzLl91cGRhdGVEaXN0YW5jZSwgdGhpcylcbiAgICAgICAgICAgIC5yZW1vdmVMYXllcih0aGlzLl9sYXllcnNDb250YWluZXIpO1xuXG4gICAgICAgIHRoaXMuX2xheWVycy5tb3VzZS5vZmYodGhpcy5fbGluZU1vdXNlRXZlbnRzLCB0aGlzKTtcbiAgICAgICAgdGhpcy5fcmVzZXQoKTtcbiAgICB9LFxuXG4gICAgZ2V0VG90YWxEaXN0YW5jZTogZnVuY3Rpb24gKCkgeyAvLyAoKSAtPiBOdW1iZXJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhbGNEaXN0YW5jZSgpO1xuICAgIH0sXG5cbiAgICBzcGxpY2VMYXRMbmdzOiBmdW5jdGlvbiAoaW5kZXgpIHsgLy8gKE51bWJlciwgTnVtYmVyLCBhcmdzIC4uLikgLT4gQXJyYXlcbiAgICAgICAgdmFyIG9sZExlbmd0aCA9IHRoaXMuX3BvaW50cy5sZW5ndGgsXG4gICAgICAgICAgICBtdXRhdGlvblN0YXJ0ID0gaW5kZXggPj0gMCA/IE1hdGgubWluKGluZGV4LCBvbGRMZW5ndGgpIDogb2xkTGVuZ3RoIC0gaW5kZXgsXG4gICAgICAgICAgICByZW1vdmVkID0gQXJyYXkucHJvdG90eXBlLnNwbGljZS5hcHBseSh0aGlzLl9wb2ludHMsIGFyZ3VtZW50cykubWFwKGZ1bmN0aW9uIChwb2ludCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xheWVycy5tb3VzZS5yZW1vdmVMYXllcihwb2ludCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvaW50Lm9mZigpLmdldExhdExuZygpO1xuICAgICAgICAgICAgfSwgdGhpcyksXG4gICAgICAgICAgICBsZW5ndGggPSB0aGlzLl9wb2ludHMubGVuZ3RoO1xuXG4gICAgICAgIGlmIChsZW5ndGgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBtdXRhdGlvblN0YXJ0OyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoISh0aGlzLl9wb2ludHNbaV0gaW5zdGFuY2VvZiBERy5SdWxlci5MYXllcmVkTWFya2VyKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wb2ludHNbaV0gPSB0aGlzLl9jcmVhdGVQb2ludCh0aGlzLl9wb2ludHNbaV0sIHRoaXMub3B0aW9ucy5pY29uU3R5bGVzLmxhcmdlKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm9uKHRoaXMuX3BvaW50RXZlbnRzLCB0aGlzKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm9uY2UoJ2FkZCcsIHRoaXMuX2FkZENsb3NlSGFuZGxlciwgdGhpcylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hZGRUbyh0aGlzLl9sYXllcnMubW91c2UsIHRoaXMuX2xheWVycyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpICYmICF0aGlzLl9wb2ludHNbaSAtIDFdLl9sZWdzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZExlZ3ModGhpcy5fcG9pbnRzW2kgLSAxXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX3BvaW50c1tpXS5zZXRQb2ludFN0eWxlKHRoaXMub3B0aW9ucy5pY29uU3R5bGVzW2kgJiYgaSA8IGxlbmd0aCAtIDEgPyAnc21hbGwnIDogJ2xhcmdlJ10pO1xuICAgICAgICAgICAgICAgIHRoaXMuX3BvaW50c1tpXS5fcG9zID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZUxlZ3ModGhpcy5fcG9pbnRzW2xlbmd0aCAtIDFdKTtcbiAgICAgICAgICAgIGlmIChvbGRMZW5ndGggPiAwICYmIG9sZExlbmd0aCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BvaW50c1tvbGRMZW5ndGggLSAxXS5jb2xsYXBzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX3BvaW50c1ttdXRhdGlvblN0YXJ0XSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUxlZ3ModGhpcy5fcG9pbnRzW211dGF0aW9uU3RhcnRdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtdXRhdGlvblN0YXJ0ID4gMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BvaW50c1ttdXRhdGlvblN0YXJ0IC0gMV0uc2V0UG9pbnRTdHlsZSh0aGlzLm9wdGlvbnMuaWNvblN0eWxlcy5zbWFsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVEaXN0YW5jZSgpO1xuICAgICAgICAgICAgdGhpcy5fbm9ybWFsaXplUnVsZXJQb2ludHMoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoREcuQnJvd3Nlci50b3VjaCAmJiB0aGlzLl9saW5lTWFya2VySGVscGVyKSB7XG4gICAgICAgICAgICB0aGlzLl9saW5lTWFya2VySGVscGVyLmNvbGxhcHNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZmlyZUNoYW5nZUV2ZW50KCk7XG4gICAgICAgIHJldHVybiByZW1vdmVkO1xuICAgIH0sXG5cbiAgICBhZGRMYXRMbmc6IGZ1bmN0aW9uIChsYXRsbmcpIHsgLy8gKExhdExuZykgLT4gUnVsZXJcbiAgICAgICAgdmFyIGxhc3RQb2ludCA9IHRoaXMuX3BvaW50c1t0aGlzLl9wb2ludHMubGVuZ3RoIC0gMV0gfHwgbnVsbDtcbiAgICAgICAgbGF0bG5nID0gREcubGF0TG5nKGxhdGxuZyk7XG5cbiAgICAgICAgaWYgKGxhc3RQb2ludCkge1xuICAgICAgICAgICAgbGF0bG5nID0gdGhpcy5fbm9ybWFsaXplTGF0TG5nKGxhdGxuZywgbGFzdFBvaW50LmdldExhdExuZygpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc3BsaWNlTGF0TG5ncyh0aGlzLl9wb2ludHMubGVuZ3RoLCAwLCBsYXRsbmcpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgZ2V0TGF0TG5nczogZnVuY3Rpb24gKCkgeyAvLyAoKSAtPiBBcnJheVxuICAgICAgICByZXR1cm4gdGhpcy5fcG9pbnRzLm1hcChmdW5jdGlvbiAocG9pbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBwb2ludC5nZXRMYXRMbmcoKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIHNldExhdExuZ3M6IGZ1bmN0aW9uIChsYXRsbmdzKSB7IC8vIChBcnJheSkgLT4gUnVsZXJcbiAgICAgICAgdmFyIGFyZ3MgPSBsYXRsbmdzLnNsaWNlKCk7XG4gICAgICAgIGFyZ3MudW5zaGlmdCgwLCB0aGlzLl9wb2ludHMubGVuZ3RoKTtcbiAgICAgICAgdGhpcy5zcGxpY2VMYXRMbmdzLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgX3Jlc2V0OiBmdW5jdGlvbiAoKSB7IC8vICgpXG4gICAgICAgIERHLmV4dGVuZCh0aGlzLCB7XG4gICAgICAgICAgICBfbGluZU1hcmtlckhlbHBlcjogbnVsbCxcbiAgICAgICAgICAgIF9tb3JwaGluZ05vdzogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIF9saW5lTW91c2VFdmVudHM6IHtcbiAgICAgICAgY2xpY2s6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgdmFyIHRhcmdldCA9IGV2ZW50LmxheWVyO1xuICAgICAgICAgICAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIERHLk1hcmtlciAmJiB0YXJnZXQuX3BvcyAhPT0gdGhpcy5fcG9pbnRzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fbGluZU1hcmtlckhlbHBlcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9saW5lTWFya2VySGVscGVyLmNvbGxhcHNlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRhcmdldC5zZXRUZXh0KHRoaXMuX2dldEZvcm1hdGVkRGlzdGFuY2UodGFyZ2V0KSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGluZU1hcmtlckhlbHBlciA9IHRhcmdldDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGFyZ2V0IGluc3RhbmNlb2YgREcuUGF0aCAmJiB0aGlzLm9wdGlvbnMuZWRpdGFibGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGF0bG5nID0gZXZlbnQubGF0bG5nLFxuICAgICAgICAgICAgICAgICAgICBpbnNlcnRQb3MgPSB0YXJnZXQuX3BvaW50Ll9wb3MgKyAxO1xuICAgICAgICAgICAgICAgIHRoaXMuc3BsaWNlTGF0TG5ncyhpbnNlcnRQb3MsIDAsIGxhdGxuZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG1vdXNlb3ZlcjogZnVuY3Rpb24gKGV2ZW50KSB7IC8vIChNb3VzZUV2ZW50KVxuICAgICAgICAgICAgdmFyIHRhcmdldCA9IGV2ZW50LmxheWVyO1xuXG4gICAgICAgICAgICB0YXJnZXQuX2hvdmVyZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHRoaXMuX21vcnBoaW5nTm93KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIERHLk1hcmtlciAmJiB0YXJnZXQuX3BvcyAhPT0gdGhpcy5fcG9pbnRzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQuc2V0VGV4dCh0aGlzLl9nZXRGb3JtYXRlZERpc3RhbmNlKHRhcmdldCkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBERy5QYXRoICYmICF0aGlzLl9saW5lTWFya2VySGVscGVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBvaW50ID0gdGFyZ2V0Ll9wb2ludDtcblxuICAgICAgICAgICAgICAgIHRoaXMuX2xpbmVNYXJrZXJIZWxwZXIgPSB0aGlzLl9hZGRSdW5uaW5nTGFiZWwoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX25lYXJlc3RQb2ludChwb2ludC5fbGVncy5taWRkbGUsIGV2ZW50LmxhdGxuZyksXG4gICAgICAgICAgICAgICAgICAgIHBvaW50XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbW91c2VvdXQ6IGZ1bmN0aW9uIChldmVudCkgeyAvLyAoTW91c2VFdmVudClcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSBldmVudC5sYXllcixcbiAgICAgICAgICAgICAgICBvcmlnaW5hbEV2ID0gZXZlbnQub3JpZ2luYWxFdmVudDtcblxuICAgICAgICAgICAgdGFyZ2V0Ll9ob3ZlcmVkID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAodGhpcy5fbW9ycGhpbmdOb3cgfHwgdGFyZ2V0Ll9wb3MgPT09IHRoaXMuX3BvaW50cy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIERHLk1hcmtlcikge1xuICAgICAgICAgICAgICAgIC8vIGNvbGxhcHNlIG9ubHkgd2hlbiB3ZSBtb3ZlIG91dCBmcm9tIGxhYmVsIGNvbnRhaW5lciAoaWYgYnJvd3NlciBzdXBwb3J0IHJlbGF0ZWRUYXJnZXQpXG4gICAgICAgICAgICAgICAgaWYgKCFvcmlnaW5hbEV2LnJlbGF0ZWRUYXJnZXQgfHxcbiAgICAgICAgICAgICAgICAgICAgKG9yaWdpbmFsRXYucmVsYXRlZFRhcmdldCAhPT0gdGFyZ2V0LnF1ZXJ5U2VsZWN0b3IoJ2NvbnRhaW5lcicpICYmXG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsRXYucmVsYXRlZFRhcmdldC5wYXJlbnROb2RlICE9PSB0YXJnZXQucXVlcnlTZWxlY3RvcignY29udGFpbmVyJykpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5jb2xsYXBzZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZlUnVubmluZ0xhYmVsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG1vdXNlbW92ZTogZnVuY3Rpb24gKGV2ZW50KSB7IC8vIChNb3VzZUV2ZW50KVxuICAgICAgICAgICAgaWYgKHRoaXMuX21vcnBoaW5nTm93IHx8ICF0aGlzLl9saW5lTWFya2VySGVscGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcG9pbnQgPSBldmVudC5sYXllci5fcG9pbnQsXG4gICAgICAgICAgICAgICAgbGF0bG5nID0gdGhpcy5fbmVhcmVzdFBvaW50KHBvaW50Ll9sZWdzLm1pZGRsZSwgZXZlbnQubGF0bG5nKTtcblxuICAgICAgICAgICAgdGhpcy5fbGluZU1hcmtlckhlbHBlclxuICAgICAgICAgICAgICAgICAgICAuc2V0TGF0TG5nKGxhdGxuZylcbiAgICAgICAgICAgICAgICAgICAgLnNldFRleHQodGhpcy5fZ2V0Rm9ybWF0ZWREaXN0YW5jZShwb2ludCwgcG9pbnQuZ2V0TGF0TG5nKCkuZGlzdGFuY2VUbyhsYXRsbmcpKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGxheWVyYWRkOiBmdW5jdGlvbiAoKSB7IC8vICgpXG4gICAgICAgICAgICBPYmplY3Qua2V5cyh0aGlzLl9sYXllcnMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sYXllcnNbbmFtZV0uYnJpbmdUb0Zyb250KCk7XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfZmlyZUNoYW5nZUV2ZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZmlyZSgnY2hhbmdlZCcsIHtsYXRsbmdzIDogdGhpcy5nZXRMYXRMbmdzKCl9KTtcbiAgICB9LFxuXG4gICAgX2FkZFJ1bm5pbmdMYWJlbDogZnVuY3Rpb24gKGxhdGxuZywgcHJldmlvdXNQb2ludCkgeyAvLyAoTGF0TG5nLCBSdWxlci5MYXllcmVkTWFya2VyKVxuICAgICAgICB2YXIgcG9pbnQgPSB0aGlzLl9jcmVhdGVQb2ludChsYXRsbmcpLmFkZFRvKHRoaXMuX2xheWVycy5tb3VzZSwgdGhpcy5fbGF5ZXJzKTtcbiAgICAgICAgdGhpcy5fbWFwLmdldFBhbmUoJ3J1bGVyTGFiZWxQYW5lJykuYXBwZW5kQ2hpbGQocG9pbnQuX2ljb24pO1xuICAgICAgICByZXR1cm4gcG9pbnQuc2V0VGV4dCh0aGlzLl9nZXRGb3JtYXRlZERpc3RhbmNlKHByZXZpb3VzUG9pbnQsIHByZXZpb3VzUG9pbnQuZ2V0TGF0TG5nKCkuZGlzdGFuY2VUbyhsYXRsbmcpKSk7XG4gICAgfSxcblxuICAgIF9yZW1vdmVSdW5uaW5nTGFiZWw6IGZ1bmN0aW9uICgpIHsgLy8gKClcbiAgICAgICAgaWYgKHRoaXMuX2xpbmVNYXJrZXJIZWxwZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2xheWVycy5tb3VzZS5yZW1vdmVMYXllcih0aGlzLl9saW5lTWFya2VySGVscGVyKTtcbiAgICAgICAgICAgIHRoaXMuX2xpbmVNYXJrZXJIZWxwZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9pbnNlcnRQb2ludEluTGluZTogZnVuY3Rpb24gKGV2ZW50KSB7IC8vIChNb3VzZUV2ZW50KVxuICAgICAgICB2YXIgbGF0bG5nID0gdGhpcy5fbGluZU1hcmtlckhlbHBlci5nZXRMYXRMbmcoKSxcbiAgICAgICAgICAgIGluc2VydFBvcyA9IGV2ZW50LnRhcmdldC5fcG9pbnQuX3BvcyArIDEsXG4gICAgICAgICAgICBwb2ludDtcblxuICAgICAgICBpZiAoTC5Ccm93c2VyLmllKSB7XG4gICAgICAgICAgICB2YXIgcGF0aCA9IGV2ZW50Lm9yaWdpbmFsRXZlbnQudGFyZ2V0IHx8IGV2ZW50Lm9yaWdpbmFsRXZlbnQuc3JjRWxlbWVudCxcbiAgICAgICAgICAgICAgICBwYXJlbnQgPSBwYXRoLnBhcmVudE5vZGU7XG4gICAgICAgICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQocGF0aCk7IC8vIElFIGNsaWNrIGV2ZW50IGxlYWtpbmcgcHJvYmxlbSBzb2x1dGlvbjogd2UgcmVhcHBlbmQgbW91c2Vkb3duIGV2ZW50IHRhcmdldCBlbGVtZW50XG4gICAgICAgIH1cblxuICAgICAgICBMLkRvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbihldmVudC5vcmlnaW5hbEV2ZW50KTtcblxuICAgICAgICB0aGlzLnNwbGljZUxhdExuZ3MoaW5zZXJ0UG9zLCAwLCBsYXRsbmcpO1xuICAgICAgICBwb2ludCA9IHRoaXMuX3BvaW50c1tpbnNlcnRQb3NdO1xuICAgICAgICBwb2ludC5zZXRUZXh0KHRoaXMuX2dldEZvcm1hdGVkRGlzdGFuY2UocG9pbnQpKTtcblxuICAgICAgICBpZiAoZG9jdW1lbnQuY3JlYXRlRXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ01vdXNlRXZlbnRzJyk7XG4gICAgICAgICAgICBlLmluaXRNb3VzZUV2ZW50KCdtb3VzZWRvd24nLCBmYWxzZSwgZmFsc2UsIGRvY3VtZW50LmRlZmF1bHRWaWV3LCAxLCAwLCAwLCAwLCAwLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgMSwgcG9pbnQuX2ljb24pO1xuICAgICAgICAgICAgcG9pbnQuX2ljb24uZGlzcGF0Y2hFdmVudChlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBvaW50Ll9pY29uLmZpcmVFdmVudCgnb25Nb3VzZURvd24nLCBERy5leHRlbmQoZG9jdW1lbnQuY3JlYXRlRXZlbnRPYmplY3QoKSwge1xuICAgICAgICAgICAgICAgIGJ1dHRvbjogMSxcbiAgICAgICAgICAgICAgICBidWJibGVzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjYW5jZWxhYmxlOiBmYWxzZVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3JlbW92ZVJ1bm5pbmdMYWJlbCgpO1xuXG4gICAgICAgIHRoaXMuX3VwZGF0ZUxlZ3MocG9pbnQpO1xuICAgIH0sXG5cbiAgICAvLyBGaW5kIHRoZSBwb2ludCBvbiBnaXZlbiBwb2x5bGluZSB3aGljaCBpcyBjbG9zZXN0IHRvIGdpdmVuIGxhdGxuZ1xuICAgIF9uZWFyZXN0UG9pbnQ6IGZ1bmN0aW9uIChwb2x5bGluZSwgbGF0bG5nKSB7IC8vIChQb2x5bGluZSwgTGF0TG5nKSAtPiBMYXRMbmdcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIC8vIENvbnZlcnQgZXZlcnl0aGluZyB0byBwaXhlbCBjb29yZGluYXRlc1xuICAgICAgICB2YXIgcG9pbnQgPSB0aGlzLl9wcm9qZWN0KGxhdGxuZyk7XG4gICAgICAgIHZhciBsaW5lUG9pbnRzID0gcG9seWxpbmUuZ2V0TGF0TG5ncygpLm1hcChmdW5jdGlvbiAobGF0bG5nKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5fcHJvamVjdChsYXRsbmcpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBGaXJzdCBsb29rIGZvciBjbG9zZXN0IHBvbHlsaW5lIHNlZ21lbnRcbiAgICAgICAgdmFyIG1pbkRpc3RhbmNlO1xuICAgICAgICB2YXIgY2xvc2VzdFNlZ21lbnRJbmRleDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lUG9pbnRzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgdmFyIGRpc3RhbmNlID0gREcuTGluZVV0aWwucG9pbnRUb1NlZ21lbnREaXN0YW5jZShcbiAgICAgICAgICAgICAgICBwb2ludCxcbiAgICAgICAgICAgICAgICBsaW5lUG9pbnRzW2ldLFxuICAgICAgICAgICAgICAgIGxpbmVQb2ludHNbaSArIDFdXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBpZiAobWluRGlzdGFuY2UgPT09IHVuZGVmaW5lZCB8fCBkaXN0YW5jZSA8IG1pbkRpc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgbWluRGlzdGFuY2UgPSBkaXN0YW5jZTtcbiAgICAgICAgICAgICAgICBjbG9zZXN0U2VnbWVudEluZGV4ID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZW4gbG9vayBmb3IgY2xvc2VzdCBwb2ludCBvbiB0aGF0IHNlZ21lbnRcbiAgICAgICAgdmFyIGNsb3Nlc3RQb2ludCA9IERHLkxpbmVVdGlsLmNsb3Nlc3RQb2ludE9uU2VnbWVudChcbiAgICAgICAgICAgIHBvaW50LFxuICAgICAgICAgICAgbGluZVBvaW50c1tjbG9zZXN0U2VnbWVudEluZGV4XSxcbiAgICAgICAgICAgIGxpbmVQb2ludHNbY2xvc2VzdFNlZ21lbnRJbmRleCArIDFdXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gQ29udmVydCBiYWNrIHRvIExhdExuZ1xuICAgICAgICByZXR1cm4gdGhpcy5fdW5wcm9qZWN0KGNsb3Nlc3RQb2ludCk7XG4gICAgfSxcblxuICAgIF9hZGRDbG9zZUhhbmRsZXI6IGZ1bmN0aW9uIChldmVudCkgeyAvLyAoRXZlbnQpXG4gICAgICAgIGV2ZW50LnRhcmdldFxuICAgICAgICAgICAgICAgIC5vbignY2xpY2snLCB0aGlzLl9kZWxldGVQb2ludCwgdGhpcylcbiAgICAgICAgICAgICAgICAucXVlcnlTZWxlY3RvcigncmVtb3ZlLWxpbmsnKS5zdHlsZS5kaXNwbGF5ID0gJ2lubGluZS1ibG9jayc7XG4gICAgfSxcblxuICAgIF9jcmVhdGVQb2ludDogZnVuY3Rpb24gKGxhdGxuZywgc3R5bGUpIHsgLy8gKExhdExuZywgT2JqZWN0KSAtPiBSdWxlci5MYXllcmVkTWFya2VyXG4gICAgICAgIHZhciBwb2ludFN0eWxlID0gc3R5bGUgPyBzdHlsZSA6IHRoaXMub3B0aW9ucy5pY29uU3R5bGVzLmxhcmdlLFxuICAgICAgICAgICAgbGF5ZXJzID0ge307XG4gICAgICAgIE9iamVjdC5rZXlzKHBvaW50U3R5bGUpLmZvckVhY2goZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgICAgICAgICBsYXllcnNbbGF5ZXJdID0gREcuY2lyY2xlTWFya2VyKGxhdGxuZywgcG9pbnRTdHlsZVtsYXllcl0pO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gREcuUnVsZXIubGF5ZXJlZE1hcmtlcihsYXRsbmcsIHtcbiAgICAgICAgICAgIGxheWVycyA6IGxheWVycyxcbiAgICAgICAgICAgIGRyYWdnYWJsZSA6IHRoaXMub3B0aW9ucy5lZGl0YWJsZVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLy8gTW92ZXMgY3VyciBMYXRMbmcgdG8gY29ycmVjdCB3b3JsZCBpZiBuZWNlc3Nhcnkgc28gdGhhdCBydWxlciBzZWN0aW9uXG4gICAgLy8gYmV0d2VlbiBjdXJyIGFuZCBiYXNlIGNhbiBiZSBwbG90dGVkIGNvcnJlY3RseS4gUmV0dXJucyBhIG5ldyBMYXRMbmdcbiAgICAvLyBvYmplY3QuXG4gICAgX25vcm1hbGl6ZUxhdExuZzogZnVuY3Rpb24gKGN1cnIsIGJhc2UpIHsgLy8gKExhdExuZywgTGF0TG5nKSAtPiBMYXRMbmdcbiAgICAgICAgdmFyIGRpZmYgPSAoY3Vyci5sbmcgPCBiYXNlLmxuZykgPyAzNjAgOiAtMzYwO1xuXG4gICAgICAgIHZhciBuZXdMbmcgPSBjdXJyLmxuZztcbiAgICAgICAgd2hpbGUgKE1hdGguYWJzKG5ld0xuZyAtIGJhc2UubG5nKSA+IDE4MCkge1xuICAgICAgICAgICAgbmV3TG5nICs9IGRpZmY7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gREcubGF0TG5nKGN1cnIubGF0LCBuZXdMbmcpO1xuICAgIH0sXG5cbiAgICAvLyBSZWFycmFuZ2VzIHJ1bGVyIHBvaW50cyBiZXR3ZWVuIHdvcmxkcyBiYXNlZCBvbiBwb2ludCBwYXJhbSBzbyB0aGF0IGFsbFxuICAgIC8vIHJ1bGVyIHNlY3Rpb25zIGNhbiBiZSBwbG90dGVkIGNvcnJlY3RseS5cbiAgICBfbm9ybWFsaXplUnVsZXJQb2ludHM6IGZ1bmN0aW9uIChwb2ludCkgeyAvLyAoUnVsZXIuTGF5ZXJlZE1hcmtlcilcbiAgICAgICAgcG9pbnQgPSBwb2ludCB8fCB0aGlzLl9wb2ludHNbMF07XG5cbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgcG9zaXRpb24gPSBwb2ludC5fcG9zO1xuICAgICAgICB2YXIgY2hhbmdlZFBvaW50cyA9IFtdO1xuICAgICAgICB2YXIgaSwgY3VyclBvaW50LCBwcmV2UG9pbnQsIGxhdGxuZywgbm9ybWFsaXplZDtcblxuICAgICAgICAvLyBDaGVjayBwb2ludHMgdG8gdGhlIHJpZ2h0XG4gICAgICAgIGZvciAoaSA9IHBvc2l0aW9uICsgMTsgaSA8IHRoaXMuX3BvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY3VyclBvaW50ID0gdGhpcy5fcG9pbnRzW2ldO1xuICAgICAgICAgICAgcHJldlBvaW50ID0gdGhpcy5fcG9pbnRzW2kgLSAxXTtcblxuICAgICAgICAgICAgbGF0bG5nID0gY3VyclBvaW50LmdldExhdExuZygpO1xuICAgICAgICAgICAgbm9ybWFsaXplZCA9IHRoaXMuX25vcm1hbGl6ZUxhdExuZyhsYXRsbmcsIHByZXZQb2ludC5nZXRMYXRMbmcoKSk7XG5cbiAgICAgICAgICAgIGlmICghbm9ybWFsaXplZC5lcXVhbHMobGF0bG5nKSkge1xuICAgICAgICAgICAgICAgIGN1cnJQb2ludC5zZXRMYXRMbmcobm9ybWFsaXplZCk7XG4gICAgICAgICAgICAgICAgY2hhbmdlZFBvaW50cy5wdXNoKGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgcG9pbnRzIHRvIHRoZSBsZWZ0XG4gICAgICAgIGZvciAoaSA9IHBvc2l0aW9uIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGN1cnJQb2ludCA9IHRoaXMuX3BvaW50c1tpXTtcbiAgICAgICAgICAgIHByZXZQb2ludCA9IHRoaXMuX3BvaW50c1tpICsgMV07XG5cbiAgICAgICAgICAgIGxhdGxuZyA9IGN1cnJQb2ludC5nZXRMYXRMbmcoKTtcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQgPSB0aGlzLl9ub3JtYWxpemVMYXRMbmcobGF0bG5nLCBwcmV2UG9pbnQuZ2V0TGF0TG5nKCkpO1xuXG4gICAgICAgICAgICBpZiAoIW5vcm1hbGl6ZWQuZXF1YWxzKGxhdGxuZykpIHtcbiAgICAgICAgICAgICAgICBjdXJyUG9pbnQuc2V0TGF0TG5nKG5vcm1hbGl6ZWQpO1xuICAgICAgICAgICAgICAgIGNoYW5nZWRQb2ludHMucHVzaChpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVwZGF0ZSBsZWdzIG9mIGFsbCBwb2ludHMgdGhhdCBjaGFuZ2VkIHBvc2l0aW9uXG4gICAgICAgIGNoYW5nZWRQb2ludHMuc29ydCgpLnJlZHVjZShmdW5jdGlvbiAocHJldmlvdXMsIGN1cnJlbnQpIHtcbiAgICAgICAgICAgIHZhciBza2lwUHJldmlvdXMgPSBwcmV2aW91cyAmJiBwcmV2aW91cyA9PT0gY3VycmVudCAtIDE7XG5cbiAgICAgICAgICAgIHNlbGYuX3VwZGF0ZUxlZ3Moc2VsZi5fcG9pbnRzW2N1cnJlbnRdLCBza2lwUHJldmlvdXMpO1xuXG4gICAgICAgICAgICByZXR1cm4gY3VycmVudDtcbiAgICAgICAgfSwgbnVsbCk7XG4gICAgfSxcblxuICAgIF9wb2ludEV2ZW50czoge1xuICAgICAgICBkcmFnOiBmdW5jdGlvbiAoZXZlbnQpIHsgLy8gKEV2ZW50KVxuICAgICAgICAgICAgdmFyIHBvaW50ID0gZXZlbnQudGFyZ2V0O1xuXG4gICAgICAgICAgICB0aGlzLl9ub3JtYWxpemVSdWxlclBvaW50cyhwb2ludCk7XG5cbiAgICAgICAgICAgIGlmICghREcuQnJvd3Nlci50b3VjaCAmJiBwb2ludCAhPT0gdGhpcy5fcG9pbnRzW3RoaXMuX3BvaW50cy5sZW5ndGggLSAxXSkge1xuICAgICAgICAgICAgICAgIHBvaW50LnNldFRleHQodGhpcy5fZ2V0Rm9ybWF0ZWREaXN0YW5jZShwb2ludCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl91cGRhdGVMZWdzKHBvaW50KTtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZURpc3RhbmNlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGRyYWdlbmQ6IGZ1bmN0aW9uIChldmVudCkgeyAvLyAoRXZlbnQpXG4gICAgICAgICAgICB2YXIgcG9pbnQgPSBldmVudC50YXJnZXQ7XG4gICAgICAgICAgICB0aGlzLl9tb3JwaGluZ05vdyA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKCFwb2ludC5faG92ZXJlZCAmJiBwb2ludCAhPT0gdGhpcy5fcG9pbnRzW3RoaXMuX3BvaW50cy5sZW5ndGggLSAxXSkge1xuICAgICAgICAgICAgICAgIHBvaW50LmNvbGxhcHNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9maXJlQ2hhbmdlRXZlbnQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZHJhZ3N0YXJ0OiBmdW5jdGlvbiAoKSB7IC8vICgpXG4gICAgICAgICAgICBpZiAoREcuQnJvd3Nlci50b3VjaCAmJiB0aGlzLl9saW5lTWFya2VySGVscGVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGluZU1hcmtlckhlbHBlci5jb2xsYXBzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fbW9ycGhpbmdOb3cgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9kZWxldGVQb2ludDogZnVuY3Rpb24gKGV2ZW50KSB7IC8vIChNb3VzZUV2ZW50KVxuICAgICAgICB2YXIgb3JpZ2luYWxFdmVudCA9IGV2ZW50Lm9yaWdpbmFsRXZlbnQsXG4gICAgICAgICAgICB0YXJnZXQgPSBvcmlnaW5hbEV2ZW50LnRhcmdldCAgfHwgb3JpZ2luYWxFdmVudC5zcmNFbGVtZW50O1xuXG4gICAgICAgIGlmICh0YXJnZXQuY2xhc3NOYW1lICE9PSAnZGctcnVsZXJfX2xhYmVsLXJlbW92ZS1saW5rJyAmJlxuICAgICAgICAgICAgdGFyZ2V0LmNsYXNzTmFtZSAhPT0gJ2RnLXJ1bGVyX19yZW1vdmUtbGluay1vdmVybGF5Jykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIERHLkRvbUV2ZW50LnN0b3AoZXZlbnQub3JpZ2luYWxFdmVudCk7XG4gICAgICAgIHRoaXMuc3BsaWNlTGF0TG5ncyhldmVudC50YXJnZXQuX3BvcywgMSk7XG4gICAgfSxcblxuICAgIF9kZWdUb1JhZDogZnVuY3Rpb24gKGRlZykge1xuICAgICAgICByZXR1cm4gKE1hdGguUEkgLyAxODApICogZGVnO1xuICAgIH0sXG5cbiAgICBfcmFkVG9EZWc6IGZ1bmN0aW9uIChyYWQpIHtcbiAgICAgICAgcmV0dXJuICgxODAgLyBNYXRoLlBJKSAqIHJhZDtcbiAgICB9LFxuXG4gICAgLy8gTWFwLWluZGVwZW5kZW50IHByb2plY3QgbWV0aG9kXG4gICAgX3Byb2plY3Q6IGZ1bmN0aW9uIChsYXRsbmcpIHtcbiAgICAgICAgaWYgKHRoaXMuX21hcCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21hcC5wcm9qZWN0KGxhdGxuZyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gREcuQ1JTLkVQU0czODU3LmxhdExuZ1RvUG9pbnQobGF0bG5nLCAxKTtcbiAgICB9LFxuXG4gICAgLy8gTWFwLWluZGVwZW5kZW50IHVucHJvamVjdCBtZXRob2RcbiAgICBfdW5wcm9qZWN0OiBmdW5jdGlvbiAocG9pbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuX21hcCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21hcC51bnByb2plY3QocG9pbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIERHLkNSUy5FUFNHMzg1Ny5wb2ludFRvTGF0TG5nKHBvaW50LCAxKTtcbiAgICB9LFxuXG4gICAgLy8gQ2FsY3VsYXRlcyB0aGUgc2l6ZSBvZiBhbmdsZSBwb2ludDEtcG9pbnQtcG9pbnQyXG4gICAgX2NhbGNBbmdsZTogZnVuY3Rpb24gKHBvaW50LCBwb2ludDEsIHBvaW50MikgeyAvLyAoTGF0TG5nLCBMYXRMbmcsIExhdExuZykgLT4gTnVtYmVyXG4gICAgICAgIHBvaW50MSA9IHRoaXMuX25vcm1hbGl6ZUxhdExuZyhwb2ludDEsIHBvaW50KTtcbiAgICAgICAgcG9pbnQyID0gdGhpcy5fbm9ybWFsaXplTGF0TG5nKHBvaW50MiwgcG9pbnQpO1xuXG4gICAgICAgIHBvaW50ID0gdGhpcy5fcHJvamVjdChwb2ludCk7XG4gICAgICAgIHBvaW50MSA9IHRoaXMuX3Byb2plY3QocG9pbnQxKTtcbiAgICAgICAgcG9pbnQyID0gdGhpcy5fcHJvamVjdChwb2ludDIpO1xuXG4gICAgICAgIHZhciB4MSA9IHBvaW50MS54IC0gcG9pbnQueDtcbiAgICAgICAgdmFyIHgyID0gcG9pbnQyLnggLSBwb2ludC54O1xuICAgICAgICB2YXIgeTEgPSBwb2ludDEueSAtIHBvaW50Lnk7XG4gICAgICAgIHZhciB5MiA9IHBvaW50Mi55IC0gcG9pbnQueTtcblxuICAgICAgICB2YXIgZG90UHJvZHVjdCA9IHgxICogeDIgKyB5MSAqIHkyO1xuICAgICAgICB2YXIgbWFnMSA9IE1hdGguc3FydCh4MSAqIHgxICsgeTEgKiB5MSk7XG4gICAgICAgIHZhciBtYWcyID0gTWF0aC5zcXJ0KHgyICogeDIgKyB5MiAqIHkyKTtcblxuICAgICAgICByZXR1cm4gTWF0aC5hY29zKGRvdFByb2R1Y3QgLyAobWFnMSAqIG1hZzIpKTtcbiAgICB9LFxuXG4gICAgLy8gQ2FsY3VsYXRlcyB0aGUgbWlkcG9pbnQgb24gdGhlIGdyZWF0IGNpcmNsZSBiZXR3ZWVuIHR3byBMYXRMbmdzXG4gICAgX2NhbGNNaWRQb2ludDogZnVuY3Rpb24gKGxhdGxuZzEsIGxhdGxuZzIpIHsgLy8gKExhdExuZywgTGF0TG5nKSAtPiBMYXRMbmdcbiAgICAgICAgdmFyIGxvbjEgPSB0aGlzLl9kZWdUb1JhZChsYXRsbmcxLmxuZyk7XG4gICAgICAgIHZhciBsYXQxID0gdGhpcy5fZGVnVG9SYWQobGF0bG5nMS5sYXQpO1xuXG4gICAgICAgIHZhciBsb24yID0gdGhpcy5fZGVnVG9SYWQobGF0bG5nMi5sbmcpO1xuICAgICAgICB2YXIgbGF0MiA9IHRoaXMuX2RlZ1RvUmFkKGxhdGxuZzIubGF0KTtcblxuICAgICAgICAvLyBCYXNlZCBvbiBmb3JtdWxhZSBmcm9tXG4gICAgICAgIC8vIGh0dHA6Ly93aWxsaWFtcy5iZXN0LnZ3aC5uZXQvYXZmb3JtLmh0bSNJbnRlcm1lZGlhdGVcbiAgICAgICAgdmFyIGQgPSBNYXRoLmFjb3MoTWF0aC5zaW4obGF0MSkgKiBNYXRoLnNpbihsYXQyKSArXG4gICAgICAgICAgICBNYXRoLmNvcyhsYXQxKSAqIE1hdGguY29zKGxhdDIpICogTWF0aC5jb3MobG9uMSAtIGxvbjIpKTtcblxuICAgICAgICAvLyBTcGxpdCB0aGUgYXJjIGluIGhhbGZcbiAgICAgICAgdmFyIGYgPSAwLjU7XG5cbiAgICAgICAgdmFyIEEgPSBNYXRoLnNpbigoMSAtIGYpICogZCkgLyBNYXRoLnNpbihkKTtcbiAgICAgICAgdmFyIEIgPSBNYXRoLnNpbihmICogZCkgLyBNYXRoLnNpbihkKTtcblxuICAgICAgICB2YXIgeCA9IEEgKiBNYXRoLmNvcyhsYXQxKSAqIE1hdGguY29zKGxvbjEpICtcbiAgICAgICAgICAgIEIgKiBNYXRoLmNvcyhsYXQyKSAqIE1hdGguY29zKGxvbjIpO1xuXG4gICAgICAgIHZhciB5ID0gQSAqIE1hdGguY29zKGxhdDEpICogTWF0aC5zaW4obG9uMSkgK1xuICAgICAgICAgICAgQiAqIE1hdGguY29zKGxhdDIpICogTWF0aC5zaW4obG9uMik7XG5cbiAgICAgICAgdmFyIHogPSBBICogTWF0aC5zaW4obGF0MSkgKyBCICogTWF0aC5zaW4obGF0Mik7XG5cbiAgICAgICAgdmFyIGxhdCA9IE1hdGguYXRhbjIoeiwgTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpKTtcbiAgICAgICAgdmFyIGxvbiA9IE1hdGguYXRhbjIoeSwgeCk7XG5cbiAgICAgICAgcmV0dXJuIERHLmxhdExuZyh0aGlzLl9yYWRUb0RlZyhsYXQpLCB0aGlzLl9yYWRUb0RlZyhsb24pKTtcbiAgICB9LFxuXG4gICAgLy8gQWRhcHRpdmUgc2FtcGxpbmcgYWxnb3JpdGhtIGJhc2VkIG9uXG4gICAgLy8gaHR0cDovL2FyaWVsLmNocm9ub3RleHQub3JnL2RkL2RlZmlndWVpcmVkbzkzYWRhcHRpdmUucGRmXG4gICAgX2FkYXB0aXZlU2FtcGxlOiBmdW5jdGlvbiAobGVmdCwgcmlnaHQsIGRlcHRoLCBtaWRkbGUpIHsgLy8gKExhdExuZywgTGF0TG5nLCBOdW1iZXJbLCBMYXRMbmddKSAtPiBMYXRMbmdbXVxuICAgICAgICBpZiAoZGVwdGggPiA5KSB7XG4gICAgICAgICAgICAvLyBNYXggcmVjdXJzaW9uIGRlcHRoIHJlYWNoZWRcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1pZGRsZSA9IG1pZGRsZSB8fCB0aGlzLl9jYWxjTWlkUG9pbnQobGVmdCwgcmlnaHQpO1xuXG4gICAgICAgIHZhciBsZWZ0TWlkZGxlID0gdGhpcy5fY2FsY01pZFBvaW50KGxlZnQsIG1pZGRsZSk7XG4gICAgICAgIHZhciByaWdodE1pZGRsZSA9IHRoaXMuX2NhbGNNaWRQb2ludChtaWRkbGUsIHJpZ2h0KTtcblxuICAgICAgICB2YXIgYW5nbGUxID0gdGhpcy5fY2FsY0FuZ2xlKGxlZnRNaWRkbGUsIG1pZGRsZSwgbGVmdCk7XG4gICAgICAgIHZhciBhbmdsZTIgPSB0aGlzLl9jYWxjQW5nbGUobWlkZGxlLCBsZWZ0LCByaWdodCk7XG4gICAgICAgIHZhciBhbmdsZTMgPSB0aGlzLl9jYWxjQW5nbGUocmlnaHRNaWRkbGUsIG1pZGRsZSwgcmlnaHQpO1xuXG4gICAgICAgIC8vIGxlZnQgLS0tIGxlZnRNaWRkbGUgLS0tIG1pZGRsZSAtLS0gcmlnaHRNaWRkbGUgLS0tIHJpZ2h0XG4gICAgICAgIC8vICAgICAgICAgICAgYW5nbGUxICAgICAgIGFuZ2xlMiAgICAgICBhbmdsZTNcblxuICAgICAgICB2YXIgbWluQW5nbGUgPSAzLjE7XG4gICAgICAgIGlmIChhbmdsZTEgPiBtaW5BbmdsZSAmJiBhbmdsZTIgPiBtaW5BbmdsZSAmJiBhbmdsZTMgPiBtaW5BbmdsZSkge1xuICAgICAgICAgICAgLy8gVGhpcyBzZWN0aW9uIGlzIHN0cmFpZ2h0IGVub3VnaCwgbm8gaW50ZXJtZWRpYXRlIHBvaW50cyBuZWVkZWQuXG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBBbmdsZXMgYXJlIHRvbyBzbWFsbC4gUmVjdXJzaXZlbHkgc2FtcGxlIGhhbHZlcyBvZiB0aGlzIHNlY3Rpb24uXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuY29uY2F0KHRoaXMuX2FkYXB0aXZlU2FtcGxlKGxlZnQsIG1pZGRsZSwgZGVwdGggKyAxLCBsZWZ0TWlkZGxlKSk7XG4gICAgICAgICAgICByZXN1bHQucHVzaChtaWRkbGUpO1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdCh0aGlzLl9hZGFwdGl2ZVNhbXBsZShtaWRkbGUsIHJpZ2h0LCBkZXB0aCArIDEsIHJpZ2h0TWlkZGxlKSk7XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gQ2FsY3VsYXRlcyB0aGUgZ3JlYXQgY2lyY2xlIGFyYyBiZXR3ZWVuIHR3byBMYXRMbmdzLlxuICAgIF9jYWxjR3JlYXRDaXJjbGU6IGZ1bmN0aW9uIChsYXRsbmcxLCBsYXRsbmcyKSB7IC8vIChMYXRMbmcsIExhdExuZykgLT4gTGF0TG5nW11cbiAgICAgICAgbGF0bG5nMiA9IHRoaXMuX25vcm1hbGl6ZUxhdExuZyhsYXRsbmcyLCBsYXRsbmcxKTtcblxuICAgICAgICAvLyBTcGVjaWFsIGNhc2U6IHBvaW50cyBhcmUgY2xvc2UgdG8gZWFjaCBvdGhlciAod2l0aGluIDEgZGVncmVlKVxuICAgICAgICBpZiAobGF0bG5nMS5lcXVhbHMobGF0bG5nMiwgMSkpIHtcbiAgICAgICAgICAgIHJldHVybiBbbGF0bG5nMSwgbGF0bG5nMl07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTcGVjaWFsIGNhc2U6IHRoZSBncmVhdCBjaXJjbGUgY3Jvc3NlcyBhIHBvbGVcbiAgICAgICAgaWYgKE1hdGguYWJzKGxhdGxuZzIubG5nIC0gbGF0bG5nMS5sbmcpID09IDE4MCkge1xuICAgICAgICAgICAgLy8gTm9ydGggb3Igc291dGggcG9sZT9cbiAgICAgICAgICAgIHZhciBsYXRpdHVkZSA9IChsYXRsbmcxLmxhdCArIGxhdGxuZzIubGF0ID4gMCkgPyA5MCA6IC05MDtcblxuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBsYXRsbmcxLFxuICAgICAgICAgICAgICAgIERHLmxhdExuZyhsYXRpdHVkZSwgbGF0bG5nMS5sbmcpLFxuICAgICAgICAgICAgICAgIERHLmxhdExuZyhsYXRpdHVkZSwgbGF0bG5nMi5sbmcpLFxuICAgICAgICAgICAgICAgIGxhdGxuZzJcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgICAgcmVzdWx0LnB1c2gobGF0bG5nMSk7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQodGhpcy5fYWRhcHRpdmVTYW1wbGUobGF0bG5nMSwgbGF0bG5nMiwgMCkpO1xuICAgICAgICByZXN1bHQucHVzaChsYXRsbmcyKTtcblxuICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIGFyYyBkb2Vzbid0IGp1bXAgYmV0d2VlbiB3b3JsZHNcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCByZXN1bHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdFtpXSA9IHRoaXMuX25vcm1hbGl6ZUxhdExuZyhyZXN1bHRbaV0sIHJlc3VsdFtpIC0gMV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgX2FkZExlZ3M6IGZ1bmN0aW9uIChwb2ludCkge1xuICAgICAgICB2YXIgcGF0aFN0eWxlcyA9IHRoaXMub3B0aW9ucy5wYXRoU3R5bGVzO1xuXG4gICAgICAgIHZhciBncmVhdENpcmNsZVBvaW50cyA9IHRoaXMuX2NhbGNHcmVhdENpcmNsZShcbiAgICAgICAgICAgIHBvaW50LmdldExhdExuZygpLFxuICAgICAgICAgICAgdGhpcy5fcG9pbnRzW3BvaW50Ll9wb3MgKyAxXS5nZXRMYXRMbmcoKVxuICAgICAgICApO1xuXG4gICAgICAgIHBvaW50Ll9sZWdzID0ge307XG4gICAgICAgIE9iamVjdC5rZXlzKHBhdGhTdHlsZXMpLmZvckVhY2goZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgICAgICAgICBwb2ludC5fbGVnc1tsYXllcl0gPSBERy5wb2x5bGluZShncmVhdENpcmNsZVBvaW50cywgcGF0aFN0eWxlc1tsYXllcl0pLmFkZFRvKHRoaXMuX2xheWVyc1tsYXllcl0pO1xuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICBwb2ludC5fbGVncy5tb3VzZS5fcG9pbnQgPSBwb2ludC5vbmNlKCdyZW1vdmUnLCB0aGlzLl9jbGVhclJlbW92aW5nUG9pbnRMZWdzLCB0aGlzKTtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmVkaXRhYmxlICYmICFERy5Ccm93c2VyLnRvdWNoKSB7XG4gICAgICAgICAgICBwb2ludC5fbGVncy5tb3VzZS5vbignbW91c2Vkb3duJywgdGhpcy5faW5zZXJ0UG9pbnRJbkxpbmUsIHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX21hcCkge1xuICAgICAgICAgICAgdGhpcy5fbGF5ZXJzLm1vdXNlLmFkZExheWVyKHBvaW50Ll9sZWdzLm1vdXNlKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfY2xlYXJSZW1vdmluZ1BvaW50TGVnczogZnVuY3Rpb24gKGV2ZW50KSB7IC8vIChFdmVudClcbiAgICAgICAgdGhpcy5fcmVtb3ZlTGVncyhldmVudC50YXJnZXQpO1xuICAgIH0sXG5cbiAgICBfcmVtb3ZlTGVnczogZnVuY3Rpb24gKHBvaW50KSB7IC8vIChSdWxlci5MYXllcmVkTWFya2VyKVxuICAgICAgICBpZiAocG9pbnQuX2xlZ3MpIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHBvaW50Ll9sZWdzKS5mb3JFYWNoKGZ1bmN0aW9uIChsYXllcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xheWVyc1tsYXllcl0ucmVtb3ZlTGF5ZXIocG9pbnQuX2xlZ3NbbGF5ZXJdKTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICAgICAgcG9pbnQuX2xlZ3MgPSBudWxsO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF91cGRhdGVMZWdzOiBmdW5jdGlvbiAocG9pbnQsIHNraXBQcmV2aW91cykgeyAvLyAoUnVsZXIuTGF5ZXJlZE1hcmtlciwgQm9vbGVhbilcbiAgICAgICAgdmFyIGxhdGxuZyA9IHBvaW50LmdldExhdExuZygpLFxuICAgICAgICAgICAgcHJldmlvdXNQb2ludCA9IHRoaXMuX3BvaW50c1twb2ludC5fcG9zIC0gMV0sXG4gICAgICAgICAgICBuZXh0UG9pbnQgPSB0aGlzLl9wb2ludHNbcG9pbnQuX3BvcyArIDFdLFxuICAgICAgICAgICAgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgICBuZXdQb2ludHM7XG5cbiAgICAgICAgaWYgKHByZXZpb3VzUG9pbnQgJiYgIXNraXBQcmV2aW91cykge1xuICAgICAgICAgICAgbmV3UG9pbnRzID0gc2VsZi5fY2FsY0dyZWF0Q2lyY2xlKHByZXZpb3VzUG9pbnQuZ2V0TGF0TG5nKCksIGxhdGxuZyk7XG5cbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHByZXZpb3VzUG9pbnQuX2xlZ3MpLmZvckVhY2goZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgICAgICAgICAgICAgcHJldmlvdXNQb2ludC5fbGVnc1tsYXllcl0uc2V0TGF0TG5ncyhuZXdQb2ludHMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobmV4dFBvaW50KSB7XG4gICAgICAgICAgICBuZXdQb2ludHMgPSBzZWxmLl9jYWxjR3JlYXRDaXJjbGUobGF0bG5nLCBuZXh0UG9pbnQuZ2V0TGF0TG5nKCkpO1xuXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhwb2ludC5fbGVncykuZm9yRWFjaChmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAgICAgICAgICAgICBwb2ludC5fbGVnc1tsYXllcl0uc2V0TGF0TG5ncyhuZXdQb2ludHMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX2NhbGNEaXN0YW5jZTogZnVuY3Rpb24gKGZpbmlzaFBvaW50LCB0YWlsKSB7IC8vIChSdWxlci5MYXllcmVkTWFya2VyLCBOdW1iZXIpIC0+IE51bWJlclxuICAgICAgICB2YXIgZGlzdGFuY2UgPSB0YWlsID8gdGFpbCA6IDAsXG4gICAgICAgICAgICBjYWxjVG8gPSBmaW5pc2hQb2ludCA/IGZpbmlzaFBvaW50Ll9wb3MgOiB0aGlzLl9wb2ludHMubGVuZ3RoIC0gMTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNhbGNUbzsgaSsrKSB7XG4gICAgICAgICAgICBkaXN0YW5jZSArPSB0aGlzLl9wb2ludHNbaV0uZ2V0TGF0TG5nKCkuZGlzdGFuY2VUbyh0aGlzLl9wb2ludHNbaSArIDFdLmdldExhdExuZygpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkaXN0YW5jZTtcbiAgICB9LFxuXG4gICAgX2dldEZvcm1hdGVkRGlzdGFuY2U6IGZ1bmN0aW9uICgpIHsgLy8gKCkgLT4gU3RyaW5nXG4gICAgICAgIHZhciBkaXN0YW5jZSA9IHRoaXMuX2NhbGNEaXN0YW5jZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpLFxuICAgICAgICAgICAgdW5pdHMgPSAnbSc7XG5cbiAgICAgICAgaWYgKGRpc3RhbmNlID4gMTAwMCkge1xuICAgICAgICAgICAgZGlzdGFuY2UgLz0gMTAwMDtcbiAgICAgICAgICAgIHVuaXRzID0gJ2ttJztcbiAgICAgICAgICAgIGlmIChkaXN0YW5jZSA+IDEwMDApIHtcbiAgICAgICAgICAgICAgICBkaXN0YW5jZSA9IGRpc3RhbmNlLnRvRml4ZWQoKTtcbiAgICAgICAgICAgICAgICBkaXN0YW5jZSA9IGRpc3RhbmNlLnNsaWNlKDAsIC0zKSArICcgJyArIGRpc3RhbmNlLnNsaWNlKC0zKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGlzdGFuY2UgPSBkaXN0YW5jZS50b0ZpeGVkKDIpLnNwbGl0KCcuJykuam9pbih0aGlzLnQoJ2RlbGltaXRlcicpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRpc3RhbmNlID0gTWF0aC5yb3VuZChkaXN0YW5jZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW2Rpc3RhbmNlIHx8IDAsICcgJywgdGhpcy50KHVuaXRzKV0uam9pbignJyk7XG4gICAgfSxcblxuICAgIF91cGRhdGVEaXN0YW5jZTogZnVuY3Rpb24gKCkgeyAvLyAoKVxuICAgICAgICBpZiAodGhpcy5fbWFwICYmIHRoaXMuX3BvaW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuX3BvaW50c1t0aGlzLl9wb2ludHMubGVuZ3RoIC0gMV0uc2V0VGV4dCh0aGlzLl9nZXRGb3JtYXRlZERpc3RhbmNlKCkpO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbkRHLnJ1bGVyID0gZnVuY3Rpb24gKGxhdGxuZ3MsIG9wdGlvbnMpIHsgLy8gKEFycmF5LCBPYmplY3QpXG4gICAgcmV0dXJuIG5ldyBERy5SdWxlcihsYXRsbmdzLCBvcHRpb25zKTtcbn07XG4iLCJERy5SdWxlci5MYXllcmVkTWFya2VyID0gREcuTWFya2VyLmV4dGVuZCh7XG5cbiAgICAvKmdsb2JhbCB7XCJSdWxlckxheWVyZWRNYXJrZXJcIjpcIihmdW5jdGlvbigpe2R1c3QucmVnaXN0ZXIoXFxcIlJ1bGVyTGF5ZXJlZE1hcmtlclxcXCIsYm9keV8wKTtmdW5jdGlvbiBib2R5XzAoY2hrLGN0eCl7cmV0dXJuIGNoay53cml0ZShcXFwiPGltZyBjbGFzcz1cXFxcXFxcImRnLXJ1bGVyX19sYWJlbC1zcGFjZXJcXFxcXFxcIiBzcmM9XFxcXFxcXCJcXFwiKS5yZWZlcmVuY2UoY3R4LmdldChbXFxcImJsYW5rZ2lmXFxcIl0sIGZhbHNlKSxjdHgsXFxcImhcXFwiKS53cml0ZShcXFwiXFxcXFxcXCIgd2lkdGg9XFxcXFxcXCIyNlxcXFxcXFwiIGhlaWdodD1cXFxcXFxcIjI2XFxcXFxcXCIgLz48ZGl2IGNsYXNzPVxcXFxcXFwiZGctcnVsZXJfX2xhYmVsLWNvbnRhaW5lclxcXFxcXFwiPjxkaXYgY2xhc3M9XFxcXFxcXCJkZy1ydWxlcl9fcG9pbnRcXFxcXFxcIj48L2Rpdj48c3BhbiBjbGFzcz1cXFxcXFxcImRnLXJ1bGVyX19sYWJlbC1kaXN0YW5jZVxcXFxcXFwiPjAg0LrQvDwvc3Bhbj48c3BhbiBjbGFzcz1cXFxcXFxcImRnLXJ1bGVyX19sYWJlbC1yZW1vdmUtbGlua1xcXFxcXFwiPjwvc3Bhbj48ZGl2IGNsYXNzPVxcXFxcXFwiZGctcnVsZXJfX3JlbW92ZS1saW5rLW92ZXJsYXlcXFxcXFxcIj48L2Rpdj48L2Rpdj5cXFwiKTt9cmV0dXJuIGJvZHlfMDt9KSgpO1wifTpmYWxzZSAqL1xuXG4gICAgb3B0aW9uczoge1xuICAgICAgICBkcmFnZ2FibGU6IGZhbHNlLFxuICAgICAgICBrZXlib2FyZDogZmFsc2UsXG4gICAgICAgIHJpc2VPbkhvdmVyOiB0cnVlLFxuICAgICAgICBpY29uSFRNTDogREcuZHVzdCh7XCJSdWxlckxheWVyZWRNYXJrZXJcIjpcIihmdW5jdGlvbigpe2R1c3QucmVnaXN0ZXIoXFxcIlJ1bGVyTGF5ZXJlZE1hcmtlclxcXCIsYm9keV8wKTtmdW5jdGlvbiBib2R5XzAoY2hrLGN0eCl7cmV0dXJuIGNoay53cml0ZShcXFwiPGltZyBjbGFzcz1cXFxcXFxcImRnLXJ1bGVyX19sYWJlbC1zcGFjZXJcXFxcXFxcIiBzcmM9XFxcXFxcXCJcXFwiKS5yZWZlcmVuY2UoY3R4LmdldChbXFxcImJsYW5rZ2lmXFxcIl0sIGZhbHNlKSxjdHgsXFxcImhcXFwiKS53cml0ZShcXFwiXFxcXFxcXCIgd2lkdGg9XFxcXFxcXCIyNlxcXFxcXFwiIGhlaWdodD1cXFxcXFxcIjI2XFxcXFxcXCIgLz48ZGl2IGNsYXNzPVxcXFxcXFwiZGctcnVsZXJfX2xhYmVsLWNvbnRhaW5lclxcXFxcXFwiPjxkaXYgY2xhc3M9XFxcXFxcXCJkZy1ydWxlcl9fcG9pbnRcXFxcXFxcIj48L2Rpdj48c3BhbiBjbGFzcz1cXFxcXFxcImRnLXJ1bGVyX19sYWJlbC1kaXN0YW5jZVxcXFxcXFwiPjAg0LrQvDwvc3Bhbj48c3BhbiBjbGFzcz1cXFxcXFxcImRnLXJ1bGVyX19sYWJlbC1yZW1vdmUtbGlua1xcXFxcXFwiPjwvc3Bhbj48ZGl2IGNsYXNzPVxcXFxcXFwiZGctcnVsZXJfX3JlbW92ZS1saW5rLW92ZXJsYXlcXFxcXFxcIj48L2Rpdj48L2Rpdj5cXFwiKTt9cmV0dXJuIGJvZHlfMDt9KSgpO1wifSkoJ1J1bGVyTGF5ZXJlZE1hcmtlcicsIHtcbiAgICAgICAgICAgIGJsYW5rZ2lmIDogJ2RhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCxSMGxHT0RsaEFRQUJBSUFBQUFBQUFQLy8veUg1QkFFQUFBQUFMQUFBQUFBQkFBRUFBQUlCUkFBNydcbiAgICAgICAgfSlcbiAgICB9LFxuXG4gICAgc3RhdGljczoge1xuICAgICAgICBkb21DbGFzcyA6ICdkZy1ydWxlcl9fbGFiZWwnXG4gICAgfSxcblxuICAgIGFkZFRvIDogZnVuY3Rpb24gKG1hcCwgbGF5ZXJzKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMuX2xheWVycykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgbGF5ZXJzW25hbWVdLmFkZExheWVyKHRoaXMuX2xheWVyc1tuYW1lXSk7XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIHRoaXMuX3ZpZXdwb3J0ID0gbGF5ZXJzO1xuICAgICAgICByZXR1cm4gREcuTWFya2VyLnByb3RvdHlwZS5hZGRUby5jYWxsKHRoaXMub24oJ21vdmUnLCB0aGlzLl9vbk1vdmUpLCBtYXApO1xuICAgIH0sXG5cbiAgICBvblJlbW92ZSA6IGZ1bmN0aW9uIChtYXApIHtcbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5fbGF5ZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICB0aGlzLl92aWV3cG9ydFtuYW1lXS5yZW1vdmVMYXllcih0aGlzLl9sYXllcnNbbmFtZV0pO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgdGhpcy5vZmYoJ21vdmUnLCB0aGlzLl9vbk1vdmUpO1xuICAgICAgICB0aGlzLl92aWV3cG9ydCA9IG51bGw7XG4gICAgICAgIHRoaXMuX3N0eWxlID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIERHLk1hcmtlci5wcm90b3R5cGUub25SZW1vdmUuY2FsbCh0aGlzLCBtYXApO1xuICAgIH0sXG5cbiAgICBzZXRUZXh0IDogZnVuY3Rpb24gKHRleHQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2ljb25Db2xsYXBzZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZXhwYW5kKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faWNvbk5vZGVzLmxhYmVsLmlubmVySFRNTCA9IHRleHQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzZXRQb2ludFN0eWxlIDogZnVuY3Rpb24gKHN0eWxlKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdHlsZSAhPT0gc3R5bGUpIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHRoaXMuX3N0eWxlID0gc3R5bGUpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sYXllcnNbbmFtZV0uc2V0U3R5bGUoc3R5bGVbbmFtZV0pO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGV4cGFuZCA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5faWNvbkNvbGxhcHNlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pY29uTm9kZXMuY29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICB0aGlzLl9pY29uTm9kZXMuc3BhY2VyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBjb2xsYXBzZSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5faWNvbkNvbGxhcHNlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX2ljb25Ob2Rlcy5jb250YWluZXIuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgdGhpcy5faWNvbk5vZGVzLnNwYWNlci5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHF1ZXJ5U2VsZWN0b3IgOiBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ljb24ucXVlcnlTZWxlY3RvcignLicgKyBERy5SdWxlci5MYXllcmVkTWFya2VyLmRvbUNsYXNzICsgJy0nICsgc2VsZWN0b3IpO1xuICAgIH0sXG5cbiAgICBfb25Nb3ZlIDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBsYXRsbmcgPSBldmVudC5sYXRsbmc7XG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMuX2xheWVycykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgdGhpcy5fbGF5ZXJzW25hbWVdLnNldExhdExuZyhsYXRsbmcpO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICB9LFxuXG4gICAgX2luaXRJY29uIDogZnVuY3Rpb24gKCkge1xuICAgICAgICBERy5NYXJrZXIucHJvdG90eXBlLl9pbml0SWNvbi5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLl9pY29uQ29sbGFwc2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5faWNvbi5zdHlsZS53aWR0aCA9ICcnO1xuICAgICAgICB0aGlzLl9pY29uTm9kZXMgPSB7XG4gICAgICAgICAgICBsYWJlbCA6IHRoaXMucXVlcnlTZWxlY3RvcignZGlzdGFuY2UnKSxcbiAgICAgICAgICAgIHNwYWNlciA6IHRoaXMucXVlcnlTZWxlY3Rvcignc3BhY2VyJyksXG4gICAgICAgICAgICBjb250YWluZXIgOiB0aGlzLnF1ZXJ5U2VsZWN0b3IoJ2NvbnRhaW5lcicpXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIF9hZnRlckluaXQgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2xheWVycyA9IHRoaXMub3B0aW9ucy5sYXllcnMgfHwgbnVsbDtcbiAgICAgICAgdGhpcy5vcHRpb25zLmljb24gPSBERy5kaXZJY29uKHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogREcuUnVsZXIuTGF5ZXJlZE1hcmtlci5kb21DbGFzcyxcbiAgICAgICAgICAgIGljb25TaXplOiBbMjYsIDI2XSxcbiAgICAgICAgICAgIGljb25BbmNob3I6IFsxMywgMTNdLFxuICAgICAgICAgICAgaHRtbDogdGhpcy5vcHRpb25zLmljb25IVE1MXG4gICAgICAgIH0pO1xuICAgIH1cblxufSk7XG5cbkRHLlJ1bGVyLkxheWVyZWRNYXJrZXIuYWRkSW5pdEhvb2soJ19hZnRlckluaXQnKTtcblxuREcuUnVsZXIubGF5ZXJlZE1hcmtlciA9IGZ1bmN0aW9uIChsYXRsbmcsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IERHLlJ1bGVyLkxheWVyZWRNYXJrZXIobGF0bG5nLCBvcHRpb25zKTtcbn07XG4iLCJ2YXIgcnVsZXJSZW5kZXJlciA9IERHLnN2Zyh7cGFuZTogJ3J1bGVyTGFiZWxQYW5lJ30pO1xuXG5ERy5SdWxlci5tZXJnZU9wdGlvbnMoe1xuICAgIHBhdGhTdHlsZXM6IHtcbiAgICAgICAgYmFjazoge1xuICAgICAgICAgICAgY29sb3I6ICcjZmZmJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgICAgICB3ZWlnaHQ6IDEyLFxuICAgICAgICAgICAgcG9pbnRlckV2ZW50czogJ25vbmUnLFxuICAgICAgICAgICAgbm9DbGlwOiB0cnVlLFxuICAgICAgICAgICAgcmVuZGVyZXI6IHJ1bGVyUmVuZGVyZXIsXG4gICAgICAgICAgICBzbW9vdGhGYWN0b3I6IDBcbiAgICAgICAgfSxcbiAgICAgICAgbWlkZGxlOiB7XG4gICAgICAgICAgICBjb2xvcjogJyMwZGE1ZDUnLFxuICAgICAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgICAgIHdlaWdodDogNCxcbiAgICAgICAgICAgIHBvaW50ZXJFdmVudHM6ICdub25lJyxcbiAgICAgICAgICAgIG5vQ2xpcDogdHJ1ZSxcbiAgICAgICAgICAgIHJlbmRlcmVyOiBydWxlclJlbmRlcmVyLFxuICAgICAgICAgICAgc21vb3RoRmFjdG9yOiAwXG4gICAgICAgIH0sXG4gICAgICAgIG1vdXNlOiB7XG4gICAgICAgICAgICBjb2xvcjogJyNmZmYnLFxuICAgICAgICAgICAgb3BhY2l0eTogREcuQnJvd3Nlci52bWwgPyAwLjEgOiAwLFxuICAgICAgICAgICAgd2VpZ2h0OiBERy5Ccm93c2VyLnRvdWNoID8gNDAgOiAyMCxcbiAgICAgICAgICAgIHBvaW50ZXJFdmVudHM6ICdwYWludGVkJyxcbiAgICAgICAgICAgIG5vQ2xpcDogdHJ1ZSxcbiAgICAgICAgICAgIHJlbmRlcmVyOiBERy5zdmcoe3BhbmU6ICdydWxlckV2ZW50UGFuZSd9KSxcbiAgICAgICAgICAgIHNtb290aEZhY3RvcjogMFxuICAgICAgICB9XG4gICAgfSxcbiAgICBpY29uU3R5bGVzOiB7XG4gICAgICAgIGxhcmdlOiB7XG4gICAgICAgICAgICBiYWNrOiB7XG4gICAgICAgICAgICAgICAgY29sb3I6ICcjZmZmJyxcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICAgICAgICAgIGZpbGxDb2xvcjogJyNmZmYnLFxuICAgICAgICAgICAgICAgIGZpbGxPcGFjaXR5OiAxLFxuICAgICAgICAgICAgICAgIHdlaWdodDogMSxcbiAgICAgICAgICAgICAgICByYWRpdXM6IDEzLFxuICAgICAgICAgICAgICAgIHJlbmRlcmVyOiBydWxlclJlbmRlcmVyXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbWlkZGxlOiB7XG4gICAgICAgICAgICAgICAgY29sb3I6ICcjMGRhNWQ1JyxcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICAgICAgICAgIGZpbGxDb2xvcjogJyMwZGE1ZDUnLFxuICAgICAgICAgICAgICAgIGZpbGxPcGFjaXR5OiAxLFxuICAgICAgICAgICAgICAgIHdlaWdodDogMSxcbiAgICAgICAgICAgICAgICByYWRpdXM6IDksXG4gICAgICAgICAgICAgICAgcmVuZGVyZXI6IHJ1bGVyUmVuZGVyZXJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmcm9udDoge1xuICAgICAgICAgICAgICAgIGNvbG9yOiAnI2ZmZicsXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgICAgICAgICBmaWxsQ29sb3I6ICcjMGRhNWQ1JyxcbiAgICAgICAgICAgICAgICBmaWxsT3BhY2l0eTogMSxcbiAgICAgICAgICAgICAgICB3ZWlnaHQ6IDQsXG4gICAgICAgICAgICAgICAgcmFkaXVzOiA1LFxuICAgICAgICAgICAgICAgIHJlbmRlcmVyOiBydWxlclJlbmRlcmVyXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNtYWxsOiB7XG4gICAgICAgICAgICBiYWNrOiB7XG4gICAgICAgICAgICAgICAgY29sb3I6ICcjZmZmJyxcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICAgICAgICAgIGZpbGxDb2xvcjogJyNmZmYnLFxuICAgICAgICAgICAgICAgIGZpbGxPcGFjaXR5OiAxLFxuICAgICAgICAgICAgICAgIHdlaWdodDogMSxcbiAgICAgICAgICAgICAgICByYWRpdXM6IDksXG4gICAgICAgICAgICAgICAgcmVuZGVyZXI6IHJ1bGVyUmVuZGVyZXJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtaWRkbGU6IHtcbiAgICAgICAgICAgICAgICBjb2xvcjogJyMwZGE1ZDUnLFxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgICAgICAgICAgZmlsbENvbG9yOiAnIzBkYTVkNScsXG4gICAgICAgICAgICAgICAgZmlsbE9wYWNpdHk6IDEsXG4gICAgICAgICAgICAgICAgd2VpZ2h0OiAxLFxuICAgICAgICAgICAgICAgIHJhZGl1czogNSxcbiAgICAgICAgICAgICAgICByZW5kZXJlcjogcnVsZXJSZW5kZXJlclxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZyb250OiB7XG4gICAgICAgICAgICAgICAgY29sb3I6ICcjZmZmJyxcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICAgICAgICAgIGZpbGxDb2xvcjogJyMwZGE1ZDUnLFxuICAgICAgICAgICAgICAgIGZpbGxPcGFjaXR5OiAxLFxuICAgICAgICAgICAgICAgIHdlaWdodDogNCxcbiAgICAgICAgICAgICAgICByYWRpdXM6IDIsXG4gICAgICAgICAgICAgICAgcmVuZGVyZXI6IHJ1bGVyUmVuZGVyZXJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn0pO1xuIiwiREcuUnVsZXIuRGljdGlvbmFyeS5ydSA9IHtcblx0a20gOiAn0LrQvCcsXG5cdG0gOiAn0LwnLFxuXHRkZWxpbWl0ZXIgOiAnLCdcbn07XG4iLCJERy5SdWxlci5EaWN0aW9uYXJ5Lml0ID0ge1xuXHRrbSA6ICdrbScsXG5cdG0gOiAnbScsXG5cdGRlbGltaXRlciA6ICcsJ1xufTsiLCJERy5SdWxlci5EaWN0aW9uYXJ5LmNzID0ge1xuXHRrbTogJ2ttJyxcblx0bTogJ20nLFxuXHRkZWxpbWl0ZXI6ICcsJ1xufTsiLCJERy5SdWxlci5EaWN0aW9uYXJ5LmVzID0ge1xuXHRrbSA6ICdrbScsXG5cdG0gOiAnbScsXG5cdGRlbGltaXRlciA6ICcsJ1xufTsiLCJERy5SdWxlci5EaWN0aW9uYXJ5LmVuID0ge1xuXHRrbSA6ICdrbScsXG5cdG0gOiAnbScsXG5cdGRlbGltaXRlciA6ICcuJ1xufTtcbiIsIkRHLkNvbnRyb2wuUnVsZXIgPSBERy5Sb3VuZENvbnRyb2wuZXh0ZW5kKHtcblxuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgcG9zaXRpb246ICd0b3ByaWdodCcsXG4gICAgICAgIGljb25DbGFzczogJ3J1bGVyJ1xuICAgIH0sXG5cbiAgICBzdGF0aWNzOiB7XG4gICAgICAgIERpY3Rpb25hcnk6IHt9XG4gICAgfSxcblxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIERHLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG4gICAgICAgIERHLmV4dGVuZCh0aGlzLCB7XG4gICAgICAgICAgICBfYWN0aXZlOiBmYWxzZSxcbiAgICAgICAgICAgIF9kcmF3aW5nSGVscGVyOiBudWxsLFxuICAgICAgICAgICAgX2dlb2NsaWNrZXJOZWVkUmVzdG9yZTogZmFsc2VcbiAgICAgICAgfSkub24odGhpcy5fY29udHJvbEV2ZW50cywgdGhpcyk7XG4gICAgfSxcblxuICAgIF9jb250cm9sRXZlbnRzOiB7XG4gICAgICAgIGFkZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fZHJhd2luZ0hlbHBlciA9IERHLnJ1bGVyKFtdKTtcbiAgICAgICAgfSxcbiAgICAgICAgY2xpY2s6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX2FjdGl2ZSA9ICF0aGlzLl9hY3RpdmU7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9hY3RpdmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKCdhY3RpdmUnKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGFydERyYXdpbmcoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSgnJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZmluaXNoRHJhd2luZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMub2ZmKHRoaXMuX2NvbnRyb2xFdmVudHMsIHRoaXMpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2FjdGl2ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX21hcC5yZW1vdmVMYXllcih0aGlzLl9kcmF3aW5nSGVscGVyKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2RyYXdpbmdIZWxwZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9zdGFydERyYXdpbmc6IGZ1bmN0aW9uICgpIHsgLy8gKClcbiAgICAgICAgdGhpcy5fbWFwXG4gICAgICAgICAgICAuYWRkTGF5ZXIodGhpcy5fZHJhd2luZ0hlbHBlcilcbiAgICAgICAgICAgIC5vbignY2xpY2snLCB0aGlzLl9oYW5kbGVNYXBDbGljaywgdGhpcyk7XG5cbiAgICAgICAgdGhpcy5fbWFwLmZpcmUoJ3J1bGVyc3RhcnQnKTtcbiAgICB9LFxuXG4gICAgX2ZpbmlzaERyYXdpbmc6IGZ1bmN0aW9uICgpIHsgLy8gKClcbiAgICAgICAgdGhpcy5fbWFwXG4gICAgICAgICAgICAub2ZmKCdjbGljaycsIHRoaXMuX2hhbmRsZU1hcENsaWNrLCB0aGlzKVxuICAgICAgICAgICAgLnJlbW92ZUxheWVyKHRoaXMuX2RyYXdpbmdIZWxwZXIpO1xuXG4gICAgICAgIHRoaXMuX2RyYXdpbmdIZWxwZXIuc2V0TGF0TG5ncyhbXSk7XG5cbiAgICAgICAgdGhpcy5fbWFwLmZpcmUoJ3J1bGVyZW5kJyk7XG4gICAgfSxcblxuICAgIF9oYW5kbGVNYXBDbGljazogZnVuY3Rpb24gKGV2ZW50KSB7IC8vIChNb3VzZUV2ZW50cylcbiAgICAgICAgdGhpcy5fZHJhd2luZ0hlbHBlci5hZGRMYXRMbmcoZXZlbnQubGF0bG5nKTtcbiAgICB9LFxuXG4gICAgX3JlbmRlclRyYW5zbGF0aW9uOiBmdW5jdGlvbiAoKSB7IC8vICgpXG4gICAgICAgIHRoaXMuX2xpbmsudGl0bGUgPSB0aGlzLnQoJ2J1dHRvbl90aXRsZScpO1xuICAgIH1cbn0pO1xuXG5ERy5jb250cm9sLnJ1bGVyID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IERHLkNvbnRyb2wuUnVsZXIob3B0aW9ucyk7XG59O1xuIiwiREcuQ29udHJvbC5SdWxlci5EaWN0aW9uYXJ5LnJ1ID0ge1xuXHRidXR0b25fdGl0bGU6ICfQm9C40L3QtdC50LrQsCdcbn07IiwiREcuQ29udHJvbC5SdWxlci5EaWN0aW9uYXJ5Lml0ID0ge1xuXHRidXR0b25fdGl0bGUgOiAnUmlnaGVsbG8nXG59OyIsIkRHLkNvbnRyb2wuUnVsZXIuRGljdGlvbmFyeS5jcyA9IHtcblx0YnV0dG9uX3RpdGxlOiAnUHJhdsOtdGtvJ1xufTsiLCJERy5Db250cm9sLlJ1bGVyLkRpY3Rpb25hcnkuZXMgPSB7XG5cdGJ1dHRvbl90aXRsZSA6ICdSZWdsYSdcbn07XG4iLCJERy5Db250cm9sLlJ1bGVyLkRpY3Rpb25hcnkuZW4gPSB7XG5cdGJ1dHRvbl90aXRsZSA6ICdSdWxlcidcbn07Il0sInNvdXJjZVJvb3QiOiIvc291cmNlLyJ9